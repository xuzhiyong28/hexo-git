---
title: redis持久化详解RDB,AOP
tags:
  - redis
categories: redis
description : redis持久化详解RDB,AOP
date: 2020-08-26 14:43:31
---

## Redis两种持久化方案

- RDB方式，生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dumpr.rdb。
- AOF方式，记录 Redis 除了查询以外的所有写命令，即对内存中数据进行修改的指令记录。

## RDB持久化

### RDB介绍和使用
- RDB是一种<font color=red>快照模式</font>。保存的是 key-value数据内容。
- RDB有两种持久化方式即**同步save模式**和**异步bgsave模式**。
  - 同步模式下阻塞其他命令执行持久化生成rdb文件，不会有一致性问题。
  - 异步模式下fork一个子进程执行持久化生成rdb文件，不会阻塞其他命令，会有一致性问题。
- 默认执行 shutdown 时，如果没有开启 AOF，则自动执行 bgsave。
- 每次的 RDB 文件都是替换的。所以在实际应用上可以通过shell脚本定时备份这个RDB文件。

Redis默认开启RDB持久化方式，通过配置redis.conf

```properties
save 900 1
save 300 10
save 60 10000
#900秒之内，如果超过1个key被修改，则发起快照保存；
#300秒之内，如果超过10个key被修改，则发起快照保存；
#60秒之内，如果1万个key被修改，则发起快照保存；
```

### bgsave方式持久化

![](redis-master-slave/1.png)

1. Redis 调用 fork() ，同时拥有父进程和子进程。
2. 子进程将数据集写入到一个临时RDB文件中。
3. 当子进程完成对新 RDB 文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。

引出问题 ：<font color=red>在bgsave期间子进程正在持久化一个很大的数据结构K时，这时候父进程收到了删除这个数据结构K的命令，这时候redis该怎么办？</font>

redis使用操作系统的多进程<font color=red>COW机制(Copy On Write)</font>机制来实现快照的持久化。子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，这是Linux操作系统的机制，为了节约内存资源，所以尽可能让父子进程共享内存，这样在进程分离的一瞬间，内存的增长几乎没有明显变化。

当子进程进行持久化时父进程收到了写请求，那么会把需要处理的一部分复制一份到内存，对复制后的数据进行修改，所以即使对某个数据进行了修改，redis持久化到RDB中的数据也是未修改的数据。实际上，内存中的全量数据由一个个的"数据段页面"组成，每个数据段页面的大小为4K，客户端要修改的数据在哪个页面中，就会复制一份这个页面到内存中。<font color=red>所以在执行持久化时就已经快照好了那一瞬间的数据，以后的更改并不会影响持久化</font>。

### 优缺点

**优点**

- 文件紧凑，适合备份，全量复制场景。
- Redis 加载 RDB 恢复数据远远快于 AOF。

**缺点**

- 无法秒级持久化。

## AOF持久化

### AOF介绍和使用

- AOF持久化时记录的是命令，每一个写命令都通过write函数追加到appendonly.aof文件中。
- AOF默认是关闭的，需要通过appendfsync配置开启
- AOF 每次保存的写命令都放在一个缓冲区，根据不同的策略（下面详细说）同步到磁盘
- AOF 由于每次都会记录写命令，文件会很大，因此需要进行优化，称之为“重写机制”
- AOF可以通过命令bgrewriteaof进行重写

AOF配置：

```properties
appendonly yes # 是否开启AOF持久化
appendfsync no # 由系统决定什么时候写入AOF
appendfsync always #每次有数据修改发生时都会写入AOF文件。
appendfsync everysec #每秒钟同步一次，该策略为AOF的缺省策略。
```

### bgrewriteaof重写

![](redis-rdb-aop/2.png)

1. 执行bgrewritedaof进行重写
2. 子进程对当前内存中的数据进行遍历，转换成一系列的redis操作指令，并序列化到一个新的AOF日志中
3. 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾： 这样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的
4. 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾

### 优缺点

- 速度快，秒级持久化。恢复数据时能实现全部数据恢复。
- AOF 文件的体积通常要大于 RDB 文件的体积。
- 恢复速速慢。

## 混合持久化

xxx

