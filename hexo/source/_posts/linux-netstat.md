---
title: Linux命令之netstat与TCP详解
tags:
  - linux
  - 网络
categories:  linux
description: Linux命令之netstat与TCP详解
---
## TCP

传输控制协议（*TCP*，Transmission Control Protocol）是一种<font color=red>面向连接的</font>、<font color=red>可靠的</font>、<font color=red>基于字节流</font>的传输层通信协议。本人是这样理解面向连接和可靠性的。

面向连接指的客户端/服务器在使用TCP进行数据传输时必须先建立一个TCP连接。连接的手段就是进行三次握手，关闭时需要四次挥手。

可靠性指的是保证顺序，超时重发，流量控制，拥塞控制，丢弃重复的数据等等。可靠性的保证主要通过如下手段实现：

- 序列号，ACK信号：发送方按照顺序给要发送的数据包的每个字节都标上编号。接收方接收到发送方的数据包之后，回传一个ACK信号，标识下一个需求的数据包初始字节编号。（可以保证顺序）
- 超时重发：在等待接收方回传的ACK信号超时后，发送方重发数据包。一旦开始重传，下一次等待的时间间隔指数增长，重发一定次数后还是收不到ACK信号，将强制终止连接。
-  TCP的连接管理：建立连接的三次握手和断开连接的四次挥手。（保证安全）
- 以段为单位发送数据包：在建立TCP连接的同时，两端协商发送数据包的单位，称为“最大消息长度”：MSS。
-  滑动窗口：以段为单位发送数据包，每发送一个数据包需要等待一个ACK信号，当数据包往返时间越长效率越低。滑动窗口中窗口前端为已发送但为收到ACK的数据，后端为待发送数据。发送端一次发送多个数据，接收端回传收到的连续数据的ACK信号，缓存缺失数据之后的数据包(保持顺序)。发送端当收到ACK信号时，窗口向前依次移动，直到遇到有数据未确认时停止。一段时间后启动超时重传，接收端若收到缺失数据，则和缓存数据一起发送ACK信号，否则，抛弃缓存数据。
- 流量控制：TCP首部有一个字段来通知窗口的大小，接收端通过设置来主动控制传输流量。
- 拥塞控制：发送端通过拥塞窗口主动控制传输流量。慢启动：防止双方通信刚开始就传送大量数据包，发送端拥塞窗口初始设置为1MSS，每接受一个ACK信号，窗口扩大为两倍。发送数据时，取拥塞窗口和滑动窗口的较小值。同时设定一个慢启动阈值，当拥塞窗口大小超过阈值时，改为线性增长，直到网络拥塞。拥塞时将慢启动阈值设置为当前窗口的的一半，并将拥塞窗口的值设置为1，然后再次重复操作。

## TCP三次握手和四次挥手

一个正常的TCP连接，都会有三个阶段:

- TCP三次握手。
- 数据传送。
- TCP四次挥手。

![三次握手](linux-netstat/1.png)

### 三次握手

![三次握手与状态](linux-netstat/2.png)

**三次握手说明：**

1. 客户端发送TCP连接的请求报文，其中SYN=1表示建立TCP连接，seq表示序列号，x为随机序列号。客户端发送后将自己的状态设置成`SYN_SENT`状态。
2. 服务单回复客户都按发送的TCP请求报文，seq=y表示序列号，y由服务端生成的随机数,SYN=1表示建立TCP连接（服务端也回复这个，表示我同意建立连接了），而且会产生ack字段，ack字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证，这里的ack加1可以理解为是确认和谁建立连接。
3. 客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。

上面的SYN，seq，ack我们可以缕一缕意思。

- 其中SYN表示是要建立TCP连接，所以值都是为1。
- seq表示发送的序列号，ack表示报文到达的确认。所以我们可以看到客户端假设发了seq=100，那么服务端确认后就发ack=100+1表示我确认了。然后服务端回复时也发了一个seq=200（这里200是图中的y），客户端确认后发送ack=200+1。
- seq和ack的作用是保证传输可靠性，顺序性。

### 四次挥手

![四次挥手与状态](linux-netstat/3.png)

1. 客户端发送TCP断开请求的报文，其中FIN=1表示要断开连接的请求，seq表示序列号，x是随机生成的。
2. 服务端收到请求后回复客户端，ack表示回复确认，seq=y随机序列号。
3. 第二步服务端回复完客户端后并不是一下子就断开，服务端需要保障所有传输到客户端的数据是否已经传输完毕，如果完毕了然后发送FIN=1表示我同意断开了，然后seq=y就是发送自己这边的随机序列号。
4.客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。

### TCP的11种状态

![](linux-netstat/4.png)

1. 一开始，建立连接之前服务器和客户端的状态都为CLOSED。
2. 服务器创建socket后开始监听，变为LISTEN状态。
3. 客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT。
4. 服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD。
5. 然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED。
6. 服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立。

![](linux-netstat/5.png)

由于TCP连接是全双工的，断开连接会比建立连接麻烦一点点。 
1. 客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1； 
2. 服务器收到FIN后向客户端发送ACK，服务器的状态围边CLOSE_WAIT； 
3. 客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送； 
4. 直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态； 
5. 客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态； 
6. 再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。 
至此，还有一个状态没有出来：CLOSING状态。 

**状态解释**

| 状态         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| LISTEN       | 等待从任何远端TCP 和端口的连接请求                           |
| SYN_SENT     | 发送完一个连接请求后等待一个匹配的连接请求                   |
| SYN_RECEIVED | 发送连接请求并且接收到匹配的连接请求以后等待连接请求确认     |
| ESTABLISHED  | 连接完成，连接的数据传输阶段的正常状态                       |
| FIN_WAIT_1   | 等待远端TCP的连接终止请求，或者等待之前发送的连接终止请求的确认 |
| FIN_WAIT_2   | 等待远端TCP的连接终止请求                                    |
| CLOSE_WAIT   | 等待本地用户的连接终止请求                                   |
| CLOSING      | 等待远端TCP的连接终止请求确认                                |
| LAST_ACK     | 等待先前发送给远端TCP的连接终止请求的确认                    |
| TIME_WAIT    | 等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认 |

### 常见问题

参考：https://juejin.cn/post/6900439208641921038

**为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次**

我们要先理解为什么要建立TCP连接，建立连接主要是双方资源的准备。例如两边建立连接了，对应的就会开辟资源用来后面传输数据用。假设只有两次连接，如果服务端发送的syn+ack丢失后，那么客户端就进入CLOSE状态了。服务端不知道就在那里傻等，结果就是服务端资源浪费。至于为什么不是4次，因为服务端是被动接受数据的，所以只要服务端能确认客户端正常就行了。

**TCP报文结构**

![](linux-netstat/6.png)

其中，

- 第一行是源端口和目的端口。
- 位序号（seq）和确认号（ack）这个就是TCP通信时发送的，确认号而是和序列号配合使用的，应答某次请求时，则返回一个确认号，它的值等于对方请求序列号加1。
- 6个标志位分别是，URG：这是条紧急信息，ACK:应答消息，PSH:缓冲区尚未填满，RST:重置连接，SYN:建立连接消息标志，FIN：连接关闭通知信息

**TCP为什么说是可靠连接的**

TCP的连接是基于三次握手，而断开则是四次挥手。为了保障数据不丢失及错误（可靠性），它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

**挥手时主动断开方状态在TIME_WAIT后为什么要等2MSL后才断开**

TIME_WAIT的作用是为了保证最后一次挥手的ACK报文能送达给对方，如果ACK丢失，对方会超时重传FIN，主动关闭端会再次响应ACK过去；如果没有TIME_WAIT状态，直接关闭，对方重传的FIN报文则被响应一个RST报文，此RST会被动关闭端被解析成错误。

## netstat

netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。

这个命令的参数太多，一般来说我们都是用它来查TCP连接的，然后看连接的状态对比对。

```shell
[root@Master1 ~]# netstat -ant #t表示只有展示TCP协议
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address               Foreign Address             State      
tcp        0      0 0.0.0.0:63501               0.0.0.0:*                   LISTEN    
tcp        1      0 127.0.0.1:44176             127.0.0.1:60047             CLOSE_WAIT  
tcp        0      0 10.8.198.151:60884          10.8.2.30:61235             TIME_WAIT   
tcp        0      0 10.8.198.151:55672          10.8.2.27:61235             TIME_WAIT   
tcp        0      0 10.8.198.151:60882          10.8.2.30:61235             TIME_WAIT   
tcp        0      0 10.8.198.151:63501          10.8.133.245:59893          ESTABLISHED 
tcp        0      0 10.8.198.151:60976          10.8.2.30:61235             TIME_WAIT    
tcp        0      0 ::ffff:127.0.0.1:9600       :::*                        LISTEN      
tcp        0      0 :::63501                    :::*                        LISTEN          
tcp        0      0 ::ffff:10.8.198.151:60061   ::ffff:10.8.198.135:63751   ESTABLISHED 
tcp        0      0 ::ffff:10.8.198.151:60050   ::ffff:10.8.198.135:63751   ESTABLISHED 
tcp        1      0 ::1:60047                   ::1:43724                   CLOSE_WAIT  
tcp        0      0 ::ffff:10.8.198.151:45024   ::ffff:10.8.198.135:63751   ESTABLISHED 
tcp        0      0 ::ffff:10.8.198.151:43592   ::ffff:10.8.215.65:34710    TIME_WAIT  
#Local Address - 源IP/端口
#Foreign Address - 目标IP/端口
#State 状态 - 对应上面说的TCP11个状态
```

netstat命令有很多参数，这里就不一一说了。这个命令能帮助我们了解到具体的TCP的连接情况，例如我们可以通过如下命令知道当前服务器连接MySQL的状态。

```
netstat -ant | grep 3306
```

## tcpdump

用来抓包tcp协议的命令

```shell
tcpdump -n port 3306 #监控端口3306的TCP情况抓包 -n不把网络地址转换为名字
# 发生了 3次握手
11:38:15.679863 IP 172.18.0.5.38822 > 172.18.0.3.3306: Flags [S], seq 4065722321, win 29200, options [mss 1460,sackOK,TS val 2997352 ecr 0,nop,wscale 7], length 0
11:38:15.679923 IP 172.18.0.3.3306 > 172.18.0.5.38822: Flags [S.], seq 780487619, ack 4065722322, win 28960, options [mss 1460,sackOK,TS val 2997352 ecr 2997352,nop,wscale 7], length 0
11:38:15.679936 IP 172.18.0.5.38822 > 172.18.0.3.3306: Flags [.], ack 1, win 229, options [nop,nop,TS val 2997352 ecr 2997352], length 0
```

```shell
# 监控端口3306的TCP情况并且截获所有10.8.152.162 的主机收到的和发出的所有的数据包
tcpdump -n port 3306 and host 10.8.152.162 
# 截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信
tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \) 
# 果想要获取主机210.27.48.1接收或发出的telnet包
tcpdump tcp port 23 and host 210.27.48.1
```

## 参考

- https://juejin.cn/post/6844903734300901390
- [Linux tcpdump命令详解](https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html)
- [wireshark抓包新手使用教程](https://www.cnblogs.com/mq0036/p/11187138.html)