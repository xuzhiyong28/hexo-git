{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/volantis/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/volantis/source/fonts/Monaco.ttf","path":"fonts/Monaco.ttf","modified":0,"renderable":1},{"_id":"themes/volantis/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/volantis/source/img/azure.svg","path":"img/azure.svg","modified":0,"renderable":1},{"_id":"themes/volantis/source/img/baidu.svg","path":"img/baidu.svg","modified":0,"renderable":1},{"_id":"themes/volantis/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/volantis/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/volantis/source/fonts/Skranji-Regular.ttf","path":"fonts/Skranji-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/volantis/source/js/valine.js","path":"js/valine.js","modified":0,"renderable":1},{"_id":"themes/volantis/source/fonts/Ubuntu-Regular.ttf","path":"fonts/Ubuntu-Regular.ttf","modified":0,"renderable":1},{"_id":"source/CHAME","path":"CHAME","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/categories/index/index.txt","path":"categories/index/index.txt","modified":0,"renderable":0},{"_id":"source/tags/index/index.txt","path":"tags/index/index.txt","modified":0,"renderable":0},{"_id":"themes/volantis/source/img/default.cur","path":"img/default.cur","modified":0,"renderable":1},{"_id":"themes/volantis/source/img/pointer.cur","path":"img/pointer.cur","modified":0,"renderable":1}],"Cache":[{"_id":"themes/volantis/.gitignore","hash":"4b5e4eb66070da8433cd43d75af0de341e04a2ed","modified":1595250283359},{"_id":"themes/volantis/LICENSE","hash":"e0cbf6906cab5926a34f17852db6c05187ee1f68","modified":1595250283359},{"_id":"themes/volantis/README.md","hash":"91f213a172dd9e57e4ef03c9151ad94ec1bb2690","modified":1595250283359},{"_id":"themes/volantis/_config.yml","hash":"60a22e1e4466394c9f658ff5d8d431358fec2f49","modified":1617842827217},{"_id":"source/_posts/db-w-r-dynamic.md","hash":"b00c324524f6c46d8928e6afbf08051b680f3fe4","modified":1617842826717},{"_id":"source/_posts/myblob.md","hash":"4be2ae2ed53c78f6c4d9ff29f83ad6c49836ad95","modified":1595250283322},{"_id":"source/_posts/hello-world.md","hash":"6b9c5669b13f4d29a510acd4c4ff046f3486bc5f","modified":1595250283322},{"_id":"themes/volantis/languages/en.yml","hash":"809cbd1198ff45440e2997a22be34ae94367f92d","modified":1595250283361},{"_id":"themes/volantis/languages/zh-CN.yml","hash":"2735c9942ba1ece0124cf65cbc2101a54eb3e0d6","modified":1595250283361},{"_id":"themes/volantis/languages/zh-TW.yml","hash":"99962c8d9b941b85395dc73d581aaf927b19275b","modified":1595250283361},{"_id":"themes/volantis/layout/404.ejs","hash":"805804c27fcdb07201d38162361c606a167b44e9","modified":1595250283362},{"_id":"themes/volantis/layout/_pre.ejs","hash":"bdbcf68e3f71df73bc59ffa5007d8fe800c5cdc1","modified":1595250283371},{"_id":"themes/volantis/layout/archive.ejs","hash":"39760a20302fe11b8e12a7e32665bbe8477ac204","modified":1595250283396},{"_id":"themes/volantis/layout/category.ejs","hash":"45345ffec8a9a737ffd767c4cce4dfed30930e20","modified":1595250283396},{"_id":"themes/volantis/layout/index.ejs","hash":"6fee00696b3de0b7440cf1b4c2c099f19c2580f8","modified":1595250283396},{"_id":"themes/volantis/layout/layout.ejs","hash":"f75179757fc587f0d26bce24c608077676dffe02","modified":1617842827257},{"_id":"themes/volantis/layout/links.ejs","hash":"1bebe4b632945d33f36e2fc446c48ff4dda65819","modified":1595250283397},{"_id":"themes/volantis/layout/page.ejs","hash":"e1285b47ace87cbcf0ab459ab2d51567e3d43bba","modified":1595250283398},{"_id":"themes/volantis/layout/list.ejs","hash":"5d1efdee83a9979996b34fc743ac957517be5bb4","modified":1595250283397},{"_id":"themes/volantis/layout/post.ejs","hash":"e1285b47ace87cbcf0ab459ab2d51567e3d43bba","modified":1595250283398},{"_id":"themes/volantis/layout/tag.ejs","hash":"ea2058e970a8a5c933c6b0180d8fc8f4985e6dea","modified":1595250283398},{"_id":"themes/volantis/layout/_cover/index.ejs","hash":"cdf5c5e17a57cda45fdb890c8f061f3f39202ca2","modified":1595250283362},{"_id":"themes/volantis/layout/_meta/author.ejs","hash":"6abae4a1e188d2f059b841d6f466c8b77918ab66","modified":1595250283363},{"_id":"themes/volantis/layout/_meta/btns.ejs","hash":"e4004bbb7a2bf46dfc95cd610822c0d58e7af6b7","modified":1595250283363},{"_id":"themes/volantis/layout/_meta/category.ejs","hash":"1a801cf409dc24fd4ea1f90c9941b74890a16ec3","modified":1595250283363},{"_id":"themes/volantis/layout/_meta/counter.ejs","hash":"65168cd369fd0ff442b07a7d84bca12bd68b37bf","modified":1595250283364},{"_id":"themes/volantis/layout/_meta/date.ejs","hash":"e18dd6f5ea703ebd7afe50d4e94fdce8e33e71b3","modified":1595250283364},{"_id":"themes/volantis/layout/_meta/share.ejs","hash":"d1aca13ece4278daf470e801b23b7546959a5b4e","modified":1595250283365},{"_id":"themes/volantis/layout/_meta/music.ejs","hash":"32e95a5ad95bf799b58ca9f4d595c201d64e372e","modified":1595250283364},{"_id":"themes/volantis/layout/_meta/tags.ejs","hash":"111c399d6b90e2cda99d9d846c60e0a65bcd7e2d","modified":1595250283365},{"_id":"themes/volantis/layout/_meta/thumbnail.ejs","hash":"8afd94949e88f7c0373974234c6f80ed858705c7","modified":1595250283365},{"_id":"themes/volantis/layout/_meta/title.ejs","hash":"fd8c7b0011d4e9c5b3aad4f3a0a058cb6c33c05c","modified":1595250283366},{"_id":"themes/volantis/layout/_meta/top.ejs","hash":"4e7f1b980942b15eb5b15e43d969c4a0d3ad921f","modified":1595250283366},{"_id":"themes/volantis/layout/_meta/updated.ejs","hash":"4e6ed816c7ff181c820d1976e4557bcfb1486bc2","modified":1595250283367},{"_id":"themes/volantis/layout/_meta/wordcount.ejs","hash":"6d75bcb787ce216b45830c52e3a69b0b2630110e","modified":1595250283367},{"_id":"themes/volantis/layout/_partial/archive.ejs","hash":"4f3ec993e4498d0a9cd6e3f9aa796cbf6e659571","modified":1595250283367},{"_id":"themes/volantis/layout/_partial/article.ejs","hash":"0ac0daa27fa74185837c7d25593400d1aab2a2e9","modified":1595250283368},{"_id":"themes/volantis/layout/_partial/categories.ejs","hash":"7c7b6cc39e1aa8d01cc2e94d1195bb7620bb68ea","modified":1595250283368},{"_id":"themes/volantis/layout/_partial/cover.ejs","hash":"5beb8271519bccc1297381effd5de7f6cbf3cd7d","modified":1595250283368},{"_id":"themes/volantis/layout/_partial/footer.ejs","hash":"5f52f4e182e5329366ff1120df83e84553d339e3","modified":1595250283369},{"_id":"themes/volantis/layout/_partial/head.ejs","hash":"ce965fcfe6109fa4a03491421651be1c6688c2b4","modified":1595250283369},{"_id":"themes/volantis/layout/_partial/header.ejs","hash":"1c6ce0c39a0d6f76df4205d8d922e052a93d3b0c","modified":1595250283370},{"_id":"themes/volantis/layout/_partial/meta.ejs","hash":"35a7ca48dda87e414abb924468a9dcdcac0aca00","modified":1595250283370},{"_id":"themes/volantis/layout/_partial/post.ejs","hash":"b4f9de79f5d153898685de976218c5ff10175d35","modified":1595250283370},{"_id":"themes/volantis/layout/_partial/scripts.ejs","hash":"0086a9122a2a18ab1ecb89740ac9127e3efac72e","modified":1595250283371},{"_id":"themes/volantis/layout/_partial/side.ejs","hash":"8fcd8edfaa77a9f2b8ec93268c9448e515b46254","modified":1595250283371},{"_id":"themes/volantis/layout/_third-party/aplayer.ejs","hash":"e520ca71b9c5a8b9eb383d82ca741efcc753ee47","modified":1595250283372},{"_id":"themes/volantis/layout/_third-party/clipboard.ejs","hash":"88266c917e7283a6c76c382ac5fa7507729d586e","modified":1595250283373},{"_id":"themes/volantis/layout/_third-party/comments.ejs","hash":"9b1910c8900b2e4f0fd97922a83a0143c88cad77","modified":1595250283373},{"_id":"themes/volantis/layout/_third-party/fancybox.ejs","hash":"43a218adabbb875f8052d552ec045c7844717f24","modified":1595250283374},{"_id":"themes/volantis/layout/_third-party/mathjax.ejs","hash":"7a041dc40a291f5e75ffdc6f9cd04f49ac00f475","modified":1595250283375},{"_id":"themes/volantis/layout/_third-party/share.ejs","hash":"c94992ac78cbf97858f0cebc4a239ac8ab9fca55","modified":1595250283375},{"_id":"themes/volantis/layout/_widget/blogger.ejs","hash":"a7762c1b189ba5a644d140a3dbf9206864505d3c","modified":1595250283390},{"_id":"themes/volantis/layout/_widget/_pre.ejs","hash":"be59b18c8816d469e2d24fa644d7dc105ed2f850","modified":1595250283376},{"_id":"themes/volantis/layout/_widget/copyright.ejs","hash":"de6870c3cc658c054012c0c700d3e0342de99251","modified":1595250283391},{"_id":"themes/volantis/layout/_widget/category.ejs","hash":"7295c87e3e095018d07af7941232b12970f0fcc5","modified":1595250283390},{"_id":"themes/volantis/layout/_widget/grid.ejs","hash":"6ceb91ad7fecbfaf86342a99656767c76bca357d","modified":1595250283391},{"_id":"themes/volantis/layout/_widget/group.ejs","hash":"28955bae655056275b5b6313a296c4601c9f421c","modified":1595250283392},{"_id":"themes/volantis/layout/_widget/header.ejs","hash":"b54a04af22efd55585af6e76ddbb7e856c5e9601","modified":1595250283392},{"_id":"themes/volantis/layout/_widget/list.ejs","hash":"eac7e6b422049eff92e2eaff892519c9058dc342","modified":1595250283393},{"_id":"themes/volantis/layout/_widget/load.ejs","hash":"ebfb18816e32dd657eb6ecdb91e8f885e9e6d85e","modified":1595250283393},{"_id":"themes/volantis/layout/_widget/music.ejs","hash":"92f156ef87392f7842c72540367ae452d85b2d63","modified":1595250283394},{"_id":"themes/volantis/layout/_widget/page.ejs","hash":"49ee453f2694a978dc159a39667e74d6b5b139e5","modified":1595250283394},{"_id":"themes/volantis/layout/_widget/qrcode.ejs","hash":"0209fc678cf2e7d0bf35be6a4b572598c150515d","modified":1595250283394},{"_id":"themes/volantis/layout/_widget/references.ejs","hash":"99621003f5c8ec8aac7cbbb10924b33c9e2a705d","modified":1595250283395},{"_id":"themes/volantis/layout/_widget/related_posts.ejs","hash":"92754a4f747299709cda4e32a1eecb6ec54265ef","modified":1595250283395},{"_id":"themes/volantis/layout/_widget/tagcloud.ejs","hash":"e58c16a7671a3575cfec7093a24267d97f84646f","modified":1595250283395},{"_id":"themes/volantis/layout/_widget/text.ejs","hash":"a6e2d9e52008b548e1863355d319504abb59fabb","modified":1595250283395},{"_id":"themes/volantis/layout/_widget/toc.ejs","hash":"14e2078fcee0dabc10f37be53a065a8d1932dcfc","modified":1595250283396},{"_id":"themes/volantis/scripts/events/index.js","hash":"a0f10031807f8c58c99085cfe95d850269ca709b","modified":1595250283399},{"_id":"themes/volantis/scripts/tags/btn.js","hash":"b89a1a6a889ed5b54b2d9a5c63493fa35934e3aa","modified":1595250283400},{"_id":"themes/volantis/scripts/tags/btns.js","hash":"84f9f17a2b73ab84d0a4e0980e393a00807db4ec","modified":1595250283400},{"_id":"themes/volantis/scripts/tags/checkbox.js","hash":"636cef0f4500a14b123c6b21187fb67989472cbd","modified":1595250283401},{"_id":"themes/volantis/scripts/tags/dropmenu.js","hash":"5af4b247d1c05681455a3538949a95486f65eea8","modified":1595250283401},{"_id":"themes/volantis/scripts/tags/fancybox.js","hash":"775cfaccf7fc77dc9cbebe64bddcfe68eeafef4b","modified":1595250283401},{"_id":"themes/volantis/scripts/tags/folding.js","hash":"13cde292311a8d00f5d149a171f3d0f3251e20da","modified":1595250283402},{"_id":"themes/volantis/scripts/tags/image.js","hash":"6b575b64f6e185583794c6bb38a3f2a6d92b3ca0","modified":1595250283402},{"_id":"themes/volantis/scripts/tags/media.js","hash":"ebe4a6ebe34e8d77c0652c63bd5f763439743eb2","modified":1595250283418},{"_id":"themes/volantis/scripts/tags/note.js","hash":"21b6180562952b425e884dad73af3728179fb675","modified":1595250283430},{"_id":"themes/volantis/scripts/tags/span.js","hash":"89aaa0678188aa85ec18116af4b036f80ca7c073","modified":1595250283430},{"_id":"themes/volantis/scripts/tags/tabs.js","hash":"c59daf8a06e3a355663b89a7ab5445cdec5384fd","modified":1595250283430},{"_id":"themes/volantis/source/css/style.styl","hash":"1495c9f380ef3767b77251dfbb30d2cefe78ca4d","modified":1595250283518},{"_id":"themes/volantis/source/fonts/Monaco.ttf","hash":"d4de9305ce9e916ece179c3ab3b1faf80cc52bbb","modified":1595250283519},{"_id":"themes/volantis/source/img/algolia.svg","hash":"f86c0288423ba1b62c3bde06fc38f031af56e5f6","modified":1595250283530},{"_id":"themes/volantis/source/img/azure.svg","hash":"9c42c8070528e28a97705fb410e65100632ae92b","modified":1595250283530},{"_id":"themes/volantis/source/img/baidu.svg","hash":"8f08ba555b4d8b262e2c3b7793dd169760f63880","modified":1595250283531},{"_id":"themes/volantis/source/js/app.js","hash":"ccc2c5bc1df54f416885c5d3cac04af754da9ee7","modified":1595250283532},{"_id":"themes/volantis/source/js/search.js","hash":"f350aa35ddd23a9ccfed7b43043dbb1f5b53964f","modified":1595250283533},{"_id":"source/_posts/db-w-r-dynamic/db1.png","hash":"e0b0e27ac757a07286dd4489837218d24b204d2e","modified":1595250283322},{"_id":"themes/volantis/scripts/events/lib/config.js","hash":"913154f487b0e49c5a7fb0f462ec7fa4c90e87cb","modified":1595250283399},{"_id":"themes/volantis/source/css/_base/index.styl","hash":"ee21eabcb9908fd01c23ae85eb8707f414c03ec7","modified":1595250283441},{"_id":"themes/volantis/source/css/_defines/color.styl","hash":"e597104a59416e7fb4d1572ff5fd0e67f297f964","modified":1595250283442},{"_id":"themes/volantis/source/css/_defines/effect.styl","hash":"065bc72deaea55a248bd1e022d92252f456d7036","modified":1595250283456},{"_id":"themes/volantis/source/css/_defines/fonts.styl","hash":"0234b03f71e7b0ee1c2f2bf48cd37737e2d0b5cd","modified":1595250283457},{"_id":"themes/volantis/source/css/_defines/func.styl","hash":"79aa375a4e3a6c6f2a0ec87fd85c547612296ecb","modified":1595250283458},{"_id":"themes/volantis/source/css/_defines/layout.styl","hash":"1643920e34312eb2f4321998aaacede68a1587db","modified":1595250283480},{"_id":"themes/volantis/source/css/_highlight/index.styl","hash":"53db45fefb84930d5d40ae439464295a2d2dbaad","modified":1595250283481},{"_id":"themes/volantis/source/css/_layout/archive.styl","hash":"67056065d1281bdd176aae97fef87f197d2e407d","modified":1595250283483},{"_id":"themes/volantis/source/css/_layout/article.styl","hash":"62d690ba78262ff5511ee5c491b5035fb2b257d7","modified":1595250283484},{"_id":"themes/volantis/source/css/_layout/cover.styl","hash":"a6db8065545e8620403a9795584cea6d10ee42c5","modified":1595250283485},{"_id":"themes/volantis/source/css/_layout/footer.styl","hash":"b1052db8e5460c825fff635cbed54d5f1bf38af1","modified":1595250283486},{"_id":"themes/volantis/source/css/_layout/friends.styl","hash":"8f5cc4d8ca1caec43fc9d257a1901322ab66e8a5","modified":1595250283487},{"_id":"themes/volantis/source/css/_layout/main.styl","hash":"6b8a19f8b820d3cce8c99f956d85dd5af500ba82","modified":1595250283488},{"_id":"themes/volantis/source/css/_layout/navbar.styl","hash":"6c1d481974c5f7285e967305db17fd53a196ec24","modified":1617842827287},{"_id":"themes/volantis/source/css/_layout/pagination.styl","hash":"9036915102a38c51f012929a6d7d5ce80c5db937","modified":1595250283490},{"_id":"themes/volantis/source/css/_layout/search.styl","hash":"1c59d6f1a45b30cc367716d340b06808a6cf5709","modified":1595250283491},{"_id":"themes/volantis/source/css/_layout/sidebar.styl","hash":"540b86a614b07955d6caea91a73f1e904141c1eb","modified":1595250283492},{"_id":"themes/volantis/source/css/_layout/toc.styl","hash":"e9d2f43c88d801fa0a4d06821a2fc0fb38e98005","modified":1595250283493},{"_id":"themes/volantis/source/css/_tag-plugins/btns.styl","hash":"a498b10986c6a0a5525753a965842d9dcf2dffdb","modified":1595250283504},{"_id":"themes/volantis/source/css/_tag-plugins/checkbox.styl","hash":"aa14bee36fb93f8dbfe2289ce3be79a42ace2f10","modified":1595250283505},{"_id":"themes/volantis/source/css/_tag-plugins/dropmenu.styl","hash":"95dee4693b259c2cf301732d02f62fc932438bda","modified":1595250283506},{"_id":"themes/volantis/source/css/_tag-plugins/folding.styl","hash":"f3fa87977eaeefb35bafd3de07a31028e2a1217b","modified":1595250283507},{"_id":"themes/volantis/source/css/_tag-plugins/media.styl","hash":"de97807507e324554608c890c7fb54aecfbffd7e","modified":1595250283508},{"_id":"themes/volantis/source/css/_tag-plugins/note.styl","hash":"d57d8bc39e1c357467948b76106921d5e6a88098","modified":1595250283509},{"_id":"themes/volantis/source/css/_tag-plugins/span.styl","hash":"d12727c02efc5cd36ab7878f1dedbbbc2a1d07b3","modified":1595250283510},{"_id":"themes/volantis/source/css/_tag-plugins/tabs.styl","hash":"c33b6d2d7094512819180c72d36101670ed491fd","modified":1595250283511},{"_id":"themes/volantis/source/css/_third-party/aplayer.styl","hash":"2aa314005ced93a5b5b6d9b7b26b613a2ad5cac7","modified":1595250283513},{"_id":"themes/volantis/source/css/_third-party/alert.styl","hash":"b70cf9bb91586c70c70238802165a56b4bee8004","modified":1595250283512},{"_id":"themes/volantis/source/css/_third-party/clipboard.styl","hash":"939053df26a187536414eccadc4114c7ad0e3532","modified":1595250283515},{"_id":"themes/volantis/source/css/_third-party/fancybox.styl","hash":"1a1cbcf39561eb1cf65528d1fe9113f081bce208","modified":1595250283516},{"_id":"themes/volantis/source/css/_third-party/mathjax.styl","hash":"67e530188e29139c63c2c5a296f210c8069b8ef6","modified":1595250283516},{"_id":"themes/volantis/source/css/_third-party/valine.styl","hash":"1655fd3d16c135024a04de8d41fcb10290773c68","modified":1595250283517},{"_id":"themes/volantis/source/fonts/Skranji-Regular.ttf","hash":"485dc033e34a5a92a45ffe5839514f0471b18208","modified":1595250283523},{"_id":"themes/volantis/source/js/valine.js","hash":"f1d97dc61c43d8f40599f35314f0573987fb0d91","modified":1595250283536},{"_id":"themes/volantis/source/fonts/Ubuntu-Regular.ttf","hash":"b100b2ed912a91e4d0a7c5f5309fe8ad7b3a2dd8","modified":1595250283529},{"_id":"source/CHAME","hash":"301f6e82d2220eefbfc7f7f4464ec99b5286fd0a","modified":1617842826707},{"_id":"source/CNAME","hash":"301f6e82d2220eefbfc7f7f4464ec99b5286fd0a","modified":1617842826707},{"_id":"source/_posts/blockingqueue.md","hash":"6565dab640803c1d82b37ec14191c2de697c4594","modified":1617842826707},{"_id":"source/_posts/completable-future.md","hash":"0c2a55e127bd6f8660d8dc698c45ac9088f2e115","modified":1617842826717},{"_id":"source/_posts/design-pattern-singleton.md","hash":"a035779fdc3e6a7c45297ed73b13cbdffb187f34","modified":1617842826727},{"_id":"source/_posts/executorservice.md","hash":"387c5b667a828241972544d39b54d35483a85a1e","modified":1626659292692},{"_id":"source/_posts/fork-join.md","hash":"5c4ee3107ee1746ff782f33fd266456c9cfe4408","modified":1617842826727},{"_id":"source/_posts/gc-log.md","hash":"8b7931316493275521aee6ec92ac7fdb32398b00","modified":1617842826737},{"_id":"source/_posts/futuretask.md","hash":"bb4bbbd63539722972c50144fc4d2ebd64256448","modified":1617842826737},{"_id":"source/_posts/hashmap.md","hash":"eb5f789f8fec3d9786cb2ed0e7240221ffaacb64","modified":1637648751471},{"_id":"source/_posts/java-aqs.md","hash":"38269a587bd0a3ba323ba5f06599d6ce2cd1442b","modified":1617842826767},{"_id":"source/_posts/jvm-optimization.md","hash":"e7acd15b9d3912b5dd891c8796dc21421ff835a5","modified":1617842826777},{"_id":"source/_posts/io.md","hash":"0f8c33513dc7d4fb65b5120efc907248a0a2c59e","modified":1617842826757},{"_id":"source/_posts/kafka-base.md","hash":"1c3f0f2edf6120190db8f113bd42d2ae4ab0f383","modified":1617842826787},{"_id":"source/_posts/kafka-messge-complete.md","hash":"757e75c0bdf72de05519109bb3a677f2560067cf","modified":1617842826787},{"_id":"source/_posts/kafka-muticustomerthread.md","hash":"84370f4350b345b9e70e0b8152500e3edd1b4f2f","modified":1617842826797},{"_id":"source/_posts/kafka-operation.md","hash":"1faf25e1fc31503392c473917a402441f77d7863","modified":1617842826797},{"_id":"source/_posts/limit-single.md","hash":"13799bdf1bf5db8b87f839bb38c8f7cbbc8fa162","modified":1617842826797},{"_id":"source/_posts/linux-netstat.md","hash":"283a96974629fc714f944300f252aab8642ef068","modified":1617842826807},{"_id":"source/_posts/mysql-count.md","hash":"2a2724da4c7526a1144768dfe5cc6470266d62f5","modified":1617842826837},{"_id":"source/_posts/linux-top.md","hash":"06c1bdb91adc940f92a0485f86f52acdb09f7e91","modified":1619744319974},{"_id":"source/_posts/mysql-explain.md","hash":"d16ffc8dc61dfa79cd94ec12a9f74c97f7c3429f","modified":1629766550559},{"_id":"source/_posts/mysql-index-single.md","hash":"b52df215b9a9bd28d46d3cf934307adf87fb04cb","modified":1617842826847},{"_id":"source/_posts/mysql-index-use.md","hash":"95b787db5b0251005acbdc73712f3c3ff7de405b","modified":1617842826867},{"_id":"source/_posts/mysql-index.md","hash":"3f1ebbf53aa2b1f0bb9612bddd77ffd5e2382694","modified":1617842826867},{"_id":"source/_posts/mysql-lock.md","hash":"aa8ad2ce8370f1a58e4362800ec5cc246665b8d1","modified":1617842826887},{"_id":"source/_posts/mysql-log.md","hash":"7afee6fb64b0d5256218b74c71ff8a11c28c5c8d","modified":1617842826897},{"_id":"source/_posts/mysql-masterslave-solve.md","hash":"2abcd0c123a3988b2d1b0715ee75429ac8db11ab","modified":1617842826907},{"_id":"source/_posts/mysql-mvcc.md","hash":"2a834ebf3fbff9b8580028dcf1ea540d33638ada","modified":1617842826907},{"_id":"source/_posts/redis-aop-limit-boot.md","hash":"22e3722d1e0c56e5306f4137f38a7d7e8e724691","modified":1617842826917},{"_id":"source/_posts/redis-cluster-build-2.md","hash":"f46c5bdd9b1cacbce4a97070331b14efc1f096b2","modified":1617842826917},{"_id":"source/_posts/redis-cluster-build.md","hash":"5d5558f73bcb8bd0d62648a52c26b01657f5e044","modified":1617842826937},{"_id":"source/_posts/redis-commons.md","hash":"4f6d387d262bd3acb2eae066d52e77fb2c95233c","modified":1617842826947},{"_id":"source/_posts/redis-data-type.md","hash":"4525fbe0bc5892b6819ec00d423898b2efb2f044","modified":1617842826947},{"_id":"source/_posts/redis-known.md","hash":"0bb12006c15ab35035e871ec77ca9edef24dfa6c","modified":1617842826957},{"_id":"source/_posts/redis-master-slave.md","hash":"c91ba100b8a6e59b4ed785dd0c126f04c25cec91","modified":1617842826957},{"_id":"source/_posts/redis-rdb-aop.md","hash":"be6c42065db57ee932efdea1d13cb9c21b0a8592","modified":1617842826967},{"_id":"source/_posts/redis-sentinel.md","hash":"3533178d64b1432eee4c39ce457ba79b0840e08a","modified":1617842826977},{"_id":"source/_posts/sharding-student.md","hash":"9d7449fc6301cd3ac039ae28892efa2accb2efd7","modified":1617842826977},{"_id":"source/_posts/shardingjdbc-reg.md","hash":"aaa21d25f387c14bb7707024db95f9abc88ba5aa","modified":1617842826987},{"_id":"source/_posts/shardingphere-problem.md","hash":"8b4e0adbed35fea3ba17a80fd33fbedbdb2f9eb5","modified":1617842826987},{"_id":"source/_posts/spring-extend.md","hash":"bb2cfd834935d8d2d73cd18344218fbeccd312fb","modified":1617842826997},{"_id":"source/_posts/spring-forbean.md","hash":"bfdd48208c55e8d394daa698beb6219aef9d2226","modified":1617842827007},{"_id":"source/_posts/springboot-custom-start.md","hash":"32e7179c03bb17b09b4b5f233b242a676f361200","modified":1617842827017},{"_id":"source/_posts/springcloud-1.md","hash":"6023de05bf1aa0ebfc14d237669c064edc3d1df0","modified":1617842827027},{"_id":"source/_posts/springcloud-2.md","hash":"4b230991c0b47123ccad58a215e4b892962271ba","modified":1617842827037},{"_id":"source/_posts/springmvc.md","hash":"9a9e15e55bfcaf9e975690e9805126ab9273dff7","modified":1617842827037},{"_id":"source/_posts/springmvc2.md","hash":"8921380354719a268dfacddc4dc90943a9b3130e","modified":1617842827057},{"_id":"source/_posts/sring-class.md","hash":"e4dea8aa07b9798189606d76122e5ba065fe348d","modified":1617842827077},{"_id":"source/_posts/synchronized-up.md","hash":"044aa2e13e0606c4cfe2ba98460bffbf20d4f375","modified":1617842827087},{"_id":"source/_posts/thread-interrupted.md","hash":"9afbdb2ba9ac476bc5f808db017b90a7116172a3","modified":1617842827107},{"_id":"source/_posts/threadlocal.md","hash":"75187e01e65dbed6990fdc45387a5dec600c6daa","modified":1617842827107},{"_id":"source/_posts/volatile.md","hash":"93407a5813ea0b239adfe0dfc604aca7d2939bde","modified":1617842827117},{"_id":"source/_posts/zookeeper-lock.md","hash":"f7a14280a45a5c85a2a26a6abe6ac1980235370d","modified":1617842827127},{"_id":"source/categories/index.md","hash":"b4f1a5e7cd7b7e254ca6bd061a4c46f42137d410","modified":1617842827137},{"_id":"source/tags/index.md","hash":"d38ed53cd835a3b4a90f4ad48c8fff2f3cdc81d0","modified":1617842827137},{"_id":"source/categories/index/index.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1617842827137},{"_id":"source/tags/index/index.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1617842827137},{"_id":"themes/volantis/source/img/default.cur","hash":"3381d41a9dcbb4c4e69559723481f85e2b8cf99e","modified":1617842827307},{"_id":"themes/volantis/source/img/pointer.cur","hash":"3adb643f97571f547021fb57b2d9d768a252d546","modified":1617842827307},{"_id":"source/_posts/blockingqueue/0.png","hash":"5efe3b81835c7c439ac393832bc94d280dc08ccb","modified":1617842826707},{"_id":"source/_posts/blockingqueue/1.png","hash":"706d0a431cbaa440a336173cf51678a4996ee473","modified":1617842826707},{"_id":"source/_posts/blockingqueue/3.png","hash":"3244b501e93cfbad236c456aeb1da81861327163","modified":1617842826717},{"_id":"source/_posts/blockingqueue/2.png","hash":"ed56711e743235cd50b30ae086eead64f2e337ce","modified":1617842826707},{"_id":"source/_posts/blockingqueue/4.png","hash":"3227d5bf94727d69d4795bd29c82dada24fa9818","modified":1617842826717},{"_id":"source/_posts/blockingqueue/6.png","hash":"3d8f8532f5a2816bd4d5541cde6f675e18ad18b3","modified":1617842826717},{"_id":"source/_posts/blockingqueue/7.png","hash":"c54a2e76935d39bb1e6b60a986ac3cae7e054426","modified":1617842826717},{"_id":"source/_posts/blockingqueue/5.png","hash":"13ee83e568c5e0c3733dba8fbb71f4f28e28eecf","modified":1617842826717},{"_id":"source/_posts/db-w-r-dynamic/AbstractRoutingDataSource.png","hash":"512e2e6fecac69a70840cc70722dfc02c504c455","modified":1617842826717},{"_id":"source/_posts/executorservice/1.png","hash":"3a4682b8288aea56f4318ab6145cdb6effa97583","modified":1617842826727},{"_id":"source/_posts/executorservice/1.jpg","hash":"283b9ab6fc7eff67a534e8eed0801ba379de9b38","modified":1617842826727},{"_id":"source/_posts/executorservice/3.png","hash":"40d81d94837d24b540bddbf732ca3b30051ca987","modified":1617842826727},{"_id":"source/_posts/futuretask/2.png","hash":"fda83c61771ca8c8b2c79397f8dbe50fb9c2dfd4","modified":1617842826737},{"_id":"source/_posts/gc-log/3.png","hash":"d1c91df081fdd9086d7baaf6a0c5492be4291f1c","modified":1617842826737},{"_id":"source/_posts/futuretask/1.png","hash":"a111c366b9a45fa298e137539cd5957291ab02c2","modified":1617842826737},{"_id":"source/_posts/gc-log/2.jpg","hash":"ad542328d4e5de941acb2a23b1259e7faf49f6ea","modified":1617842826737},{"_id":"source/_posts/hashmap/2.png","hash":"2cb5fa5e53f4d70d62fd01fb6166cf28a14c9ee6","modified":1617842826747},{"_id":"source/_posts/gc-log/4.png","hash":"ac6072dcb882aa5502bcc645a6fdfcb62154b1c1","modified":1617842826737},{"_id":"source/_posts/hashmap/4.png","hash":"a00f42064c6eae9c95ef8c7142c7f08a48edd11d","modified":1617842826747},{"_id":"source/_posts/io/2.png","hash":"1d2bc6c05645cb5960c0c9e3d92d1432fa02260e","modified":1617842826757},{"_id":"source/_posts/io/1.png","hash":"9402dda2b02714b552cb2d984a889277715dd5ab","modified":1617842826757},{"_id":"source/_posts/java-aqs/1.jpg","hash":"d75006e35829bce9dabb8bff79b3d8cf549783a7","modified":1617842826767},{"_id":"source/_posts/java-aqs/2.jpg","hash":"7963eafcf3d94f053c6402527b0a561a9ca34389","modified":1617842826767},{"_id":"source/_posts/java-aqs/1.png","hash":"c13b617e06e9e6b17ca36dd9a4b6d98e2cebe4dd","modified":1617842826767},{"_id":"source/_posts/java-aqs/3.jpg","hash":"c72369593396990ad186c629f165731dd35d2ea9","modified":1617842826777},{"_id":"source/_posts/jvm-optimization/4.png","hash":"9038f86e74d4b8171a7f977d4644220ca57a4dae","modified":1617842826777},{"_id":"source/_posts/jvm-optimization/1.png","hash":"f4b894336a9d58bf18edbd158935d59751786f3e","modified":1617842826777},{"_id":"source/_posts/jvm-optimization/3.png","hash":"ac9c07053f183fd8a0933aa5422170e33bb3e0fd","modified":1617842826777},{"_id":"source/_posts/jvm-optimization/6.png","hash":"10b2c564e4848a168aa3e416b5595e9375a49a65","modified":1617842826787},{"_id":"source/_posts/jvm-optimization/5.png","hash":"8b41811815d037aa4a61ebfe9a6ea92284e278bb","modified":1617842826777},{"_id":"source/_posts/kafka-base/3.png","hash":"3c247c08bf7d3d898a4a4d3c0d258a7b5ad2822d","modified":1617842826787},{"_id":"source/_posts/kafka-base/4.png","hash":"6712356b0e980ddc61b89255c8ba460257a8cdd2","modified":1617842826787},{"_id":"source/_posts/kafka-messge-complete/1.png","hash":"15601248b896ece38b6e2d38c043fa8c0832e30d","modified":1617842826787},{"_id":"source/_posts/kafka-base/2.png","hash":"a43939ffe6e5600199a91f4d8e1829b7809360d3","modified":1617842826787},{"_id":"source/_posts/kafka-messge-complete/2.png","hash":"45d7e5819528878cfe10df49ae48a495608fb7aa","modified":1617842826787},{"_id":"source/_posts/kafka-messge-complete/3.png","hash":"36c0d3146f92baadac31322df649422a59c3cfc9","modified":1617842826797},{"_id":"source/_posts/kafka-muticustomerthread/1.png","hash":"1b42338f1630c801a1e7ed6b32b2db146918a69b","modified":1617842826797},{"_id":"source/_posts/linkedHashMap/1.png","hash":"1c11a7a02b5e2bdffc040fdc6ba840ca03d1686b","modified":1617842826807},{"_id":"source/_posts/linkedHashMap/2.png","hash":"3b1c66a4483f4e616eb3919ded8d5d03b6fa437d","modified":1617842826807},{"_id":"source/_posts/linux-netstat/2.png","hash":"e40e1b480ed38713e32b9f671384496b8b1b8ce3","modified":1617842826817},{"_id":"source/_posts/linux-netstat/4.png","hash":"48bb93f74ed981b730813cce7e446a26d2d59b89","modified":1617842826817},{"_id":"source/_posts/linux-netstat/3.png","hash":"ac7cf1e40ac921ea6d8506658992f3f6c2ee9391","modified":1617842826817},{"_id":"source/_posts/linux-netstat/5.png","hash":"637b69dec456a83c060cfd58088823d1d3f7af2b","modified":1617842826817},{"_id":"source/_posts/linux-top/1.png","hash":"73e5dd02fb26ec42690de2f23e235a9a0b160ce6","modified":1617842826827},{"_id":"source/_posts/linux-top/3.png","hash":"0eb78426115f0d147234b6439b5e5d43be704910","modified":1617842826827},{"_id":"source/_posts/linux-top/2.png","hash":"2546bb8025ef05a9634387f3d8e1ab330dbdabe2","modified":1617842826827},{"_id":"source/_posts/linux-top/4.png","hash":"cb057751e28e7505c010f4a73c300fab50f93724","modified":1617842826827},{"_id":"source/_posts/linux-top/5.png","hash":"9bb01438c01bbac427fb7beab021e6e43846650f","modified":1617842826827},{"_id":"source/_posts/linux-top/6.png","hash":"396444e99f9157531f18f03306f4bea3642c8183","modified":1617842826827},{"_id":"source/_posts/mysql-explain/1.png","hash":"e0a148157bca31264cd139d82b078f3a32105370","modified":1617842826837},{"_id":"source/_posts/mysql-explain/11.png","hash":"b9c9db4c3f28bce4148b16c85ea0f0b4c193f7c3","modified":1617842826837},{"_id":"source/_posts/mysql-explain/10.png","hash":"723b17612c27bc7528c2574fbf8b2b17d7062219","modified":1617842826837},{"_id":"source/_posts/mysql-explain/12.png","hash":"612d2986eac25acd1a93d54def33c20502b57a9f","modified":1617842826837},{"_id":"source/_posts/mysql-explain/13.png","hash":"5ef2b16707384b1e46618781a6295adb11959bf9","modified":1617842826847},{"_id":"source/_posts/mysql-explain/2.png","hash":"f9766858f432eb4ea210913d15841e32c1296dee","modified":1617842826847},{"_id":"source/_posts/mysql-explain/3.png","hash":"2fb49c998c5c441144f770822a39cea0ff3b76c2","modified":1617842826847},{"_id":"source/_posts/mysql-explain/5.png","hash":"00bc3294472b3ad24e6c5a7efc34d08eb6552fb4","modified":1617842826847},{"_id":"source/_posts/mysql-explain/4.png","hash":"f1e4211a217a0f1e2591a22afb87e371d466f076","modified":1617842826847},{"_id":"source/_posts/mysql-explain/7.png","hash":"882d96312ae1a994d23ba3c2a5f93c2f8b8a9557","modified":1617842826847},{"_id":"source/_posts/mysql-explain/8.png","hash":"fad38b076519dcf2e46678ec8bf8dd6191c638d9","modified":1617842826847},{"_id":"source/_posts/mysql-explain/9.png","hash":"0686402a1d93025d80ab4a0b9b8bd48bef13bfff","modified":1617842826847},{"_id":"source/_posts/mysql-explain/6.png","hash":"3a86a6468bee06b62826b4b6e31d58f55aad5697","modified":1617842826847},{"_id":"source/_posts/mysql-index/5.png","hash":"34c2d39e25de753949c40b308bc14720fbc9dee4","modified":1617842826877},{"_id":"source/_posts/mysql-index/6.png","hash":"be29dafbbba51cadded9c50c8602169f16a42e4f","modified":1617842826877},{"_id":"source/_posts/mysql-index-single/1.png","hash":"c9f3596a49b492c6ba587497d4d00df0aa5680ca","modified":1617842826857},{"_id":"source/_posts/mysql-index-single/2.png","hash":"e1aa45ba85c9740cd734035ec369b079b7f7c6c4","modified":1617842826857},{"_id":"source/_posts/mysql-index-single/10.png","hash":"e9d0f6012dbbc64b30270bdfd96ba835962c3c9c","modified":1617842826857},{"_id":"source/_posts/mysql-index-single/3.png","hash":"31cb0c3b4ac8639de69147403d55e165e501ca6f","modified":1617842826857},{"_id":"source/_posts/mysql-index-single/7.png","hash":"24ea2cf8b38aa29485dd4643c74450a50621b8f8","modified":1617842826857},{"_id":"source/_posts/mysql-index-single/6.png","hash":"5129bb4d3810f203f362b7f2bf36991d2b6a69ba","modified":1617842826857},{"_id":"source/_posts/mysql-index-single/8.png","hash":"6e56a2abaf102799bf3198c6f8f3436b9b86141b","modified":1617842826857},{"_id":"source/_posts/mysql-lock/2.png","hash":"0adcfa90c5a8f52ca0aa57570c8fda2be66947ca","modified":1617842826897},{"_id":"source/_posts/mysql-lock/3.png","hash":"435d3d4888673dac7b2cd6663f45286a747f7387","modified":1617842826897},{"_id":"source/_posts/mysql-lock/5.png","hash":"3d916d5e030ba6282cc2d9209c2ecfb1ba24f8de","modified":1617842826897},{"_id":"source/_posts/mysql-lock/4.png","hash":"d19e8e93ed53ff9278857aec39a0c22691687e4e","modified":1617842826897},{"_id":"source/_posts/mysql-lock/6.png","hash":"52dd43e150fdba915712541333ab157182d1b4b9","modified":1617842826897},{"_id":"source/_posts/mysql-lock/8.png","hash":"2427f9d7dbf5b2f8677edb97eabff99ca3ab375c","modified":1617842826897},{"_id":"source/_posts/mysql-masterslave-solve/1.jpg","hash":"8b36c7c9a7aff09da128c6056e910133276a32b0","modified":1617842826907},{"_id":"source/_posts/mysql-mvcc/1.png","hash":"62e983218071cfade48ef493afe9fb828ab75b8b","modified":1617842826917},{"_id":"source/_posts/mysql-mvcc/2.png","hash":"065d56e599940faa50daa41f43f1526f5bd8e83d","modified":1617842826917},{"_id":"source/_posts/redis-cluster-build/1.png","hash":"684e357612fccba91f3c261aaf0e0b67c05cea9e","modified":1617842826937},{"_id":"source/_posts/redis-cluster-build/10.png","hash":"900addde5c2b629f060a99f8640630ae6628e94c","modified":1617842826937},{"_id":"source/_posts/redis-cluster-build/3.png","hash":"b253f7fe18c6784a586e4b6ce9f16c27490e69fc","modified":1617842826937},{"_id":"source/_posts/redis-cluster-build/2.png","hash":"aa598a040798a15494cbe9b7005a9abc35f8c962","modified":1617842826937},{"_id":"source/_posts/redis-cluster-build/5.png","hash":"b31ca09270410b604344bce804f3a99d2bae4535","modified":1617842826937},{"_id":"source/_posts/redis-cluster-build/4.png","hash":"9b1271e1e5caf4231d9cec8f740eaa13158bc963","modified":1617842826937},{"_id":"source/_posts/redis-cluster-build/6.png","hash":"05693e37fbc379accc5b70add27c034cbae65d56","modified":1617842826947},{"_id":"source/_posts/redis-cluster-build/8.png","hash":"e299893a6c1496fb19d7ee730d94869f1a73d2b8","modified":1617842826947},{"_id":"source/_posts/redis-cluster-build/7.png","hash":"e7980bef26cc81a5807f04fe39956f000ac26eeb","modified":1617842826947},{"_id":"source/_posts/redis-cluster-build/9.png","hash":"856105fa0775abe10d445e322a24baa2784660bd","modified":1617842826947},{"_id":"source/_posts/redis-cluster-build-2/1.png","hash":"53ffddf403a4d26e9a24de4c7ed60058fdd81aaf","modified":1617842826917},{"_id":"source/_posts/redis-cluster-build-2/2.png","hash":"81304c8a9087f6efd692b90fe897e650fa879906","modified":1617842826917},{"_id":"source/_posts/redis-cluster-build-2/3.png","hash":"d9d1f25700a1b7872a3294bb20140be663a335de","modified":1617842826927},{"_id":"source/_posts/redis-cluster-build-2/4.png","hash":"342e3a623d9828c5b29e33960f75fcc61530397e","modified":1617842826927},{"_id":"source/_posts/redis-cluster-build-2/5.png","hash":"412648b61d5cdf2104894d66f62ee173bc38109f","modified":1617842826927},{"_id":"source/_posts/redis-cluster-build-2/6.png","hash":"e18fec49233eb866383c92df84cccae6731218fe","modified":1617842826927},{"_id":"source/_posts/redis-cluster-build-2/9.png","hash":"d92d64a7b127e888d3cc67856450248f9de58d1f","modified":1617842826937},{"_id":"source/_posts/redis-data-type/1.png","hash":"7d5fc065f85184510445c8100993f81aaed90095","modified":1617842826947},{"_id":"source/_posts/redis-data-type/3.png","hash":"a63c9b8d4194eb88e2898f890582ab2c3243e03f","modified":1617842826947},{"_id":"source/_posts/redis-data-type/2.png","hash":"b267cb522acd47056318e0b1181077cecbd93af7","modified":1617842826947},{"_id":"source/_posts/redis-data-type/4.png","hash":"5c1a19807fc9134cce58aac14f33422ddbabe859","modified":1617842826957},{"_id":"source/_posts/redis-data-type/5.png","hash":"96db1ca1407c9a79d39ffddd07c7af32612a281f","modified":1617842826957},{"_id":"source/_posts/redis-known/2.png","hash":"5653ea41f9fa3e5889860945d287d960476a6f06","modified":1617842826957},{"_id":"source/_posts/redis-known/1.png","hash":"c3b59a9ddc1bb1ce14c7aa28b169dac0e03297e3","modified":1617842826957},{"_id":"source/_posts/redis-master-slave/3.png","hash":"f627db51ddd50f68fa21e3bddf8e5ed3645fdf63","modified":1617842826967},{"_id":"source/_posts/redis-sentinel/1.png","hash":"0a5def8c5a790f12261f0a2d7bf9fcf0ca7b0478","modified":1617842826977},{"_id":"source/_posts/sharding-student/1.png","hash":"969c138fcf2d2ae8c083011da4473107fcab242d","modified":1617842826977},{"_id":"source/_posts/redis-sentinel/2.png","hash":"23b48b7cee91f9bad089f8f2b2a829d3ef814f9f","modified":1617842826977},{"_id":"source/_posts/sharding-student/3.png","hash":"1f4b4f7c349d8cf113bf973fc5333ce578b09ec8","modified":1617842826977},{"_id":"source/_posts/sharding-student/4.png","hash":"5ad4d9f93109ad3c683648f935d0be70f6a6364d","modified":1617842826977},{"_id":"source/_posts/shardingjdbc-reg/1.png","hash":"28b3eb91b0c4d3d6414862fb454e3fa8b3f31004","modified":1617842826987},{"_id":"source/_posts/spring-extend/1.png","hash":"208b77be0ca2c4386916695f0d0a9950a1ba35da","modified":1617842826997},{"_id":"source/_posts/spring-extend/3.png","hash":"5412c8b35c9f27cd2b64b2cc52ec1e6ff2a70d2f","modified":1617842826997},{"_id":"source/_posts/spring-extend/2.png","hash":"c2ef9b256068d6ced1dd89ee60b0e247a1df4e90","modified":1617842826997},{"_id":"source/_posts/springboot-custom-start/1.png","hash":"abcc5ad123604454dcb2e082cd5a9ca020152a81","modified":1617842827017},{"_id":"source/_posts/springboot-custom-start/2.png","hash":"b70ebadd1e9b3855ff890e7edfc6d4a5cc0e6782","modified":1617842827017},{"_id":"source/_posts/springboot-custom-start/4.png","hash":"7d07b83787c26f6aa47606c10332ab944321d2ca","modified":1617842827027},{"_id":"source/_posts/springboot-custom-start/5.png","hash":"0d1de503cb979be81d68b926432c60667c37b330","modified":1617842827027},{"_id":"source/_posts/springboot-custom-start/6.png","hash":"7eece3ad17a6a588d7f186632eda6310cbd51d6a","modified":1617842827027},{"_id":"source/_posts/springcloud-1/1.png","hash":"bef59875b49bcfee389e483f6a1c5910f31273ba","modified":1617842827027},{"_id":"source/_posts/springcloud-2/1.png","hash":"b6e339997ff3e3faba8a7f46e5b18150e2d63efc","modified":1617842827037},{"_id":"source/_posts/springmvc/2.png","hash":"36d372d40a4662102d10040b2058e134e66d9983","modified":1617842827047},{"_id":"source/_posts/springmvc/5.png","hash":"f655f0507e55e592d94a79a46d8220846026b63f","modified":1617842827057},{"_id":"source/_posts/springmvc/4.png","hash":"8badfc7b4a8e32b64ad5a1cda5e73ce1ded5a135","modified":1617842827047},{"_id":"source/_posts/springmvc/7.png","hash":"5b5aa2a37e3f7741444e8864a15b5a8350b6dac4","modified":1617842827057},{"_id":"source/_posts/springmvc2/10.png","hash":"10d853c5b61981adbd913aa1b5def022ab531cbc","modified":1617842827067},{"_id":"source/_posts/sring-class/1.jpg","hash":"f60f5483f0e7d0b8ad27fd320e356198603f3177","modified":1617842827077},{"_id":"source/_posts/sring-class/2.jpg","hash":"f23f793c0ccde9bf19502b79ae634c8262431e5f","modified":1617842827087},{"_id":"source/_posts/sring-class/4.png","hash":"5007fe666463ec229d2e4d5805281f462355b75e","modified":1617842827087},{"_id":"source/_posts/synchronized-up/1.jpg","hash":"4b096854decabb8c19d717d9e84e49bc02a3360c","modified":1617842827087},{"_id":"source/_posts/synchronized-up/6.png","hash":"d0a9ebec0a968cd3d37a68f11654c897e1f54bf1","modified":1617842827107},{"_id":"source/_posts/volatile/2.png","hash":"87caef509ec0ee6d8d852fc446a56e10018574cc","modified":1617842827127},{"_id":"source/_posts/zookeeper-lock/1.png","hash":"78e0866ada3a68c6eddbacad6ab5998f065cef56","modified":1617842827127},{"_id":"source/_posts/zookeeper-lock/2.png","hash":"dc7d2b0d8fb619856c189c035b4223ff5e08e23f","modified":1617842827127},{"_id":"source/_posts/zookeeper-lock/3.png","hash":"fa9549485e0509604e585b32c3a35dea17ab78c8","modified":1617842827127},{"_id":"source/_posts/executorservice/4.png","hash":"91149d5c4ee2014b517540877336ca6ef510294e","modified":1617842826727},{"_id":"source/_posts/gc-log/1.jpg","hash":"f576808db7c258888e0c4b961066219e3eacda51","modified":1617842826737},{"_id":"source/_posts/java-aqs/2.png","hash":"17106cdf8abc13e7404989b489084e29e2151caa","modified":1617842826767},{"_id":"source/_posts/kafka-base/1.png","hash":"d531dad10c13bca4d48dd6ffdd62443dc22ee3e9","modified":1617842826787},{"_id":"source/_posts/limit-single/2.png","hash":"fab361dd8d9049acb285b3afd9becb4d7c4b7eae","modified":1617842826807},{"_id":"source/_posts/limit-single/1.png","hash":"79174ff831d95783ef983cb161914319e8aa53bf","modified":1617842826797},{"_id":"source/_posts/linux-netstat/6.png","hash":"2813d5df686053cef0e10a717ef952b1d0a480b1","modified":1617842826827},{"_id":"source/_posts/mysql-explain/14.png","hash":"d75a58d8ed4fd012f962d8d7317981f929cdf9d6","modified":1617842826847},{"_id":"source/_posts/mysql-index/1.png","hash":"d3ea95f9a94a36a972f3bf46173b20045a5f4c88","modified":1617842826867},{"_id":"source/_posts/mysql-index/2.png","hash":"8bbaf9d18a8d0c8043000923c77c9983af0a8c8c","modified":1617842826867},{"_id":"source/_posts/mysql-index/3.png","hash":"9174ec848d4fdf797ab730a379b7a2fc4e32f93f","modified":1617842826877},{"_id":"source/_posts/mysql-index-single/4.png","hash":"397358c3fcd12febc42c138639474d851995a249","modified":1617842826857},{"_id":"source/_posts/mysql-index-single/5.png","hash":"fd0f98c5315e33c21f7345f26f7becee6f98191c","modified":1617842826857},{"_id":"source/_posts/mysql-index-single/9.png","hash":"08c706d872e5166067b6c5c019c865cf395750c8","modified":1617842826867},{"_id":"source/_posts/redis-aop-limit-boot/1.png","hash":"79174ff831d95783ef983cb161914319e8aa53bf","modified":1617842826917},{"_id":"source/_posts/redis-aop-limit-boot/2.png","hash":"fab361dd8d9049acb285b3afd9becb4d7c4b7eae","modified":1617842826917},{"_id":"source/_posts/redis-cluster-build-2/8.png","hash":"55479153d8d624a5ab1ce600d2873438cf326302","modified":1617842826927},{"_id":"source/_posts/redis-cluster-build-2/7.png","hash":"c4bcd50ed8860b29e70113f2135596ba1c3043c7","modified":1617842826927},{"_id":"source/_posts/redis-master-slave/1.png","hash":"7c944848d609b32c54dc41dd12229e02b7a073e3","modified":1617842826967},{"_id":"source/_posts/redis-master-slave/2.png","hash":"efafddee4293ed2ffa9c83fd69cba447a36b3cd3","modified":1617842826967},{"_id":"source/_posts/redis-rdb-aop/1.png","hash":"7c944848d609b32c54dc41dd12229e02b7a073e3","modified":1617842826967},{"_id":"source/_posts/shardingjdbc-reg/2.png","hash":"60cd868c22211019331342266a00937d29f5db38","modified":1617842826987},{"_id":"source/_posts/shardingphere-problem/2.png","hash":"4ade0a4a28428211126978a3e52979bb85eca8f0","modified":1617842826997},{"_id":"source/_posts/spring-extend/4.png","hash":"627e82ae73a943379d62dcad307274d2290bb601","modified":1617842827007},{"_id":"source/_posts/spring-forbean/1.png","hash":"f01c0cc64977367829d830d848610ad05e410846","modified":1617842827007},{"_id":"source/_posts/spring-forbean/5.png","hash":"01c0a43780757c3a953d59190613903d71939c96","modified":1617842827017},{"_id":"source/_posts/springcloud-2/Hystrix.png","hash":"933e4df680f8f681a3934bf9a666ecd6faef7258","modified":1617842827037},{"_id":"source/_posts/springmvc/10.png","hash":"7c4d83765f9f74b84861cf806ee8170bdea9d00f","modified":1617842827047},{"_id":"source/_posts/springmvc/6.png","hash":"7bacf148e1e82022d616a8989b6d02cc8582d71c","modified":1617842827057},{"_id":"source/_posts/springmvc/8.png","hash":"b83b77cfd02de2607eaff64828a0c06ae7b3972f","modified":1617842827057},{"_id":"source/_posts/springmvc2/11.png","hash":"7aca834d553f182df1bb89b72df61bf0a719ce3a","modified":1617842827067},{"_id":"source/_posts/springmvc2/13.png","hash":"6fcc61bec3de669e69f07524e6b17098cda5bc29","modified":1617842827067},{"_id":"source/_posts/sring-class/1.png","hash":"6be2302b416e6a29b41da1531c34281565f4a721","modified":1617842827087},{"_id":"source/_posts/threadlocal/4.png","hash":"f6e5dbb559dc1f7b7ae5dc02f09cdb2d87ba08fc","modified":1617842827117},{"_id":"source/_posts/threadlocal/2.png","hash":"8cc5585a4ddc1e81e11a35d3401ab7058444fc70","modified":1617842827107},{"_id":"source/_posts/threadlocal/5.png","hash":"d42aeff70c69f488dbca9450c891665efd17f604","modified":1617842827117},{"_id":"source/_posts/threadlocal/6.png","hash":"d0c160d22ac14324d20a4dbde468d530d20edd9e","modified":1617842827117},{"_id":"source/_posts/volatile/1.png","hash":"128c34f5c3b398cf0efdc4bb14c626761d1ff13b","modified":1617842827127},{"_id":"source/_posts/mysql-index/4.png","hash":"c84c1987cc47d6f36ae8ddcfbcfca68ebbf3f2a2","modified":1617842826877},{"_id":"source/_posts/mysql-index/7.png","hash":"92bf4b898e3501d626f0bee5e5614a6682a89bf6","modified":1617842826877},{"_id":"source/_posts/mysql-index-use/1.png","hash":"63057fb1deb7fa27ab2c73779a742874a3ec13b5","modified":1617842826867},{"_id":"source/_posts/mysql-lock/7.png","hash":"0603105790a687ab19ec220563de68ec27b11cf5","modified":1617842826897},{"_id":"source/_posts/redis-rdb-aop/3.png","hash":"974dda74335d942120861d44655c705807427c88","modified":1617842826967},{"_id":"source/_posts/sharding-student/2.png","hash":"225583b10cda9550c62b3c6d803c8bbd611420f9","modified":1617842826977},{"_id":"source/_posts/shardingphere-problem/1.png","hash":"9b6a021f9cc3075bac7fa77766ea4cd9665ac645","modified":1617842826997},{"_id":"source/_posts/spring-forbean/1.jpg","hash":"f57e001a46ea900febb2bc28dfa1eaaa46e9c686","modified":1617842827007},{"_id":"source/_posts/springmvc2/12.png","hash":"1f41a0a5ae46cfc3ba5550d8595ca4425935ca77","modified":1617842827067},{"_id":"source/_posts/springmvc2/14.png","hash":"97e3e2e2cae20302c1db05d7b0dfe5d12215de77","modified":1617842827067},{"_id":"source/_posts/sring-class/3.png","hash":"256ff4a2a75e539ca9a24d8aaff92c7a675ca30c","modified":1617842827087},{"_id":"source/_posts/threadlocal/1.png","hash":"138bfe43bc2548b17b22b416c905551bf90fc879","modified":1617842827107},{"_id":"source/_posts/io/3.png","hash":"28049a44fae989f2e1064c513ac693787e085429","modified":1617842826757},{"_id":"source/_posts/jvm-optimization/2.png","hash":"190f2e044a6baf14da40fc8df3262577b5a9875f","modified":1617842826777},{"_id":"source/_posts/mysql-index/8.png","hash":"764bd50903b85cbfc9c14d2fd36e6e1377b50fc2","modified":1617842826887},{"_id":"source/_posts/redis-rdb-aop/2.png","hash":"fa15ad2b45c316c9e7262882d877401cdfa7d678","modified":1617842826967},{"_id":"source/_posts/spring-forbean/2.png","hash":"7ba2d137e4613ba1d6dca98bf22fcc6d3652e5d8","modified":1617842827007},{"_id":"source/_posts/spring-forbean/4.png","hash":"8b46904f55c3af297eb4727b39fc5b0685867c88","modified":1617842827017},{"_id":"source/_posts/springboot-custom-start/3.png","hash":"c038091fde608162d3412d3f71517ad66f2de3eb","modified":1617842827027},{"_id":"source/_posts/springboot-custom-start/7.png","hash":"fdb6365de751bf2944c2860dff54f869c3dd3c8e","modified":1617842827027},{"_id":"source/_posts/springmvc2/15.png","hash":"4f95e32fa55772ee20d816ada0acff48b8841a65","modified":1617842827077},{"_id":"source/_posts/springmvc2/16.png","hash":"e8c121887f8a46a819f6357565ce4ae9a230f0b8","modified":1617842827077},{"_id":"source/_posts/hashmap/3.png","hash":"4643087f458887d5743069f90e1691642a47ae6f","modified":1617842826747},{"_id":"source/_posts/hashmap/1.png","hash":"d7c240371f349cc0a84411bb72dfcb9a0eaa2d8b","modified":1617842826747},{"_id":"source/_posts/io/4.png","hash":"e706080387623abcbce59b0853564c411812fc6d","modified":1617842826767},{"_id":"source/_posts/springmvc/9.png","hash":"d7c1d85109edd964cb9b5a74b43124e849a60562","modified":1617842827057},{"_id":"source/_posts/threadlocal/3.png","hash":"b78663c288f6015f002fa1b2cdb93a1f87dad055","modified":1617842827117},{"_id":"source/_posts/mysql-explain/1.jpg","hash":"127cba4a5ff20fca3c34ab946c0c2af3f97bf0dc","modified":1617842826837},{"_id":"source/_posts/mysql-log/1.png","hash":"b697a4d816c99d0a275ecea99302f3a5d508170b","modified":1617842826907},{"_id":"source/_posts/mysql-log/2.png","hash":"b0311c9c6a1ac5aad8bbb34f123db0e6131857a3","modified":1617842826907},{"_id":"source/_posts/spring-forbean/3.png","hash":"a5b9516ad74ad7424cd8fa8a6fe3b4a940b78351","modified":1617842827017},{"_id":"source/_posts/springmvc/3.png","hash":"b1fce291dcc78db58788e58e9c585475014d2833","modified":1617842827047},{"_id":"source/_posts/synchronized-up/4.png","hash":"b28b3266ec5e47c8c04744bd5d4b22dfccdf8f27","modified":1617842827097},{"_id":"source/_posts/synchronized-up/3.png","hash":"9e4849d1fac3ff7e76c653d6d78dae28d23355cb","modified":1617842827097},{"_id":"source/_posts/executorservice/2.png","hash":"094bb1fb6515174badd053a02f493cf7ed252c01","modified":1617842826727},{"_id":"source/_posts/synchronized-up/2.png","hash":"0b636cb6389f04aa5d5649588fa2aabe8917e727","modified":1617842827087},{"_id":"source/_posts/synchronized-up/5.png","hash":"c997c59d5468ce4f709917e7ac7975b56e816605","modified":1617842827097},{"_id":"source/_posts/hashmap/5.png","hash":"5be06150681a29d113a9db3dbf6bb5c268382460","modified":1617842826757},{"_id":"source/_posts/linux-netstat/1.png","hash":"ef984b3b670eac9b4425a87979db0dc9e6edae48","modified":1617842826817},{"_id":"source/_posts/springmvc/1.png","hash":"f97a46fefebc780e4a5f543058dc5b6e7152a903","modified":1617842827047},{"_id":"source/_posts/mysql-lock/1.png","hash":"2a84e5eadda98e728c1727e6eb1f24e9d5b51398","modified":1617842826887},{"_id":"source/_posts/blockchain-1.md","hash":"0888fb07fc501a0a556361df9c482516dca8d5fb","modified":1623036015938},{"_id":"source/_posts/elasticsearch-01.md","hash":"9a9288f3623ab49288b76701861070f256b9728b","modified":1619267355104},{"_id":"source/_posts/influxdb-1.md","hash":"d127fb1afc66c4444a2b8aa5145041a8247efddc","modified":1619744891109},{"_id":"source/_posts/docker-redis.md","hash":"398a41c4dbc156bfd22635a4c6feebef62eca283","modified":1623978927673},{"_id":"source/_posts/docker-study.md","hash":"3b55e936148eadef6e3eee9276a78e181ac99aa2","modified":1633786550014},{"_id":"source/_posts/go-pointer.md","hash":"4926b59a2c13c3ce4883342ee28148910a2ad6ea","modified":1637306226487},{"_id":"source/_posts/go-study-01.md","hash":"22cc4a2ff29503809c61cccaa4f6da2ecb819b6f","modified":1637648751468},{"_id":"source/_posts/rust-node-1.md","hash":"4e968a400432bf1ea4268bc43ec0d0a5e92f7b18","modified":1624257182868},{"_id":"source/_posts/solidity.md","hash":"2b7f0c614374c8fc75e916d2525edc6c1d5bbbaa","modified":1632057287967},{"_id":"source/_posts/go-study-01/1.png","hash":"b770e4ca2a8968347213686f7ce5246cf441f78e","modified":1637648751469},{"_id":"source/_posts/go-study-01/2.png","hash":"18b6014911463fbddb0ef5ee65badd6edb6fee5f","modified":1637648751469},{"_id":"source/_posts/go-pointer/1.png","hash":"f43eb962738647a211080a5c74dd79be59b933ce","modified":1637302969598},{"_id":"source/_posts/go-study-01/3.png","hash":"5327dad3dc7977ac4b7d15f1c97294b2b021fef0","modified":1637648751470},{"_id":"source/_posts/go-pointer/2.png","hash":"47b77c3c51073d8e98ef1a9dcacd79fd443903f0","modified":1637305315428},{"_id":"source/_posts/go-study-01/4.png","hash":"3156a3a5bd07ac5d43cff196c5eebf40de5d2df0","modified":1637648751470},{"_id":"source/_posts/go-study-01/5.png","hash":"513dd952b1aa49d43875903bb0586149171335b4","modified":1637648751470},{"_id":"source/_posts/go-pointer/3.png","hash":"31f29c33776040af4a5a345966b2e2a3a12c33a7","modified":1637305689830},{"_id":"public/tags/index.html","hash":"297344778f7eee10c8923fae3660fda006c08fe5","modified":1637648791194},{"_id":"public/categories/index.html","hash":"3c580ae3d6020182c000aa6d84087783b97cedba","modified":1637648791194},{"_id":"public/2021/11/12/go-pointer/index.html","hash":"506a4bbce853156f19e87c53021f9d5e88bec9f7","modified":1637648791194},{"_id":"public/2021/05/30/solidity/index.html","hash":"d8fb67be7a304f80b92ab3d112a0350372a5c65e","modified":1637648791194},{"_id":"public/2021/04/24/elasticsearch-01/index.html","hash":"437714cef0e3ff489e387edad050f6aac197c27e","modified":1637648791194},{"_id":"public/2021/05/18/go-study-01/index.html","hash":"cfd103126d34fbebf755917fe5b30774d20d9b93","modified":1637648791194},{"_id":"public/2021/04/08/sring-class/index.html","hash":"586853f70535518e771d9071a72254941c0f6f35","modified":1637648791194},{"_id":"public/2021/04/08/linux-top/index.html","hash":"a25270b3a1b6507c6759f969610b8b8f10eac7a5","modified":1637648791194},{"_id":"public/2021/04/08/linux-netstat/index.html","hash":"f562c667da8cf5303152e9a55d9a0b1fbb730616","modified":1637648791194},{"_id":"public/2020/07/20/db-w-r-dynamic/index.html","hash":"da3f5cad058aa74a39814039ffda6a87f2a8e674","modified":1637648791194},{"_id":"public/archives/index.html","hash":"9fb9c2e7a397d8c70b133330c6772057416b2018","modified":1637648791194},{"_id":"public/archives/2020/index.html","hash":"45eef648cf6e61ee874c553a0a6ee313bcddbdba","modified":1637648791194},{"_id":"public/archives/2020/07/index.html","hash":"444fcb4575b71cdb06571ddc6c2953d2b8f81fb6","modified":1637648791194},{"_id":"public/tags/mysql/index.html","hash":"bcff1015e56765d14143391b8a31d8c09643fe57","modified":1637648791194},{"_id":"public/tags/架构/index.html","hash":"8ef41c90fd373bb474677601bef63b6d6258c65f","modified":1637648791194},{"_id":"public/index.html","hash":"a8c02f8bc8e5a4891dd771c832fe14619ee06a83","modified":1637648791194},{"_id":"public/tags/index/index.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1637648791194},{"_id":"public/categories/index/index.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1637648791194},{"_id":"public/2021/02/02/shardingjdbc-reg/index.html","hash":"1dca3cc8bc2634580b86259339165bd200beafd4","modified":1637648791194},{"_id":"public/2021/02/02/shardingphere-problem/index.html","hash":"5d869e0dfc7de5e798a97b5c250276c06861603c","modified":1637648791194},{"_id":"public/2021/02/10/influxdb-1/index.html","hash":"d02509db6726eb6fbedf535e789b73419c77efbb","modified":1637648791194},{"_id":"public/2021/01/09/sharding-student/index.html","hash":"40f30cfa6d2141e4827fd620e4adf21424d17029","modified":1637648791194},{"_id":"public/2021/01/02/springcloud-2/index.html","hash":"037cf6d16b3c0a3970547a18ba7fdd5b08c6c7d6","modified":1637648791194},{"_id":"public/2021/01/01/springcloud-1/index.html","hash":"d10e9e8feb10df88a5987f17116dd29912d3ace2","modified":1637648791194},{"_id":"public/2020/12/02/kafka-messge-complete/index.html","hash":"bc81518078af87e10f471dcfcec94a006c33b01a","modified":1637648791194},{"_id":"public/2020/12/10/io/index.html","hash":"40d2eade731bd355b8f78dbde7740c96c7f8f734","modified":1637648791194},{"_id":"public/2020/12/17/redis-known/index.html","hash":"d343aa9ce0fee19515564a7150c3f1d6be84a38b","modified":1637648791194},{"_id":"public/2020/10/30/blockingqueue/index.html","hash":"0817b5b1e8792cebff19fee02016ee475e163df8","modified":1637648791194},{"_id":"public/2020/11/11/mysql-lock/index.html","hash":"b9f17a17d5c0aee9dcb8ebf5cbabffa2fe9d8fd3","modified":1637648791194},{"_id":"public/2020/10/30/blockchain-1/index.html","hash":"eb42c172f7ef18283187ab8a1b273febaaf5b0b2","modified":1637648791194},{"_id":"public/2020/10/09/kafka-base/index.html","hash":"50070d36e70f7e760f0723bc07e8c26c990ee8b4","modified":1637648791194},{"_id":"public/2020/10/03/redis-data-type/index.html","hash":"6de2e00255d8e5545e983896899c017d1f042f1b","modified":1637648791194},{"_id":"public/2020/09/27/springboot-custom-start/index.html","hash":"c99d3086f22e706cd85bdf73ca50f5be38a09756","modified":1637648791194},{"_id":"public/2020/09/13/spring-extend/index.html","hash":"8f0358263449e1671aec41de4f97e18f26312252","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/index.html","hash":"69200fc34a11465edd187c2263f19f7970c42972","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/index.html","hash":"0c53667d2ec777899951755bfbf7b04e34073292","modified":1637648791194},{"_id":"public/2020/09/06/java-aqs/index.html","hash":"a7f15b3c704ea966aadc997568fbe8f90d54a895","modified":1637648791194},{"_id":"public/2020/08/30/mysql-mvcc/index.html","hash":"4e3981d0ec13ccefb2ebb6f3088d667db0fc1beb","modified":1637648791194},{"_id":"public/2020/08/27/zookeeper-lock/index.html","hash":"1ab7689e3386ee0dd27071ff84e6fef7556f02b9","modified":1637648791194},{"_id":"public/2020/08/27/thread-interrupted/index.html","hash":"0bdb23da8bfff76087f44eb5a10445ec82459792","modified":1637648791194},{"_id":"public/2020/08/26/redis-rdb-aop/index.html","hash":"65ce19a8caa6a91aa38d21ad0a3201501fae5728","modified":1637648791194},{"_id":"public/2020/08/19/mysql-masterslave-solve/index.html","hash":"530522edaf807975b31b5b0d27f45bbd24b1d7ec","modified":1637648791194},{"_id":"public/2020/08/20/redis-master-slave/index.html","hash":"d015b91480da9a65b91a9f463f5ab04115b8811a","modified":1637648791194},{"_id":"public/2020/08/14/redis-sentinel/index.html","hash":"18152b10bf958b223176454e8135c3e2cae9ec13","modified":1637648791194},{"_id":"public/2020/08/14/rust-node-1/index.html","hash":"bbecf1db149a8495483940af62b5345001582850","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/index.html","hash":"e1e9605b2a740068490a9213137dd1e49e32935c","modified":1637648791194},{"_id":"public/2020/08/12/threadlocal/index.html","hash":"c1a8ec7b44d268d630c51a0f48d1736ea8ae4735","modified":1637648791194},{"_id":"public/2020/08/09/synchronized-up/index.html","hash":"afbe67b29321cde164540b9f7801129f5186ae43","modified":1637648791194},{"_id":"public/2020/07/30/fork-join/index.html","hash":"93380cc27fbe0c81868665e655dce693df466ea8","modified":1637648791194},{"_id":"public/2020/05/10/spring-forbean/index.html","hash":"123aace2f73080e69b3ebea0170153a45b136687","modified":1637648791194},{"_id":"public/2020/05/07/jvm-optimization/index.html","hash":"af2282404063a7c1f773bbef5e51768eafab91eb","modified":1637648791194},{"_id":"public/2020/01/26/mysql-count/index.html","hash":"f3813f634bcaa4f2490bb80f44e3a88dd8de4c4d","modified":1637648791194},{"_id":"public/2020/01/04/springmvc2/index.html","hash":"7419bb9e088465fce75487e1f8405ca493076ef8","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/index.html","hash":"c86a81b343305c7fcc5e99f64c77f5c2adc7cb5d","modified":1637648791194},{"_id":"public/2020/07/28/hashmap/index.html","hash":"437ffe053c55ca3aea938ceaba64a1704b9ef02c","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/index.html","hash":"2251a3420d26bb98b36e21e02f5608d56cfab033","modified":1637648791194},{"_id":"public/2019/11/16/kafka-operation/index.html","hash":"b019707d324cb9ad7d51675f7485e688d23962b4","modified":1637648791194},{"_id":"public/2019/10/03/redis-commons/index.html","hash":"2a1123ed13027d8f3c727655e7ccc5c4aea97ddf","modified":1637648791194},{"_id":"public/2019/11/15/kafka-muticustomerthread/index.html","hash":"8abad8742af924b81d525f59904c54c1aba3a075","modified":1637648791194},{"_id":"public/2019/07/18/completable-future/index.html","hash":"c7af3bb2ecbadcc7a92902933b37eb39a0bd7b76","modified":1637648791194},{"_id":"public/2019/07/18/design-pattern-singleton/index.html","hash":"bf7381d8a79ed6563bdb2d79616a06be1497e7ca","modified":1637648791194},{"_id":"public/2019/07/18/futuretask/index.html","hash":"15820bf56afeb4819e306af1057dadda549a88e0","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index-use/index.html","hash":"bc187a7e4b4f69face56f8e8cb4d231c828b35ed","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index/index.html","hash":"ca65c25de6e7fa048b13b5ada8f969f14044aa28","modified":1637648791194},{"_id":"public/2019/07/18/volatile/index.html","hash":"c6d69e9935d977eb2fcf355f9e23bbdf3fc482f8","modified":1637648791194},{"_id":"public/2019/07/18/docker-study/index.html","hash":"215d7e97e6de8cb37be156a35fc92d328075b477","modified":1637648791194},{"_id":"public/2019/07/18/docker-redis/index.html","hash":"f3f3e2bb72d24fb85bdf7b179233586e8251ca22","modified":1637648791194},{"_id":"public/2019/02/18/gc-log/index.html","hash":"1fe99e2fb67121bef47707cd4c0b8a9e799ec95f","modified":1637648791194},{"_id":"public/2019/02/18/limit-single/index.html","hash":"ab272b37aaa3c1e31cf23a54b903f7f0e9b056b7","modified":1637648791194},{"_id":"public/2019/02/18/redis-aop-limit-boot/index.html","hash":"ad03773d3e80436d00703b198789afd272dd1c8f","modified":1637648791194},{"_id":"public/2018/08/07/mysql-log/index.html","hash":"e1efc22d09c17bc57e1f673e575e420b69138a52","modified":1637648791194},{"_id":"public/archives/page/2/index.html","hash":"9fb9c2e7a397d8c70b133330c6772057416b2018","modified":1637648791194},{"_id":"public/2018/01/18/executorservice/index.html","hash":"eee7db3cd458419e2285bea672f8b8106e3c61f1","modified":1637648791194},{"_id":"public/archives/page/3/index.html","hash":"9fb9c2e7a397d8c70b133330c6772057416b2018","modified":1637648791194},{"_id":"public/archives/page/4/index.html","hash":"9fb9c2e7a397d8c70b133330c6772057416b2018","modified":1637648791194},{"_id":"public/archives/page/5/index.html","hash":"9fb9c2e7a397d8c70b133330c6772057416b2018","modified":1637648791194},{"_id":"public/archives/page/6/index.html","hash":"9fb9c2e7a397d8c70b133330c6772057416b2018","modified":1637648791194},{"_id":"public/archives/page/7/index.html","hash":"9fb9c2e7a397d8c70b133330c6772057416b2018","modified":1637648791194},{"_id":"public/archives/2018/index.html","hash":"d8f9c18e0994242f8bc6724dff6e11039c0c1a87","modified":1637648791194},{"_id":"public/archives/2018/01/index.html","hash":"1595bfc792143e6ace90bfdcb8e4a3835b598f0f","modified":1637648791194},{"_id":"public/archives/2018/08/index.html","hash":"fc37c236cde37d5bafa79c607c9026a97d8bcb79","modified":1637648791194},{"_id":"public/archives/2019/index.html","hash":"70d1c41f7a1efd737f465c13883d0dc8b1eadbc2","modified":1637648791194},{"_id":"public/archives/2019/page/2/index.html","hash":"85d479ebfbc618c20e19d49bcfb6d2b4bd6425e3","modified":1637648791194},{"_id":"public/archives/2019/02/index.html","hash":"013d07db6601c74598c7eb42ce64499ba26e2efe","modified":1637648791194},{"_id":"public/archives/2019/07/index.html","hash":"3e554a96a63ffc98d4ffcffc29e97e6cca3ad30b","modified":1637648791194},{"_id":"public/archives/2019/10/index.html","hash":"337a606e083a1b1974f8a566f9273baeccdbc8dd","modified":1637648791194},{"_id":"public/archives/2019/11/index.html","hash":"4d70649d0989881b794982bc02083b5ae0f89145","modified":1637648791194},{"_id":"public/archives/2020/page/3/index.html","hash":"0f89d6bb1200dc941ca0d8a4e99035a02313566d","modified":1637648791194},{"_id":"public/archives/2020/page/2/index.html","hash":"6955e6ad7eb4156900553dc9d275b67406186935","modified":1637648791194},{"_id":"public/archives/2020/page/4/index.html","hash":"f7879a3181be8d0900d92565263bcbd429136c28","modified":1637648791194},{"_id":"public/archives/2020/01/index.html","hash":"629c13909f5cdda3f29df1057d783a97a66c6e7c","modified":1637648791194},{"_id":"public/archives/2020/05/index.html","hash":"8636f3b3e8a0b13b5585a7b6078285533daa24d9","modified":1637648791194},{"_id":"public/archives/2020/08/index.html","hash":"65c46679e23c23df55f4c7dac77ca0cd1486c703","modified":1637648791194},{"_id":"public/archives/2020/09/index.html","hash":"8fe9995f2de2cc21e5d52959ce74355b1e018189","modified":1637648791194},{"_id":"public/archives/2021/index.html","hash":"e04f301a0b813cfe31358a49720a50d718e8725c","modified":1637648791194},{"_id":"public/archives/2021/page/2/index.html","hash":"bba7f2f3ddd1dca9718a3e81e5d3ceb61aa0d2ed","modified":1637648791194},{"_id":"public/archives/2021/01/index.html","hash":"94b363b6f55c68fd60110b1cc54238f4d3e5a11e","modified":1637648791194},{"_id":"public/archives/2020/10/index.html","hash":"19ecc1b1dfecf4a56e41c61bf468c091bd5b5ca9","modified":1637648791194},{"_id":"public/archives/2021/02/index.html","hash":"a88f07296d89c9dadd9e23fe2bd4e5709575d900","modified":1637648791194},{"_id":"public/archives/2020/11/index.html","hash":"6691cf34a5988227ad67114e702708db5e61abbe","modified":1637648791194},{"_id":"public/archives/2020/12/index.html","hash":"cf1c85ecca27ef325b05f49c598936025648d09e","modified":1637648791194},{"_id":"public/archives/2021/04/index.html","hash":"28de372a01cf512f735a0eda2a960ee2bd41a386","modified":1637648791194},{"_id":"public/categories/java/index.html","hash":"198369fa61e122dc40b0add66ca4f6635e87e5ec","modified":1637648791194},{"_id":"public/archives/2021/05/index.html","hash":"da9e989a8f8e28feb327d644a30f26411dd8c43e","modified":1637648791194},{"_id":"public/archives/2021/11/index.html","hash":"251f8fb031760fcab0742c01178ffaf95cfe772c","modified":1637648791194},{"_id":"public/categories/linux/index.html","hash":"74311760bf1c090d39531568055b88af6ac118f7","modified":1637648791194},{"_id":"public/categories/java/page/2/index.html","hash":"4a69ce158e4f868b0e6af169c8a1471e0c5a66fe","modified":1637648791194},{"_id":"public/categories/kafka/index.html","hash":"a97285f97b9080b8c04c45aac004c72b3247ddd2","modified":1637648791194},{"_id":"public/categories/mysql/index.html","hash":"28092caacb7d28bc252434db2a26084a50ddd11d","modified":1637648791194},{"_id":"public/categories/redis/index.html","hash":"af3cf2ff18f8a8e297b4c328784b217f321380b8","modified":1637648791194},{"_id":"public/categories/shardingjdbc/index.html","hash":"2625fa96762a5bcb64cfb1f7114a2632b6c8b22f","modified":1637648791194},{"_id":"public/categories/spring/index.html","hash":"a134e4796922c01d255a7c899ff4656dde21ed01","modified":1637648791194},{"_id":"public/categories/SpringCloud/index.html","hash":"9c48d8d3b9b98da6a3485135be5053c9c5608ba9","modified":1637648791194},{"_id":"public/categories/zookeeper/index.html","hash":"a06737d050e438701fd0c00b4355f99fd6a3287b","modified":1637648791194},{"_id":"public/categories/架构/index.html","hash":"5654dfc94ec1ef961b1059a0cfa0cdd385939bd1","modified":1637648791194},{"_id":"public/categories/区块链/index.html","hash":"5c318994e2e7fdbdf01c5f0d28c8d05eb61d3280","modified":1637648791194},{"_id":"public/categories/influxdb/index.html","hash":"5b6edea376b6c4cac38719047b1244a1893461c0","modified":1637648791194},{"_id":"public/categories/ElasticSearch/index.html","hash":"d919d768d997ec4d6206371d68e651899601cc42","modified":1637648791194},{"_id":"public/categories/GoLang/index.html","hash":"de83ff3776a1e0c010bee0f1a21d124a09c2b9b6","modified":1637648791194},{"_id":"public/categories/Docker/index.html","hash":"2571c4b9db1640384c6f918fcfb88cb66d5c6e4c","modified":1637648791194},{"_id":"public/tags/java并发/index.html","hash":"cccad559225cecc94edb55ff5577e2cac025d0b2","modified":1637648791194},{"_id":"public/categories/rust/index.html","hash":"e545f779337a731416c972b2ead4a0de05b544b9","modified":1637648791194},{"_id":"public/tags/设计模式/index.html","hash":"d3f0b2f9cdad995eec82e44827f949cf4a8b1164","modified":1637648791194},{"_id":"public/tags/java8/index.html","hash":"dfbccfab8b835177e811637510e4d3a8bda3d19c","modified":1637648791194},{"_id":"public/tags/java并发/page/2/index.html","hash":"4002f80ea0e93f93520d71c72f3d43ddd1defd78","modified":1637648791194},{"_id":"public/tags/jvm/index.html","hash":"a53a10252bcc4186ad71a29801c1428a671f86b8","modified":1637648791194},{"_id":"public/tags/linux/index.html","hash":"41437fb690f29c6dcd28f5cc8ddc541045af5afc","modified":1637648791194},{"_id":"public/tags/java集合/index.html","hash":"5f501a42c9e3d9cef2c76d26f800af496bb1c27a","modified":1637648791194},{"_id":"public/tags/kafka/index.html","hash":"de680455fe5ec3c1a4caef3d4b55920accbccbd1","modified":1637648791194},{"_id":"public/tags/项目实践/index.html","hash":"19e45cf94f2ee2034ca86b7e6755b115c94d6374","modified":1637648791194},{"_id":"public/tags/网络/index.html","hash":"765b55bbd4d6b72d0ecaa8aad57c660dc21d94ff","modified":1637648791194},{"_id":"public/tags/redis/index.html","hash":"e782c58c3bd5a4137f6aafe4d38157205933bba8","modified":1637648791194},{"_id":"public/tags/shardingjdbc/index.html","hash":"618e02a7b8da9459e130d2a4781ee77f14e7dd21","modified":1637648791194},{"_id":"public/tags/spring/index.html","hash":"98b55afdf3160414d56368f090ed842dcd78b84d","modified":1637648791194},{"_id":"public/tags/SpringCloud/index.html","hash":"2eae486b69a9a2e4e01583f4a887e35789e34330","modified":1637648791194},{"_id":"public/tags/zookeeper/index.html","hash":"a584072f3f45b0a49320b4d1f944d65b0ed8414d","modified":1637648791194},{"_id":"public/tags/区块链/index.html","hash":"54746361b1c54991b9388f8910a9bcf688395b0d","modified":1637648791194},{"_id":"public/tags/influxdb/index.html","hash":"4e7b90a99776d1104e580b2aa6cb47131fdec0fa","modified":1637648791194},{"_id":"public/tags/ElasticSearch/index.html","hash":"d9aa27195493c6aea420ac5423051a3e0a209985","modified":1637648791194},{"_id":"public/tags/GoLang/index.html","hash":"2856860540814b4ec67ee6046203ea969c6c83e0","modified":1637648791194},{"_id":"public/tags/Docker/index.html","hash":"96a0adf802f9093a330e9661f1db8a86262c04fc","modified":1637648791194},{"_id":"public/page/3/index.html","hash":"fedd6ab4ee622102799b2cd4839d088fa06c9b39","modified":1637648791194},{"_id":"public/tags/rust/index.html","hash":"73d5a901522e127bbb0cdc0de81fbffafc30a6cd","modified":1637648791194},{"_id":"public/page/4/index.html","hash":"1bc822a2faafe2ff61fff05bb93c8deef1f39cbd","modified":1637648791194},{"_id":"public/page/2/index.html","hash":"05db1dddc9b72f118c6e47a2692667c595c7b7e0","modified":1637648791194},{"_id":"public/page/5/index.html","hash":"00403b9ddd6afe726b02939923b40946872343e4","modified":1637648791194},{"_id":"public/page/6/index.html","hash":"36ff93ead0be51f3a72df3ab1a1be4e921e6d173","modified":1637648791194},{"_id":"public/page/7/index.html","hash":"1322e30b6420d21ba9c0d34545de0bea353a50db","modified":1637648791194},{"_id":"public/CNAME","hash":"301f6e82d2220eefbfc7f7f4464ec99b5286fd0a","modified":1637648791194},{"_id":"public/CHAME","hash":"301f6e82d2220eefbfc7f7f4464ec99b5286fd0a","modified":1637648791194},{"_id":"public/2020/07/20/db-w-r-dynamic/AbstractRoutingDataSource.png","hash":"512e2e6fecac69a70840cc70722dfc02c504c455","modified":1637648791194},{"_id":"public/img/pointer.cur","hash":"3adb643f97571f547021fb57b2d9d768a252d546","modified":1637648791194},{"_id":"public/img/default.cur","hash":"3381d41a9dcbb4c4e69559723481f85e2b8cf99e","modified":1637648791194},{"_id":"public/2019/11/15/kafka-muticustomerthread/1.png","hash":"1b42338f1630c801a1e7ed6b32b2db146918a69b","modified":1637648791194},{"_id":"public/2021/01/01/springcloud-1/1.png","hash":"bef59875b49bcfee389e483f6a1c5910f31273ba","modified":1637648791194},{"_id":"public/2019/07/18/futuretask/1.png","hash":"a111c366b9a45fa298e137539cd5957291ab02c2","modified":1637648791194},{"_id":"public/2019/07/18/futuretask/2.png","hash":"fda83c61771ca8c8b2c79397f8dbe50fb9c2dfd4","modified":1637648791194},{"_id":"public/2020/08/19/mysql-masterslave-solve/1.jpg","hash":"8b36c7c9a7aff09da128c6056e910133276a32b0","modified":1637648791194},{"_id":"public/2020/08/30/mysql-mvcc/1.png","hash":"62e983218071cfade48ef493afe9fb828ab75b8b","modified":1637648791194},{"_id":"public/2020/08/30/mysql-mvcc/2.png","hash":"065d56e599940faa50daa41f43f1526f5bd8e83d","modified":1637648791194},{"_id":"public/2020/12/17/redis-known/1.png","hash":"c3b59a9ddc1bb1ce14c7aa28b169dac0e03297e3","modified":1637648791194},{"_id":"public/2020/08/14/redis-sentinel/1.png","hash":"0a5def8c5a790f12261f0a2d7bf9fcf0ca7b0478","modified":1637648791194},{"_id":"public/2021/02/02/shardingjdbc-reg/1.png","hash":"28b3eb91b0c4d3d6414862fb454e3fa8b3f31004","modified":1637648791194},{"_id":"public/2020/08/14/redis-sentinel/2.png","hash":"23b48b7cee91f9bad089f8f2b2a829d3ef814f9f","modified":1637648791194},{"_id":"public/2021/01/02/springcloud-2/1.png","hash":"b6e339997ff3e3faba8a7f46e5b18150e2d63efc","modified":1637648791194},{"_id":"public/2020/12/02/kafka-messge-complete/2.png","hash":"45d7e5819528878cfe10df49ae48a495608fb7aa","modified":1637648791194},{"_id":"public/2020/08/20/redis-master-slave/3.png","hash":"f627db51ddd50f68fa21e3bddf8e5ed3645fdf63","modified":1637648791194},{"_id":"public/2020/12/02/kafka-messge-complete/3.png","hash":"36c0d3146f92baadac31322df649422a59c3cfc9","modified":1637648791194},{"_id":"public/2019/07/18/volatile/2.png","hash":"87caef509ec0ee6d8d852fc446a56e10018574cc","modified":1637648791194},{"_id":"public/2020/12/02/kafka-messge-complete/1.png","hash":"15601248b896ece38b6e2d38c043fa8c0832e30d","modified":1637648791194},{"_id":"public/2019/02/18/gc-log/3.png","hash":"d1c91df081fdd9086d7baaf6a0c5492be4291f1c","modified":1637648791194},{"_id":"public/2020/08/27/zookeeper-lock/1.png","hash":"78e0866ada3a68c6eddbacad6ab5998f065cef56","modified":1637648791194},{"_id":"public/2020/12/10/io/2.png","hash":"1d2bc6c05645cb5960c0c9e3d92d1432fa02260e","modified":1637648791194},{"_id":"public/2019/02/18/gc-log/2.jpg","hash":"ad542328d4e5de941acb2a23b1259e7faf49f6ea","modified":1637648791194},{"_id":"public/2021/01/09/sharding-student/1.png","hash":"969c138fcf2d2ae8c083011da4473107fcab242d","modified":1637648791194},{"_id":"public/2020/08/27/zookeeper-lock/2.png","hash":"dc7d2b0d8fb619856c189c035b4223ff5e08e23f","modified":1637648791194},{"_id":"public/2020/10/09/kafka-base/2.png","hash":"a43939ffe6e5600199a91f4d8e1829b7809360d3","modified":1637648791194},{"_id":"public/2021/01/09/sharding-student/3.png","hash":"1f4b4f7c349d8cf113bf973fc5333ce578b09ec8","modified":1637648791194},{"_id":"public/2020/10/09/kafka-base/4.png","hash":"6712356b0e980ddc61b89255c8ba460257a8cdd2","modified":1637648791194},{"_id":"public/2021/01/09/sharding-student/4.png","hash":"5ad4d9f93109ad3c683648f935d0be70f6a6364d","modified":1637648791194},{"_id":"public/2020/10/09/kafka-base/3.png","hash":"3c247c08bf7d3d898a4a4d3c0d258a7b5ad2822d","modified":1637648791194},{"_id":"public/2018/01/18/executorservice/1.jpg","hash":"283b9ab6fc7eff67a534e8eed0801ba379de9b38","modified":1637648791194},{"_id":"public/2018/01/18/executorservice/1.png","hash":"3a4682b8288aea56f4318ab6145cdb6effa97583","modified":1637648791194},{"_id":"public/2020/09/13/spring-extend/1.png","hash":"208b77be0ca2c4386916695f0d0a9950a1ba35da","modified":1637648791194},{"_id":"public/2020/09/13/spring-extend/2.png","hash":"c2ef9b256068d6ced1dd89ee60b0e247a1df4e90","modified":1637648791194},{"_id":"public/2020/09/13/spring-extend/3.png","hash":"5412c8b35c9f27cd2b64b2cc52ec1e6ff2a70d2f","modified":1637648791194},{"_id":"public/2018/01/18/executorservice/4.png","hash":"91149d5c4ee2014b517540877336ca6ef510294e","modified":1637648791194},{"_id":"public/2020/07/28/hashmap/4.png","hash":"a00f42064c6eae9c95ef8c7142c7f08a48edd11d","modified":1637648791194},{"_id":"public/2020/09/06/java-aqs/1.jpg","hash":"d75006e35829bce9dabb8bff79b3d8cf549783a7","modified":1637648791194},{"_id":"public/2018/01/18/executorservice/3.png","hash":"40d81d94837d24b540bddbf732ca3b30051ca987","modified":1637648791194},{"_id":"public/2020/09/06/java-aqs/2.jpg","hash":"7963eafcf3d94f053c6402527b0a561a9ca34389","modified":1637648791194},{"_id":"public/2020/09/06/java-aqs/1.png","hash":"c13b617e06e9e6b17ca36dd9a4b6d98e2cebe4dd","modified":1637648791194},{"_id":"public/2020/07/28/hashmap/2.png","hash":"2cb5fa5e53f4d70d62fd01fb6166cf28a14c9ee6","modified":1637648791194},{"_id":"public/2020/10/03/redis-data-type/2.png","hash":"b267cb522acd47056318e0b1181077cecbd93af7","modified":1637648791194},{"_id":"public/2020/10/03/redis-data-type/1.png","hash":"7d5fc065f85184510445c8100993f81aaed90095","modified":1637648791194},{"_id":"public/2021/04/08/sring-class/1.jpg","hash":"f60f5483f0e7d0b8ad27fd320e356198603f3177","modified":1637648791194},{"_id":"public/2020/10/03/redis-data-type/3.png","hash":"a63c9b8d4194eb88e2898f890582ab2c3243e03f","modified":1637648791194},{"_id":"public/2020/09/06/java-aqs/3.jpg","hash":"c72369593396990ad186c629f165731dd35d2ea9","modified":1637648791194},{"_id":"public/2020/10/03/redis-data-type/4.png","hash":"5c1a19807fc9134cce58aac14f33422ddbabe859","modified":1637648791194},{"_id":"public/2021/04/08/sring-class/2.jpg","hash":"f23f793c0ccde9bf19502b79ae634c8262431e5f","modified":1637648791194},{"_id":"public/2021/04/08/sring-class/4.png","hash":"5007fe666463ec229d2e4d5805281f462355b75e","modified":1637648791194},{"_id":"public/2020/05/07/jvm-optimization/4.png","hash":"9038f86e74d4b8171a7f977d4644220ca57a4dae","modified":1637648791194},{"_id":"public/2020/10/03/redis-data-type/5.png","hash":"96db1ca1407c9a79d39ffddd07c7af32612a281f","modified":1637648791194},{"_id":"public/2020/05/07/jvm-optimization/3.png","hash":"ac9c07053f183fd8a0933aa5422170e33bb3e0fd","modified":1637648791194},{"_id":"public/2021/04/08/linux-netstat/2.png","hash":"e40e1b480ed38713e32b9f671384496b8b1b8ce3","modified":1637648791194},{"_id":"public/2021/04/08/linux-netstat/4.png","hash":"48bb93f74ed981b730813cce7e446a26d2d59b89","modified":1637648791194},{"_id":"public/2020/05/07/jvm-optimization/1.png","hash":"f4b894336a9d58bf18edbd158935d59751786f3e","modified":1637648791194},{"_id":"public/2021/04/08/linux-netstat/5.png","hash":"637b69dec456a83c060cfd58088823d1d3f7af2b","modified":1637648791194},{"_id":"public/2020/05/07/jvm-optimization/5.png","hash":"8b41811815d037aa4a61ebfe9a6ea92284e278bb","modified":1637648791194},{"_id":"public/2020/05/07/jvm-optimization/6.png","hash":"10b2c564e4848a168aa3e416b5595e9375a49a65","modified":1637648791194},{"_id":"public/2021/04/08/linux-netstat/3.png","hash":"ac7cf1e40ac921ea6d8506658992f3f6c2ee9391","modified":1637648791194},{"_id":"public/2021/04/08/linux-top/1.png","hash":"73e5dd02fb26ec42690de2f23e235a9a0b160ce6","modified":1637648791194},{"_id":"public/2021/04/08/linux-top/2.png","hash":"2546bb8025ef05a9634387f3d8e1ab330dbdabe2","modified":1637648791194},{"_id":"public/2021/04/08/linux-top/3.png","hash":"0eb78426115f0d147234b6439b5e5d43be704910","modified":1637648791194},{"_id":"public/2021/04/08/linux-top/4.png","hash":"cb057751e28e7505c010f4a73c300fab50f93724","modified":1637648791194},{"_id":"public/2021/04/08/linux-top/5.png","hash":"9bb01438c01bbac427fb7beab021e6e43846650f","modified":1637648791194},{"_id":"public/2020/08/09/synchronized-up/1.jpg","hash":"4b096854decabb8c19d717d9e84e49bc02a3360c","modified":1637648791194},{"_id":"public/2021/04/08/linux-top/6.png","hash":"396444e99f9157531f18f03306f4bea3642c8183","modified":1637648791194},{"_id":"public/2020/08/09/synchronized-up/6.png","hash":"d0a9ebec0a968cd3d37a68f11654c897e1f54bf1","modified":1637648791194},{"_id":"public/2020/09/27/springboot-custom-start/1.png","hash":"abcc5ad123604454dcb2e082cd5a9ca020152a81","modified":1637648791194},{"_id":"public/2020/09/27/springboot-custom-start/2.png","hash":"b70ebadd1e9b3855ff890e7edfc6d4a5cc0e6782","modified":1637648791194},{"_id":"public/2020/09/27/springboot-custom-start/4.png","hash":"7d07b83787c26f6aa47606c10332ab944321d2ca","modified":1637648791194},{"_id":"public/2020/09/27/springboot-custom-start/5.png","hash":"0d1de503cb979be81d68b926432c60667c37b330","modified":1637648791194},{"_id":"public/2020/09/27/springboot-custom-start/6.png","hash":"7eece3ad17a6a588d7f186632eda6310cbd51d6a","modified":1637648791194},{"_id":"public/2020/01/04/springmvc2/10.png","hash":"10d853c5b61981adbd913aa1b5def022ab531cbc","modified":1637648791194},{"_id":"public/2020/10/30/blockingqueue/0.png","hash":"5efe3b81835c7c439ac393832bc94d280dc08ccb","modified":1637648791194},{"_id":"public/2020/10/30/blockingqueue/1.png","hash":"706d0a431cbaa440a336173cf51678a4996ee473","modified":1637648791194},{"_id":"public/2020/10/30/blockingqueue/4.png","hash":"3227d5bf94727d69d4795bd29c82dada24fa9818","modified":1637648791194},{"_id":"public/2020/10/30/blockingqueue/2.png","hash":"ed56711e743235cd50b30ae086eead64f2e337ce","modified":1637648791194},{"_id":"public/2020/10/30/blockingqueue/3.png","hash":"3244b501e93cfbad236c456aeb1da81861327163","modified":1637648791194},{"_id":"public/2020/10/30/blockingqueue/5.png","hash":"13ee83e568c5e0c3733dba8fbb71f4f28e28eecf","modified":1637648791194},{"_id":"public/2020/10/30/blockingqueue/7.png","hash":"c54a2e76935d39bb1e6b60a986ac3cae7e054426","modified":1637648791194},{"_id":"public/2020/10/30/blockingqueue/6.png","hash":"3d8f8532f5a2816bd4d5541cde6f675e18ad18b3","modified":1637648791194},{"_id":"public/2020/11/11/mysql-lock/2.png","hash":"0adcfa90c5a8f52ca0aa57570c8fda2be66947ca","modified":1637648791194},{"_id":"public/2020/11/11/mysql-lock/4.png","hash":"d19e8e93ed53ff9278857aec39a0c22691687e4e","modified":1637648791194},{"_id":"public/2020/11/11/mysql-lock/3.png","hash":"435d3d4888673dac7b2cd6663f45286a747f7387","modified":1637648791194},{"_id":"public/2020/11/11/mysql-lock/6.png","hash":"52dd43e150fdba915712541333ab157182d1b4b9","modified":1637648791194},{"_id":"public/2020/11/11/mysql-lock/5.png","hash":"3d916d5e030ba6282cc2d9209c2ecfb1ba24f8de","modified":1637648791194},{"_id":"public/2020/11/11/mysql-lock/8.png","hash":"2427f9d7dbf5b2f8677edb97eabff99ca3ab375c","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/1.png","hash":"53ffddf403a4d26e9a24de4c7ed60058fdd81aaf","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/2.png","hash":"81304c8a9087f6efd692b90fe897e650fa879906","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index/5.png","hash":"34c2d39e25de753949c40b308bc14720fbc9dee4","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index/6.png","hash":"be29dafbbba51cadded9c50c8602169f16a42e4f","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/3.png","hash":"d9d1f25700a1b7872a3294bb20140be663a335de","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/6.png","hash":"e18fec49233eb866383c92df84cccae6731218fe","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/4.png","hash":"342e3a623d9828c5b29e33960f75fcc61530397e","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/7.png","hash":"c4bcd50ed8860b29e70113f2135596ba1c3043c7","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/5.png","hash":"412648b61d5cdf2104894d66f62ee173bc38109f","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/1.png","hash":"c9f3596a49b492c6ba587497d4d00df0aa5680ca","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/10.png","hash":"e9d0f6012dbbc64b30270bdfd96ba835962c3c9c","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/2.png","hash":"e1aa45ba85c9740cd734035ec369b079b7f7c6c4","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/9.png","hash":"d92d64a7b127e888d3cc67856450248f9de58d1f","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/3.png","hash":"31cb0c3b4ac8639de69147403d55e165e501ca6f","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/6.png","hash":"5129bb4d3810f203f362b7f2bf36991d2b6a69ba","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/7.png","hash":"24ea2cf8b38aa29485dd4643c74450a50621b8f8","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/1.png","hash":"684e357612fccba91f3c261aaf0e0b67c05cea9e","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/8.png","hash":"6e56a2abaf102799bf3198c6f8f3436b9b86141b","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/2.png","hash":"aa598a040798a15494cbe9b7005a9abc35f8c962","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/3.png","hash":"b253f7fe18c6784a586e4b6ce9f16c27490e69fc","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/4.png","hash":"9b1271e1e5caf4231d9cec8f740eaa13158bc963","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/6.png","hash":"05693e37fbc379accc5b70add27c034cbae65d56","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/10.png","hash":"900addde5c2b629f060a99f8640630ae6628e94c","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/5.png","hash":"b31ca09270410b604344bce804f3a99d2bae4535","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/8.png","hash":"e299893a6c1496fb19d7ee730d94869f1a73d2b8","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/7.png","hash":"e7980bef26cc81a5807f04fe39956f000ac26eeb","modified":1637648791194},{"_id":"public/2020/09/01/redis-cluster-build/9.png","hash":"856105fa0775abe10d445e322a24baa2784660bd","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/2.png","hash":"36d372d40a4662102d10040b2058e134e66d9983","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/4.png","hash":"8badfc7b4a8e32b64ad5a1cda5e73ce1ded5a135","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/5.png","hash":"f655f0507e55e592d94a79a46d8220846026b63f","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/1.png","hash":"e0a148157bca31264cd139d82b078f3a32105370","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/10.png","hash":"723b17612c27bc7528c2574fbf8b2b17d7062219","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/7.png","hash":"5b5aa2a37e3f7741444e8864a15b5a8350b6dac4","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/13.png","hash":"5ef2b16707384b1e46618781a6295adb11959bf9","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/11.png","hash":"b9c9db4c3f28bce4148b16c85ea0f0b4c193f7c3","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/12.png","hash":"612d2986eac25acd1a93d54def33c20502b57a9f","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/2.png","hash":"f9766858f432eb4ea210913d15841e32c1296dee","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/3.png","hash":"2fb49c998c5c441144f770822a39cea0ff3b76c2","modified":1637648791194},{"_id":"public/2021/11/12/go-pointer/1.png","hash":"f43eb962738647a211080a5c74dd79be59b933ce","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/4.png","hash":"f1e4211a217a0f1e2591a22afb87e371d466f076","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/6.png","hash":"3a86a6468bee06b62826b4b6e31d58f55aad5697","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/5.png","hash":"00bc3294472b3ad24e6c5a7efc34d08eb6552fb4","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/7.png","hash":"882d96312ae1a994d23ba3c2a5f93c2f8b8a9557","modified":1637648791194},{"_id":"public/2021/11/12/go-pointer/3.png","hash":"31f29c33776040af4a5a345966b2e2a3a12c33a7","modified":1637648791194},{"_id":"public/2021/05/18/go-study-01/2.png","hash":"18b6014911463fbddb0ef5ee65badd6edb6fee5f","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/8.png","hash":"fad38b076519dcf2e46678ec8bf8dd6191c638d9","modified":1637648791194},{"_id":"public/2021/11/12/go-pointer/2.png","hash":"47b77c3c51073d8e98ef1a9dcacd79fd443903f0","modified":1637648791194},{"_id":"public/2021/05/18/go-study-01/1.png","hash":"b770e4ca2a8968347213686f7ce5246cf441f78e","modified":1637648791194},{"_id":"public/2021/05/18/go-study-01/4.png","hash":"3156a3a5bd07ac5d43cff196c5eebf40de5d2df0","modified":1637648791194},{"_id":"public/2021/05/18/go-study-01/3.png","hash":"5327dad3dc7977ac4b7d15f1c97294b2b021fef0","modified":1637648791194},{"_id":"public/2021/05/18/go-study-01/5.png","hash":"513dd952b1aa49d43875903bb0586149171335b4","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/9.png","hash":"0686402a1d93025d80ab4a0b9b8bd48bef13bfff","modified":1637648791194},{"_id":"public/css/prism.css","hash":"7525a8ef14db7e676922607e580e90dc68ad3e35","modified":1637648791194},{"_id":"public/2019/02/18/limit-single/2.png","hash":"fab361dd8d9049acb285b3afd9becb4d7c4b7eae","modified":1637648791194},{"_id":"public/2019/02/18/limit-single/1.png","hash":"79174ff831d95783ef983cb161914319e8aa53bf","modified":1637648791194},{"_id":"public/2019/02/18/redis-aop-limit-boot/1.png","hash":"79174ff831d95783ef983cb161914319e8aa53bf","modified":1637648791194},{"_id":"public/2020/12/17/redis-known/2.png","hash":"5653ea41f9fa3e5889860945d287d960476a6f06","modified":1637648791194},{"_id":"public/2019/02/18/redis-aop-limit-boot/2.png","hash":"fab361dd8d9049acb285b3afd9becb4d7c4b7eae","modified":1637648791194},{"_id":"public/2021/02/02/shardingjdbc-reg/2.png","hash":"60cd868c22211019331342266a00937d29f5db38","modified":1637648791194},{"_id":"public/2021/01/02/springcloud-2/Hystrix.png","hash":"933e4df680f8f681a3934bf9a666ecd6faef7258","modified":1637648791194},{"_id":"public/2021/02/02/shardingphere-problem/2.png","hash":"4ade0a4a28428211126978a3e52979bb85eca8f0","modified":1637648791194},{"_id":"public/2019/07/18/volatile/1.png","hash":"128c34f5c3b398cf0efdc4bb14c626761d1ff13b","modified":1637648791194},{"_id":"public/2020/08/20/redis-master-slave/2.png","hash":"efafddee4293ed2ffa9c83fd69cba447a36b3cd3","modified":1637648791194},{"_id":"public/2020/08/26/redis-rdb-aop/1.png","hash":"7c944848d609b32c54dc41dd12229e02b7a073e3","modified":1637648791194},{"_id":"public/2020/08/20/redis-master-slave/1.png","hash":"7c944848d609b32c54dc41dd12229e02b7a073e3","modified":1637648791194},{"_id":"public/2019/02/18/gc-log/1.jpg","hash":"f576808db7c258888e0c4b961066219e3eacda51","modified":1637648791194},{"_id":"public/2020/08/27/zookeeper-lock/3.png","hash":"fa9549485e0509604e585b32c3a35dea17ab78c8","modified":1637648791194},{"_id":"public/2019/02/18/gc-log/4.png","hash":"ac6072dcb882aa5502bcc645a6fdfcb62154b1c1","modified":1637648791194},{"_id":"public/2020/10/09/kafka-base/1.png","hash":"d531dad10c13bca4d48dd6ffdd62443dc22ee3e9","modified":1637648791194},{"_id":"public/2020/12/10/io/1.png","hash":"9402dda2b02714b552cb2d984a889277715dd5ab","modified":1637648791194},{"_id":"public/2020/09/13/spring-extend/4.png","hash":"627e82ae73a943379d62dcad307274d2290bb601","modified":1637648791194},{"_id":"public/2020/09/06/java-aqs/2.png","hash":"17106cdf8abc13e7404989b489084e29e2151caa","modified":1637648791194},{"_id":"public/2021/04/08/sring-class/1.png","hash":"6be2302b416e6a29b41da1531c34281565f4a721","modified":1637648791194},{"_id":"public/2021/04/08/linux-netstat/6.png","hash":"2813d5df686053cef0e10a717ef952b1d0a480b1","modified":1637648791194},{"_id":"public/2020/05/10/spring-forbean/1.png","hash":"f01c0cc64977367829d830d848610ad05e410846","modified":1637648791194},{"_id":"public/2020/05/10/spring-forbean/5.png","hash":"01c0a43780757c3a953d59190613903d71939c96","modified":1637648791194},{"_id":"public/2020/08/12/threadlocal/2.png","hash":"8cc5585a4ddc1e81e11a35d3401ab7058444fc70","modified":1637648791194},{"_id":"public/2020/08/12/threadlocal/5.png","hash":"d42aeff70c69f488dbca9450c891665efd17f604","modified":1637648791194},{"_id":"public/2020/08/12/threadlocal/4.png","hash":"f6e5dbb559dc1f7b7ae5dc02f09cdb2d87ba08fc","modified":1637648791194},{"_id":"public/2020/08/12/threadlocal/6.png","hash":"d0c160d22ac14324d20a4dbde468d530d20edd9e","modified":1637648791194},{"_id":"public/2020/01/04/springmvc2/11.png","hash":"7aca834d553f182df1bb89b72df61bf0a719ce3a","modified":1637648791194},{"_id":"public/2020/01/04/springmvc2/13.png","hash":"6fcc61bec3de669e69f07524e6b17098cda5bc29","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index/1.png","hash":"d3ea95f9a94a36a972f3bf46173b20045a5f4c88","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index/3.png","hash":"9174ec848d4fdf797ab730a379b7a2fc4e32f93f","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index/2.png","hash":"8bbaf9d18a8d0c8043000923c77c9983af0a8c8c","modified":1637648791194},{"_id":"public/2020/09/02/redis-cluster-build-2/8.png","hash":"55479153d8d624a5ab1ce600d2873438cf326302","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/5.png","hash":"fd0f98c5315e33c21f7345f26f7becee6f98191c","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/4.png","hash":"397358c3fcd12febc42c138639474d851995a249","modified":1637648791194},{"_id":"public/2020/07/31/mysql-index-single/9.png","hash":"08c706d872e5166067b6c5c019c865cf395750c8","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/10.png","hash":"7c4d83765f9f74b84861cf806ee8170bdea9d00f","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/6.png","hash":"7bacf148e1e82022d616a8989b6d02cc8582d71c","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/8.png","hash":"b83b77cfd02de2607eaff64828a0c06ae7b3972f","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/14.png","hash":"d75a58d8ed4fd012f962d8d7317981f929cdf9d6","modified":1637648791194},{"_id":"public/2020/08/26/redis-rdb-aop/2.png","hash":"fa15ad2b45c316c9e7262882d877401cdfa7d678","modified":1637648791194},{"_id":"public/2020/09/27/springboot-custom-start/7.png","hash":"fdb6365de751bf2944c2860dff54f869c3dd3c8e","modified":1637648791194},{"_id":"public/2020/05/10/spring-forbean/2.png","hash":"7ba2d137e4613ba1d6dca98bf22fcc6d3652e5d8","modified":1637648791194},{"_id":"public/2020/05/10/spring-forbean/4.png","hash":"8b46904f55c3af297eb4727b39fc5b0685867c88","modified":1637648791194},{"_id":"public/2020/01/04/springmvc2/16.png","hash":"e8c121887f8a46a819f6357565ce4ae9a230f0b8","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index-use/1.png","hash":"63057fb1deb7fa27ab2c73779a742874a3ec13b5","modified":1637648791194},{"_id":"public/2021/02/02/shardingphere-problem/1.png","hash":"9b6a021f9cc3075bac7fa77766ea4cd9665ac645","modified":1637648791194},{"_id":"public/2021/01/09/sharding-student/2.png","hash":"225583b10cda9550c62b3c6d803c8bbd611420f9","modified":1637648791194},{"_id":"public/2021/04/08/sring-class/3.png","hash":"256ff4a2a75e539ca9a24d8aaff92c7a675ca30c","modified":1637648791194},{"_id":"public/2020/05/10/spring-forbean/1.jpg","hash":"f57e001a46ea900febb2bc28dfa1eaaa46e9c686","modified":1637648791194},{"_id":"public/2020/08/12/threadlocal/1.png","hash":"138bfe43bc2548b17b22b416c905551bf90fc879","modified":1637648791194},{"_id":"public/2020/01/04/springmvc2/12.png","hash":"1f41a0a5ae46cfc3ba5550d8595ca4425935ca77","modified":1637648791194},{"_id":"public/2020/01/04/springmvc2/14.png","hash":"97e3e2e2cae20302c1db05d7b0dfe5d12215de77","modified":1637648791194},{"_id":"public/2020/11/11/mysql-lock/7.png","hash":"0603105790a687ab19ec220563de68ec27b11cf5","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index/4.png","hash":"c84c1987cc47d6f36ae8ddcfbcfca68ebbf3f2a2","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index/7.png","hash":"92bf4b898e3501d626f0bee5e5614a6682a89bf6","modified":1637648791194},{"_id":"public/2019/07/18/mysql-index/8.png","hash":"764bd50903b85cbfc9c14d2fd36e6e1377b50fc2","modified":1637648791194},{"_id":"public/2020/05/07/jvm-optimization/2.png","hash":"190f2e044a6baf14da40fc8df3262577b5a9875f","modified":1637648791194},{"_id":"public/2020/12/10/io/3.png","hash":"28049a44fae989f2e1064c513ac693787e085429","modified":1637648791194},{"_id":"public/2020/09/27/springboot-custom-start/3.png","hash":"c038091fde608162d3412d3f71517ad66f2de3eb","modified":1637648791194},{"_id":"public/2020/01/04/springmvc2/15.png","hash":"4f95e32fa55772ee20d816ada0acff48b8841a65","modified":1637648791194},{"_id":"public/2020/07/28/hashmap/1.png","hash":"d7c240371f349cc0a84411bb72dfcb9a0eaa2d8b","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/9.png","hash":"d7c1d85109edd964cb9b5a74b43124e849a60562","modified":1637648791194},{"_id":"public/2018/08/07/mysql-log/2.png","hash":"b0311c9c6a1ac5aad8bbb34f123db0e6131857a3","modified":1637648791194},{"_id":"public/2020/08/26/redis-rdb-aop/3.png","hash":"974dda74335d942120861d44655c705807427c88","modified":1637648791194},{"_id":"public/2020/07/28/hashmap/3.png","hash":"4643087f458887d5743069f90e1691642a47ae6f","modified":1637648791194},{"_id":"public/2020/08/12/threadlocal/3.png","hash":"b78663c288f6015f002fa1b2cdb93a1f87dad055","modified":1637648791194},{"_id":"public/2018/08/07/mysql-log/1.png","hash":"b697a4d816c99d0a275ecea99302f3a5d508170b","modified":1637648791194},{"_id":"public/2020/05/10/spring-forbean/3.png","hash":"a5b9516ad74ad7424cd8fa8a6fe3b4a940b78351","modified":1637648791194},{"_id":"public/2018/01/18/executorservice/2.png","hash":"094bb1fb6515174badd053a02f493cf7ed252c01","modified":1637648791194},{"_id":"public/2020/08/09/synchronized-up/3.png","hash":"9e4849d1fac3ff7e76c653d6d78dae28d23355cb","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/3.png","hash":"b1fce291dcc78db58788e58e9c585475014d2833","modified":1637648791194},{"_id":"public/2020/08/09/synchronized-up/2.png","hash":"0b636cb6389f04aa5d5649588fa2aabe8917e727","modified":1637648791194},{"_id":"public/2020/07/31/mysql-explain/1.jpg","hash":"127cba4a5ff20fca3c34ab946c0c2af3f97bf0dc","modified":1637648791194},{"_id":"public/2020/12/10/io/4.png","hash":"e706080387623abcbce59b0853564c411812fc6d","modified":1637648791194},{"_id":"public/2020/07/28/hashmap/5.png","hash":"5be06150681a29d113a9db3dbf6bb5c268382460","modified":1637648791194},{"_id":"public/2020/08/09/synchronized-up/4.png","hash":"b28b3266ec5e47c8c04744bd5d4b22dfccdf8f27","modified":1637648791194},{"_id":"public/2020/08/09/synchronized-up/5.png","hash":"c997c59d5468ce4f709917e7ac7975b56e816605","modified":1637648791194},{"_id":"public/2021/04/08/linux-netstat/1.png","hash":"ef984b3b670eac9b4425a87979db0dc9e6edae48","modified":1637648791194},{"_id":"public/2020/11/11/mysql-lock/1.png","hash":"2a84e5eadda98e728c1727e6eb1f24e9d5b51398","modified":1637648791194},{"_id":"public/2020/01/01/springmvc/1.png","hash":"f97a46fefebc780e4a5f543058dc5b6e7152a903","modified":1637648791194}],"Category":[{"name":"java","_id":"ckn9yvhua0003qwv20e2fceb2"},{"name":"linux","_id":"ckn9yvhut000nqwv2491z2enk"},{"name":"kafka","_id":"ckn9yvhv2000xqwv27se1ajnh"},{"name":"mysql","_id":"ckn9yvhv9001gqwv240uigsrm"},{"name":"redis","_id":"ckn9yvhvk002mqwv253w783ef"},{"name":"shardingjdbc","_id":"ckn9yvhvu003kqwv274ho83o7"},{"name":"spring","_id":"ckn9yvhvy0042qwv2drgndm5p"},{"name":"SpringCloud","_id":"ckn9yvhw6004oqwv2bebqbtxq"},{"name":"zookeeper","_id":"ckn9yvhw90055qwv2dcjqfso9"},{"name":"架构","_id":"ckn9yvhwi005uqwv2eypzfb12"},{"name":"区块链","_id":"ckpxmxgsc0002h8v23tnn8wbb"},{"name":"influxdb","_id":"ckpxmxgsi0005h8v2bbvg6twm"},{"name":"ElasticSearch","_id":"ckpxmxgsk0009h8v28hs7gosd"},{"name":"GoLang","_id":"ckwbpt4ir0002zsv2f53i8sju"},{"name":"Docker","_id":"ckwbpt4iy0007zsv2cwyr7zd6"},{"name":"rust","_id":"ckwbpt4j2000gzsv2ax606pdu"}],"Data":[],"Page":[{"title":"文章分类","date":"2020-07-21T09:44:02.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2020-07-21 17:44:02\ntype: \"categories\"\ncomments: false\n---\n","updated":"2021-04-08T00:47:07.137Z","path":"categories/index.html","layout":"page","_id":"ckn9yvhu50001qwv2hcch9zba","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2017-05-27T05:47:40.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-05-27 13:47:40\ntype: \"tags\"\n---","updated":"2021-04-08T00:47:07.137Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckn9yvhwh005tqwv2bejkdvq2","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"读写分离设计与思考","description":"高性能数据库集群的第一种方式是“读写分离”","date":"2020-07-20T02:14:00.000Z","_content":"\n## 读写分离基本原理\n\n高性能数据库集群的第一种方式是“***读写分离***”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。\n\n读写分离的基本实现是：\n\n- 数据库服务器搭建主从集群，一主一从、一主多从都可以\n- 数据库主机负责读写操作，从机只负责读操作\n- 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据\n- 业务服务器将写操作发给数据库主机，将读操作发给数据库从机\n\n![](db-w-r-dynamic/db1.png)\n<!--more-->\n\n## 读写分离常见问题与解决\n\n### 主从延迟\n以MYSQL为例，当主库插入数据后从库需要一段时间才能同步，时间可能达到1秒多，如果有大量数同步延迟1分钟也有可能。如果业务服务器将数据写入到数据库主服务器后立刻(1秒内)进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。\n### 常见解决方法\n1. 关键业务读写操作指向主机，非关键业务采用读写分离。从业务上来区别理论上是比较好的。\n2. 读从机失败后再读一次主机。这种方式与业务无偶尔，只需要在公共类上处理。不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。\n\n## Spring实现读写分离\n### 原理\nSrping提供了一个AbstractRoutingDataSource类来支持多数据库。我们先来看一下他的继承结构。实现了InitializingBean接口,所以在bean初始化之前会调用afterPropertiesSet方法初始化数据库信息\n![](db-w-r-dynamic/AbstractRoutingDataSource.png)\n```\n    Override\n    public void afterPropertiesSet() {\n        if (this.targetDataSources == null) {\n            throw new IllegalArgumentException(\"Property 'targetDataSources' is required\");\n        }\n        //获取xml文件配置的数据库并存到resolvedDataSources对象中\n        this.resolvedDataSources = new HashMap<>(this.targetDataSources.size());\n        this.targetDataSources.forEach((key, value) -> {\n            Object lookupKey = resolveSpecifiedLookupKey(key);\n            DataSource dataSource = resolveSpecifiedDataSource(value);\n            this.resolvedDataSources.put(lookupKey, dataSource);\n        });\n        if (this.defaultTargetDataSource != null) {\n            this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);\n        }\n    }\n```\n因为DynamicDataSource重写了determineCurrentLookupKey方法，所以在每次获取数据库时都会从ThreadLocal中获取当前线程对应的数据库类型\n```\n\t//每次获取数据库连接时从这里进入\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn determineTargetDataSource().getConnection();\n\t}\n\t\n\tprotected DataSource determineTargetDataSource() {\n\t\tAssert.notNull(this.resolvedDataSources, \"DataSource router not initialized\");\n\t\tObject lookupKey = determineCurrentLookupKey();\n\t\tDataSource dataSource = this.resolvedDataSources.get(lookupKey);\n\t\tif (dataSource == null && (this.lenientFallback || lookupKey == null)) {\n\t\t\tdataSource = this.resolvedDefaultDataSource;\n\t\t}\n\t\tif (dataSource == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot determine target DataSource for lookup key [\" + lookupKey + \"]\");\n\t\t}\n\t\treturn dataSource;\n\t}\n\n\t//子类重写determineCurrentLookupKey方法\n    protected Object determineCurrentLookupKey() {\n        return DBContextHolder.get();\n    }\n\n```\n\n### 实现代码\n#### 导出MAVEN包\n```\n<dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>druid</artifactId>\n      <version>1.0.9</version>\n</dependency>\n```\n#### 配置文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <context:component-scan base-package=\"com.xzy.tx\"/>\n    <tx:annotation-driven/>\n    <!--读写分离动态数据库-->\n    <bean id=\"dynamicDataSource\" class=\"com.xzy.rwDynamic.DynamicDataSource\">\n        <property name=\"targetDataSources\">\n            <map>\n                <entry value-ref=\"dataSourceMaster\" key=\"dataSourceMaster\"></entry>\n                <entry value-ref=\"dataSourceSlave\" key=\"dataSourceSlave\"></entry>\n            </map>\n        </property>\n    </bean>\n\n    <bean id=\"transactionManager\"\n          class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dynamicDataSource\"/>\n    </bean>\n\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"dynamicDataSource\"></property>\n    </bean>\n\t<!--主库-->\n    <bean id=\"dataSourceMaster\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\"\n          destroy-method=\"close\">\n        <!--省略很多-->\n    </bean>\n    <!--从库-->\n    <bean id=\"dataSourceSlave\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\">\n        <!--省略很多-->\n    </bean>\n</beans>\n```\n\n#### 逻辑代码\n```\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\n/***\n * 动态数据库\n */\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n    protected Object determineCurrentLookupKey() {\n        return DBContextHolder.get();\n    }\n}\n```\n```\npackage com.xzy.rwDynamic;\n/**\n * 枚举类\n*/\npublic enum DbType {\n    MASTER(\"dataSourceMaster\"),\n    SLAVE(\"dataSourceSlave\");\n    private String type;\n    DbType(String type){\n        this.type = type;\n    }\n    public String getType() {\n        return type;\n    }\n    public void setType(String type) {\n        this.type = type;\n    }\n}\n```\n\n```\npackage com.xzy.rwDynamic;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class DBContextHolder {\n    private static final ThreadLocal<String> dbHolder = new ThreadLocal<String>();\n\n    public static String get(){\n        String db = dbHolder.get();\n        return StringUtils.isNoneBlank(db) ? db : DbType.MASTER.getType();\n    }\n    public static void set(String type){\n        if(StringUtils.isBlank(type)){\n            dbHolder.set(DbType.MASTER.getType());\n        }else{\n            dbHolder.set(type);\n        }\n    }\n    public static void remove(){\n        dbHolder.remove();\n    }\n}\n```\n#### 测试代码\n```\n@Test\n    public void testwrDynamic(){\n        //设置当前线程使用主线程\n        DBContextHolder.set(DbType.MASTER.getType());\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext-w-r-dynamic.xml\");\n        JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class);\n        jdbcTemplate.queryForList(\"select * from user\");\n        DBContextHolder.remove()\n    }\n```\n#### 扩展\n每次需要读写分离时，都需要在开头DBContextHolder.set()，然后在结尾DBContextHolder.remove()。这样代码臃肿，耦合性强。可以使用AOP+自定义注解的方式，使用环绕增强对代码进行处理\n\n\n","source":"_posts/db-w-r-dynamic.md","raw":"---\ntitle: 读写分离设计与思考\ntags:\n  - mysql\n  - 架构\ncategories: \n  - 架构\ndescription : 高性能数据库集群的第一种方式是“读写分离”\ndate: 2020-07-20 10:14:00\n---\n\n## 读写分离基本原理\n\n高性能数据库集群的第一种方式是“***读写分离***”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。\n\n读写分离的基本实现是：\n\n- 数据库服务器搭建主从集群，一主一从、一主多从都可以\n- 数据库主机负责读写操作，从机只负责读操作\n- 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据\n- 业务服务器将写操作发给数据库主机，将读操作发给数据库从机\n\n![](db-w-r-dynamic/db1.png)\n<!--more-->\n\n## 读写分离常见问题与解决\n\n### 主从延迟\n以MYSQL为例，当主库插入数据后从库需要一段时间才能同步，时间可能达到1秒多，如果有大量数同步延迟1分钟也有可能。如果业务服务器将数据写入到数据库主服务器后立刻(1秒内)进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。\n### 常见解决方法\n1. 关键业务读写操作指向主机，非关键业务采用读写分离。从业务上来区别理论上是比较好的。\n2. 读从机失败后再读一次主机。这种方式与业务无偶尔，只需要在公共类上处理。不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。\n\n## Spring实现读写分离\n### 原理\nSrping提供了一个AbstractRoutingDataSource类来支持多数据库。我们先来看一下他的继承结构。实现了InitializingBean接口,所以在bean初始化之前会调用afterPropertiesSet方法初始化数据库信息\n![](db-w-r-dynamic/AbstractRoutingDataSource.png)\n```\n    Override\n    public void afterPropertiesSet() {\n        if (this.targetDataSources == null) {\n            throw new IllegalArgumentException(\"Property 'targetDataSources' is required\");\n        }\n        //获取xml文件配置的数据库并存到resolvedDataSources对象中\n        this.resolvedDataSources = new HashMap<>(this.targetDataSources.size());\n        this.targetDataSources.forEach((key, value) -> {\n            Object lookupKey = resolveSpecifiedLookupKey(key);\n            DataSource dataSource = resolveSpecifiedDataSource(value);\n            this.resolvedDataSources.put(lookupKey, dataSource);\n        });\n        if (this.defaultTargetDataSource != null) {\n            this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);\n        }\n    }\n```\n因为DynamicDataSource重写了determineCurrentLookupKey方法，所以在每次获取数据库时都会从ThreadLocal中获取当前线程对应的数据库类型\n```\n\t//每次获取数据库连接时从这里进入\n\t@Override\n\tpublic Connection getConnection() throws SQLException {\n\t\treturn determineTargetDataSource().getConnection();\n\t}\n\t\n\tprotected DataSource determineTargetDataSource() {\n\t\tAssert.notNull(this.resolvedDataSources, \"DataSource router not initialized\");\n\t\tObject lookupKey = determineCurrentLookupKey();\n\t\tDataSource dataSource = this.resolvedDataSources.get(lookupKey);\n\t\tif (dataSource == null && (this.lenientFallback || lookupKey == null)) {\n\t\t\tdataSource = this.resolvedDefaultDataSource;\n\t\t}\n\t\tif (dataSource == null) {\n\t\t\tthrow new IllegalStateException(\"Cannot determine target DataSource for lookup key [\" + lookupKey + \"]\");\n\t\t}\n\t\treturn dataSource;\n\t}\n\n\t//子类重写determineCurrentLookupKey方法\n    protected Object determineCurrentLookupKey() {\n        return DBContextHolder.get();\n    }\n\n```\n\n### 实现代码\n#### 导出MAVEN包\n```\n<dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>druid</artifactId>\n      <version>1.0.9</version>\n</dependency>\n```\n#### 配置文件\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <context:component-scan base-package=\"com.xzy.tx\"/>\n    <tx:annotation-driven/>\n    <!--读写分离动态数据库-->\n    <bean id=\"dynamicDataSource\" class=\"com.xzy.rwDynamic.DynamicDataSource\">\n        <property name=\"targetDataSources\">\n            <map>\n                <entry value-ref=\"dataSourceMaster\" key=\"dataSourceMaster\"></entry>\n                <entry value-ref=\"dataSourceSlave\" key=\"dataSourceSlave\"></entry>\n            </map>\n        </property>\n    </bean>\n\n    <bean id=\"transactionManager\"\n          class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dynamicDataSource\"/>\n    </bean>\n\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"dynamicDataSource\"></property>\n    </bean>\n\t<!--主库-->\n    <bean id=\"dataSourceMaster\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\"\n          destroy-method=\"close\">\n        <!--省略很多-->\n    </bean>\n    <!--从库-->\n    <bean id=\"dataSourceSlave\" class=\"com.alibaba.druid.pool.DruidDataSource\" init-method=\"init\" destroy-method=\"close\">\n        <!--省略很多-->\n    </bean>\n</beans>\n```\n\n#### 逻辑代码\n```\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\n/***\n * 动态数据库\n */\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n    protected Object determineCurrentLookupKey() {\n        return DBContextHolder.get();\n    }\n}\n```\n```\npackage com.xzy.rwDynamic;\n/**\n * 枚举类\n*/\npublic enum DbType {\n    MASTER(\"dataSourceMaster\"),\n    SLAVE(\"dataSourceSlave\");\n    private String type;\n    DbType(String type){\n        this.type = type;\n    }\n    public String getType() {\n        return type;\n    }\n    public void setType(String type) {\n        this.type = type;\n    }\n}\n```\n\n```\npackage com.xzy.rwDynamic;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class DBContextHolder {\n    private static final ThreadLocal<String> dbHolder = new ThreadLocal<String>();\n\n    public static String get(){\n        String db = dbHolder.get();\n        return StringUtils.isNoneBlank(db) ? db : DbType.MASTER.getType();\n    }\n    public static void set(String type){\n        if(StringUtils.isBlank(type)){\n            dbHolder.set(DbType.MASTER.getType());\n        }else{\n            dbHolder.set(type);\n        }\n    }\n    public static void remove(){\n        dbHolder.remove();\n    }\n}\n```\n#### 测试代码\n```\n@Test\n    public void testwrDynamic(){\n        //设置当前线程使用主线程\n        DBContextHolder.set(DbType.MASTER.getType());\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationContext-w-r-dynamic.xml\");\n        JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class);\n        jdbcTemplate.queryForList(\"select * from user\");\n        DBContextHolder.remove()\n    }\n```\n#### 扩展\n每次需要读写分离时，都需要在开头DBContextHolder.set()，然后在结尾DBContextHolder.remove()。这样代码臃肿，耦合性强。可以使用AOP+自定义注解的方式，使用环绕增强对代码进行处理\n\n\n","slug":"db-w-r-dynamic","published":1,"updated":"2021-04-08T00:47:06.717Z","_id":"ckcujgdbf0000e0xlg085gsal","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"读写分离基本原理\"><a href=\"#读写分离基本原理\" class=\"headerlink\" title=\"读写分离基本原理\"></a>读写分离基本原理</h2><p>高性能数据库集群的第一种方式是“<strong><em>读写分离</em></strong>”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。</p>\n<p>读写分离的基本实现是：</p>\n<ul>\n<li>数据库服务器搭建主从集群，一主一从、一主多从都可以</li>\n<li>数据库主机负责读写操作，从机只负责读操作</li>\n<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据</li>\n<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机</li>\n</ul>\n<p><img src=\"/2020/07/20/db-w-r-dynamic/db1.png\" alt></p>\n<a id=\"more\"></a>\n\n<h2 id=\"读写分离常见问题与解决\"><a href=\"#读写分离常见问题与解决\" class=\"headerlink\" title=\"读写分离常见问题与解决\"></a>读写分离常见问题与解决</h2><h3 id=\"主从延迟\"><a href=\"#主从延迟\" class=\"headerlink\" title=\"主从延迟\"></a>主从延迟</h3><p>以MYSQL为例，当主库插入数据后从库需要一段时间才能同步，时间可能达到1秒多，如果有大量数同步延迟1分钟也有可能。如果业务服务器将数据写入到数据库主服务器后立刻(1秒内)进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。</p>\n<h3 id=\"常见解决方法\"><a href=\"#常见解决方法\" class=\"headerlink\" title=\"常见解决方法\"></a>常见解决方法</h3><ol>\n<li>关键业务读写操作指向主机，非关键业务采用读写分离。从业务上来区别理论上是比较好的。</li>\n<li>读从机失败后再读一次主机。这种方式与业务无偶尔，只需要在公共类上处理。不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。</li>\n</ol>\n<h2 id=\"Spring实现读写分离\"><a href=\"#Spring实现读写分离\" class=\"headerlink\" title=\"Spring实现读写分离\"></a>Spring实现读写分离</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>Srping提供了一个AbstractRoutingDataSource类来支持多数据库。我们先来看一下他的继承结构。实现了InitializingBean接口,所以在bean初始化之前会调用afterPropertiesSet方法初始化数据库信息<br><img src=\"/2020/07/20/db-w-r-dynamic/AbstractRoutingDataSource.png\" alt></p>\n<pre><code>    Override\n    public void afterPropertiesSet() {\n        if (this.targetDataSources == null) {\n            throw new IllegalArgumentException(&quot;Property &#39;targetDataSources&#39; is required&quot;);\n        }\n        //获取xml文件配置的数据库并存到resolvedDataSources对象中\n        this.resolvedDataSources = new HashMap&lt;&gt;(this.targetDataSources.size());\n        this.targetDataSources.forEach((key, value) -&gt; {\n            Object lookupKey = resolveSpecifiedLookupKey(key);\n            DataSource dataSource = resolveSpecifiedDataSource(value);\n            this.resolvedDataSources.put(lookupKey, dataSource);\n        });\n        if (this.defaultTargetDataSource != null) {\n            this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);\n        }\n    }</code></pre><p>因为DynamicDataSource重写了determineCurrentLookupKey方法，所以在每次获取数据库时都会从ThreadLocal中获取当前线程对应的数据库类型</p>\n<pre><code>    //每次获取数据库连接时从这里进入\n    @Override\n    public Connection getConnection() throws SQLException {\n        return determineTargetDataSource().getConnection();\n    }\n\n    protected DataSource determineTargetDataSource() {\n        Assert.notNull(this.resolvedDataSources, &quot;DataSource router not initialized&quot;);\n        Object lookupKey = determineCurrentLookupKey();\n        DataSource dataSource = this.resolvedDataSources.get(lookupKey);\n        if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) {\n            dataSource = this.resolvedDefaultDataSource;\n        }\n        if (dataSource == null) {\n            throw new IllegalStateException(&quot;Cannot determine target DataSource for lookup key [&quot; + lookupKey + &quot;]&quot;);\n        }\n        return dataSource;\n    }\n\n    //子类重写determineCurrentLookupKey方法\n    protected Object determineCurrentLookupKey() {\n        return DBContextHolder.get();\n    }\n</code></pre><h3 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h3><h4 id=\"导出MAVEN包\"><a href=\"#导出MAVEN包\" class=\"headerlink\" title=\"导出MAVEN包\"></a>导出MAVEN包</h4><pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n      &lt;artifactId&gt;druid&lt;/artifactId&gt;\n      &lt;version&gt;1.0.9&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><h4 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n    &lt;context:component-scan base-package=&quot;com.xzy.tx&quot;/&gt;\n    &lt;tx:annotation-driven/&gt;\n    &lt;!--读写分离动态数据库--&gt;\n    &lt;bean id=&quot;dynamicDataSource&quot; class=&quot;com.xzy.rwDynamic.DynamicDataSource&quot;&gt;\n        &lt;property name=&quot;targetDataSources&quot;&gt;\n            &lt;map&gt;\n                &lt;entry value-ref=&quot;dataSourceMaster&quot; key=&quot;dataSourceMaster&quot;&gt;&lt;/entry&gt;\n                &lt;entry value-ref=&quot;dataSourceSlave&quot; key=&quot;dataSourceSlave&quot;&gt;&lt;/entry&gt;\n            &lt;/map&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;transactionManager&quot;\n          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dynamicDataSource&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dynamicDataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;!--主库--&gt;\n    &lt;bean id=&quot;dataSourceMaster&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot;\n          destroy-method=&quot;close&quot;&gt;\n        &lt;!--省略很多--&gt;\n    &lt;/bean&gt;\n    &lt;!--从库--&gt;\n    &lt;bean id=&quot;dataSourceSlave&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;!--省略很多--&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre><h4 id=\"逻辑代码\"><a href=\"#逻辑代码\" class=\"headerlink\" title=\"逻辑代码\"></a>逻辑代码</h4><pre><code>import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\n/***\n * 动态数据库\n */\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n    protected Object determineCurrentLookupKey() {\n        return DBContextHolder.get();\n    }\n}</code></pre><pre><code>package com.xzy.rwDynamic;\n/**\n * 枚举类\n*/\npublic enum DbType {\n    MASTER(&quot;dataSourceMaster&quot;),\n    SLAVE(&quot;dataSourceSlave&quot;);\n    private String type;\n    DbType(String type){\n        this.type = type;\n    }\n    public String getType() {\n        return type;\n    }\n    public void setType(String type) {\n        this.type = type;\n    }\n}</code></pre><pre><code>package com.xzy.rwDynamic;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class DBContextHolder {\n    private static final ThreadLocal&lt;String&gt; dbHolder = new ThreadLocal&lt;String&gt;();\n\n    public static String get(){\n        String db = dbHolder.get();\n        return StringUtils.isNoneBlank(db) ? db : DbType.MASTER.getType();\n    }\n    public static void set(String type){\n        if(StringUtils.isBlank(type)){\n            dbHolder.set(DbType.MASTER.getType());\n        }else{\n            dbHolder.set(type);\n        }\n    }\n    public static void remove(){\n        dbHolder.remove();\n    }\n}</code></pre><h4 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h4><pre><code>@Test\n    public void testwrDynamic(){\n        //设置当前线程使用主线程\n        DBContextHolder.set(DbType.MASTER.getType());\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-w-r-dynamic.xml&quot;);\n        JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class);\n        jdbcTemplate.queryForList(&quot;select * from user&quot;);\n        DBContextHolder.remove()\n    }</code></pre><h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>每次需要读写分离时，都需要在开头DBContextHolder.set()，然后在结尾DBContextHolder.remove()。这样代码臃肿，耦合性强。可以使用AOP+自定义注解的方式，使用环绕增强对代码进行处理</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"读写分离基本原理\"><a href=\"#读写分离基本原理\" class=\"headerlink\" title=\"读写分离基本原理\"></a>读写分离基本原理</h2><p>高性能数据库集群的第一种方式是“<strong><em>读写分离</em></strong>”，其本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力；第二种方式是“分库分表”，既可以分散访问压力，又可以分散存储压力。</p>\n<p>读写分离的基本实现是：</p>\n<ul>\n<li>数据库服务器搭建主从集群，一主一从、一主多从都可以</li>\n<li>数据库主机负责读写操作，从机只负责读操作</li>\n<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据</li>\n<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机</li>\n</ul>\n<p><img src=\"/2020/07/20/db-w-r-dynamic/db1.png\" alt></p>","more":"<h2 id=\"读写分离常见问题与解决\"><a href=\"#读写分离常见问题与解决\" class=\"headerlink\" title=\"读写分离常见问题与解决\"></a>读写分离常见问题与解决</h2><h3 id=\"主从延迟\"><a href=\"#主从延迟\" class=\"headerlink\" title=\"主从延迟\"></a>主从延迟</h3><p>以MYSQL为例，当主库插入数据后从库需要一段时间才能同步，时间可能达到1秒多，如果有大量数同步延迟1分钟也有可能。如果业务服务器将数据写入到数据库主服务器后立刻(1秒内)进行读取，此时读操作访问的是从机，主机还没有将数据复制过来，到从机读取数据是读不到最新数据的，业务上就可能出现问题。</p>\n<h3 id=\"常见解决方法\"><a href=\"#常见解决方法\" class=\"headerlink\" title=\"常见解决方法\"></a>常见解决方法</h3><ol>\n<li>关键业务读写操作指向主机，非关键业务采用读写分离。从业务上来区别理论上是比较好的。</li>\n<li>读从机失败后再读一次主机。这种方式与业务无偶尔，只需要在公共类上处理。不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。</li>\n</ol>\n<h2 id=\"Spring实现读写分离\"><a href=\"#Spring实现读写分离\" class=\"headerlink\" title=\"Spring实现读写分离\"></a>Spring实现读写分离</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>Srping提供了一个AbstractRoutingDataSource类来支持多数据库。我们先来看一下他的继承结构。实现了InitializingBean接口,所以在bean初始化之前会调用afterPropertiesSet方法初始化数据库信息<br><img src=\"/2020/07/20/db-w-r-dynamic/AbstractRoutingDataSource.png\" alt></p>\n<pre><code>    Override\n    public void afterPropertiesSet() {\n        if (this.targetDataSources == null) {\n            throw new IllegalArgumentException(&quot;Property &#39;targetDataSources&#39; is required&quot;);\n        }\n        //获取xml文件配置的数据库并存到resolvedDataSources对象中\n        this.resolvedDataSources = new HashMap&lt;&gt;(this.targetDataSources.size());\n        this.targetDataSources.forEach((key, value) -&gt; {\n            Object lookupKey = resolveSpecifiedLookupKey(key);\n            DataSource dataSource = resolveSpecifiedDataSource(value);\n            this.resolvedDataSources.put(lookupKey, dataSource);\n        });\n        if (this.defaultTargetDataSource != null) {\n            this.resolvedDefaultDataSource = resolveSpecifiedDataSource(this.defaultTargetDataSource);\n        }\n    }</code></pre><p>因为DynamicDataSource重写了determineCurrentLookupKey方法，所以在每次获取数据库时都会从ThreadLocal中获取当前线程对应的数据库类型</p>\n<pre><code>    //每次获取数据库连接时从这里进入\n    @Override\n    public Connection getConnection() throws SQLException {\n        return determineTargetDataSource().getConnection();\n    }\n\n    protected DataSource determineTargetDataSource() {\n        Assert.notNull(this.resolvedDataSources, &quot;DataSource router not initialized&quot;);\n        Object lookupKey = determineCurrentLookupKey();\n        DataSource dataSource = this.resolvedDataSources.get(lookupKey);\n        if (dataSource == null &amp;&amp; (this.lenientFallback || lookupKey == null)) {\n            dataSource = this.resolvedDefaultDataSource;\n        }\n        if (dataSource == null) {\n            throw new IllegalStateException(&quot;Cannot determine target DataSource for lookup key [&quot; + lookupKey + &quot;]&quot;);\n        }\n        return dataSource;\n    }\n\n    //子类重写determineCurrentLookupKey方法\n    protected Object determineCurrentLookupKey() {\n        return DBContextHolder.get();\n    }\n</code></pre><h3 id=\"实现代码\"><a href=\"#实现代码\" class=\"headerlink\" title=\"实现代码\"></a>实现代码</h3><h4 id=\"导出MAVEN包\"><a href=\"#导出MAVEN包\" class=\"headerlink\" title=\"导出MAVEN包\"></a>导出MAVEN包</h4><pre><code>&lt;dependency&gt;\n      &lt;groupId&gt;com.alibaba&lt;/groupId&gt;\n      &lt;artifactId&gt;druid&lt;/artifactId&gt;\n      &lt;version&gt;1.0.9&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><h4 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n    &lt;context:component-scan base-package=&quot;com.xzy.tx&quot;/&gt;\n    &lt;tx:annotation-driven/&gt;\n    &lt;!--读写分离动态数据库--&gt;\n    &lt;bean id=&quot;dynamicDataSource&quot; class=&quot;com.xzy.rwDynamic.DynamicDataSource&quot;&gt;\n        &lt;property name=&quot;targetDataSources&quot;&gt;\n            &lt;map&gt;\n                &lt;entry value-ref=&quot;dataSourceMaster&quot; key=&quot;dataSourceMaster&quot;&gt;&lt;/entry&gt;\n                &lt;entry value-ref=&quot;dataSourceSlave&quot; key=&quot;dataSourceSlave&quot;&gt;&lt;/entry&gt;\n            &lt;/map&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;transactionManager&quot;\n          class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dynamicDataSource&quot;/&gt;\n    &lt;/bean&gt;\n\n    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dynamicDataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;!--主库--&gt;\n    &lt;bean id=&quot;dataSourceMaster&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot;\n          destroy-method=&quot;close&quot;&gt;\n        &lt;!--省略很多--&gt;\n    &lt;/bean&gt;\n    &lt;!--从库--&gt;\n    &lt;bean id=&quot;dataSourceSlave&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; init-method=&quot;init&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;!--省略很多--&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre><h4 id=\"逻辑代码\"><a href=\"#逻辑代码\" class=\"headerlink\" title=\"逻辑代码\"></a>逻辑代码</h4><pre><code>import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\n/***\n * 动态数据库\n */\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n    protected Object determineCurrentLookupKey() {\n        return DBContextHolder.get();\n    }\n}</code></pre><pre><code>package com.xzy.rwDynamic;\n/**\n * 枚举类\n*/\npublic enum DbType {\n    MASTER(&quot;dataSourceMaster&quot;),\n    SLAVE(&quot;dataSourceSlave&quot;);\n    private String type;\n    DbType(String type){\n        this.type = type;\n    }\n    public String getType() {\n        return type;\n    }\n    public void setType(String type) {\n        this.type = type;\n    }\n}</code></pre><pre><code>package com.xzy.rwDynamic;\nimport org.apache.commons.lang3.StringUtils;\n\npublic class DBContextHolder {\n    private static final ThreadLocal&lt;String&gt; dbHolder = new ThreadLocal&lt;String&gt;();\n\n    public static String get(){\n        String db = dbHolder.get();\n        return StringUtils.isNoneBlank(db) ? db : DbType.MASTER.getType();\n    }\n    public static void set(String type){\n        if(StringUtils.isBlank(type)){\n            dbHolder.set(DbType.MASTER.getType());\n        }else{\n            dbHolder.set(type);\n        }\n    }\n    public static void remove(){\n        dbHolder.remove();\n    }\n}</code></pre><h4 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h4><pre><code>@Test\n    public void testwrDynamic(){\n        //设置当前线程使用主线程\n        DBContextHolder.set(DbType.MASTER.getType());\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-w-r-dynamic.xml&quot;);\n        JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class);\n        jdbcTemplate.queryForList(&quot;select * from user&quot;);\n        DBContextHolder.remove()\n    }</code></pre><h4 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h4><p>每次需要读写分离时，都需要在开头DBContextHolder.set()，然后在结尾DBContextHolder.remove()。这样代码臃肿，耦合性强。可以使用AOP+自定义注解的方式，使用环绕增强对代码进行处理</p>"},{"title":"阻塞队列(BlockingQueue)详解(带图解)","description":"详解Fork/join框架","date":"2020-10-30T05:53:30.000Z","_content":"\n## BlockingQueue接口\n\nJava中的`BlockingQueue`接口是一个线程安全的存取队列。继承Queue（队列）接口，再此基础上新定义了<font color=red>阻塞方法</font>。\n\n![BlockingQueue接口方法图解](blockingqueue/0.png)\n\n\n|          | 抛出异常  | 返回特殊值 | 一直阻塞 | 阻塞超时后退出              |\n| :------- | :-------- | :--------- | :------- | --------------------------- |\n| 插入方法 | add(o)    | offer(o)   | put(o)   | offer(o, timeout, timeunit) |\n| 移除方法 | remove(o) | poll()     | take(o)  | poll(o, timeout, timeunit)  |\n| 检查方法 | element() | peek()     | —        | —                           |\n\n<!--more-->\n\n- 抛出异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(\"Queue full\")异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常。\n- 返回特殊值。\n  - 元素入队 ： 插入成功返回true，当阻塞队列满时候插入失败返回false。\n  - 元素出队 ：从队列里拿出一个元素，如果没有则返回null。\n- 一直阻塞。当阻塞队列满时候，再往队列里插入元素时阻塞生产者线程；当队列空时，再往队列中获取数据时阻塞消费者线程。\n\nJDK中阻塞队列（BlockingQueue）的实现类如下 ：ArrayBlockingQueue，LinkedBlockingQueue，PriorityBlockingQueue，DelayQueue，SynchronousQueue，LinkedTransferQueue，LinkedBlockingDeque。\n\n![阻塞队列七个实现类](blockingqueue/1.png)\n\n## ArrayBlockingQueue\n\n特点 ：一个由 <font color=red>数组</font> 实现的<font color=red>有界</font>，<font color=red>阻塞</font>，<font color=red>线程安全</font>，<font color=red>FIFO（先进先出）</font>队列。\n\n```java\n  public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {\n        private static final long serialVersionUID = -817911632652898426L;\n        //数组实现的队列\n        final Object[] items;\n        //记录队列中消费者消费的索引\n        int takeIndex;\n        //记录队列中生产者生产的索引\n        int putIndex;\n        //队列中元素个数\n        int count;\n        // 重入锁,对入队操作和出队操作加锁，保证线程安全\n        final ReentrantLock lock;\n        // 出列条件，如果队列为空，会执行notEmpty.await()阻塞消费者队列\n        private final Condition notEmpty;\n        // 入列条件，如果队列满，会执行notFull.await()阻塞生产者队列\n        private final Condition notFull;\n        transient ArrayBlockingQueue.Itrs itrs;\n    }\n\npublic ArrayBlockingQueue(int capacity) {\n      this(capacity, false);\n}\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity <= 0)\n        throw new IllegalArgumentException();\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull =  lock.newCondition();\n}\n```\n\n我们首先先看下出队和入队的代码实现。\n\n```java\n//==============================入队=================================\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate void enqueue(E x) {\n    final Object[] items = this.items;\n    items[putIndex] = x;\n    if (++putIndex == items.length)\n        putIndex = 0;\n    count++;\n    notEmpty.signal();\n}\n\n//==============================出队=================================\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0)\n            notEmpty.await();\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate E dequeue() {\n    final Object[] items = this.items;\n    E x = (E) items[takeIndex];\n    items[takeIndex] = null;\n    if (++takeIndex == items.length)\n        takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    notFull.signal();\n    return x;\n}\n```\n\n从代码层面，我们大概知道如下几点：\n\n- 每次入队出队都`ReentrantLock`加锁来保证线程安全，且入队和出队用的同一个锁。\n- 当`count`（实际元素个数）等于数组长度时，队列满，阻塞生产者队列，禁止往队列中添加元素。\n- 当`count`（实际元素个数）等于0时，队列空，阻塞消费者队列，禁止往队列中移除元素。\n- `putIndex`和`takeIndex`用来定义生产者和消费者的位置，当到达items.length时则从0重新开始。所以可以看出数组在逻辑上是一个<font color=red>环形数组</font>。\n\n![入队图解](blockingqueue/2.png)\n\n![出队图解](blockingqueue/3.png)\n\n总结：ArrayBlockingQueue使用有界数组作为队列容器，采用ReentrantLock重入锁对入队和出队操作加锁保证线程安全，由于入队和出队操作采用的是同一把锁，所以再效率上相对较差。采用Condition实现队列满和空时的消息通知。\n\n\n## LinkedBlockingQueue\n特点 ：一个由 <font color=red>单链表</font> 实现的<font color=red>似无界</font>，<font color=red>阻塞</font>，<font color=red>线程安全</font>，<font color=red>FIFO（先进先出）</font>队列。这里解释下似无界的意思，LinkedBlockingQueue阻塞队列允许传入一个容量，如果不传容量则默认容量是`Integer.MAX_VALUE`。所以他其实也算是一个无界队列了。\n\n**属性字段**，往往了解属性字段可以大概猜测出他的实现逻辑\n\n```java\n// 容量\nprivate final int capacity;\n// 实际元素数量,这里为啥要用原子类，后面说\nprivate final AtomicInteger count = new AtomicInteger();\n// 链表头\ntransient Node<E> head;\n// 链表尾\nprivate transient Node<E> last;\n// 出队的锁\nprivate final ReentrantLock takeLock = new ReentrantLock();\n// notEmpty条件\n// 出列条件，如果队列为空，会执行notEmpty.await()阻塞消费者队列\nprivate final Condition notEmpty = takeLock.newCondition();\n// 入队的锁\nprivate final ReentrantLock putLock = new ReentrantLock();\n// notFull条件\n// 入列条件，如果队列满，会执行notFull.await()阻塞生产者队列\nprivate final Condition notFull = putLock.newCondition();\n\nstatic class Node<E> {\n    E item;\n    Node<E> next;\n    Node(E x) { item = x; }\n}\n```\n\n先看下入队出队的代码。\n\n```java\n//=============================入队代码=====================================\npublic void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    int c = -1;\n    Node<E> node = new Node<E>(e);\n    final ReentrantLock putLock = this.putLock;\n    final AtomicInteger count = this.count;\n    putLock.lockInterruptibly();\n    try {\n        while (count.get() == capacity) {\n            notFull.await();\n        }\n        enqueue(node);\n        //入队时通过CAS操作来++count\n        c = count.getAndIncrement();\n        //这里其实是做了一个优化，当实际的元素个数小于容量时，这时候是允许入队的，所以这里唤醒一下看看\n        if (c + 1 < capacity)\n            notFull.signal();\n    } finally {\n        putLock.unlock();\n    }\n    if (c == 0)\n        signalNotEmpty(); //唤醒消费者 notEmpty.signal()\n}\n\nprivate void enqueue(Node<E> node) {\n    last = last.next = node;\n}\n\n//==========================出队代码============================\npublic E take() throws InterruptedException {\n    E x;\n    int c = -1;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lockInterruptibly();\n    try {\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n        x = dequeue();\n        c = count.getAndDecrement();\n        if (c > 1)\n            notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n    if (c == capacity)\n        signalNotFull();\n    return x;\n}\n\nprivate E dequeue() {\n    Node<E> h = head;\n    Node<E> first = h.next;\n    h.next = h; // help GC\n    head = first;\n    E x = first.item;\n    first.item = null;\n    return x;\n}\n```\n\n从代码层面，我们大概知道如下几点：\n\n- 入队和出队使用的不同的锁，分别是putLock,takeLock。也就是说入队和出队操作互不阻塞，多个线程的入队或者多个线程的出队相互阻塞。\n- 记录队列元素个数的值用原子类(AtomicInteger)记录，由于入队和出队操作互不阻塞，所以count++会有线程安全问题，所以采用CAS方式，保证线程安全的同时又性能高。\n\n![LinkedBlockingQueue出入队图解](blockingqueue/5.png)\n\n**ArrayBlockingQueue和LinkedBlockingQueue区别**\n\n- 结构上\n  - 一个是有界数组结构。一个是单链表结构，至于有不有界看开发者怎么用。\n- 性能上\n  - ArrayBlockingQueue使用的是一个锁控制入队和出队，同一时刻入队出队阻塞。LinkedBlockingQueue使用两个锁分别控制入队和出队，同一时刻入队出队不阻塞，性能更高。\n  - ArrayBlockingQueue使用的是数组结构，LinkedBlockingQueue使用的单链表结构，在入队和出队需要创建/回收节点，从而需要GC的操作。\n\n## PriorityBlockingQueue\n\n特点 ：一个由 <font color=red>数组</font> 实现的<font color=red>无界</font>，<font color=red>可扩容</font>，<font color=red>优先级</font>，<font color=red>阻塞</font>，<font color=red>线程安全</font>，<font color=red>FIFO（先进先出）</font>队列。\n\nPriorityBlockingQueue优先级队列属性字段\n\n```java\n// 默认容量为11\nprivate static final int DEFAULT_INITIAL_CAPACITY = 11;\n// 最大数组大小\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n// 存储元素的地方\nprivate transient Object[] queue;\n// 元素个数\nprivate transient int size;\n// 比较器\nprivate transient Comparator<? super E> comparator;\n// 重入锁 跟ArrayBlockingQueue一样也是只用一把锁\nprivate final ReentrantLock lock;\n// 非空条件\nprivate final Condition notEmpty;\n// 扩容的时候使用的控制变量，CAS更新这个值，谁更新成功了谁扩容，其它线程让出CPU\nprivate transient volatile int allocationSpinLock;\n// 不阻塞的优先级队列，非存储元素的地方，仅用于序列化/反序列化时\nprivate PriorityQueue<E> q;\n\npublic PriorityBlockingQueue(int initialCapacity,\n                             Comparator<? super E> comparator) {\n    if (initialCapacity < 1)\n        throw new IllegalArgumentException();\n    this.lock = new ReentrantLock();\n    this.notEmpty = lock.newCondition();\n    this.comparator = comparator;\n    this.queue = new Object[initialCapacity];\n}\n```\n\n**入库出库代码**\n\n```java\n//======================插入元素============================\npublic void put(E e) {\n    offer(e);\n}\n\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    int n, cap;\n    Object[] array;\n    while ((n = size) >= (cap = (array = queue).length))\n    \t//扩容\n        tryGrow(array, cap);\n    try {\n        Comparator<? super E> cmp = comparator;\n        //自下而上的堆化\n        if (cmp == null)\n            siftUpComparable(n, e, array); //按照默认的排序方式堆化\n        else\n            siftUpUsingComparator(n, e, array, cmp); //按照自定义的排序方式堆化\n        size = n + 1;\n        notEmpty.signal();\n    } finally {\n        lock.unlock();\n    }\n    return true;\n}\n\n//======================删除元素============================\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    E result;\n    try {\n        while ( (result = dequeue()) == null)\n            notEmpty.await();\n    } finally {\n        lock.unlock();\n    }\n    return result;\n}\n\nprivate E dequeue() {\n    int n = size - 1;\n    if (n < 0)\n        return null;\n    else {\n        Object[] array = queue;\n        E result = (E) array[0]; //出队取堆顶元素\n        E x = (E) array[n]; // 把堆尾元素拿到堆顶\n        array[n] = null;\n        Comparator<? super E> cmp = comparator;\n        // 并做自上而下的堆化\n        if (cmp == null)\n            siftDownComparable(0, x, array, n);\n        else\n            siftDownUsingComparator(0, x, array, n, cmp);\n        size = n;\n        return result;\n    }\n}\n```\n\n- PriorityBlockingQueue底层使用的是数组结构存储元素。\n- 使用一个锁加一个notEmpty条件来保证并发安全。为啥只有一个notEmtry，是因为它是可扩容的，不存在队列满的情况。\n- 使用一个变量allocationSpinLock的CAS操作来控制扩容。\n- PriorityBlockingQueue的构造函数需要Comparator，所以它支持对元素进行排序（堆排序）。\n- 堆的知识点：[堆（排序）](https://mp.weixin.qq.com/s?__biz=MzkxNDEyOTI0OQ==&mid=2247484450&amp;idx=1&amp;sn=2be695dbf92e1e209a405422e8da5616&source=41#wechat_redirect)。\n- 每次入队操作和出队操作都需要做堆化，入队采用自下而上堆化，出队采用自上而下堆化。\n- 每次出队都是取堆顶元素，因为每次堆化后堆顶元素都是最大(最小)的值。\n\n![PriorityBlockingQueue入队](blockingqueue/6.png)\n\n![PriorityBlockingQueue出队](blockingqueue/7.png)\n\n## ConcurrentLinkedQueue\n\n特点 ：一个由 <font color=red>单链表</font> 实现的<font color=red>无界</font>，<font color=red>非阻塞（采用CAS）</font>，<font color=red>线程安全</font>，<font color=red>FIFO（先进先出）</font>队列，适合高并发场景。\n\nArrayBlockingQueue或者LinkedBlockingQueue在多个线程入队或出队时都需要阻塞线程，就涉及到了多了线程挂起和上下文切换的开销，所以相对于CAS性能差，而ConcurrentLinkedQueue采用CAS的方式，提高了吞吐量。但是我们知道CAS有缺点，其中一个就是CAS自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。所以我们在选择队列时应考虑到实际场景做出选择。\n\n(ConcurrentLinkedQueue源码比较难懂，具体源码分析可以看其他大神的分析：[J.U.C之Java并发容器：ConcurrentLinkedQueue](http://cmsblogs.com/?p=2353))\n\n| queue                 | 阻塞与否 | 是否有界 | 线程安全保障  | 适用场景                       | 注意事项                      |\n| --------------------- | -------- | -------- | ------------- | ------------------------------ | ----------------------------- |\n| ArrayBlockingQueue    | 阻塞     | 有界     | 一把全局锁    | 生产消费模型，平衡两边处理速度 | --                            |\n| LinkedBlockingQueue   | 阻塞     | 可配置   | 存取采用2把锁 | 生产消费模型，平衡两边处理速度 | 无界的时候注意内存溢出问题    |\n| ConcurrentLinkedQueue | 非阻塞   | 无界     | CAS           | 需要高并发队列的场景           | size() 是要遍历一遍集合，慎用 |","source":"_posts/blockingqueue.md","raw":"---\ntitle: 阻塞队列(BlockingQueue)详解(带图解)\ntags:\n  - java并发\ncategories:  java\ndescription : 详解Fork/join框架\ndate: 2020-10-30 13:53:30\n---\n\n## BlockingQueue接口\n\nJava中的`BlockingQueue`接口是一个线程安全的存取队列。继承Queue（队列）接口，再此基础上新定义了<font color=red>阻塞方法</font>。\n\n![BlockingQueue接口方法图解](blockingqueue/0.png)\n\n\n|          | 抛出异常  | 返回特殊值 | 一直阻塞 | 阻塞超时后退出              |\n| :------- | :-------- | :--------- | :------- | --------------------------- |\n| 插入方法 | add(o)    | offer(o)   | put(o)   | offer(o, timeout, timeunit) |\n| 移除方法 | remove(o) | poll()     | take(o)  | poll(o, timeout, timeunit)  |\n| 检查方法 | element() | peek()     | —        | —                           |\n\n<!--more-->\n\n- 抛出异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(\"Queue full\")异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常。\n- 返回特殊值。\n  - 元素入队 ： 插入成功返回true，当阻塞队列满时候插入失败返回false。\n  - 元素出队 ：从队列里拿出一个元素，如果没有则返回null。\n- 一直阻塞。当阻塞队列满时候，再往队列里插入元素时阻塞生产者线程；当队列空时，再往队列中获取数据时阻塞消费者线程。\n\nJDK中阻塞队列（BlockingQueue）的实现类如下 ：ArrayBlockingQueue，LinkedBlockingQueue，PriorityBlockingQueue，DelayQueue，SynchronousQueue，LinkedTransferQueue，LinkedBlockingDeque。\n\n![阻塞队列七个实现类](blockingqueue/1.png)\n\n## ArrayBlockingQueue\n\n特点 ：一个由 <font color=red>数组</font> 实现的<font color=red>有界</font>，<font color=red>阻塞</font>，<font color=red>线程安全</font>，<font color=red>FIFO（先进先出）</font>队列。\n\n```java\n  public class ArrayBlockingQueue<E> extends AbstractQueue<E> implements BlockingQueue<E>, Serializable {\n        private static final long serialVersionUID = -817911632652898426L;\n        //数组实现的队列\n        final Object[] items;\n        //记录队列中消费者消费的索引\n        int takeIndex;\n        //记录队列中生产者生产的索引\n        int putIndex;\n        //队列中元素个数\n        int count;\n        // 重入锁,对入队操作和出队操作加锁，保证线程安全\n        final ReentrantLock lock;\n        // 出列条件，如果队列为空，会执行notEmpty.await()阻塞消费者队列\n        private final Condition notEmpty;\n        // 入列条件，如果队列满，会执行notFull.await()阻塞生产者队列\n        private final Condition notFull;\n        transient ArrayBlockingQueue.Itrs itrs;\n    }\n\npublic ArrayBlockingQueue(int capacity) {\n      this(capacity, false);\n}\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity <= 0)\n        throw new IllegalArgumentException();\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull =  lock.newCondition();\n}\n```\n\n我们首先先看下出队和入队的代码实现。\n\n```java\n//==============================入队=================================\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate void enqueue(E x) {\n    final Object[] items = this.items;\n    items[putIndex] = x;\n    if (++putIndex == items.length)\n        putIndex = 0;\n    count++;\n    notEmpty.signal();\n}\n\n//==============================出队=================================\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0)\n            notEmpty.await();\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate E dequeue() {\n    final Object[] items = this.items;\n    E x = (E) items[takeIndex];\n    items[takeIndex] = null;\n    if (++takeIndex == items.length)\n        takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    notFull.signal();\n    return x;\n}\n```\n\n从代码层面，我们大概知道如下几点：\n\n- 每次入队出队都`ReentrantLock`加锁来保证线程安全，且入队和出队用的同一个锁。\n- 当`count`（实际元素个数）等于数组长度时，队列满，阻塞生产者队列，禁止往队列中添加元素。\n- 当`count`（实际元素个数）等于0时，队列空，阻塞消费者队列，禁止往队列中移除元素。\n- `putIndex`和`takeIndex`用来定义生产者和消费者的位置，当到达items.length时则从0重新开始。所以可以看出数组在逻辑上是一个<font color=red>环形数组</font>。\n\n![入队图解](blockingqueue/2.png)\n\n![出队图解](blockingqueue/3.png)\n\n总结：ArrayBlockingQueue使用有界数组作为队列容器，采用ReentrantLock重入锁对入队和出队操作加锁保证线程安全，由于入队和出队操作采用的是同一把锁，所以再效率上相对较差。采用Condition实现队列满和空时的消息通知。\n\n\n## LinkedBlockingQueue\n特点 ：一个由 <font color=red>单链表</font> 实现的<font color=red>似无界</font>，<font color=red>阻塞</font>，<font color=red>线程安全</font>，<font color=red>FIFO（先进先出）</font>队列。这里解释下似无界的意思，LinkedBlockingQueue阻塞队列允许传入一个容量，如果不传容量则默认容量是`Integer.MAX_VALUE`。所以他其实也算是一个无界队列了。\n\n**属性字段**，往往了解属性字段可以大概猜测出他的实现逻辑\n\n```java\n// 容量\nprivate final int capacity;\n// 实际元素数量,这里为啥要用原子类，后面说\nprivate final AtomicInteger count = new AtomicInteger();\n// 链表头\ntransient Node<E> head;\n// 链表尾\nprivate transient Node<E> last;\n// 出队的锁\nprivate final ReentrantLock takeLock = new ReentrantLock();\n// notEmpty条件\n// 出列条件，如果队列为空，会执行notEmpty.await()阻塞消费者队列\nprivate final Condition notEmpty = takeLock.newCondition();\n// 入队的锁\nprivate final ReentrantLock putLock = new ReentrantLock();\n// notFull条件\n// 入列条件，如果队列满，会执行notFull.await()阻塞生产者队列\nprivate final Condition notFull = putLock.newCondition();\n\nstatic class Node<E> {\n    E item;\n    Node<E> next;\n    Node(E x) { item = x; }\n}\n```\n\n先看下入队出队的代码。\n\n```java\n//=============================入队代码=====================================\npublic void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    int c = -1;\n    Node<E> node = new Node<E>(e);\n    final ReentrantLock putLock = this.putLock;\n    final AtomicInteger count = this.count;\n    putLock.lockInterruptibly();\n    try {\n        while (count.get() == capacity) {\n            notFull.await();\n        }\n        enqueue(node);\n        //入队时通过CAS操作来++count\n        c = count.getAndIncrement();\n        //这里其实是做了一个优化，当实际的元素个数小于容量时，这时候是允许入队的，所以这里唤醒一下看看\n        if (c + 1 < capacity)\n            notFull.signal();\n    } finally {\n        putLock.unlock();\n    }\n    if (c == 0)\n        signalNotEmpty(); //唤醒消费者 notEmpty.signal()\n}\n\nprivate void enqueue(Node<E> node) {\n    last = last.next = node;\n}\n\n//==========================出队代码============================\npublic E take() throws InterruptedException {\n    E x;\n    int c = -1;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lockInterruptibly();\n    try {\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n        x = dequeue();\n        c = count.getAndDecrement();\n        if (c > 1)\n            notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n    if (c == capacity)\n        signalNotFull();\n    return x;\n}\n\nprivate E dequeue() {\n    Node<E> h = head;\n    Node<E> first = h.next;\n    h.next = h; // help GC\n    head = first;\n    E x = first.item;\n    first.item = null;\n    return x;\n}\n```\n\n从代码层面，我们大概知道如下几点：\n\n- 入队和出队使用的不同的锁，分别是putLock,takeLock。也就是说入队和出队操作互不阻塞，多个线程的入队或者多个线程的出队相互阻塞。\n- 记录队列元素个数的值用原子类(AtomicInteger)记录，由于入队和出队操作互不阻塞，所以count++会有线程安全问题，所以采用CAS方式，保证线程安全的同时又性能高。\n\n![LinkedBlockingQueue出入队图解](blockingqueue/5.png)\n\n**ArrayBlockingQueue和LinkedBlockingQueue区别**\n\n- 结构上\n  - 一个是有界数组结构。一个是单链表结构，至于有不有界看开发者怎么用。\n- 性能上\n  - ArrayBlockingQueue使用的是一个锁控制入队和出队，同一时刻入队出队阻塞。LinkedBlockingQueue使用两个锁分别控制入队和出队，同一时刻入队出队不阻塞，性能更高。\n  - ArrayBlockingQueue使用的是数组结构，LinkedBlockingQueue使用的单链表结构，在入队和出队需要创建/回收节点，从而需要GC的操作。\n\n## PriorityBlockingQueue\n\n特点 ：一个由 <font color=red>数组</font> 实现的<font color=red>无界</font>，<font color=red>可扩容</font>，<font color=red>优先级</font>，<font color=red>阻塞</font>，<font color=red>线程安全</font>，<font color=red>FIFO（先进先出）</font>队列。\n\nPriorityBlockingQueue优先级队列属性字段\n\n```java\n// 默认容量为11\nprivate static final int DEFAULT_INITIAL_CAPACITY = 11;\n// 最大数组大小\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n// 存储元素的地方\nprivate transient Object[] queue;\n// 元素个数\nprivate transient int size;\n// 比较器\nprivate transient Comparator<? super E> comparator;\n// 重入锁 跟ArrayBlockingQueue一样也是只用一把锁\nprivate final ReentrantLock lock;\n// 非空条件\nprivate final Condition notEmpty;\n// 扩容的时候使用的控制变量，CAS更新这个值，谁更新成功了谁扩容，其它线程让出CPU\nprivate transient volatile int allocationSpinLock;\n// 不阻塞的优先级队列，非存储元素的地方，仅用于序列化/反序列化时\nprivate PriorityQueue<E> q;\n\npublic PriorityBlockingQueue(int initialCapacity,\n                             Comparator<? super E> comparator) {\n    if (initialCapacity < 1)\n        throw new IllegalArgumentException();\n    this.lock = new ReentrantLock();\n    this.notEmpty = lock.newCondition();\n    this.comparator = comparator;\n    this.queue = new Object[initialCapacity];\n}\n```\n\n**入库出库代码**\n\n```java\n//======================插入元素============================\npublic void put(E e) {\n    offer(e);\n}\n\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    int n, cap;\n    Object[] array;\n    while ((n = size) >= (cap = (array = queue).length))\n    \t//扩容\n        tryGrow(array, cap);\n    try {\n        Comparator<? super E> cmp = comparator;\n        //自下而上的堆化\n        if (cmp == null)\n            siftUpComparable(n, e, array); //按照默认的排序方式堆化\n        else\n            siftUpUsingComparator(n, e, array, cmp); //按照自定义的排序方式堆化\n        size = n + 1;\n        notEmpty.signal();\n    } finally {\n        lock.unlock();\n    }\n    return true;\n}\n\n//======================删除元素============================\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    E result;\n    try {\n        while ( (result = dequeue()) == null)\n            notEmpty.await();\n    } finally {\n        lock.unlock();\n    }\n    return result;\n}\n\nprivate E dequeue() {\n    int n = size - 1;\n    if (n < 0)\n        return null;\n    else {\n        Object[] array = queue;\n        E result = (E) array[0]; //出队取堆顶元素\n        E x = (E) array[n]; // 把堆尾元素拿到堆顶\n        array[n] = null;\n        Comparator<? super E> cmp = comparator;\n        // 并做自上而下的堆化\n        if (cmp == null)\n            siftDownComparable(0, x, array, n);\n        else\n            siftDownUsingComparator(0, x, array, n, cmp);\n        size = n;\n        return result;\n    }\n}\n```\n\n- PriorityBlockingQueue底层使用的是数组结构存储元素。\n- 使用一个锁加一个notEmpty条件来保证并发安全。为啥只有一个notEmtry，是因为它是可扩容的，不存在队列满的情况。\n- 使用一个变量allocationSpinLock的CAS操作来控制扩容。\n- PriorityBlockingQueue的构造函数需要Comparator，所以它支持对元素进行排序（堆排序）。\n- 堆的知识点：[堆（排序）](https://mp.weixin.qq.com/s?__biz=MzkxNDEyOTI0OQ==&mid=2247484450&amp;idx=1&amp;sn=2be695dbf92e1e209a405422e8da5616&source=41#wechat_redirect)。\n- 每次入队操作和出队操作都需要做堆化，入队采用自下而上堆化，出队采用自上而下堆化。\n- 每次出队都是取堆顶元素，因为每次堆化后堆顶元素都是最大(最小)的值。\n\n![PriorityBlockingQueue入队](blockingqueue/6.png)\n\n![PriorityBlockingQueue出队](blockingqueue/7.png)\n\n## ConcurrentLinkedQueue\n\n特点 ：一个由 <font color=red>单链表</font> 实现的<font color=red>无界</font>，<font color=red>非阻塞（采用CAS）</font>，<font color=red>线程安全</font>，<font color=red>FIFO（先进先出）</font>队列，适合高并发场景。\n\nArrayBlockingQueue或者LinkedBlockingQueue在多个线程入队或出队时都需要阻塞线程，就涉及到了多了线程挂起和上下文切换的开销，所以相对于CAS性能差，而ConcurrentLinkedQueue采用CAS的方式，提高了吞吐量。但是我们知道CAS有缺点，其中一个就是CAS自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。所以我们在选择队列时应考虑到实际场景做出选择。\n\n(ConcurrentLinkedQueue源码比较难懂，具体源码分析可以看其他大神的分析：[J.U.C之Java并发容器：ConcurrentLinkedQueue](http://cmsblogs.com/?p=2353))\n\n| queue                 | 阻塞与否 | 是否有界 | 线程安全保障  | 适用场景                       | 注意事项                      |\n| --------------------- | -------- | -------- | ------------- | ------------------------------ | ----------------------------- |\n| ArrayBlockingQueue    | 阻塞     | 有界     | 一把全局锁    | 生产消费模型，平衡两边处理速度 | --                            |\n| LinkedBlockingQueue   | 阻塞     | 可配置   | 存取采用2把锁 | 生产消费模型，平衡两边处理速度 | 无界的时候注意内存溢出问题    |\n| ConcurrentLinkedQueue | 非阻塞   | 无界     | CAS           | 需要高并发队列的场景           | size() 是要遍历一遍集合，慎用 |","slug":"blockingqueue","published":1,"updated":"2021-04-08T00:47:06.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhu00000qwv2glga3xcy","content":"<h2 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a>BlockingQueue接口</h2><p>Java中的<code>BlockingQueue</code>接口是一个线程安全的存取队列。继承Queue（队列）接口，再此基础上新定义了<font color=\"red\">阻塞方法</font>。</p>\n<p><img src=\"/2020/10/30/blockingqueue/0.png\" alt=\"BlockingQueue接口方法图解\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">抛出异常</th>\n<th align=\"left\">返回特殊值</th>\n<th align=\"left\">一直阻塞</th>\n<th>阻塞超时后退出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">插入方法</td>\n<td align=\"left\">add(o)</td>\n<td align=\"left\">offer(o)</td>\n<td align=\"left\">put(o)</td>\n<td>offer(o, timeout, timeunit)</td>\n</tr>\n<tr>\n<td align=\"left\">移除方法</td>\n<td align=\"left\">remove(o)</td>\n<td align=\"left\">poll()</td>\n<td align=\"left\">take(o)</td>\n<td>poll(o, timeout, timeunit)</td>\n</tr>\n<tr>\n<td align=\"left\">检查方法</td>\n<td align=\"left\">element()</td>\n<td align=\"left\">peek()</td>\n<td align=\"left\">—</td>\n<td>—</td>\n</tr>\n</tbody></table>\n<a id=\"more\"></a>\n\n<ul>\n<li>抛出异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常。</li>\n<li>返回特殊值。<ul>\n<li>元素入队 ： 插入成功返回true，当阻塞队列满时候插入失败返回false。</li>\n<li>元素出队 ：从队列里拿出一个元素，如果没有则返回null。</li>\n</ul>\n</li>\n<li>一直阻塞。当阻塞队列满时候，再往队列里插入元素时阻塞生产者线程；当队列空时，再往队列中获取数据时阻塞消费者线程。</li>\n</ul>\n<p>JDK中阻塞队列（BlockingQueue）的实现类如下 ：ArrayBlockingQueue，LinkedBlockingQueue，PriorityBlockingQueue，DelayQueue，SynchronousQueue，LinkedTransferQueue，LinkedBlockingDeque。</p>\n<p><img src=\"/2020/10/30/blockingqueue/1.png\" alt=\"阻塞队列七个实现类\"></p>\n<h2 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h2><p>特点 ：一个由 <font color=\"red\">数组</font> 实现的<font color=\"red\">有界</font>，<font color=\"red\">阻塞</font>，<font color=\"red\">线程安全</font>，<font color=\"red\">FIFO（先进先出）</font>队列。</p>\n<pre class=\" language-java\"><code class=\"language-java\">  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractQueue</span><span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">BlockingQueue</span><span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> Serializable <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> serialVersionUID <span class=\"token operator\">=</span> <span class=\"token operator\">-</span>817911632652898426L<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//数组实现的队列</span>\n        <span class=\"token keyword\">final</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> items<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//记录队列中消费者消费的索引</span>\n        <span class=\"token keyword\">int</span> takeIndex<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//记录队列中生产者生产的索引</span>\n        <span class=\"token keyword\">int</span> putIndex<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//队列中元素个数</span>\n        <span class=\"token keyword\">int</span> count<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 重入锁,对入队操作和出队操作加锁，保证线程安全</span>\n        <span class=\"token keyword\">final</span> ReentrantLock lock<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 出列条件，如果队列为空，会执行notEmpty.await()阻塞消费者队列</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Condition notEmpty<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 入列条件，如果队列满，会执行notFull.await()阻塞生产者队列</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Condition notFull<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">transient</span> ArrayBlockingQueue<span class=\"token punctuation\">.</span>Itrs itrs<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token function\">ArrayBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>capacity<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token function\">ArrayBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> fair<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>capacity <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>items <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span>capacity<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span>fair<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    notEmpty <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    notFull <span class=\"token operator\">=</span>  lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>我们首先先看下出队和入队的代码实现。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//==============================入队=================================</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">checkNotNull</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> items<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span>\n            notFull<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>E x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> items <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">;</span>\n    items<span class=\"token punctuation\">[</span>putIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>putIndex <span class=\"token operator\">==</span> items<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span>\n        putIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n    notEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//==============================出队=================================</span>\n<span class=\"token keyword\">public</span> E <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            notEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> E <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> items <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>items<span class=\"token punctuation\">;</span>\n    E x <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>E<span class=\"token punctuation\">)</span> items<span class=\"token punctuation\">[</span>takeIndex<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    items<span class=\"token punctuation\">[</span>takeIndex<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>takeIndex <span class=\"token operator\">==</span> items<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span>\n        takeIndex <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    count<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>itrs <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        itrs<span class=\"token punctuation\">.</span><span class=\"token function\">elementDequeued</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    notFull<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>从代码层面，我们大概知道如下几点：</p>\n<ul>\n<li>每次入队出队都<code>ReentrantLock</code>加锁来保证线程安全，且入队和出队用的同一个锁。</li>\n<li>当<code>count</code>（实际元素个数）等于数组长度时，队列满，阻塞生产者队列，禁止往队列中添加元素。</li>\n<li>当<code>count</code>（实际元素个数）等于0时，队列空，阻塞消费者队列，禁止往队列中移除元素。</li>\n<li><code>putIndex</code>和<code>takeIndex</code>用来定义生产者和消费者的位置，当到达items.length时则从0重新开始。所以可以看出数组在逻辑上是一个<font color=\"red\">环形数组</font>。</li>\n</ul>\n<p><img src=\"/2020/10/30/blockingqueue/2.png\" alt=\"入队图解\"></p>\n<p><img src=\"/2020/10/30/blockingqueue/3.png\" alt=\"出队图解\"></p>\n<p>总结：ArrayBlockingQueue使用有界数组作为队列容器，采用ReentrantLock重入锁对入队和出队操作加锁保证线程安全，由于入队和出队操作采用的是同一把锁，所以再效率上相对较差。采用Condition实现队列满和空时的消息通知。</p>\n<h2 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h2><p>特点 ：一个由 <font color=\"red\">单链表</font> 实现的<font color=\"red\">似无界</font>，<font color=\"red\">阻塞</font>，<font color=\"red\">线程安全</font>，<font color=\"red\">FIFO（先进先出）</font>队列。这里解释下似无界的意思，LinkedBlockingQueue阻塞队列允许传入一个容量，如果不传容量则默认容量是<code>Integer.MAX_VALUE</code>。所以他其实也算是一个无界队列了。</p>\n<p><strong>属性字段</strong>，往往了解属性字段可以大概猜测出他的实现逻辑</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 容量</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> capacity<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 实际元素数量,这里为啥要用原子类，后面说</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> AtomicInteger count <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 链表头</span>\n<span class=\"token keyword\">transient</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> head<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 链表尾</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> last<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 出队的锁</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> ReentrantLock takeLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// notEmpty条件</span>\n<span class=\"token comment\" spellcheck=\"true\">// 出列条件，如果队列为空，会执行notEmpty.await()阻塞消费者队列</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Condition notEmpty <span class=\"token operator\">=</span> takeLock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 入队的锁</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> ReentrantLock putLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// notFull条件</span>\n<span class=\"token comment\" spellcheck=\"true\">// 入列条件，如果队列满，会执行notFull.await()阻塞生产者队列</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Condition notFull <span class=\"token operator\">=</span> putLock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    E item<span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>E x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> item <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>先看下入队出队的代码。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//=============================入队代码=====================================</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> node <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> ReentrantLock putLock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>putLock<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> AtomicInteger count <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span>\n    putLock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> capacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            notFull<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//入队时通过CAS操作来++count</span>\n        c <span class=\"token operator\">=</span> count<span class=\"token punctuation\">.</span><span class=\"token function\">getAndIncrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这里其实是做了一个优化，当实际的元素个数小于容量时，这时候是允许入队的，所以这里唤醒一下看看</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> capacity<span class=\"token punctuation\">)</span>\n            notFull<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        putLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token function\">signalNotEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//唤醒消费者 notEmpty.signal()</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    last <span class=\"token operator\">=</span> last<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//==========================出队代码============================</span>\n<span class=\"token keyword\">public</span> E <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    E x<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> AtomicInteger count <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> ReentrantLock takeLock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>takeLock<span class=\"token punctuation\">;</span>\n    takeLock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>count<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            notEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        x <span class=\"token operator\">=</span> <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        c <span class=\"token operator\">=</span> count<span class=\"token punctuation\">.</span><span class=\"token function\">getAndDecrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">></span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n            notEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        takeLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> capacity<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">signalNotFull</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> E <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> h <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> first <span class=\"token operator\">=</span> h<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n    h<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> h<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// help GC</span>\n    head <span class=\"token operator\">=</span> first<span class=\"token punctuation\">;</span>\n    E x <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span>item<span class=\"token punctuation\">;</span>\n    first<span class=\"token punctuation\">.</span>item <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>从代码层面，我们大概知道如下几点：</p>\n<ul>\n<li>入队和出队使用的不同的锁，分别是putLock,takeLock。也就是说入队和出队操作互不阻塞，多个线程的入队或者多个线程的出队相互阻塞。</li>\n<li>记录队列元素个数的值用原子类(AtomicInteger)记录，由于入队和出队操作互不阻塞，所以count++会有线程安全问题，所以采用CAS方式，保证线程安全的同时又性能高。</li>\n</ul>\n<p><img src=\"/2020/10/30/blockingqueue/5.png\" alt=\"LinkedBlockingQueue出入队图解\"></p>\n<p><strong>ArrayBlockingQueue和LinkedBlockingQueue区别</strong></p>\n<ul>\n<li>结构上<ul>\n<li>一个是有界数组结构。一个是单链表结构，至于有不有界看开发者怎么用。</li>\n</ul>\n</li>\n<li>性能上<ul>\n<li>ArrayBlockingQueue使用的是一个锁控制入队和出队，同一时刻入队出队阻塞。LinkedBlockingQueue使用两个锁分别控制入队和出队，同一时刻入队出队不阻塞，性能更高。</li>\n<li>ArrayBlockingQueue使用的是数组结构，LinkedBlockingQueue使用的单链表结构，在入队和出队需要创建/回收节点，从而需要GC的操作。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h2><p>特点 ：一个由 <font color=\"red\">数组</font> 实现的<font color=\"red\">无界</font>，<font color=\"red\">可扩容</font>，<font color=\"red\">优先级</font>，<font color=\"red\">阻塞</font>，<font color=\"red\">线程安全</font>，<font color=\"red\">FIFO（先进先出）</font>队列。</p>\n<p>PriorityBlockingQueue优先级队列属性字段</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// 默认容量为11</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> DEFAULT_INITIAL_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">11</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 最大数组大小</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MAX_ARRAY_SIZE <span class=\"token operator\">=</span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE <span class=\"token operator\">-</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 存储元素的地方</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> queue<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 元素个数</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 比较器</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> Comparator<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> E<span class=\"token operator\">></span> comparator<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 重入锁 跟ArrayBlockingQueue一样也是只用一把锁</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> ReentrantLock lock<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 非空条件</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Condition notEmpty<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 扩容的时候使用的控制变量，CAS更新这个值，谁更新成功了谁扩容，其它线程让出CPU</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> allocationSpinLock<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 不阻塞的优先级队列，非存储元素的地方，仅用于序列化/反序列化时</span>\n<span class=\"token keyword\">private</span> PriorityQueue<span class=\"token operator\">&lt;</span>E<span class=\"token operator\">></span> q<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token function\">PriorityBlockingQueue</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initialCapacity<span class=\"token punctuation\">,</span>\n                             Comparator<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> E<span class=\"token operator\">></span> comparator<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>initialCapacity <span class=\"token operator\">&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>notEmpty <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>comparator <span class=\"token operator\">=</span> comparator<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>queue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span>initialCapacity<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>入库出库代码</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//======================插入元素============================</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">offer</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">offer</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> cap<span class=\"token punctuation\">;</span>\n    Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> size<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token punctuation\">(</span>cap <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>array <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">//扩容</span>\n        <span class=\"token function\">tryGrow</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> cap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        Comparator<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> E<span class=\"token operator\">></span> cmp <span class=\"token operator\">=</span> comparator<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//自下而上的堆化</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cmp <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">siftUpComparable</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//按照默认的排序方式堆化</span>\n        <span class=\"token keyword\">else</span>\n            <span class=\"token function\">siftUpUsingComparator</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">,</span> cmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//按照自定义的排序方式堆化</span>\n        size <span class=\"token operator\">=</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        notEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//======================删除元素============================</span>\n<span class=\"token keyword\">public</span> E <span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n    lock<span class=\"token punctuation\">.</span><span class=\"token function\">lockInterruptibly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    E result<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span> <span class=\"token punctuation\">(</span>result <span class=\"token operator\">=</span> <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            notEmpty<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> E <span class=\"token function\">dequeue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> queue<span class=\"token punctuation\">;</span>\n        E result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>E<span class=\"token punctuation\">)</span> array<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//出队取堆顶元素</span>\n        E x <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>E<span class=\"token punctuation\">)</span> array<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 把堆尾元素拿到堆顶</span>\n        array<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        Comparator<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> E<span class=\"token operator\">></span> cmp <span class=\"token operator\">=</span> comparator<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 并做自上而下的堆化</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cmp <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">siftDownComparable</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span>\n            <span class=\"token function\">siftDownUsingComparator</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> x<span class=\"token punctuation\">,</span> array<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">,</span> cmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        size <span class=\"token operator\">=</span> n<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>PriorityBlockingQueue底层使用的是数组结构存储元素。</li>\n<li>使用一个锁加一个notEmpty条件来保证并发安全。为啥只有一个notEmtry，是因为它是可扩容的，不存在队列满的情况。</li>\n<li>使用一个变量allocationSpinLock的CAS操作来控制扩容。</li>\n<li>PriorityBlockingQueue的构造函数需要Comparator，所以它支持对元素进行排序（堆排序）。</li>\n<li>堆的知识点：<a href=\"https://mp.weixin.qq.com/s?__biz=MzkxNDEyOTI0OQ==&mid=2247484450&amp;idx=1&amp;sn=2be695dbf92e1e209a405422e8da5616&source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener\">堆（排序）</a>。</li>\n<li>每次入队操作和出队操作都需要做堆化，入队采用自下而上堆化，出队采用自上而下堆化。</li>\n<li>每次出队都是取堆顶元素，因为每次堆化后堆顶元素都是最大(最小)的值。</li>\n</ul>\n<p><img src=\"/2020/10/30/blockingqueue/6.png\" alt=\"PriorityBlockingQueue入队\"></p>\n<p><img src=\"/2020/10/30/blockingqueue/7.png\" alt=\"PriorityBlockingQueue出队\"></p>\n<h2 id=\"ConcurrentLinkedQueue\"><a href=\"#ConcurrentLinkedQueue\" class=\"headerlink\" title=\"ConcurrentLinkedQueue\"></a>ConcurrentLinkedQueue</h2><p>特点 ：一个由 <font color=\"red\">单链表</font> 实现的<font color=\"red\">无界</font>，<font color=\"red\">非阻塞（采用CAS）</font>，<font color=\"red\">线程安全</font>，<font color=\"red\">FIFO（先进先出）</font>队列，适合高并发场景。</p>\n<p>ArrayBlockingQueue或者LinkedBlockingQueue在多个线程入队或出队时都需要阻塞线程，就涉及到了多了线程挂起和上下文切换的开销，所以相对于CAS性能差，而ConcurrentLinkedQueue采用CAS的方式，提高了吞吐量。但是我们知道CAS有缺点，其中一个就是CAS自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。所以我们在选择队列时应考虑到实际场景做出选择。</p>\n<p>(ConcurrentLinkedQueue源码比较难懂，具体源码分析可以看其他大神的分析：<a href=\"http://cmsblogs.com/?p=2353\" target=\"_blank\" rel=\"noopener\">J.U.C之Java并发容器：ConcurrentLinkedQueue</a>)</p>\n<table>\n<thead>\n<tr>\n<th>queue</th>\n<th>阻塞与否</th>\n<th>是否有界</th>\n<th>线程安全保障</th>\n<th>适用场景</th>\n<th>注意事项</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayBlockingQueue</td>\n<td>阻塞</td>\n<td>有界</td>\n<td>一把全局锁</td>\n<td>生产消费模型，平衡两边处理速度</td>\n<td>–</td>\n</tr>\n<tr>\n<td>LinkedBlockingQueue</td>\n<td>阻塞</td>\n<td>可配置</td>\n<td>存取采用2把锁</td>\n<td>生产消费模型，平衡两边处理速度</td>\n<td>无界的时候注意内存溢出问题</td>\n</tr>\n<tr>\n<td>ConcurrentLinkedQueue</td>\n<td>非阻塞</td>\n<td>无界</td>\n<td>CAS</td>\n<td>需要高并发队列的场景</td>\n<td>size() 是要遍历一遍集合，慎用</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"<h2 id=\"BlockingQueue接口\"><a href=\"#BlockingQueue接口\" class=\"headerlink\" title=\"BlockingQueue接口\"></a>BlockingQueue接口</h2><p>Java中的<code>BlockingQueue</code>接口是一个线程安全的存取队列。继承Queue（队列）接口，再此基础上新定义了<font color=\"red\">阻塞方法</font>。</p>\n<p><img src=\"/2020/10/30/blockingqueue/0.png\" alt=\"BlockingQueue接口方法图解\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">抛出异常</th>\n<th align=\"left\">返回特殊值</th>\n<th align=\"left\">一直阻塞</th>\n<th>阻塞超时后退出</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">插入方法</td>\n<td align=\"left\">add(o)</td>\n<td align=\"left\">offer(o)</td>\n<td align=\"left\">put(o)</td>\n<td>offer(o, timeout, timeunit)</td>\n</tr>\n<tr>\n<td align=\"left\">移除方法</td>\n<td align=\"left\">remove(o)</td>\n<td align=\"left\">poll()</td>\n<td align=\"left\">take(o)</td>\n<td>poll(o, timeout, timeunit)</td>\n</tr>\n<tr>\n<td align=\"left\">检查方法</td>\n<td align=\"left\">element()</td>\n<td align=\"left\">peek()</td>\n<td align=\"left\">—</td>\n<td>—</td>\n</tr>\n</tbody></table>","more":"<ul>\n<li>抛出异常。当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常。</li>\n<li>返回特殊值。<ul>\n<li>元素入队 ： 插入成功返回true，当阻塞队列满时候插入失败返回false。</li>\n<li>元素出队 ：从队列里拿出一个元素，如果没有则返回null。</li>\n</ul>\n</li>\n<li>一直阻塞。当阻塞队列满时候，再往队列里插入元素时阻塞生产者线程；当队列空时，再往队列中获取数据时阻塞消费者线程。</li>\n</ul>\n<p>JDK中阻塞队列（BlockingQueue）的实现类如下 ：ArrayBlockingQueue，LinkedBlockingQueue，PriorityBlockingQueue，DelayQueue，SynchronousQueue，LinkedTransferQueue，LinkedBlockingDeque。</p>\n<p><img src=\"/2020/10/30/blockingqueue/1.png\" alt=\"阻塞队列七个实现类\"></p>\n<h2 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h2><p>特点 ：一个由 <font color=\"red\">数组</font> 实现的<font color=\"red\">有界</font>，<font color=\"red\">阻塞</font>，<font color=\"red\">线程安全</font>，<font color=\"red\">FIFO（先进先出）</font>队列。</p>\n<pre><code class=\"java\">  public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, Serializable {\n        private static final long serialVersionUID = -817911632652898426L;\n        //数组实现的队列\n        final Object[] items;\n        //记录队列中消费者消费的索引\n        int takeIndex;\n        //记录队列中生产者生产的索引\n        int putIndex;\n        //队列中元素个数\n        int count;\n        // 重入锁,对入队操作和出队操作加锁，保证线程安全\n        final ReentrantLock lock;\n        // 出列条件，如果队列为空，会执行notEmpty.await()阻塞消费者队列\n        private final Condition notEmpty;\n        // 入列条件，如果队列满，会执行notFull.await()阻塞生产者队列\n        private final Condition notFull;\n        transient ArrayBlockingQueue.Itrs itrs;\n    }\n\npublic ArrayBlockingQueue(int capacity) {\n      this(capacity, false);\n}\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity &lt;= 0)\n        throw new IllegalArgumentException();\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull =  lock.newCondition();\n}</code></pre>\n<p>我们首先先看下出队和入队的代码实现。</p>\n<pre><code class=\"java\">//==============================入队=================================\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == items.length)\n            notFull.await();\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate void enqueue(E x) {\n    final Object[] items = this.items;\n    items[putIndex] = x;\n    if (++putIndex == items.length)\n        putIndex = 0;\n    count++;\n    notEmpty.signal();\n}\n\n//==============================出队=================================\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        while (count == 0)\n            notEmpty.await();\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n\nprivate E dequeue() {\n    final Object[] items = this.items;\n    E x = (E) items[takeIndex];\n    items[takeIndex] = null;\n    if (++takeIndex == items.length)\n        takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    notFull.signal();\n    return x;\n}</code></pre>\n<p>从代码层面，我们大概知道如下几点：</p>\n<ul>\n<li>每次入队出队都<code>ReentrantLock</code>加锁来保证线程安全，且入队和出队用的同一个锁。</li>\n<li>当<code>count</code>（实际元素个数）等于数组长度时，队列满，阻塞生产者队列，禁止往队列中添加元素。</li>\n<li>当<code>count</code>（实际元素个数）等于0时，队列空，阻塞消费者队列，禁止往队列中移除元素。</li>\n<li><code>putIndex</code>和<code>takeIndex</code>用来定义生产者和消费者的位置，当到达items.length时则从0重新开始。所以可以看出数组在逻辑上是一个<font color=\"red\">环形数组</font>。</li>\n</ul>\n<p><img src=\"/2020/10/30/blockingqueue/2.png\" alt=\"入队图解\"></p>\n<p><img src=\"/2020/10/30/blockingqueue/3.png\" alt=\"出队图解\"></p>\n<p>总结：ArrayBlockingQueue使用有界数组作为队列容器，采用ReentrantLock重入锁对入队和出队操作加锁保证线程安全，由于入队和出队操作采用的是同一把锁，所以再效率上相对较差。采用Condition实现队列满和空时的消息通知。</p>\n<h2 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h2><p>特点 ：一个由 <font color=\"red\">单链表</font> 实现的<font color=\"red\">似无界</font>，<font color=\"red\">阻塞</font>，<font color=\"red\">线程安全</font>，<font color=\"red\">FIFO（先进先出）</font>队列。这里解释下似无界的意思，LinkedBlockingQueue阻塞队列允许传入一个容量，如果不传容量则默认容量是<code>Integer.MAX_VALUE</code>。所以他其实也算是一个无界队列了。</p>\n<p><strong>属性字段</strong>，往往了解属性字段可以大概猜测出他的实现逻辑</p>\n<pre><code class=\"java\">// 容量\nprivate final int capacity;\n// 实际元素数量,这里为啥要用原子类，后面说\nprivate final AtomicInteger count = new AtomicInteger();\n// 链表头\ntransient Node&lt;E&gt; head;\n// 链表尾\nprivate transient Node&lt;E&gt; last;\n// 出队的锁\nprivate final ReentrantLock takeLock = new ReentrantLock();\n// notEmpty条件\n// 出列条件，如果队列为空，会执行notEmpty.await()阻塞消费者队列\nprivate final Condition notEmpty = takeLock.newCondition();\n// 入队的锁\nprivate final ReentrantLock putLock = new ReentrantLock();\n// notFull条件\n// 入列条件，如果队列满，会执行notFull.await()阻塞生产者队列\nprivate final Condition notFull = putLock.newCondition();\n\nstatic class Node&lt;E&gt; {\n    E item;\n    Node&lt;E&gt; next;\n    Node(E x) { item = x; }\n}</code></pre>\n<p>先看下入队出队的代码。</p>\n<pre><code class=\"java\">//=============================入队代码=====================================\npublic void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    int c = -1;\n    Node&lt;E&gt; node = new Node&lt;E&gt;(e);\n    final ReentrantLock putLock = this.putLock;\n    final AtomicInteger count = this.count;\n    putLock.lockInterruptibly();\n    try {\n        while (count.get() == capacity) {\n            notFull.await();\n        }\n        enqueue(node);\n        //入队时通过CAS操作来++count\n        c = count.getAndIncrement();\n        //这里其实是做了一个优化，当实际的元素个数小于容量时，这时候是允许入队的，所以这里唤醒一下看看\n        if (c + 1 &lt; capacity)\n            notFull.signal();\n    } finally {\n        putLock.unlock();\n    }\n    if (c == 0)\n        signalNotEmpty(); //唤醒消费者 notEmpty.signal()\n}\n\nprivate void enqueue(Node&lt;E&gt; node) {\n    last = last.next = node;\n}\n\n//==========================出队代码============================\npublic E take() throws InterruptedException {\n    E x;\n    int c = -1;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lockInterruptibly();\n    try {\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n        x = dequeue();\n        c = count.getAndDecrement();\n        if (c &gt; 1)\n            notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n    if (c == capacity)\n        signalNotFull();\n    return x;\n}\n\nprivate E dequeue() {\n    Node&lt;E&gt; h = head;\n    Node&lt;E&gt; first = h.next;\n    h.next = h; // help GC\n    head = first;\n    E x = first.item;\n    first.item = null;\n    return x;\n}</code></pre>\n<p>从代码层面，我们大概知道如下几点：</p>\n<ul>\n<li>入队和出队使用的不同的锁，分别是putLock,takeLock。也就是说入队和出队操作互不阻塞，多个线程的入队或者多个线程的出队相互阻塞。</li>\n<li>记录队列元素个数的值用原子类(AtomicInteger)记录，由于入队和出队操作互不阻塞，所以count++会有线程安全问题，所以采用CAS方式，保证线程安全的同时又性能高。</li>\n</ul>\n<p><img src=\"/2020/10/30/blockingqueue/5.png\" alt=\"LinkedBlockingQueue出入队图解\"></p>\n<p><strong>ArrayBlockingQueue和LinkedBlockingQueue区别</strong></p>\n<ul>\n<li>结构上<ul>\n<li>一个是有界数组结构。一个是单链表结构，至于有不有界看开发者怎么用。</li>\n</ul>\n</li>\n<li>性能上<ul>\n<li>ArrayBlockingQueue使用的是一个锁控制入队和出队，同一时刻入队出队阻塞。LinkedBlockingQueue使用两个锁分别控制入队和出队，同一时刻入队出队不阻塞，性能更高。</li>\n<li>ArrayBlockingQueue使用的是数组结构，LinkedBlockingQueue使用的单链表结构，在入队和出队需要创建/回收节点，从而需要GC的操作。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h2><p>特点 ：一个由 <font color=\"red\">数组</font> 实现的<font color=\"red\">无界</font>，<font color=\"red\">可扩容</font>，<font color=\"red\">优先级</font>，<font color=\"red\">阻塞</font>，<font color=\"red\">线程安全</font>，<font color=\"red\">FIFO（先进先出）</font>队列。</p>\n<p>PriorityBlockingQueue优先级队列属性字段</p>\n<pre><code class=\"java\">// 默认容量为11\nprivate static final int DEFAULT_INITIAL_CAPACITY = 11;\n// 最大数组大小\nprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n// 存储元素的地方\nprivate transient Object[] queue;\n// 元素个数\nprivate transient int size;\n// 比较器\nprivate transient Comparator&lt;? super E&gt; comparator;\n// 重入锁 跟ArrayBlockingQueue一样也是只用一把锁\nprivate final ReentrantLock lock;\n// 非空条件\nprivate final Condition notEmpty;\n// 扩容的时候使用的控制变量，CAS更新这个值，谁更新成功了谁扩容，其它线程让出CPU\nprivate transient volatile int allocationSpinLock;\n// 不阻塞的优先级队列，非存储元素的地方，仅用于序列化/反序列化时\nprivate PriorityQueue&lt;E&gt; q;\n\npublic PriorityBlockingQueue(int initialCapacity,\n                             Comparator&lt;? super E&gt; comparator) {\n    if (initialCapacity &lt; 1)\n        throw new IllegalArgumentException();\n    this.lock = new ReentrantLock();\n    this.notEmpty = lock.newCondition();\n    this.comparator = comparator;\n    this.queue = new Object[initialCapacity];\n}</code></pre>\n<p><strong>入库出库代码</strong></p>\n<pre><code class=\"java\">//======================插入元素============================\npublic void put(E e) {\n    offer(e);\n}\n\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    int n, cap;\n    Object[] array;\n    while ((n = size) &gt;= (cap = (array = queue).length))\n        //扩容\n        tryGrow(array, cap);\n    try {\n        Comparator&lt;? super E&gt; cmp = comparator;\n        //自下而上的堆化\n        if (cmp == null)\n            siftUpComparable(n, e, array); //按照默认的排序方式堆化\n        else\n            siftUpUsingComparator(n, e, array, cmp); //按照自定义的排序方式堆化\n        size = n + 1;\n        notEmpty.signal();\n    } finally {\n        lock.unlock();\n    }\n    return true;\n}\n\n//======================删除元素============================\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    E result;\n    try {\n        while ( (result = dequeue()) == null)\n            notEmpty.await();\n    } finally {\n        lock.unlock();\n    }\n    return result;\n}\n\nprivate E dequeue() {\n    int n = size - 1;\n    if (n &lt; 0)\n        return null;\n    else {\n        Object[] array = queue;\n        E result = (E) array[0]; //出队取堆顶元素\n        E x = (E) array[n]; // 把堆尾元素拿到堆顶\n        array[n] = null;\n        Comparator&lt;? super E&gt; cmp = comparator;\n        // 并做自上而下的堆化\n        if (cmp == null)\n            siftDownComparable(0, x, array, n);\n        else\n            siftDownUsingComparator(0, x, array, n, cmp);\n        size = n;\n        return result;\n    }\n}</code></pre>\n<ul>\n<li>PriorityBlockingQueue底层使用的是数组结构存储元素。</li>\n<li>使用一个锁加一个notEmpty条件来保证并发安全。为啥只有一个notEmtry，是因为它是可扩容的，不存在队列满的情况。</li>\n<li>使用一个变量allocationSpinLock的CAS操作来控制扩容。</li>\n<li>PriorityBlockingQueue的构造函数需要Comparator，所以它支持对元素进行排序（堆排序）。</li>\n<li>堆的知识点：<a href=\"https://mp.weixin.qq.com/s?__biz=MzkxNDEyOTI0OQ==&mid=2247484450&amp;idx=1&amp;sn=2be695dbf92e1e209a405422e8da5616&source=41#wechat_redirect\" target=\"_blank\" rel=\"noopener\">堆（排序）</a>。</li>\n<li>每次入队操作和出队操作都需要做堆化，入队采用自下而上堆化，出队采用自上而下堆化。</li>\n<li>每次出队都是取堆顶元素，因为每次堆化后堆顶元素都是最大(最小)的值。</li>\n</ul>\n<p><img src=\"/2020/10/30/blockingqueue/6.png\" alt=\"PriorityBlockingQueue入队\"></p>\n<p><img src=\"/2020/10/30/blockingqueue/7.png\" alt=\"PriorityBlockingQueue出队\"></p>\n<h2 id=\"ConcurrentLinkedQueue\"><a href=\"#ConcurrentLinkedQueue\" class=\"headerlink\" title=\"ConcurrentLinkedQueue\"></a>ConcurrentLinkedQueue</h2><p>特点 ：一个由 <font color=\"red\">单链表</font> 实现的<font color=\"red\">无界</font>，<font color=\"red\">非阻塞（采用CAS）</font>，<font color=\"red\">线程安全</font>，<font color=\"red\">FIFO（先进先出）</font>队列，适合高并发场景。</p>\n<p>ArrayBlockingQueue或者LinkedBlockingQueue在多个线程入队或出队时都需要阻塞线程，就涉及到了多了线程挂起和上下文切换的开销，所以相对于CAS性能差，而ConcurrentLinkedQueue采用CAS的方式，提高了吞吐量。但是我们知道CAS有缺点，其中一个就是CAS自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。所以我们在选择队列时应考虑到实际场景做出选择。</p>\n<p>(ConcurrentLinkedQueue源码比较难懂，具体源码分析可以看其他大神的分析：<a href=\"http://cmsblogs.com/?p=2353\" target=\"_blank\" rel=\"noopener\">J.U.C之Java并发容器：ConcurrentLinkedQueue</a>)</p>\n<table>\n<thead>\n<tr>\n<th>queue</th>\n<th>阻塞与否</th>\n<th>是否有界</th>\n<th>线程安全保障</th>\n<th>适用场景</th>\n<th>注意事项</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayBlockingQueue</td>\n<td>阻塞</td>\n<td>有界</td>\n<td>一把全局锁</td>\n<td>生产消费模型，平衡两边处理速度</td>\n<td>–</td>\n</tr>\n<tr>\n<td>LinkedBlockingQueue</td>\n<td>阻塞</td>\n<td>可配置</td>\n<td>存取采用2把锁</td>\n<td>生产消费模型，平衡两边处理速度</td>\n<td>无界的时候注意内存溢出问题</td>\n</tr>\n<tr>\n<td>ConcurrentLinkedQueue</td>\n<td>非阻塞</td>\n<td>无界</td>\n<td>CAS</td>\n<td>需要高并发队列的场景</td>\n<td>size() 是要遍历一遍集合，慎用</td>\n</tr>\n</tbody></table>"},{"title":"JAVA线程池详解","description":"详解线程池用法和原理","date":"2018-01-18T13:10:00.000Z","_content":"## 为什么要使用线程池?\n多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。使用多线程技术完成一个任务所需的时间包括。\n- T1 创建线程时间\n- T2 执行线程任务的时间\n- T3 销毁线程的时间\n\n如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。不单单如此，合理的线程池帮我们管理系统线程资源防止由于线程太多导致的系统崩溃问题等。\n所以,**线程池有如下作用**:\n- 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务\n- 可根据系统的承受能力调整线程池中工作线线程的数目防止因为消耗过多的内存而把服务器累趴下\n\n此外，参考美团上的一段关于线程多的弊端：\n\n- 线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数，需要调用系统内核的API，然后操作系统为其分配一系列资源，整个正本很高。\n-  线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。\n- 线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。**如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。**\n- 容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。\n<!--more-->\n## 线程池详解\n\n### 继承体系\n![](executorservice/1.png)\nExecutor为线程池的顶级接口，声明了<font color=#FF0000 >execute</font>方法。\nExecutors为创建线程池的工具类，提供了多种方式的线程池创建方法。\n\n### 核心参数\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n| 参数            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| corePoolSize    | 核心线程数。当线程数小于该值时，线程池会优先创建新线程来执行新任务 |\n| maximumPoolSize | 线程池所能维护的最大线程数                                   |\n| keepAliveTime   | 空闲线程的存活时间                                           |\n| workQueue       | 任务队列，用于缓存未执行的任务                               |\n| threadFactory   | 线程工厂。可通过工厂为新建的线程设置更有意义的名字           |\n| handler         | 拒绝策略。当线程池和任务队列均处于饱和状态时，使用拒绝策略处理新任务。默认是 AbortPolicy，即直接抛出异常 |\n\n\n\n### 线程池执行逻辑\n\n![](executorservice/2.png)\n假设目前定义了一个线程池\ncorePoolSize = 2 \nkeepAliveTime = 10ms\nmaximumPoolSize = 3\nworkQueue = ArrayBlockingQueue(长度为3)\n\n执行步骤如下:\n1. 首先进来一个任务A,在线程池没有任务在执行,正在运行线程 <  核心线程数,建一个线程执行任务\n2. 又来一个任务B,此时正在运行的线程数为1.正在运行线程 <  核心线程数,则继续创建一个线程执行任务\n3. 又来一个任务C,此时正在运行线程 > 核心线程数,将任务放到workQueue等待执行。\n4. 此时又来了任务DEF.....,由于队列只允许存3个,DE进入到队列等待\n5. 此时F没有进入队列, 正在运行线程 < 最大线程数,则任务F允许创建一个线程执行。\n6. 此时任务G到来，由于AB任务还没结束，workQueue存放了CDE任务等待执行,此时正在运行线程 =最大线程数,则G被拒绝，执行对应的拒绝策略。\n7. 此时任务A执行完毕,任务C则从workQueue取出,沿用刚开始创建的线程执行任务。\n\n**keepAliveTime** : 由于任务F是额外创建的一个线程去执行，线程池在空闲时只能保持 核心线程数个线程，所以当任务F执行完后，在keepAliveTime时间内如果没有新的任务进来导致正在运行线程 > 核心线程数 & workQueue已满 这两个条件，则对应的线程会被销毁。\n\n线程创建规则如下:\n\n| 序号 | 条件                                                        | 动作             |\n| ---- | ----------------------------------------------------------- | ---------------- |\n| 1    | 线程数 < corePoolSize                                       | 创建新线程       |\n| 2    | 线程数 ≥ corePoolSize，且 workQueue 未满                    | 缓存新任务       |\n| 3    | corePoolSize ≤ 线程数 ＜ maximumPoolSize，且 workQueue 已满 | 创建新线程       |\n| 4    | 线程数 ≥ maximumPoolSize，且 workQueue 已满                 | 使用拒绝策略处理 |\n\n从线程池执行逻辑总结 :\n\n- 任务进来时首先先在核心线程中执行，如果核心线程满则放到队列中，如果队列满且还没到最大线程数则可以额外创建线程执行(这个额外的线程是会被回收的)\n- 核心线程不会被回收，额外的线程会被回收，如果设置了allowCoreThreadTimeOut为true，则核心线程数也可以被回收，但一般不这样做\n- 如果workQueue是无界队列，则keepAliveTime将不起作用\n\n### 排队策略\n当线程数 ≥ corePoolSize时，任务会存到队列中排队，有3中类型的容器可供使用，分别是同步队列，有界队列和无界队列。对于有优先级的任务，这里还可以增加优先级队列。\n\n| 实现类                | 类型       | 说明                                                         |\n| --------------------- | ---------- | ------------------------------------------------------------ |\n| SynchronousQueue      | 同步队列   | 该队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞 |\n| ArrayBlockingQueue    | 有界队列   | 基于数组的阻塞队列，按照 FIFO 原则对元素进行排序             |\n| LinkedBlockingQueue   | 无界队列   | 基于链表的阻塞队列，按照 FIFO 原则对元素进行排序             |\n| PriorityBlockingQueue | 优先级队列 | 具有优先级的阻塞队列                                         |\n\n### 拒绝策略\n线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务。Java 线程池提供了4中拒绝策略实现类\n\n| 实现类              | 说明                                          |\n| ------------------- | --------------------------------------------- |\n| AbortPolicy         | 丢弃新任务，并抛出 RejectedExecutionException |\n| DiscardPolicy       | 不做任何操作，直接丢弃新任务                  |\n| DiscardOldestPolicy | 丢弃队列队首的元素，并执行新任务              |\n| CallerRunsPolicy    | 由调用线程执行新任务                          |\n\n```java\n//使用拒绝策略\nThreadPoolExecutor executor = new ThreadPoolExecutor(1 , 1 , 1L , TimeUnit.MINUTES,new ArrayBlockingQueue<>(1),\nnew ThreadPoolExecutor.AbortPolicy());\n//自定义拒绝策略\nThreadPoolExecutor executor2 = new ThreadPoolExecutor(1 , 1 , 1L , TimeUnit.MINUTES , new ArrayBlockingQueue<>(1),\n        new RejectedExecutionHandler(){\n            @Override\n            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n \t\t\t\t//doSomeing   \n            }\n });\n```\n\n\n\n## 几种线程池\n\nExecutors为创建线程池的工具类，提供了多种方式的线程池创建方法。\n### newFixedThreadPool\n构建包含固定线程数的线程池，默认情况下，空闲线程不会被回收。\n从参数可以看出核心线程数 = 最大线程数 / 采用无界队列。\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n**特点与隐患**\n这种方式采用的是无界队列，如果任务执行时间长且任务量多将会出现任务堆积在队列中导致系统内存飙升，内存溢出等问题\n### newCachedThreadPool\n构建线程数不定的线程池，线程数量随任务量变动，空闲线程存活时间超过60秒后会被回收。\n**SynchronousQueue**特点是队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞。\n\n```\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n**特点与隐患**\n队列相当于不排队，每次来一个任务就创建一个线程执行。当对应的任务执行完以后对应的线程如果在60秒内没有没有其他任务继续复用则会销毁。\n**推荐使用这种线程池**。能够自动在并发量不多的时候自动销毁执行完的线程。但是最大线程数为无穷大,没有控制线程数也容易造成当并发量特别高时不加以控制导致线程数飙升\n### newSingleThreadExecutor\n构建线程数为1的线程池，等价于 newFixedThreadPool(1) 所构造出的线程池\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n**特点与隐患**\n一次只能一个线程在运行，只会创建一个线程进行复用，采用无界队列容易造成内存飙升\n### newScheduledThreadPool\n创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n   public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n\n```\n\n## ThreadPoolExecutor源码分析\n\n### executre和submit方法\n\n首先先来看下两个方法如何使用。线程池支持无返回值的execute方法，和有返回值的submit方法。有返回值的其实是将task封装成一个FutureTask。关于FutureTask可以看另外篇博客《[Fork/join框架你会用吗？](http://xuzyblog.top/2020/07/30/fork-join/)》。\n\n```java\n@Test\npublic void testError() throws InterruptedException, ExecutionException {\n    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 20, 60L, TimeUnit.MINUTES, new LinkedBlockingQueue<>());\n    threadPoolExecutor.execute(() -> {\n        System.out.println(\"线程池源码解析-execute\");\n    });\n    Future future = threadPoolExecutor.submit(() -> {\n        System.out.println(\"线程池源码解析-submit\");\n    });\n    future.get();\n}\n```\n\n```java\njava.util.concurrent.AbstractExecutorService\n\nprotected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n    return new FutureTask<T>(callable);\n}\n\nprotected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n        return new FutureTask<T>(runnable, value);\n}\n\n//传入Runable 返回Future\npublic Future<?> submit(Runnable task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<Void> ftask = newTaskFor(task, null);\n    //最终都是调用到了execute方法执行逻辑\n    execute(ftask);\n    return ftask;\n}\n\n//传入Callable 返回Future\npublic <T> Future<T> submit(Callable<T> task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task);\n    execute(ftask);\n    return ftask;\n}\n```\n\n这里需要先明白一个易错点，execute(Runnable task) 和 submit(Runnable task) 中的task应该理解成任务，而不是线程。整个线程池的逻辑大概可以这样概括 ： <font color=red>当execture提交一个task后，会新建一个Worker对象，并将任务放到里面，这个Worker里面有一个Thred变量就是真正线程池用来执行任务的线程。当一个task执行完以后，这个Worker会继续从队列中获取任务继续执行。</font>\n\n![](executorservice/3.png)\n\n### 重要属性分析\n\n采用一个 32 位的整数来存放线程池的状态和当前池中的线程数。\n\n- 高 3 位用于存放线程池状态\n- 低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）\n\n```java\n//ThreadPoolExecutor中的控制状态\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n//线程池中当前活动的线程数量允许的最大值\n//运算方法就是1左移29位再减1 00000000 00000000 00000000 00000001 --> 001 0000 00000000 00000000 00000000 - 1 = 536870911\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n//===我们说过高三位代表的是线程池的状态，所以下面就是线程池的几种状态\n//RUNNING - 正常的状态：接受新的任务，处理等待队列中的任务\n//SHUTDOWN - 不接受新的任务提交，但是会继续处理等待队列中的任务\n//STOP - 不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程\n//TIDYING - 所有的任务都销毁了，workCount为0，线程过渡到TIDYING状态，将会执行terminated()钩子方法\n//TERMINATED - terminated()方法已经完成\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n//用来存放task的阻塞队列\nprivate final BlockingQueue<Runnable> workQueue;\n//线程池中所有工作线程worker的集合\nprivate final HashSet<Worker> workers = new HashSet<Worker>();\n//创建线程的工厂，值得是Worker中变量Thread t的创建工厂\nprivate volatile ThreadFactory threadFactory;\n//拒绝策略\nprivate volatile RejectedExecutionHandler handler;\n//空闲线程存活时间\nprivate volatile long keepAliveTime;\n//核心线程数\nprivate volatile int corePoolSize;\n//最大线程数\nprivate volatile int maximumPoolSize;\n```\n\n![线程池状态转换](executorservice/4.png)\n\n### Worker内部类\n\nWorker是线程池中真正用来执行任务的类。继承了AQS，实现了Runable接口。这里继承AQS，主要是为了独占锁，如果是加锁状态证明Worker正在执行，如果解锁状态证明空闲。\n\n**Worker为什么不直接使用ReentrantLock而是继承AQS ?**  tryAcquire方法它是不允许重入的，而ReentrantLock是允许重入的。对于线程来说，如果线程正在执行是不允许其它锁重入进来的。\n\n我们可以理解Worker表示线程池中的<font color=red>工人</font>，Runnable command表示工人要做的任务。一个工人对应的是一个线程，一个工人一次做一个任务。工人做完任务后再从队列中获取任务继续做。\n\n```java\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable{\n    \n    private static final long serialVersionUID = 6138294804551838833L;\n    //真正用来执行任务的线程\n    final Thread thread;\n    //在new Worker时候传入的任务，这里交first值得是他是new Worker时候传入的那就是第一个。\n    //但是有时候这个是null,那代表没有传入，这时候就是从队列中取\n    Runnable firstTask;\n    //用于存放此线程完成的任务数，注意了，这里用了 volatile，保证可见性\n    volatile long completedTasks;\n\n    \n    Worker(Runnable firstTask) {\n        setState(-1);\n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    public void run() {\n        runWorker(this);\n    }\n\n    protected boolean isHeldExclusively() {\n        return getState() != 0;\n    }\n\n    protected boolean tryAcquire(int unused) {\n        if (compareAndSetState(0, 1)) {\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryRelease(int unused) {\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); }\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); }\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}\n```\n\n\n\n### 核心源码分析\n\n![线程池执行流程](executorservice/1.jpg)\n\n#### execute方法\n\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    //如果线程池中工作的Worker数量小于核心线程数\n    if (workerCountOf(c) < corePoolSize) {\n        //直接new一个worker来执行任务，并把当前任务 command 作为这个线程的第一个任务(firstTask)\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    \n    //到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了\n    \n    //判断当前线程池的状态是不是RUNNING状态，如果是则将任务放到队列中等待\n    //offer - 将给定的元素设置到队列中，如果设置成功返回true, 否则返回false\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        //刚将任务放到队列后发现线程池不是运行的，那就删除把刚放到队列的任务删除并执行拒绝策略\n        if (! isRunning(recheck) && remove(command)){\n         \treject(command);   \n        }\n        //如果线程池还是 RUNNING 的，但是工作线程数为 0，那么开启新的线程，这种情况比较少见\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    //这个分支，表示前面入队失败了，那么以 maximumPoolSize 为界创建新的 worker\n    else if (!addWorker(command, false)){\n        reject(command); //失败就执行拒绝策略   \n    }\n}\n```\n\n#### addWorker方法\n\n```java\n//core = true 时代表使用核心线程数 corePoolSize 作为创建线程的界限\n//core = flase 时代表使用最大线程数 maximumPoolSize 作为创建线程的界限\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // 判断是否可以addWorker\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            //获取当前工作的worker数量\n            int wc = workerCountOf(c);\n            //如果大于允许的最大数或者大于核心线程数则返回false\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            //如果运行线程数可以+1表示能成功new Worker,跳出循环\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get(); \n            if (runStateOf(c) != rs)\n                continue retry;\n        }\n    }\n\n    //用来判断worker 是否已经启动\n    boolean workerStarted = false;\n    //是否已将这个 worker 添加到 workers 这个 HashSet 中\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        //先建一个\"工人\"\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            //这里使用mainLock保证workers.add(w)\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n\n                int rs = runStateOf(ctl.get());\n\t\t\t   //小于SHUTTDOWN 那就是 RUNNING状态\n                //如果等于SHUTDOWN，不接受新的任务，但是会继续执行等待队列中的任务\n                if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) throw new IllegalThreadStateException();\n                    //将这个\"工人\"存到workers中\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                //这个\"工人\"开始工作，对应Worker->run方法->runWorker(this)方法\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        //如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n\n//启动\"工人\"失败就炒了这个\"工人\"\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        if (w != null)\n            workers.remove(w);\n        decrementWorkerCount();\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n\n```\n\n#### runWorker方法\n\n```java\n//此方法由worker线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    //第一个任务就直接运行，不用从队列中取\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            //判断各种不合适的状态然后中断\n            //(线程状态>=STOP 或者 (线程中断且线程状态>=STOP)) 且 当时线程没有中断\n            //其实主要保证2点 : 1.线程池没有停止 2.保证线程没有中断\n            if (\n                ( runStateAtLeast(ctl.get(), STOP) ||\n                  (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))\n                ) &&\n                !wt.isInterrupted()\n               )\n                wt.interrupt();\n            try {\n                //钩子\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    //真正的执行任务，这里task要嘛是Runnable要嘛是FutureTask。\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    //钩子\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                //置空 task，准备 getTask 获取下一个任务\n                task = null;\n                //完成数+1\n                w.completedTasks++;\n                //释放独占锁\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        //如果执行到这一步说明线程池状态不对了。\n        //getTask()是会阻塞的，所以即使队列中为空，除非是超过核心线程数\n        //的worker才会执行到这一步，不然会阻塞住\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n总结runWorker方法执行过程：\n\n1. while循环中，不断地通过getTask()方法从workerQueue中获取任务\n2. 如果线程池正在停止，则中断线程。否则调用3.\n3. 调用task.run()执行任务\n4. 如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程`workers.remove(w)`\n\n**keepAliveTime作用详解**\n\n我们知道当任务大于核心线程数+队列大小后，会额外new Worker来执行任务。随着队列中任务的消化，创建出来额外的Worker是需要被回收的。这个实现的过程是通过如下代码。\n\n```java\nfinal void runWorker(Worker w) {\n   Thread wt = Thread.currentThread();\n   Runnable task = w.firstTask;\n   w.firstTask = null;\n   w.unlock(); // allow interrupts\n   boolean completedAbruptly = true;\n   try {\n       while (task != null || (task = getTask()) != null) {\n           //省略很多代码\n       }\n       completedAbruptly = false;\n   } finally {\n       //getTask()从队列中获取任务超时了，就关闭额外的Worker\n       processWorkerExit(w, completedAbruptly);\n   }\n\n\nprivate Runnable getTask() {\n    boolean timedOut = false; \n    for (;;) {\n        \n        //省略很多代码...\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        //省略很多代码...\n\n        try {\n        \t//如果从队列中获取任务超时，也就是说队列中任务已经被消化完了，\n        \t//那么就会抛出InterruptedException异常\n        \t//所以runWorker会处理异常，执行processWorkerExit将额外的Worker关闭\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n\n\n#### getTask()方法\n\ngetTask方法表示从队列中获取任务。正常情况下如果是核心线程数内的Worker获取时，如果有则返回，如果队列中没有任务会阻塞。\n\n如果这个方法不阻塞而是返回null，有如下几种可能\n\n- 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务\n- 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行\n- 大于核心线程数时额外创建出来的Worker，如果这个Worker空闲超过了keepAliveTime则会返回null\n\n```java\nprivate Runnable getTask() {\n    boolean timedOut = false;\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\t    //1. rs == SHUTDOWN && workQueue.isEmpty()\n        //2. rs >= STOP\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n             // CAS 操作，减少工作线程数\n            decrementWorkerCount();\n            return null;\n        }\n\t    //获取当天工作的worker数\n        int wc = workerCountOf(c);\n\t    //允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n## 优雅关闭线程池\n\n### shutdown\n\n会等正在执行的任务和队列中的任务完成后再关闭。\n\n1. shutDown会首先将线程设置成`SHUTDOWN`状态。\n2. 执行的线程和已经在队列中的线程并不会被中断，继续执行。\n3. 中断没有执行的Worker。\n4. shutdown()方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。\n\n### shutdownNow\n\n马上关闭，强制关闭正在执行的任务和队列中的任务。\n\n## 常见疑问\n\n**为什么execute方法会抛异常，submit不会**\n\n```java\nexecutors.execute(new Runnable() {\n    @Override\n    public void run() {\n        throw new RuntimeException(\"xxx\");\n    }\n});\n//抛出异常\nException in thread \"pool-1-thread-1\" java.lang.RuntimeException: xxx\n\tat xzy.OtherTest$1.run(OtherTest.java:33)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\n\nexecutors.submit(new Runnable() {\n    @Override\n    public void run() {\n        throw new RuntimeException(\"xxx\");\n    }\n});\n//不抛出异常\n```\n\n我们定位到**runWorker**源码中，可以看到**task.run()**做了异常处理。\n\n- 如果是execute方法，task=Runnable接口，调用run方法出现错误抛出异常可以被捕获\n- 如果是submit方法，Runnable会被封装成FutureTask，所以task=FutureTask。FutureTask重写了run方法，如果遇到异常会记录起来在get()方法调用时候才抛出。\n\n```java\ntry {\n       task.run();\n   } catch (RuntimeException x) {\n       thrown = x; throw x;\n   } catch (Error x) {\n       thrown = x; throw x;\n   } catch (Throwable x) {\n       // 这里不允许抛出 Throwable，所以转换为 Error\n       thrown = x; throw new Error(x);\n   } finally {\n       // 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现\n       afterExecute(task, thrown);\n}\n```\n\n\n\n## 参考\n\n- https://zhuanlan.zhihu.com/p/60524908","source":"_posts/executorservice.md","raw":"---\ntitle: JAVA线程池详解\ntags:\n  - java并发\ncategories:  java\ndescription : 详解线程池用法和原理\ndate: 2018-01-18 21:10:00\n---\n## 为什么要使用线程池?\n多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。使用多线程技术完成一个任务所需的时间包括。\n- T1 创建线程时间\n- T2 执行线程任务的时间\n- T3 销毁线程的时间\n\n如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。不单单如此，合理的线程池帮我们管理系统线程资源防止由于线程太多导致的系统崩溃问题等。\n所以,**线程池有如下作用**:\n- 减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务\n- 可根据系统的承受能力调整线程池中工作线线程的数目防止因为消耗过多的内存而把服务器累趴下\n\n此外，参考美团上的一段关于线程多的弊端：\n\n- 线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数，需要调用系统内核的API，然后操作系统为其分配一系列资源，整个正本很高。\n-  线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。\n- 线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。**如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。**\n- 容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。\n<!--more-->\n## 线程池详解\n\n### 继承体系\n![](executorservice/1.png)\nExecutor为线程池的顶级接口，声明了<font color=#FF0000 >execute</font>方法。\nExecutors为创建线程池的工具类，提供了多种方式的线程池创建方法。\n\n### 核心参数\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)\n```\n\n| 参数            | 说明                                                         |\n| --------------- | ------------------------------------------------------------ |\n| corePoolSize    | 核心线程数。当线程数小于该值时，线程池会优先创建新线程来执行新任务 |\n| maximumPoolSize | 线程池所能维护的最大线程数                                   |\n| keepAliveTime   | 空闲线程的存活时间                                           |\n| workQueue       | 任务队列，用于缓存未执行的任务                               |\n| threadFactory   | 线程工厂。可通过工厂为新建的线程设置更有意义的名字           |\n| handler         | 拒绝策略。当线程池和任务队列均处于饱和状态时，使用拒绝策略处理新任务。默认是 AbortPolicy，即直接抛出异常 |\n\n\n\n### 线程池执行逻辑\n\n![](executorservice/2.png)\n假设目前定义了一个线程池\ncorePoolSize = 2 \nkeepAliveTime = 10ms\nmaximumPoolSize = 3\nworkQueue = ArrayBlockingQueue(长度为3)\n\n执行步骤如下:\n1. 首先进来一个任务A,在线程池没有任务在执行,正在运行线程 <  核心线程数,建一个线程执行任务\n2. 又来一个任务B,此时正在运行的线程数为1.正在运行线程 <  核心线程数,则继续创建一个线程执行任务\n3. 又来一个任务C,此时正在运行线程 > 核心线程数,将任务放到workQueue等待执行。\n4. 此时又来了任务DEF.....,由于队列只允许存3个,DE进入到队列等待\n5. 此时F没有进入队列, 正在运行线程 < 最大线程数,则任务F允许创建一个线程执行。\n6. 此时任务G到来，由于AB任务还没结束，workQueue存放了CDE任务等待执行,此时正在运行线程 =最大线程数,则G被拒绝，执行对应的拒绝策略。\n7. 此时任务A执行完毕,任务C则从workQueue取出,沿用刚开始创建的线程执行任务。\n\n**keepAliveTime** : 由于任务F是额外创建的一个线程去执行，线程池在空闲时只能保持 核心线程数个线程，所以当任务F执行完后，在keepAliveTime时间内如果没有新的任务进来导致正在运行线程 > 核心线程数 & workQueue已满 这两个条件，则对应的线程会被销毁。\n\n线程创建规则如下:\n\n| 序号 | 条件                                                        | 动作             |\n| ---- | ----------------------------------------------------------- | ---------------- |\n| 1    | 线程数 < corePoolSize                                       | 创建新线程       |\n| 2    | 线程数 ≥ corePoolSize，且 workQueue 未满                    | 缓存新任务       |\n| 3    | corePoolSize ≤ 线程数 ＜ maximumPoolSize，且 workQueue 已满 | 创建新线程       |\n| 4    | 线程数 ≥ maximumPoolSize，且 workQueue 已满                 | 使用拒绝策略处理 |\n\n从线程池执行逻辑总结 :\n\n- 任务进来时首先先在核心线程中执行，如果核心线程满则放到队列中，如果队列满且还没到最大线程数则可以额外创建线程执行(这个额外的线程是会被回收的)\n- 核心线程不会被回收，额外的线程会被回收，如果设置了allowCoreThreadTimeOut为true，则核心线程数也可以被回收，但一般不这样做\n- 如果workQueue是无界队列，则keepAliveTime将不起作用\n\n### 排队策略\n当线程数 ≥ corePoolSize时，任务会存到队列中排队，有3中类型的容器可供使用，分别是同步队列，有界队列和无界队列。对于有优先级的任务，这里还可以增加优先级队列。\n\n| 实现类                | 类型       | 说明                                                         |\n| --------------------- | ---------- | ------------------------------------------------------------ |\n| SynchronousQueue      | 同步队列   | 该队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞 |\n| ArrayBlockingQueue    | 有界队列   | 基于数组的阻塞队列，按照 FIFO 原则对元素进行排序             |\n| LinkedBlockingQueue   | 无界队列   | 基于链表的阻塞队列，按照 FIFO 原则对元素进行排序             |\n| PriorityBlockingQueue | 优先级队列 | 具有优先级的阻塞队列                                         |\n\n### 拒绝策略\n线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务。Java 线程池提供了4中拒绝策略实现类\n\n| 实现类              | 说明                                          |\n| ------------------- | --------------------------------------------- |\n| AbortPolicy         | 丢弃新任务，并抛出 RejectedExecutionException |\n| DiscardPolicy       | 不做任何操作，直接丢弃新任务                  |\n| DiscardOldestPolicy | 丢弃队列队首的元素，并执行新任务              |\n| CallerRunsPolicy    | 由调用线程执行新任务                          |\n\n```java\n//使用拒绝策略\nThreadPoolExecutor executor = new ThreadPoolExecutor(1 , 1 , 1L , TimeUnit.MINUTES,new ArrayBlockingQueue<>(1),\nnew ThreadPoolExecutor.AbortPolicy());\n//自定义拒绝策略\nThreadPoolExecutor executor2 = new ThreadPoolExecutor(1 , 1 , 1L , TimeUnit.MINUTES , new ArrayBlockingQueue<>(1),\n        new RejectedExecutionHandler(){\n            @Override\n            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n \t\t\t\t//doSomeing   \n            }\n });\n```\n\n\n\n## 几种线程池\n\nExecutors为创建线程池的工具类，提供了多种方式的线程池创建方法。\n### newFixedThreadPool\n构建包含固定线程数的线程池，默认情况下，空闲线程不会被回收。\n从参数可以看出核心线程数 = 最大线程数 / 采用无界队列。\n```\n    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>());\n    }\n```\n**特点与隐患**\n这种方式采用的是无界队列，如果任务执行时间长且任务量多将会出现任务堆积在队列中导致系统内存飙升，内存溢出等问题\n### newCachedThreadPool\n构建线程数不定的线程池，线程数量随任务量变动，空闲线程存活时间超过60秒后会被回收。\n**SynchronousQueue**特点是队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞。\n\n```\n    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue<Runnable>());\n    }\n```\n**特点与隐患**\n队列相当于不排队，每次来一个任务就创建一个线程执行。当对应的任务执行完以后对应的线程如果在60秒内没有没有其他任务继续复用则会销毁。\n**推荐使用这种线程池**。能够自动在并发量不多的时候自动销毁执行完的线程。但是最大线程数为无穷大,没有控制线程数也容易造成当并发量特别高时不加以控制导致线程数飙升\n### newSingleThreadExecutor\n构建线程数为1的线程池，等价于 newFixedThreadPool(1) 所构造出的线程池\n```\n    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n\n```\n**特点与隐患**\n一次只能一个线程在运行，只会创建一个线程进行复用，采用无界队列容易造成内存飙升\n### newScheduledThreadPool\n创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n```\n    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n   public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n\n```\n\n## ThreadPoolExecutor源码分析\n\n### executre和submit方法\n\n首先先来看下两个方法如何使用。线程池支持无返回值的execute方法，和有返回值的submit方法。有返回值的其实是将task封装成一个FutureTask。关于FutureTask可以看另外篇博客《[Fork/join框架你会用吗？](http://xuzyblog.top/2020/07/30/fork-join/)》。\n\n```java\n@Test\npublic void testError() throws InterruptedException, ExecutionException {\n    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 20, 60L, TimeUnit.MINUTES, new LinkedBlockingQueue<>());\n    threadPoolExecutor.execute(() -> {\n        System.out.println(\"线程池源码解析-execute\");\n    });\n    Future future = threadPoolExecutor.submit(() -> {\n        System.out.println(\"线程池源码解析-submit\");\n    });\n    future.get();\n}\n```\n\n```java\njava.util.concurrent.AbstractExecutorService\n\nprotected <T> RunnableFuture<T> newTaskFor(Callable<T> callable) {\n    return new FutureTask<T>(callable);\n}\n\nprotected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n        return new FutureTask<T>(runnable, value);\n}\n\n//传入Runable 返回Future\npublic Future<?> submit(Runnable task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<Void> ftask = newTaskFor(task, null);\n    //最终都是调用到了execute方法执行逻辑\n    execute(ftask);\n    return ftask;\n}\n\n//传入Callable 返回Future\npublic <T> Future<T> submit(Callable<T> task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task);\n    execute(ftask);\n    return ftask;\n}\n```\n\n这里需要先明白一个易错点，execute(Runnable task) 和 submit(Runnable task) 中的task应该理解成任务，而不是线程。整个线程池的逻辑大概可以这样概括 ： <font color=red>当execture提交一个task后，会新建一个Worker对象，并将任务放到里面，这个Worker里面有一个Thred变量就是真正线程池用来执行任务的线程。当一个task执行完以后，这个Worker会继续从队列中获取任务继续执行。</font>\n\n![](executorservice/3.png)\n\n### 重要属性分析\n\n采用一个 32 位的整数来存放线程池的状态和当前池中的线程数。\n\n- 高 3 位用于存放线程池状态\n- 低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）\n\n```java\n//ThreadPoolExecutor中的控制状态\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n//线程池中当前活动的线程数量允许的最大值\n//运算方法就是1左移29位再减1 00000000 00000000 00000000 00000001 --> 001 0000 00000000 00000000 00000000 - 1 = 536870911\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n//===我们说过高三位代表的是线程池的状态，所以下面就是线程池的几种状态\n//RUNNING - 正常的状态：接受新的任务，处理等待队列中的任务\n//SHUTDOWN - 不接受新的任务提交，但是会继续处理等待队列中的任务\n//STOP - 不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程\n//TIDYING - 所有的任务都销毁了，workCount为0，线程过渡到TIDYING状态，将会执行terminated()钩子方法\n//TERMINATED - terminated()方法已经完成\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n//用来存放task的阻塞队列\nprivate final BlockingQueue<Runnable> workQueue;\n//线程池中所有工作线程worker的集合\nprivate final HashSet<Worker> workers = new HashSet<Worker>();\n//创建线程的工厂，值得是Worker中变量Thread t的创建工厂\nprivate volatile ThreadFactory threadFactory;\n//拒绝策略\nprivate volatile RejectedExecutionHandler handler;\n//空闲线程存活时间\nprivate volatile long keepAliveTime;\n//核心线程数\nprivate volatile int corePoolSize;\n//最大线程数\nprivate volatile int maximumPoolSize;\n```\n\n![线程池状态转换](executorservice/4.png)\n\n### Worker内部类\n\nWorker是线程池中真正用来执行任务的类。继承了AQS，实现了Runable接口。这里继承AQS，主要是为了独占锁，如果是加锁状态证明Worker正在执行，如果解锁状态证明空闲。\n\n**Worker为什么不直接使用ReentrantLock而是继承AQS ?**  tryAcquire方法它是不允许重入的，而ReentrantLock是允许重入的。对于线程来说，如果线程正在执行是不允许其它锁重入进来的。\n\n我们可以理解Worker表示线程池中的<font color=red>工人</font>，Runnable command表示工人要做的任务。一个工人对应的是一个线程，一个工人一次做一个任务。工人做完任务后再从队列中获取任务继续做。\n\n```java\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable{\n    \n    private static final long serialVersionUID = 6138294804551838833L;\n    //真正用来执行任务的线程\n    final Thread thread;\n    //在new Worker时候传入的任务，这里交first值得是他是new Worker时候传入的那就是第一个。\n    //但是有时候这个是null,那代表没有传入，这时候就是从队列中取\n    Runnable firstTask;\n    //用于存放此线程完成的任务数，注意了，这里用了 volatile，保证可见性\n    volatile long completedTasks;\n\n    \n    Worker(Runnable firstTask) {\n        setState(-1);\n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    public void run() {\n        runWorker(this);\n    }\n\n    protected boolean isHeldExclusively() {\n        return getState() != 0;\n    }\n\n    protected boolean tryAcquire(int unused) {\n        if (compareAndSetState(0, 1)) {\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryRelease(int unused) {\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); }\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); }\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}\n```\n\n\n\n### 核心源码分析\n\n![线程池执行流程](executorservice/1.jpg)\n\n#### execute方法\n\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    //如果线程池中工作的Worker数量小于核心线程数\n    if (workerCountOf(c) < corePoolSize) {\n        //直接new一个worker来执行任务，并把当前任务 command 作为这个线程的第一个任务(firstTask)\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    \n    //到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了\n    \n    //判断当前线程池的状态是不是RUNNING状态，如果是则将任务放到队列中等待\n    //offer - 将给定的元素设置到队列中，如果设置成功返回true, 否则返回false\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        //刚将任务放到队列后发现线程池不是运行的，那就删除把刚放到队列的任务删除并执行拒绝策略\n        if (! isRunning(recheck) && remove(command)){\n         \treject(command);   \n        }\n        //如果线程池还是 RUNNING 的，但是工作线程数为 0，那么开启新的线程，这种情况比较少见\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    //这个分支，表示前面入队失败了，那么以 maximumPoolSize 为界创建新的 worker\n    else if (!addWorker(command, false)){\n        reject(command); //失败就执行拒绝策略   \n    }\n}\n```\n\n#### addWorker方法\n\n```java\n//core = true 时代表使用核心线程数 corePoolSize 作为创建线程的界限\n//core = flase 时代表使用最大线程数 maximumPoolSize 作为创建线程的界限\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // 判断是否可以addWorker\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            //获取当前工作的worker数量\n            int wc = workerCountOf(c);\n            //如果大于允许的最大数或者大于核心线程数则返回false\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            //如果运行线程数可以+1表示能成功new Worker,跳出循环\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get(); \n            if (runStateOf(c) != rs)\n                continue retry;\n        }\n    }\n\n    //用来判断worker 是否已经启动\n    boolean workerStarted = false;\n    //是否已将这个 worker 添加到 workers 这个 HashSet 中\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        //先建一个\"工人\"\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            //这里使用mainLock保证workers.add(w)\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n\n                int rs = runStateOf(ctl.get());\n\t\t\t   //小于SHUTTDOWN 那就是 RUNNING状态\n                //如果等于SHUTDOWN，不接受新的任务，但是会继续执行等待队列中的任务\n                if (rs < SHUTDOWN || (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) throw new IllegalThreadStateException();\n                    //将这个\"工人\"存到workers中\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                //这个\"工人\"开始工作，对应Worker->run方法->runWorker(this)方法\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        //如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n\n//启动\"工人\"失败就炒了这个\"工人\"\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        if (w != null)\n            workers.remove(w);\n        decrementWorkerCount();\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n\n```\n\n#### runWorker方法\n\n```java\n//此方法由worker线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    //第一个任务就直接运行，不用从队列中取\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            //判断各种不合适的状态然后中断\n            //(线程状态>=STOP 或者 (线程中断且线程状态>=STOP)) 且 当时线程没有中断\n            //其实主要保证2点 : 1.线程池没有停止 2.保证线程没有中断\n            if (\n                ( runStateAtLeast(ctl.get(), STOP) ||\n                  (Thread.interrupted() && runStateAtLeast(ctl.get(), STOP))\n                ) &&\n                !wt.isInterrupted()\n               )\n                wt.interrupt();\n            try {\n                //钩子\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    //真正的执行任务，这里task要嘛是Runnable要嘛是FutureTask。\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    //钩子\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                //置空 task，准备 getTask 获取下一个任务\n                task = null;\n                //完成数+1\n                w.completedTasks++;\n                //释放独占锁\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        //如果执行到这一步说明线程池状态不对了。\n        //getTask()是会阻塞的，所以即使队列中为空，除非是超过核心线程数\n        //的worker才会执行到这一步，不然会阻塞住\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n总结runWorker方法执行过程：\n\n1. while循环中，不断地通过getTask()方法从workerQueue中获取任务\n2. 如果线程池正在停止，则中断线程。否则调用3.\n3. 调用task.run()执行任务\n4. 如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程`workers.remove(w)`\n\n**keepAliveTime作用详解**\n\n我们知道当任务大于核心线程数+队列大小后，会额外new Worker来执行任务。随着队列中任务的消化，创建出来额外的Worker是需要被回收的。这个实现的过程是通过如下代码。\n\n```java\nfinal void runWorker(Worker w) {\n   Thread wt = Thread.currentThread();\n   Runnable task = w.firstTask;\n   w.firstTask = null;\n   w.unlock(); // allow interrupts\n   boolean completedAbruptly = true;\n   try {\n       while (task != null || (task = getTask()) != null) {\n           //省略很多代码\n       }\n       completedAbruptly = false;\n   } finally {\n       //getTask()从队列中获取任务超时了，就关闭额外的Worker\n       processWorkerExit(w, completedAbruptly);\n   }\n\n\nprivate Runnable getTask() {\n    boolean timedOut = false; \n    for (;;) {\n        \n        //省略很多代码...\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        //省略很多代码...\n\n        try {\n        \t//如果从队列中获取任务超时，也就是说队列中任务已经被消化完了，\n        \t//那么就会抛出InterruptedException异常\n        \t//所以runWorker会处理异常，执行processWorkerExit将额外的Worker关闭\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n\n\n#### getTask()方法\n\ngetTask方法表示从队列中获取任务。正常情况下如果是核心线程数内的Worker获取时，如果有则返回，如果队列中没有任务会阻塞。\n\n如果这个方法不阻塞而是返回null，有如下几种可能\n\n- 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务\n- 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行\n- 大于核心线程数时额外创建出来的Worker，如果这个Worker空闲超过了keepAliveTime则会返回null\n\n```java\nprivate Runnable getTask() {\n    boolean timedOut = false;\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\t    //1. rs == SHUTDOWN && workQueue.isEmpty()\n        //2. rs >= STOP\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n             // CAS 操作，减少工作线程数\n            decrementWorkerCount();\n            return null;\n        }\n\t    //获取当天工作的worker数\n        int wc = workerCountOf(c);\n\t    //允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut)) && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n## 优雅关闭线程池\n\n### shutdown\n\n会等正在执行的任务和队列中的任务完成后再关闭。\n\n1. shutDown会首先将线程设置成`SHUTDOWN`状态。\n2. 执行的线程和已经在队列中的线程并不会被中断，继续执行。\n3. 中断没有执行的Worker。\n4. shutdown()方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。\n\n### shutdownNow\n\n马上关闭，强制关闭正在执行的任务和队列中的任务。\n\n## 常见疑问\n\n**为什么execute方法会抛异常，submit不会**\n\n```java\nexecutors.execute(new Runnable() {\n    @Override\n    public void run() {\n        throw new RuntimeException(\"xxx\");\n    }\n});\n//抛出异常\nException in thread \"pool-1-thread-1\" java.lang.RuntimeException: xxx\n\tat xzy.OtherTest$1.run(OtherTest.java:33)\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n\tat java.lang.Thread.run(Thread.java:748)\n\nexecutors.submit(new Runnable() {\n    @Override\n    public void run() {\n        throw new RuntimeException(\"xxx\");\n    }\n});\n//不抛出异常\n```\n\n我们定位到**runWorker**源码中，可以看到**task.run()**做了异常处理。\n\n- 如果是execute方法，task=Runnable接口，调用run方法出现错误抛出异常可以被捕获\n- 如果是submit方法，Runnable会被封装成FutureTask，所以task=FutureTask。FutureTask重写了run方法，如果遇到异常会记录起来在get()方法调用时候才抛出。\n\n```java\ntry {\n       task.run();\n   } catch (RuntimeException x) {\n       thrown = x; throw x;\n   } catch (Error x) {\n       thrown = x; throw x;\n   } catch (Throwable x) {\n       // 这里不允许抛出 Throwable，所以转换为 Error\n       thrown = x; throw new Error(x);\n   } finally {\n       // 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现\n       afterExecute(task, thrown);\n}\n```\n\n\n\n## 参考\n\n- https://zhuanlan.zhihu.com/p/60524908","slug":"executorservice","published":1,"updated":"2021-07-19T01:48:12.692Z","_id":"ckn9yvhu70002qwv28poxegic","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"为什么要使用线程池\"><a href=\"#为什么要使用线程池\" class=\"headerlink\" title=\"为什么要使用线程池?\"></a>为什么要使用线程池?</h2><p>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。使用多线程技术完成一个任务所需的时间包括。</p>\n<ul>\n<li>T1 创建线程时间</li>\n<li>T2 执行线程任务的时间</li>\n<li>T3 销毁线程的时间</li>\n</ul>\n<p>如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。不单单如此，合理的线程池帮我们管理系统线程资源防止由于线程太多导致的系统崩溃问题等。<br>所以,<strong>线程池有如下作用</strong>:</p>\n<ul>\n<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>\n<li>可根据系统的承受能力调整线程池中工作线线程的数目防止因为消耗过多的内存而把服务器累趴下</li>\n</ul>\n<p>此外，参考美团上的一段关于线程多的弊端：</p>\n<ul>\n<li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数，需要调用系统内核的API，然后操作系统为其分配一系列资源，整个正本很高。</li>\n<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。</li>\n<li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。<strong>如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。</strong></li>\n<li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。<a id=\"more\"></a>\n<h2 id=\"线程池详解\"><a href=\"#线程池详解\" class=\"headerlink\" title=\"线程池详解\"></a>线程池详解</h2></li>\n</ul>\n<h3 id=\"继承体系\"><a href=\"#继承体系\" class=\"headerlink\" title=\"继承体系\"></a>继承体系</h3><p><img src=\"/2018/01/18/executorservice/1.png\" alt><br>Executor为线程池的顶级接口，声明了<font color=\"#FF0000\">execute</font>方法。<br>Executors为创建线程池的工具类，提供了多种方式的线程池创建方法。</p>\n<h3 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span>\n                          TimeUnit unit<span class=\"token punctuation\">,</span>\n                          BlockingQueue<span class=\"token operator\">&lt;</span>Runnable<span class=\"token operator\">></span> workQueue<span class=\"token punctuation\">,</span>\n                          ThreadFactory threadFactory<span class=\"token punctuation\">,</span>\n                          RejectedExecutionHandler handler<span class=\"token punctuation\">)</span></code></pre>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>corePoolSize</td>\n<td>核心线程数。当线程数小于该值时，线程池会优先创建新线程来执行新任务</td>\n</tr>\n<tr>\n<td>maximumPoolSize</td>\n<td>线程池所能维护的最大线程数</td>\n</tr>\n<tr>\n<td>keepAliveTime</td>\n<td>空闲线程的存活时间</td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>任务队列，用于缓存未执行的任务</td>\n</tr>\n<tr>\n<td>threadFactory</td>\n<td>线程工厂。可通过工厂为新建的线程设置更有意义的名字</td>\n</tr>\n<tr>\n<td>handler</td>\n<td>拒绝策略。当线程池和任务队列均处于饱和状态时，使用拒绝策略处理新任务。默认是 AbortPolicy，即直接抛出异常</td>\n</tr>\n</tbody></table>\n<h3 id=\"线程池执行逻辑\"><a href=\"#线程池执行逻辑\" class=\"headerlink\" title=\"线程池执行逻辑\"></a>线程池执行逻辑</h3><p><img src=\"/2018/01/18/executorservice/2.png\" alt><br>假设目前定义了一个线程池<br>corePoolSize = 2<br>keepAliveTime = 10ms<br>maximumPoolSize = 3<br>workQueue = ArrayBlockingQueue(长度为3)</p>\n<p>执行步骤如下:</p>\n<ol>\n<li>首先进来一个任务A,在线程池没有任务在执行,正在运行线程 &lt;  核心线程数,建一个线程执行任务</li>\n<li>又来一个任务B,此时正在运行的线程数为1.正在运行线程 &lt;  核心线程数,则继续创建一个线程执行任务</li>\n<li>又来一个任务C,此时正在运行线程 &gt; 核心线程数,将任务放到workQueue等待执行。</li>\n<li>此时又来了任务DEF…..,由于队列只允许存3个,DE进入到队列等待</li>\n<li>此时F没有进入队列, 正在运行线程 &lt; 最大线程数,则任务F允许创建一个线程执行。</li>\n<li>此时任务G到来，由于AB任务还没结束，workQueue存放了CDE任务等待执行,此时正在运行线程 =最大线程数,则G被拒绝，执行对应的拒绝策略。</li>\n<li>此时任务A执行完毕,任务C则从workQueue取出,沿用刚开始创建的线程执行任务。</li>\n</ol>\n<p><strong>keepAliveTime</strong> : 由于任务F是额外创建的一个线程去执行，线程池在空闲时只能保持 核心线程数个线程，所以当任务F执行完后，在keepAliveTime时间内如果没有新的任务进来导致正在运行线程 &gt; 核心线程数 &amp; workQueue已满 这两个条件，则对应的线程会被销毁。</p>\n<p>线程创建规则如下:</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>条件</th>\n<th>动作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>线程数 &lt; corePoolSize</td>\n<td>创建新线程</td>\n</tr>\n<tr>\n<td>2</td>\n<td>线程数 ≥ corePoolSize，且 workQueue 未满</td>\n<td>缓存新任务</td>\n</tr>\n<tr>\n<td>3</td>\n<td>corePoolSize ≤ 线程数 ＜ maximumPoolSize，且 workQueue 已满</td>\n<td>创建新线程</td>\n</tr>\n<tr>\n<td>4</td>\n<td>线程数 ≥ maximumPoolSize，且 workQueue 已满</td>\n<td>使用拒绝策略处理</td>\n</tr>\n</tbody></table>\n<p>从线程池执行逻辑总结 :</p>\n<ul>\n<li>任务进来时首先先在核心线程中执行，如果核心线程满则放到队列中，如果队列满且还没到最大线程数则可以额外创建线程执行(这个额外的线程是会被回收的)</li>\n<li>核心线程不会被回收，额外的线程会被回收，如果设置了allowCoreThreadTimeOut为true，则核心线程数也可以被回收，但一般不这样做</li>\n<li>如果workQueue是无界队列，则keepAliveTime将不起作用</li>\n</ul>\n<h3 id=\"排队策略\"><a href=\"#排队策略\" class=\"headerlink\" title=\"排队策略\"></a>排队策略</h3><p>当线程数 ≥ corePoolSize时，任务会存到队列中排队，有3中类型的容器可供使用，分别是同步队列，有界队列和无界队列。对于有优先级的任务，这里还可以增加优先级队列。</p>\n<table>\n<thead>\n<tr>\n<th>实现类</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SynchronousQueue</td>\n<td>同步队列</td>\n<td>该队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞</td>\n</tr>\n<tr>\n<td>ArrayBlockingQueue</td>\n<td>有界队列</td>\n<td>基于数组的阻塞队列，按照 FIFO 原则对元素进行排序</td>\n</tr>\n<tr>\n<td>LinkedBlockingQueue</td>\n<td>无界队列</td>\n<td>基于链表的阻塞队列，按照 FIFO 原则对元素进行排序</td>\n</tr>\n<tr>\n<td>PriorityBlockingQueue</td>\n<td>优先级队列</td>\n<td>具有优先级的阻塞队列</td>\n</tr>\n</tbody></table>\n<h3 id=\"拒绝策略\"><a href=\"#拒绝策略\" class=\"headerlink\" title=\"拒绝策略\"></a>拒绝策略</h3><p>线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务。Java 线程池提供了4中拒绝策略实现类</p>\n<table>\n<thead>\n<tr>\n<th>实现类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AbortPolicy</td>\n<td>丢弃新任务，并抛出 RejectedExecutionException</td>\n</tr>\n<tr>\n<td>DiscardPolicy</td>\n<td>不做任何操作，直接丢弃新任务</td>\n</tr>\n<tr>\n<td>DiscardOldestPolicy</td>\n<td>丢弃队列队首的元素，并执行新任务</td>\n</tr>\n<tr>\n<td>CallerRunsPolicy</td>\n<td>由调用线程执行新任务</td>\n</tr>\n</tbody></table>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//使用拒绝策略</span>\nThreadPoolExecutor executor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">,</span> 1L <span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>MINUTES<span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor<span class=\"token punctuation\">.</span>AbortPolicy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//自定义拒绝策略</span>\nThreadPoolExecutor executor2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">,</span> 1L <span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>MINUTES <span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayBlockingQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">RejectedExecutionHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">rejectedExecution</span><span class=\"token punctuation\">(</span>Runnable r<span class=\"token punctuation\">,</span> ThreadPoolExecutor executor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                 <span class=\"token comment\" spellcheck=\"true\">//doSomeing   </span>\n            <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"几种线程池\"><a href=\"#几种线程池\" class=\"headerlink\" title=\"几种线程池\"></a>几种线程池</h2><p>Executors为创建线程池的工具类，提供了多种方式的线程池创建方法。</p>\n<h3 id=\"newFixedThreadPool\"><a href=\"#newFixedThreadPool\" class=\"headerlink\" title=\"newFixedThreadPool\"></a>newFixedThreadPool</h3><p>构建包含固定线程数的线程池，默认情况下，空闲线程不会被回收。<br>从参数可以看出核心线程数 = 最大线程数 / 采用无界队列。</p>\n<pre><code>    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue&lt;Runnable&gt;());\n    }</code></pre><p><strong>特点与隐患</strong><br>这种方式采用的是无界队列，如果任务执行时间长且任务量多将会出现任务堆积在队列中导致系统内存飙升，内存溢出等问题</p>\n<h3 id=\"newCachedThreadPool\"><a href=\"#newCachedThreadPool\" class=\"headerlink\" title=\"newCachedThreadPool\"></a>newCachedThreadPool</h3><p>构建线程数不定的线程池，线程数量随任务量变动，空闲线程存活时间超过60秒后会被回收。<br><strong>SynchronousQueue</strong>特点是队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞。</p>\n<pre><code>    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue&lt;Runnable&gt;());\n    }</code></pre><p><strong>特点与隐患</strong><br>队列相当于不排队，每次来一个任务就创建一个线程执行。当对应的任务执行完以后对应的线程如果在60秒内没有没有其他任务继续复用则会销毁。<br><strong>推荐使用这种线程池</strong>。能够自动在并发量不多的时候自动销毁执行完的线程。但是最大线程数为无穷大,没有控制线程数也容易造成当并发量特别高时不加以控制导致线程数飙升</p>\n<h3 id=\"newSingleThreadExecutor\"><a href=\"#newSingleThreadExecutor\" class=\"headerlink\" title=\"newSingleThreadExecutor\"></a>newSingleThreadExecutor</h3><p>构建线程数为1的线程池，等价于 newFixedThreadPool(1) 所构造出的线程池</p>\n<pre><code>    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue&lt;Runnable&gt;()));\n    }\n</code></pre><p><strong>特点与隐患</strong><br>一次只能一个线程在运行，只会创建一个线程进行复用，采用无界队列容易造成内存飙升</p>\n<h3 id=\"newScheduledThreadPool\"><a href=\"#newScheduledThreadPool\" class=\"headerlink\" title=\"newScheduledThreadPool\"></a>newScheduledThreadPool</h3><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>\n<pre><code>    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n   public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n</code></pre><h2 id=\"ThreadPoolExecutor源码分析\"><a href=\"#ThreadPoolExecutor源码分析\" class=\"headerlink\" title=\"ThreadPoolExecutor源码分析\"></a>ThreadPoolExecutor源码分析</h2><h3 id=\"executre和submit方法\"><a href=\"#executre和submit方法\" class=\"headerlink\" title=\"executre和submit方法\"></a>executre和submit方法</h3><p>首先先来看下两个方法如何使用。线程池支持无返回值的execute方法，和有返回值的submit方法。有返回值的其实是将task封装成一个FutureTask。关于FutureTask可以看另外篇博客《<a href=\"http://xuzyblog.top/2020/07/30/fork-join/\" target=\"_blank\" rel=\"noopener\">Fork/join框架你会用吗？</a>》。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException<span class=\"token punctuation\">,</span> ExecutionException <span class=\"token punctuation\">{</span>\n    ThreadPoolExecutor threadPoolExecutor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">20</span><span class=\"token punctuation\">,</span> 60L<span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>MINUTES<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程池源码解析-execute\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Future future <span class=\"token operator\">=</span> threadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程池源码解析-submit\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    future<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>AbstractExecutorService\n\n<span class=\"token keyword\">protected</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> RunnableFuture<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">newTaskFor</span><span class=\"token punctuation\">(</span>Callable<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> callable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureTask</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>callable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protected</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> RunnableFuture<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">newTaskFor</span><span class=\"token punctuation\">(</span>Runnable runnable<span class=\"token punctuation\">,</span> T value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureTask</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>runnable<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//传入Runable 返回Future</span>\n<span class=\"token keyword\">public</span> Future<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> <span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>Runnable task<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>task <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    RunnableFuture<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> ftask <span class=\"token operator\">=</span> <span class=\"token function\">newTaskFor</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//最终都是调用到了execute方法执行逻辑</span>\n    <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>ftask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ftask<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//传入Callable 返回Future</span>\n<span class=\"token keyword\">public</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> Future<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">submit</span><span class=\"token punctuation\">(</span>Callable<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> task<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>task <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    RunnableFuture<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> ftask <span class=\"token operator\">=</span> <span class=\"token function\">newTaskFor</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>ftask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> ftask<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这里需要先明白一个易错点，execute(Runnable task) 和 submit(Runnable task) 中的task应该理解成任务，而不是线程。整个线程池的逻辑大概可以这样概括 ： <font color=\"red\">当execture提交一个task后，会新建一个Worker对象，并将任务放到里面，这个Worker里面有一个Thred变量就是真正线程池用来执行任务的线程。当一个task执行完以后，这个Worker会继续从队列中获取任务继续执行。</font></p>\n<p><img src=\"/2018/01/18/executorservice/3.png\" alt></p>\n<h3 id=\"重要属性分析\"><a href=\"#重要属性分析\" class=\"headerlink\" title=\"重要属性分析\"></a>重要属性分析</h3><p>采用一个 32 位的整数来存放线程池的状态和当前池中的线程数。</p>\n<ul>\n<li>高 3 位用于存放线程池状态</li>\n<li>低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//ThreadPoolExecutor中的控制状态</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> AtomicInteger ctl <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token function\">ctlOf</span><span class=\"token punctuation\">(</span>RUNNING<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> COUNT_BITS <span class=\"token operator\">=</span> Integer<span class=\"token punctuation\">.</span>SIZE <span class=\"token operator\">-</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//线程池中当前活动的线程数量允许的最大值</span>\n<span class=\"token comment\" spellcheck=\"true\">//运算方法就是1左移29位再减1 00000000 00000000 00000000 00000001 --> 001 0000 00000000 00000000 00000000 - 1 = 536870911</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> CAPACITY   <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> COUNT_BITS<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//===我们说过高三位代表的是线程池的状态，所以下面就是线程池的几种状态</span>\n<span class=\"token comment\" spellcheck=\"true\">//RUNNING - 正常的状态：接受新的任务，处理等待队列中的任务</span>\n<span class=\"token comment\" spellcheck=\"true\">//SHUTDOWN - 不接受新的任务提交，但是会继续处理等待队列中的任务</span>\n<span class=\"token comment\" spellcheck=\"true\">//STOP - 不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</span>\n<span class=\"token comment\" spellcheck=\"true\">//TIDYING - 所有的任务都销毁了，workCount为0，线程过渡到TIDYING状态，将会执行terminated()钩子方法</span>\n<span class=\"token comment\" spellcheck=\"true\">//TERMINATED - terminated()方法已经完成</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> RUNNING    <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> COUNT_BITS<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> SHUTDOWN   <span class=\"token operator\">=</span>  <span class=\"token number\">0</span> <span class=\"token operator\">&lt;&lt;</span> COUNT_BITS<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> STOP       <span class=\"token operator\">=</span>  <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> COUNT_BITS<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> TIDYING    <span class=\"token operator\">=</span>  <span class=\"token number\">2</span> <span class=\"token operator\">&lt;&lt;</span> COUNT_BITS<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> TERMINATED <span class=\"token operator\">=</span>  <span class=\"token number\">3</span> <span class=\"token operator\">&lt;&lt;</span> COUNT_BITS<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//用来存放task的阻塞队列</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> BlockingQueue<span class=\"token operator\">&lt;</span>Runnable<span class=\"token operator\">></span> workQueue<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//线程池中所有工作线程worker的集合</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> HashSet<span class=\"token operator\">&lt;</span>Worker<span class=\"token operator\">></span> workers <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token operator\">&lt;</span>Worker<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//创建线程的工厂，值得是Worker中变量Thread t的创建工厂</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> ThreadFactory threadFactory<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//拒绝策略</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> RejectedExecutionHandler handler<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//空闲线程存活时间</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//核心线程数</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//最大线程数</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2018/01/18/executorservice/4.png\" alt=\"线程池状态转换\"></p>\n<h3 id=\"Worker内部类\"><a href=\"#Worker内部类\" class=\"headerlink\" title=\"Worker内部类\"></a>Worker内部类</h3><p>Worker是线程池中真正用来执行任务的类。继承了AQS，实现了Runable接口。这里继承AQS，主要是为了独占锁，如果是加锁状态证明Worker正在执行，如果解锁状态证明空闲。</p>\n<p><strong>Worker为什么不直接使用ReentrantLock而是继承AQS ?</strong>  tryAcquire方法它是不允许重入的，而ReentrantLock是允许重入的。对于线程来说，如果线程正在执行是不允许其它锁重入进来的。</p>\n<p>我们可以理解Worker表示线程池中的<font color=\"red\">工人</font>，Runnable command表示工人要做的任务。一个工人对应的是一个线程，一个工人一次做一个任务。工人做完任务后再从队列中获取任务继续做。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Worker</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractQueuedSynchronizer</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> serialVersionUID <span class=\"token operator\">=</span> 6138294804551838833L<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//真正用来执行任务的线程</span>\n    <span class=\"token keyword\">final</span> Thread thread<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//在new Worker时候传入的任务，这里交first值得是他是new Worker时候传入的那就是第一个。</span>\n    <span class=\"token comment\" spellcheck=\"true\">//但是有时候这个是null,那代表没有传入，这时候就是从队列中取</span>\n    Runnable firstTask<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//用于存放此线程完成的任务数，注意了，这里用了 volatile，保证可见性</span>\n    <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">long</span> completedTasks<span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token function\">Worker</span><span class=\"token punctuation\">(</span>Runnable firstTask<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstTask <span class=\"token operator\">=</span> firstTask<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>thread <span class=\"token operator\">=</span> <span class=\"token function\">getThreadFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">newThread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">runWorker</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isHeldExclusively</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> unused<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> unused<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>        <span class=\"token punctuation\">{</span> <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>      <span class=\"token punctuation\">{</span> <span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isLocked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">return</span> <span class=\"token function\">isHeldExclusively</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">void</span> <span class=\"token function\">interruptIfStarted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Thread t<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">=</span> thread<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                t<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">SecurityException</span> ignore<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"核心源码分析\"><a href=\"#核心源码分析\" class=\"headerlink\" title=\"核心源码分析\"></a>核心源码分析</h3><p><img src=\"/2018/01/18/executorservice/1.jpg\" alt=\"线程池执行流程\"></p>\n<h4 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"execute方法\"></a>execute方法</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>Runnable command<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>command <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果线程池中工作的Worker数量小于核心线程数</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> corePoolSize<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//直接new一个worker来执行任务，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//判断当前线程池的状态是不是RUNNING状态，如果是则将任务放到队列中等待</span>\n    <span class=\"token comment\" spellcheck=\"true\">//offer - 将给定的元素设置到队列中，如果设置成功返回true, 否则返回false</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isRunning</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">offer</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> recheck <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//刚将任务放到队列后发现线程池不是运行的，那就删除把刚放到队列的任务删除并执行拒绝策略</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span> <span class=\"token function\">isRunning</span><span class=\"token punctuation\">(</span>recheck<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n             <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   \n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果线程池还是 RUNNING 的，但是工作线程数为 0，那么开启新的线程，这种情况比较少见</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span>recheck<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//这个分支，表示前面入队失败了，那么以 maximumPoolSize 为界创建新的 worker</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>command<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//失败就执行拒绝策略   </span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"addWorker方法\"><a href=\"#addWorker方法\" class=\"headerlink\" title=\"addWorker方法\"></a>addWorker方法</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//core = true 时代表使用核心线程数 corePoolSize 作为创建线程的界限</span>\n<span class=\"token comment\" spellcheck=\"true\">//core = flase 时代表使用最大线程数 maximumPoolSize 作为创建线程的界限</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">addWorker</span><span class=\"token punctuation\">(</span>Runnable firstTask<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> core<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    retry<span class=\"token operator\">:</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> rs <span class=\"token operator\">=</span> <span class=\"token function\">runStateOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 判断是否可以addWorker</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">>=</span> SHUTDOWN <span class=\"token operator\">&amp;&amp;</span>\n            <span class=\"token operator\">!</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">==</span> SHUTDOWN <span class=\"token operator\">&amp;&amp;</span>\n               firstTask <span class=\"token operator\">==</span> null <span class=\"token operator\">&amp;&amp;</span>\n               <span class=\"token operator\">!</span> workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//获取当前工作的worker数量</span>\n            <span class=\"token keyword\">int</span> wc <span class=\"token operator\">=</span> <span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果大于允许的最大数或者大于核心线程数则返回false</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>wc <span class=\"token operator\">>=</span> CAPACITY <span class=\"token operator\">||</span>\n                wc <span class=\"token operator\">>=</span> <span class=\"token punctuation\">(</span>core <span class=\"token operator\">?</span> corePoolSize <span class=\"token operator\">:</span> maximumPoolSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果运行线程数可以+1表示能成功new Worker,跳出循环</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndIncrementWorkerCount</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">break</span> retry<span class=\"token punctuation\">;</span>\n            c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">runStateOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> rs<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">continue</span> retry<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//用来判断worker 是否已经启动</span>\n    <span class=\"token keyword\">boolean</span> workerStarted <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//是否已将这个 worker 添加到 workers 这个 HashSet 中</span>\n    <span class=\"token keyword\">boolean</span> workerAdded <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    Worker w <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//先建一个\"工人\"</span>\n        w <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Worker</span><span class=\"token punctuation\">(</span>firstTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> Thread t <span class=\"token operator\">=</span> w<span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//这里使用mainLock保证workers.add(w)</span>\n            <span class=\"token keyword\">final</span> ReentrantLock mainLock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mainLock<span class=\"token punctuation\">;</span>\n            mainLock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\n                <span class=\"token keyword\">int</span> rs <span class=\"token operator\">=</span> <span class=\"token function\">runStateOf</span><span class=\"token punctuation\">(</span>ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n               <span class=\"token comment\" spellcheck=\"true\">//小于SHUTTDOWN 那就是 RUNNING状态</span>\n                <span class=\"token comment\" spellcheck=\"true\">//如果等于SHUTDOWN，不接受新的任务，但是会继续执行等待队列中的任务</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">&lt;</span> SHUTDOWN <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">==</span> SHUTDOWN <span class=\"token operator\">&amp;&amp;</span> firstTask <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span><span class=\"token function\">isAlive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalThreadStateException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//将这个\"工人\"存到workers中</span>\n                    workers<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">int</span> s <span class=\"token operator\">=</span> workers<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">></span> largestPoolSize<span class=\"token punctuation\">)</span>\n                        largestPoolSize <span class=\"token operator\">=</span> s<span class=\"token punctuation\">;</span>\n                    workerAdded <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                mainLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workerAdded<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//这个\"工人\"开始工作，对应Worker->run方法->runWorker(this)方法</span>\n                t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                workerStarted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span> workerStarted<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">addWorkerFailed</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> workerStarted<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//启动\"工人\"失败就炒了这个\"工人\"</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addWorkerFailed</span><span class=\"token punctuation\">(</span>Worker w<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> ReentrantLock mainLock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>mainLock<span class=\"token punctuation\">;</span>\n    mainLock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>w <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n            workers<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">decrementWorkerCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">tryTerminate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        mainLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"runWorker方法\"><a href=\"#runWorker方法\" class=\"headerlink\" title=\"runWorker方法\"></a>runWorker方法</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//此方法由worker线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行</span>\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">runWorker</span><span class=\"token punctuation\">(</span>Worker w<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Thread wt <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//第一个任务就直接运行，不用从队列中取</span>\n    Runnable task <span class=\"token operator\">=</span> w<span class=\"token punctuation\">.</span>firstTask<span class=\"token punctuation\">;</span>\n    w<span class=\"token punctuation\">.</span>firstTask <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    w<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// allow interrupts</span>\n    <span class=\"token keyword\">boolean</span> completedAbruptly <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>task <span class=\"token operator\">!=</span> null <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>task <span class=\"token operator\">=</span> <span class=\"token function\">getTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            w<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//判断各种不合适的状态然后中断</span>\n            <span class=\"token comment\" spellcheck=\"true\">//(线程状态>=STOP 或者 (线程中断且线程状态>=STOP)) 且 当时线程没有中断</span>\n            <span class=\"token comment\" spellcheck=\"true\">//其实主要保证2点 : 1.线程池没有停止 2.保证线程没有中断</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n                <span class=\"token punctuation\">(</span> <span class=\"token function\">runStateAtLeast</span><span class=\"token punctuation\">(</span>ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> STOP<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n                  <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">runStateAtLeast</span><span class=\"token punctuation\">(</span>ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> STOP<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n                <span class=\"token operator\">!</span>wt<span class=\"token punctuation\">.</span><span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n               <span class=\"token punctuation\">)</span>\n                wt<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//钩子</span>\n                <span class=\"token function\">beforeExecute</span><span class=\"token punctuation\">(</span>wt<span class=\"token punctuation\">,</span> task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                Throwable thrown <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//真正的执行任务，这里task要嘛是Runnable要嘛是FutureTask。</span>\n                    task<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">RuntimeException</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    thrown <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token keyword\">throw</span> x<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Error</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    thrown <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token keyword\">throw</span> x<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    thrown <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//钩子</span>\n                    <span class=\"token function\">afterExecute</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">,</span> thrown<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//置空 task，准备 getTask 获取下一个任务</span>\n                task <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//完成数+1</span>\n                w<span class=\"token punctuation\">.</span>completedTasks<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//释放独占锁</span>\n                w<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        completedAbruptly <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果执行到这一步说明线程池状态不对了。</span>\n        <span class=\"token comment\" spellcheck=\"true\">//getTask()是会阻塞的，所以即使队列中为空，除非是超过核心线程数</span>\n        <span class=\"token comment\" spellcheck=\"true\">//的worker才会执行到这一步，不然会阻塞住</span>\n        <span class=\"token function\">processWorkerExit</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">,</span> completedAbruptly<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>总结runWorker方法执行过程：</p>\n<ol>\n<li>while循环中，不断地通过getTask()方法从workerQueue中获取任务</li>\n<li>如果线程池正在停止，则中断线程。否则调用3.</li>\n<li>调用task.run()执行任务</li>\n<li>如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程<code>workers.remove(w)</code></li>\n</ol>\n<p><strong>keepAliveTime作用详解</strong></p>\n<p>我们知道当任务大于核心线程数+队列大小后，会额外new Worker来执行任务。随着队列中任务的消化，创建出来额外的Worker是需要被回收的。这个实现的过程是通过如下代码。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">runWorker</span><span class=\"token punctuation\">(</span>Worker w<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   Thread wt <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   Runnable task <span class=\"token operator\">=</span> w<span class=\"token punctuation\">.</span>firstTask<span class=\"token punctuation\">;</span>\n   w<span class=\"token punctuation\">.</span>firstTask <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n   w<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// allow interrupts</span>\n   <span class=\"token keyword\">boolean</span> completedAbruptly <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>task <span class=\"token operator\">!=</span> null <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>task <span class=\"token operator\">=</span> <span class=\"token function\">getTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token comment\" spellcheck=\"true\">//省略很多代码</span>\n       <span class=\"token punctuation\">}</span>\n       completedAbruptly <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token comment\" spellcheck=\"true\">//getTask()从队列中获取任务超时了，就关闭额外的Worker</span>\n       <span class=\"token function\">processWorkerExit</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">,</span> completedAbruptly<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">private</span> Runnable <span class=\"token function\">getTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> timedOut <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//省略很多代码...</span>\n        <span class=\"token keyword\">boolean</span> timed <span class=\"token operator\">=</span> allowCoreThreadTimeOut <span class=\"token operator\">||</span> wc <span class=\"token operator\">></span> corePoolSize<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//省略很多代码...</span>\n\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果从队列中获取任务超时，也就是说队列中任务已经被消化完了，</span>\n            <span class=\"token comment\" spellcheck=\"true\">//那么就会抛出InterruptedException异常</span>\n            <span class=\"token comment\" spellcheck=\"true\">//所以runWorker会处理异常，执行processWorkerExit将额外的Worker关闭</span>\n            Runnable r <span class=\"token operator\">=</span> timed <span class=\"token operator\">?</span>\n                workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span>keepAliveTime<span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>NANOSECONDS<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>\n                workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> r<span class=\"token punctuation\">;</span>\n            timedOut <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> retry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            timedOut <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"getTask-方法\"><a href=\"#getTask-方法\" class=\"headerlink\" title=\"getTask()方法\"></a>getTask()方法</h4><p>getTask方法表示从队列中获取任务。正常情况下如果是核心线程数内的Worker获取时，如果有则返回，如果队列中没有任务会阻塞。</p>\n<p>如果这个方法不阻塞而是返回null，有如下几种可能</p>\n<ul>\n<li>线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</li>\n<li>线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</li>\n<li>大于核心线程数时额外创建出来的Worker，如果这个Worker空闲超过了keepAliveTime则会返回null</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> Runnable <span class=\"token function\">getTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> timedOut <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> ctl<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> rs <span class=\"token operator\">=</span> <span class=\"token function\">runStateOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//1. rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()</span>\n        <span class=\"token comment\" spellcheck=\"true\">//2. rs >= STOP</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">>=</span> SHUTDOWN <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>rs <span class=\"token operator\">>=</span> STOP <span class=\"token operator\">||</span> workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n             <span class=\"token comment\" spellcheck=\"true\">// CAS 操作，减少工作线程数</span>\n            <span class=\"token function\">decrementWorkerCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//获取当天工作的worker数</span>\n        <span class=\"token keyword\">int</span> wc <span class=\"token operator\">=</span> <span class=\"token function\">workerCountOf</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span>\n        <span class=\"token keyword\">boolean</span> timed <span class=\"token operator\">=</span> allowCoreThreadTimeOut <span class=\"token operator\">||</span> wc <span class=\"token operator\">></span> corePoolSize<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>wc <span class=\"token operator\">></span> maximumPoolSize <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>timed <span class=\"token operator\">&amp;&amp;</span> timedOut<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>wc <span class=\"token operator\">></span> <span class=\"token number\">1</span> <span class=\"token operator\">||</span> workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndDecrementWorkerCount</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            Runnable r <span class=\"token operator\">=</span> timed <span class=\"token operator\">?</span>\n                workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">poll</span><span class=\"token punctuation\">(</span>keepAliveTime<span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>NANOSECONDS<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>\n                workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> r<span class=\"token punctuation\">;</span>\n            timedOut <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> retry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            timedOut <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"优雅关闭线程池\"><a href=\"#优雅关闭线程池\" class=\"headerlink\" title=\"优雅关闭线程池\"></a>优雅关闭线程池</h2><h3 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h3><p>会等正在执行的任务和队列中的任务完成后再关闭。</p>\n<ol>\n<li>shutDown会首先将线程设置成<code>SHUTDOWN</code>状态。</li>\n<li>执行的线程和已经在队列中的线程并不会被中断，继续执行。</li>\n<li>中断没有执行的Worker。</li>\n<li>shutdown()方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</li>\n</ol>\n<h3 id=\"shutdownNow\"><a href=\"#shutdownNow\" class=\"headerlink\" title=\"shutdownNow\"></a>shutdownNow</h3><p>马上关闭，强制关闭正在执行的任务和队列中的任务。</p>\n<h2 id=\"常见疑问\"><a href=\"#常见疑问\" class=\"headerlink\" title=\"常见疑问\"></a>常见疑问</h2><p><strong>为什么execute方法会抛异常，submit不会</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\">executors<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"xxx\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//抛出异常</span>\nException in thread <span class=\"token string\">\"pool-1-thread-1\"</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>RuntimeException<span class=\"token operator\">:</span> xxx\n    at xzy<span class=\"token punctuation\">.</span>OtherTest$<span class=\"token number\">1</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>OtherTest<span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">33</span><span class=\"token punctuation\">)</span>\n    at java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>ThreadPoolExecutor<span class=\"token punctuation\">.</span><span class=\"token function\">runWorker</span><span class=\"token punctuation\">(</span>ThreadPoolExecutor<span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">1149</span><span class=\"token punctuation\">)</span>\n    at java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>ThreadPoolExecutor$Worker<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>ThreadPoolExecutor<span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">624</span><span class=\"token punctuation\">)</span>\n    at java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span>java<span class=\"token operator\">:</span><span class=\"token number\">748</span><span class=\"token punctuation\">)</span>\n\nexecutors<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"xxx\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//不抛出异常</span></code></pre>\n<p>我们定位到<strong>runWorker</strong>源码中，可以看到<strong>task.run()</strong>做了异常处理。</p>\n<ul>\n<li>如果是execute方法，task=Runnable接口，调用run方法出现错误抛出异常可以被捕获</li>\n<li>如果是submit方法，Runnable会被封装成FutureTask，所以task=FutureTask。FutureTask重写了run方法，如果遇到异常会记录起来在get()方法调用时候才抛出。</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n       task<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">RuntimeException</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       thrown <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token keyword\">throw</span> x<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Error</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       thrown <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token keyword\">throw</span> x<span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> x<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token comment\" spellcheck=\"true\">// 这里不允许抛出 Throwable，所以转换为 Error</span>\n       thrown <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token comment\" spellcheck=\"true\">// 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现</span>\n       <span class=\"token function\">afterExecute</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">,</span> thrown<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/60524908\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/60524908</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"为什么要使用线程池\"><a href=\"#为什么要使用线程池\" class=\"headerlink\" title=\"为什么要使用线程池?\"></a>为什么要使用线程池?</h2><p>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。使用多线程技术完成一个任务所需的时间包括。</p>\n<ul>\n<li>T1 创建线程时间</li>\n<li>T2 执行线程任务的时间</li>\n<li>T3 销毁线程的时间</li>\n</ul>\n<p>如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。不单单如此，合理的线程池帮我们管理系统线程资源防止由于线程太多导致的系统崩溃问题等。<br>所以,<strong>线程池有如下作用</strong>:</p>\n<ul>\n<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>\n<li>可根据系统的承受能力调整线程池中工作线线程的数目防止因为消耗过多的内存而把服务器累趴下</li>\n</ul>\n<p>此外，参考美团上的一段关于线程多的弊端：</p>\n<ul>\n<li>线程的创建和销毁成本很高，在Linux这样的操作系统中，线程本质上就是一个进程。创建和销毁都是重量级的系统函数，需要调用系统内核的API，然后操作系统为其分配一系列资源，整个正本很高。</li>\n<li>线程本身占用较大内存，像Java的线程栈，一般至少分配512K～1M的空间，如果系统中的线程数过千，恐怕整个JVM的内存都会被吃掉一半。</li>\n<li>线程的切换成本是很高的。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。<strong>如果线程数过高，可能执行线程切换的时间甚至会大于线程执行的时间，这时候带来的表现往往是系统load偏高、CPU sy使用率特别高（超过20%以上)，导致系统几乎陷入不可用的状态。</strong></li>\n<li>容易造成锯齿状的系统负载。因为系统负载是用活动线程数或CPU核心数，一旦线程数量高但外部网络环境不是很稳定，就很容易造成大量请求的结果同时返回，激活大量阻塞线程从而使系统负载压力过大。</li></ul>","more":"<h2 id=\"线程池详解\"><a href=\"#线程池详解\" class=\"headerlink\" title=\"线程池详解\"></a>线程池详解</h2>\n\n<h3 id=\"继承体系\"><a href=\"#继承体系\" class=\"headerlink\" title=\"继承体系\"></a>继承体系</h3><p><img src=\"/2018/01/18/executorservice/1.png\" alt><br>Executor为线程池的顶级接口，声明了<font color=\"#FF0000\">execute</font>方法。<br>Executors为创建线程池的工具类，提供了多种方式的线程池创建方法。</p>\n<h3 id=\"核心参数\"><a href=\"#核心参数\" class=\"headerlink\" title=\"核心参数\"></a>核心参数</h3><pre><code class=\"java\">public ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler)</code></pre>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>corePoolSize</td>\n<td>核心线程数。当线程数小于该值时，线程池会优先创建新线程来执行新任务</td>\n</tr>\n<tr>\n<td>maximumPoolSize</td>\n<td>线程池所能维护的最大线程数</td>\n</tr>\n<tr>\n<td>keepAliveTime</td>\n<td>空闲线程的存活时间</td>\n</tr>\n<tr>\n<td>workQueue</td>\n<td>任务队列，用于缓存未执行的任务</td>\n</tr>\n<tr>\n<td>threadFactory</td>\n<td>线程工厂。可通过工厂为新建的线程设置更有意义的名字</td>\n</tr>\n<tr>\n<td>handler</td>\n<td>拒绝策略。当线程池和任务队列均处于饱和状态时，使用拒绝策略处理新任务。默认是 AbortPolicy，即直接抛出异常</td>\n</tr>\n</tbody></table>\n<h3 id=\"线程池执行逻辑\"><a href=\"#线程池执行逻辑\" class=\"headerlink\" title=\"线程池执行逻辑\"></a>线程池执行逻辑</h3><p><img src=\"/2018/01/18/executorservice/2.png\" alt><br>假设目前定义了一个线程池<br>corePoolSize = 2<br>keepAliveTime = 10ms<br>maximumPoolSize = 3<br>workQueue = ArrayBlockingQueue(长度为3)</p>\n<p>执行步骤如下:</p>\n<ol>\n<li>首先进来一个任务A,在线程池没有任务在执行,正在运行线程 &lt;  核心线程数,建一个线程执行任务</li>\n<li>又来一个任务B,此时正在运行的线程数为1.正在运行线程 &lt;  核心线程数,则继续创建一个线程执行任务</li>\n<li>又来一个任务C,此时正在运行线程 &gt; 核心线程数,将任务放到workQueue等待执行。</li>\n<li>此时又来了任务DEF…..,由于队列只允许存3个,DE进入到队列等待</li>\n<li>此时F没有进入队列, 正在运行线程 &lt; 最大线程数,则任务F允许创建一个线程执行。</li>\n<li>此时任务G到来，由于AB任务还没结束，workQueue存放了CDE任务等待执行,此时正在运行线程 =最大线程数,则G被拒绝，执行对应的拒绝策略。</li>\n<li>此时任务A执行完毕,任务C则从workQueue取出,沿用刚开始创建的线程执行任务。</li>\n</ol>\n<p><strong>keepAliveTime</strong> : 由于任务F是额外创建的一个线程去执行，线程池在空闲时只能保持 核心线程数个线程，所以当任务F执行完后，在keepAliveTime时间内如果没有新的任务进来导致正在运行线程 &gt; 核心线程数 &amp; workQueue已满 这两个条件，则对应的线程会被销毁。</p>\n<p>线程创建规则如下:</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>条件</th>\n<th>动作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>线程数 &lt; corePoolSize</td>\n<td>创建新线程</td>\n</tr>\n<tr>\n<td>2</td>\n<td>线程数 ≥ corePoolSize，且 workQueue 未满</td>\n<td>缓存新任务</td>\n</tr>\n<tr>\n<td>3</td>\n<td>corePoolSize ≤ 线程数 ＜ maximumPoolSize，且 workQueue 已满</td>\n<td>创建新线程</td>\n</tr>\n<tr>\n<td>4</td>\n<td>线程数 ≥ maximumPoolSize，且 workQueue 已满</td>\n<td>使用拒绝策略处理</td>\n</tr>\n</tbody></table>\n<p>从线程池执行逻辑总结 :</p>\n<ul>\n<li>任务进来时首先先在核心线程中执行，如果核心线程满则放到队列中，如果队列满且还没到最大线程数则可以额外创建线程执行(这个额外的线程是会被回收的)</li>\n<li>核心线程不会被回收，额外的线程会被回收，如果设置了allowCoreThreadTimeOut为true，则核心线程数也可以被回收，但一般不这样做</li>\n<li>如果workQueue是无界队列，则keepAliveTime将不起作用</li>\n</ul>\n<h3 id=\"排队策略\"><a href=\"#排队策略\" class=\"headerlink\" title=\"排队策略\"></a>排队策略</h3><p>当线程数 ≥ corePoolSize时，任务会存到队列中排队，有3中类型的容器可供使用，分别是同步队列，有界队列和无界队列。对于有优先级的任务，这里还可以增加优先级队列。</p>\n<table>\n<thead>\n<tr>\n<th>实现类</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SynchronousQueue</td>\n<td>同步队列</td>\n<td>该队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞</td>\n</tr>\n<tr>\n<td>ArrayBlockingQueue</td>\n<td>有界队列</td>\n<td>基于数组的阻塞队列，按照 FIFO 原则对元素进行排序</td>\n</tr>\n<tr>\n<td>LinkedBlockingQueue</td>\n<td>无界队列</td>\n<td>基于链表的阻塞队列，按照 FIFO 原则对元素进行排序</td>\n</tr>\n<tr>\n<td>PriorityBlockingQueue</td>\n<td>优先级队列</td>\n<td>具有优先级的阻塞队列</td>\n</tr>\n</tbody></table>\n<h3 id=\"拒绝策略\"><a href=\"#拒绝策略\" class=\"headerlink\" title=\"拒绝策略\"></a>拒绝策略</h3><p>线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务。Java 线程池提供了4中拒绝策略实现类</p>\n<table>\n<thead>\n<tr>\n<th>实现类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AbortPolicy</td>\n<td>丢弃新任务，并抛出 RejectedExecutionException</td>\n</tr>\n<tr>\n<td>DiscardPolicy</td>\n<td>不做任何操作，直接丢弃新任务</td>\n</tr>\n<tr>\n<td>DiscardOldestPolicy</td>\n<td>丢弃队列队首的元素，并执行新任务</td>\n</tr>\n<tr>\n<td>CallerRunsPolicy</td>\n<td>由调用线程执行新任务</td>\n</tr>\n</tbody></table>\n<pre><code class=\"java\">//使用拒绝策略\nThreadPoolExecutor executor = new ThreadPoolExecutor(1 , 1 , 1L , TimeUnit.MINUTES,new ArrayBlockingQueue&lt;&gt;(1),\nnew ThreadPoolExecutor.AbortPolicy());\n//自定义拒绝策略\nThreadPoolExecutor executor2 = new ThreadPoolExecutor(1 , 1 , 1L , TimeUnit.MINUTES , new ArrayBlockingQueue&lt;&gt;(1),\n        new RejectedExecutionHandler(){\n            @Override\n            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n                 //doSomeing   \n            }\n });</code></pre>\n<h2 id=\"几种线程池\"><a href=\"#几种线程池\" class=\"headerlink\" title=\"几种线程池\"></a>几种线程池</h2><p>Executors为创建线程池的工具类，提供了多种方式的线程池创建方法。</p>\n<h3 id=\"newFixedThreadPool\"><a href=\"#newFixedThreadPool\" class=\"headerlink\" title=\"newFixedThreadPool\"></a>newFixedThreadPool</h3><p>构建包含固定线程数的线程池，默认情况下，空闲线程不会被回收。<br>从参数可以看出核心线程数 = 最大线程数 / 采用无界队列。</p>\n<pre><code>    public static ExecutorService newFixedThreadPool(int nThreads) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue&lt;Runnable&gt;());\n    }</code></pre><p><strong>特点与隐患</strong><br>这种方式采用的是无界队列，如果任务执行时间长且任务量多将会出现任务堆积在队列中导致系统内存飙升，内存溢出等问题</p>\n<h3 id=\"newCachedThreadPool\"><a href=\"#newCachedThreadPool\" class=\"headerlink\" title=\"newCachedThreadPool\"></a>newCachedThreadPool</h3><p>构建线程数不定的线程池，线程数量随任务量变动，空闲线程存活时间超过60秒后会被回收。<br><strong>SynchronousQueue</strong>特点是队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞。</p>\n<pre><code>    public static ExecutorService newCachedThreadPool() {\n        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                      60L, TimeUnit.SECONDS,\n                                      new SynchronousQueue&lt;Runnable&gt;());\n    }</code></pre><p><strong>特点与隐患</strong><br>队列相当于不排队，每次来一个任务就创建一个线程执行。当对应的任务执行完以后对应的线程如果在60秒内没有没有其他任务继续复用则会销毁。<br><strong>推荐使用这种线程池</strong>。能够自动在并发量不多的时候自动销毁执行完的线程。但是最大线程数为无穷大,没有控制线程数也容易造成当并发量特别高时不加以控制导致线程数飙升</p>\n<h3 id=\"newSingleThreadExecutor\"><a href=\"#newSingleThreadExecutor\" class=\"headerlink\" title=\"newSingleThreadExecutor\"></a>newSingleThreadExecutor</h3><p>构建线程数为1的线程池，等价于 newFixedThreadPool(1) 所构造出的线程池</p>\n<pre><code>    public static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue&lt;Runnable&gt;()));\n    }\n</code></pre><p><strong>特点与隐患</strong><br>一次只能一个线程在运行，只会创建一个线程进行复用，采用无界队列容易造成内存飙升</p>\n<h3 id=\"newScheduledThreadPool\"><a href=\"#newScheduledThreadPool\" class=\"headerlink\" title=\"newScheduledThreadPool\"></a>newScheduledThreadPool</h3><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>\n<pre><code>    public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) {\n        return new ScheduledThreadPoolExecutor(corePoolSize);\n    }\n   public ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n              new DelayedWorkQueue());\n    }\n\n</code></pre><h2 id=\"ThreadPoolExecutor源码分析\"><a href=\"#ThreadPoolExecutor源码分析\" class=\"headerlink\" title=\"ThreadPoolExecutor源码分析\"></a>ThreadPoolExecutor源码分析</h2><h3 id=\"executre和submit方法\"><a href=\"#executre和submit方法\" class=\"headerlink\" title=\"executre和submit方法\"></a>executre和submit方法</h3><p>首先先来看下两个方法如何使用。线程池支持无返回值的execute方法，和有返回值的submit方法。有返回值的其实是将task封装成一个FutureTask。关于FutureTask可以看另外篇博客《<a href=\"http://xuzyblog.top/2020/07/30/fork-join/\" target=\"_blank\" rel=\"noopener\">Fork/join框架你会用吗？</a>》。</p>\n<pre><code class=\"java\">@Test\npublic void testError() throws InterruptedException, ExecutionException {\n    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 20, 60L, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;());\n    threadPoolExecutor.execute(() -&gt; {\n        System.out.println(&quot;线程池源码解析-execute&quot;);\n    });\n    Future future = threadPoolExecutor.submit(() -&gt; {\n        System.out.println(&quot;线程池源码解析-submit&quot;);\n    });\n    future.get();\n}</code></pre>\n<pre><code class=\"java\">java.util.concurrent.AbstractExecutorService\n\nprotected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {\n    return new FutureTask&lt;T&gt;(callable);\n}\n\nprotected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {\n        return new FutureTask&lt;T&gt;(runnable, value);\n}\n\n//传入Runable 返回Future\npublic Future&lt;?&gt; submit(Runnable task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);\n    //最终都是调用到了execute方法执行逻辑\n    execute(ftask);\n    return ftask;\n}\n\n//传入Callable 返回Future\npublic &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);\n    execute(ftask);\n    return ftask;\n}</code></pre>\n<p>这里需要先明白一个易错点，execute(Runnable task) 和 submit(Runnable task) 中的task应该理解成任务，而不是线程。整个线程池的逻辑大概可以这样概括 ： <font color=\"red\">当execture提交一个task后，会新建一个Worker对象，并将任务放到里面，这个Worker里面有一个Thred变量就是真正线程池用来执行任务的线程。当一个task执行完以后，这个Worker会继续从队列中获取任务继续执行。</font></p>\n<p><img src=\"/2018/01/18/executorservice/3.png\" alt></p>\n<h3 id=\"重要属性分析\"><a href=\"#重要属性分析\" class=\"headerlink\" title=\"重要属性分析\"></a>重要属性分析</h3><p>采用一个 32 位的整数来存放线程池的状态和当前池中的线程数。</p>\n<ul>\n<li>高 3 位用于存放线程池状态</li>\n<li>低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）</li>\n</ul>\n<pre><code class=\"java\">//ThreadPoolExecutor中的控制状态\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\n//线程池中当前活动的线程数量允许的最大值\n//运算方法就是1左移29位再减1 00000000 00000000 00000000 00000001 --&gt; 001 0000 00000000 00000000 00000000 - 1 = 536870911\nprivate static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;\n\n//===我们说过高三位代表的是线程池的状态，所以下面就是线程池的几种状态\n//RUNNING - 正常的状态：接受新的任务，处理等待队列中的任务\n//SHUTDOWN - 不接受新的任务提交，但是会继续处理等待队列中的任务\n//STOP - 不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程\n//TIDYING - 所有的任务都销毁了，workCount为0，线程过渡到TIDYING状态，将会执行terminated()钩子方法\n//TERMINATED - terminated()方法已经完成\nprivate static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;\nprivate static final int STOP       =  1 &lt;&lt; COUNT_BITS;\nprivate static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;\nprivate static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;\n//用来存放task的阻塞队列\nprivate final BlockingQueue&lt;Runnable&gt; workQueue;\n//线程池中所有工作线程worker的集合\nprivate final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();\n//创建线程的工厂，值得是Worker中变量Thread t的创建工厂\nprivate volatile ThreadFactory threadFactory;\n//拒绝策略\nprivate volatile RejectedExecutionHandler handler;\n//空闲线程存活时间\nprivate volatile long keepAliveTime;\n//核心线程数\nprivate volatile int corePoolSize;\n//最大线程数\nprivate volatile int maximumPoolSize;</code></pre>\n<p><img src=\"/2018/01/18/executorservice/4.png\" alt=\"线程池状态转换\"></p>\n<h3 id=\"Worker内部类\"><a href=\"#Worker内部类\" class=\"headerlink\" title=\"Worker内部类\"></a>Worker内部类</h3><p>Worker是线程池中真正用来执行任务的类。继承了AQS，实现了Runable接口。这里继承AQS，主要是为了独占锁，如果是加锁状态证明Worker正在执行，如果解锁状态证明空闲。</p>\n<p><strong>Worker为什么不直接使用ReentrantLock而是继承AQS ?</strong>  tryAcquire方法它是不允许重入的，而ReentrantLock是允许重入的。对于线程来说，如果线程正在执行是不允许其它锁重入进来的。</p>\n<p>我们可以理解Worker表示线程池中的<font color=\"red\">工人</font>，Runnable command表示工人要做的任务。一个工人对应的是一个线程，一个工人一次做一个任务。工人做完任务后再从队列中获取任务继续做。</p>\n<pre><code class=\"java\">private final class Worker extends AbstractQueuedSynchronizer implements Runnable{\n\n    private static final long serialVersionUID = 6138294804551838833L;\n    //真正用来执行任务的线程\n    final Thread thread;\n    //在new Worker时候传入的任务，这里交first值得是他是new Worker时候传入的那就是第一个。\n    //但是有时候这个是null,那代表没有传入，这时候就是从队列中取\n    Runnable firstTask;\n    //用于存放此线程完成的任务数，注意了，这里用了 volatile，保证可见性\n    volatile long completedTasks;\n\n\n    Worker(Runnable firstTask) {\n        setState(-1);\n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    public void run() {\n        runWorker(this);\n    }\n\n    protected boolean isHeldExclusively() {\n        return getState() != 0;\n    }\n\n    protected boolean tryAcquire(int unused) {\n        if (compareAndSetState(0, 1)) {\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryRelease(int unused) {\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); }\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); }\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}</code></pre>\n<h3 id=\"核心源码分析\"><a href=\"#核心源码分析\" class=\"headerlink\" title=\"核心源码分析\"></a>核心源码分析</h3><p><img src=\"/2018/01/18/executorservice/1.jpg\" alt=\"线程池执行流程\"></p>\n<h4 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"execute方法\"></a>execute方法</h4><pre><code class=\"java\">public void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    //如果线程池中工作的Worker数量小于核心线程数\n    if (workerCountOf(c) &lt; corePoolSize) {\n        //直接new一个worker来执行任务，并把当前任务 command 作为这个线程的第一个任务(firstTask)\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n\n    //到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了\n\n    //判断当前线程池的状态是不是RUNNING状态，如果是则将任务放到队列中等待\n    //offer - 将给定的元素设置到队列中，如果设置成功返回true, 否则返回false\n    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {\n        int recheck = ctl.get();\n        //刚将任务放到队列后发现线程池不是运行的，那就删除把刚放到队列的任务删除并执行拒绝策略\n        if (! isRunning(recheck) &amp;&amp; remove(command)){\n             reject(command);   \n        }\n        //如果线程池还是 RUNNING 的，但是工作线程数为 0，那么开启新的线程，这种情况比较少见\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    //这个分支，表示前面入队失败了，那么以 maximumPoolSize 为界创建新的 worker\n    else if (!addWorker(command, false)){\n        reject(command); //失败就执行拒绝策略   \n    }\n}</code></pre>\n<h4 id=\"addWorker方法\"><a href=\"#addWorker方法\" class=\"headerlink\" title=\"addWorker方法\"></a>addWorker方法</h4><pre><code class=\"java\">//core = true 时代表使用核心线程数 corePoolSize 作为创建线程的界限\n//core = flase 时代表使用最大线程数 maximumPoolSize 作为创建线程的界限\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // 判断是否可以addWorker\n        if (rs &gt;= SHUTDOWN &amp;&amp;\n            ! (rs == SHUTDOWN &amp;&amp;\n               firstTask == null &amp;&amp;\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            //获取当前工作的worker数量\n            int wc = workerCountOf(c);\n            //如果大于允许的最大数或者大于核心线程数则返回false\n            if (wc &gt;= CAPACITY ||\n                wc &gt;= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            //如果运行线程数可以+1表示能成功new Worker,跳出循环\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get(); \n            if (runStateOf(c) != rs)\n                continue retry;\n        }\n    }\n\n    //用来判断worker 是否已经启动\n    boolean workerStarted = false;\n    //是否已将这个 worker 添加到 workers 这个 HashSet 中\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        //先建一个&quot;工人&quot;\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            //这里使用mainLock保证workers.add(w)\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n\n                int rs = runStateOf(ctl.get());\n               //小于SHUTTDOWN 那就是 RUNNING状态\n                //如果等于SHUTDOWN，不接受新的任务，但是会继续执行等待队列中的任务\n                if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) {\n                    if (t.isAlive()) throw new IllegalThreadStateException();\n                    //将这个&quot;工人&quot;存到workers中\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s &gt; largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                //这个&quot;工人&quot;开始工作，对应Worker-&gt;run方法-&gt;runWorker(this)方法\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        //如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n\n//启动&quot;工人&quot;失败就炒了这个&quot;工人&quot;\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        if (w != null)\n            workers.remove(w);\n        decrementWorkerCount();\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n</code></pre>\n<h4 id=\"runWorker方法\"><a href=\"#runWorker方法\" class=\"headerlink\" title=\"runWorker方法\"></a>runWorker方法</h4><pre><code class=\"java\">//此方法由worker线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    //第一个任务就直接运行，不用从队列中取\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            //判断各种不合适的状态然后中断\n            //(线程状态&gt;=STOP 或者 (线程中断且线程状态&gt;=STOP)) 且 当时线程没有中断\n            //其实主要保证2点 : 1.线程池没有停止 2.保证线程没有中断\n            if (\n                ( runStateAtLeast(ctl.get(), STOP) ||\n                  (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))\n                ) &amp;&amp;\n                !wt.isInterrupted()\n               )\n                wt.interrupt();\n            try {\n                //钩子\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    //真正的执行任务，这里task要嘛是Runnable要嘛是FutureTask。\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    //钩子\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                //置空 task，准备 getTask 获取下一个任务\n                task = null;\n                //完成数+1\n                w.completedTasks++;\n                //释放独占锁\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        //如果执行到这一步说明线程池状态不对了。\n        //getTask()是会阻塞的，所以即使队列中为空，除非是超过核心线程数\n        //的worker才会执行到这一步，不然会阻塞住\n        processWorkerExit(w, completedAbruptly);\n    }\n}</code></pre>\n<p>总结runWorker方法执行过程：</p>\n<ol>\n<li>while循环中，不断地通过getTask()方法从workerQueue中获取任务</li>\n<li>如果线程池正在停止，则中断线程。否则调用3.</li>\n<li>调用task.run()执行任务</li>\n<li>如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程<code>workers.remove(w)</code></li>\n</ol>\n<p><strong>keepAliveTime作用详解</strong></p>\n<p>我们知道当任务大于核心线程数+队列大小后，会额外new Worker来执行任务。随着队列中任务的消化，创建出来额外的Worker是需要被回收的。这个实现的过程是通过如下代码。</p>\n<pre><code class=\"java\">final void runWorker(Worker w) {\n   Thread wt = Thread.currentThread();\n   Runnable task = w.firstTask;\n   w.firstTask = null;\n   w.unlock(); // allow interrupts\n   boolean completedAbruptly = true;\n   try {\n       while (task != null || (task = getTask()) != null) {\n           //省略很多代码\n       }\n       completedAbruptly = false;\n   } finally {\n       //getTask()从队列中获取任务超时了，就关闭额外的Worker\n       processWorkerExit(w, completedAbruptly);\n   }\n\n\nprivate Runnable getTask() {\n    boolean timedOut = false; \n    for (;;) {\n\n        //省略很多代码...\n        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;\n\n        //省略很多代码...\n\n        try {\n            //如果从队列中获取任务超时，也就是说队列中任务已经被消化完了，\n            //那么就会抛出InterruptedException异常\n            //所以runWorker会处理异常，执行processWorkerExit将额外的Worker关闭\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}</code></pre>\n<h4 id=\"getTask-方法\"><a href=\"#getTask-方法\" class=\"headerlink\" title=\"getTask()方法\"></a>getTask()方法</h4><p>getTask方法表示从队列中获取任务。正常情况下如果是核心线程数内的Worker获取时，如果有则返回，如果队列中没有任务会阻塞。</p>\n<p>如果这个方法不阻塞而是返回null，有如下几种可能</p>\n<ul>\n<li>线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</li>\n<li>线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</li>\n<li>大于核心线程数时额外创建出来的Worker，如果这个Worker空闲超过了keepAliveTime则会返回null</li>\n</ul>\n<pre><code class=\"java\">private Runnable getTask() {\n    boolean timedOut = false;\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n        //1. rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()\n        //2. rs &gt;= STOP\n        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {\n             // CAS 操作，减少工作线程数\n            decrementWorkerCount();\n            return null;\n        }\n        //获取当天工作的worker数\n        int wc = workerCountOf(c);\n        //允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭\n        boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;\n\n        if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n        try {\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}</code></pre>\n<h2 id=\"优雅关闭线程池\"><a href=\"#优雅关闭线程池\" class=\"headerlink\" title=\"优雅关闭线程池\"></a>优雅关闭线程池</h2><h3 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h3><p>会等正在执行的任务和队列中的任务完成后再关闭。</p>\n<ol>\n<li>shutDown会首先将线程设置成<code>SHUTDOWN</code>状态。</li>\n<li>执行的线程和已经在队列中的线程并不会被中断，继续执行。</li>\n<li>中断没有执行的Worker。</li>\n<li>shutdown()方法后如果还有新的任务被提交，线程池则会根据拒绝策略直接拒绝后续新提交的任务。</li>\n</ol>\n<h3 id=\"shutdownNow\"><a href=\"#shutdownNow\" class=\"headerlink\" title=\"shutdownNow\"></a>shutdownNow</h3><p>马上关闭，强制关闭正在执行的任务和队列中的任务。</p>\n<h2 id=\"常见疑问\"><a href=\"#常见疑问\" class=\"headerlink\" title=\"常见疑问\"></a>常见疑问</h2><p><strong>为什么execute方法会抛异常，submit不会</strong></p>\n<pre><code class=\"java\">executors.execute(new Runnable() {\n    @Override\n    public void run() {\n        throw new RuntimeException(&quot;xxx&quot;);\n    }\n});\n//抛出异常\nException in thread &quot;pool-1-thread-1&quot; java.lang.RuntimeException: xxx\n    at xzy.OtherTest$1.run(OtherTest.java:33)\n    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\n    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\n    at java.lang.Thread.run(Thread.java:748)\n\nexecutors.submit(new Runnable() {\n    @Override\n    public void run() {\n        throw new RuntimeException(&quot;xxx&quot;);\n    }\n});\n//不抛出异常</code></pre>\n<p>我们定位到<strong>runWorker</strong>源码中，可以看到<strong>task.run()</strong>做了异常处理。</p>\n<ul>\n<li>如果是execute方法，task=Runnable接口，调用run方法出现错误抛出异常可以被捕获</li>\n<li>如果是submit方法，Runnable会被封装成FutureTask，所以task=FutureTask。FutureTask重写了run方法，如果遇到异常会记录起来在get()方法调用时候才抛出。</li>\n</ul>\n<pre><code class=\"java\">try {\n       task.run();\n   } catch (RuntimeException x) {\n       thrown = x; throw x;\n   } catch (Error x) {\n       thrown = x; throw x;\n   } catch (Throwable x) {\n       // 这里不允许抛出 Throwable，所以转换为 Error\n       thrown = x; throw new Error(x);\n   } finally {\n       // 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现\n       afterExecute(task, thrown);\n}</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/60524908\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/60524908</a></li>\n</ul>"},{"title":"CompletableFuture使用详解","description":"CompletableFuture使用详解","date":"2019-07-18T02:00:00.000Z","_content":"## CompletableFuture介绍\nCompletableFuture是JDK8新出来一种异步组合式编程。\nFuture接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：\n- 将多个异步计算的结果合并成一个\n- 等待Future集合中的所有任务都完成\n- Future完成事件（即，任务完成以后触发执行动作）\n<!--more-->\n## CompletableFuture使用\n### 场景一：普通异步使用\nCompletableFuture提供了4个方法用来执行异步调用。一组是有返回值的，一组是无返回值的\n```java\npublic static CompletableFuture<Void> runAsync(Runnable runnable)\npublic static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)\n```\n\n- runAsync 和 supplyAsync 的区别是有没有返回值\n- 没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。\n- 如何判断是自己传线程池还是用ForkJoinPool线程池呢？\n  - ThreadPool：多见于线程并发，阻塞时延比较长的，这种线程池比较常用，一般设置的线程个数根据业务性能要求会比较多\n  - ForkJoinPool：特点是少量线程完成大量任务，一般用于非阻塞的，能快速处理的业务，或阻塞时延比较少的\n\n```java\n@org.junit.Test\npublic void runOrsupply() throws ExecutionException, InterruptedException {\n    //无返回值\n    CompletableFuture<Void> voidCompletableFuture = CompletableFuture.runAsync(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"!!!\");\n        }\n    } , Executors.newCachedThreadPool());\n    voidCompletableFuture.get();\n   \n    //有返回值\n    CompletableFuture<String> stringCompletableFuture = CompletableFuture.supplyAsync(new Supplier<String>() {\n        @Override\n        public String get() {\n            return \"success\";\n        }\n    });\n    System.out.println(stringCompletableFuture.get());\n}\n```\n\n### 场景二：任务执行后回调方法\n\n当CompletableFuture任务完成时或抛出异常时执行特定的回调方法。\n\n- whenComplete 和 whenCompleteAsync 表示在任务完成时执行的方法\n- exceptionally表示任务异常时回调方法\n\n```java\npublic CompletableFuture<T> whenComplete(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)\npublic CompletableFuture<T> exceptionally(Function<Throwable,? extends T> fn)\n```\n\n```java\n@org.junit.Test\npublic void testWhenComplete2() throws ExecutionException, InterruptedException {\n    CompletableFuture<String> stringCompletableFuture = CompletableFuture.supplyAsync(new Supplier<String>() {\n        @Override\n        public String get() {\n            int i = 1 / 0; //发生异常\n            return \"xuzy\";\n        }\n    }).whenComplete(new BiConsumer<String, Throwable>() {\n        @Override\n        public void accept(String s, Throwable throwable) {\n            System.out.println(\"获取supplyAsync返回的值 = \" + s);\n        }\n    }).exceptionally(new Function<Throwable, String>() {\n        @Override\n        public String apply(Throwable throwable) {\n            //当supplyAsync失败时，捕获异常并返回值\n            return \"xuzy is fail\";\n        }\n    });\n    System.out.println(stringCompletableFuture.get());\n}\n```\n\n### 场景三：任务执行后对任务结果再进行处理\n\nhandle 是执行任务完成时对结果的处理。\n\n```java\npublic <U> CompletionStage<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);\npublic <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);\npublic <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn,Executor executor);\n```\n\n```java\n@org.junit.Test\npublic void testHandle() throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> future = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int i = 1 / 0; //发生异常\n            return new RandomUtils().nextInt(0, 10);\n        }\n    }).handle(new BiFunction<Integer, Throwable, Integer>() {\n        @Override\n        public Integer apply(Integer integer, Throwable throwable) {\n            int result = -1;\n            //获取到任务的结果，如果没异常则值*2后返回，如果有异常就打印异常并返回-1\n            if (throwable == null) {\n                result = integer * 2;\n            } else {\n                System.out.println(throwable.getMessage());\n            }\n            return result;\n        }\n    });\n    Integer result = future.get();\n    System.out.println(result);\n}\n```\n\n### 场景四 ： 一个线程依赖另一个线程的结果\n\n当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。<font color=red>如果线程A出现异常则不会再执行thenApply</font>。\n\n```java\n@org.junit.Test\npublic void testThenApply() throws ExecutionException, InterruptedException {\n    //任务A\n    CompletableFuture<Long> futureA = CompletableFuture.supplyAsync(new Supplier<Long>() {\n        @Override\n        public Long get() {\n            return RandomUtils.nextLong(0, 100);\n        }\n    });\n    //任务B\n    CompletableFuture<String> futureB = futureA.thenApply(new Function<Long, String>() {\n        @Override\n        public String apply(Long aLong) {\n            long result = aLong * 5;\n            return \"xuzy-\" + result;\n        }\n    });\n    System.out.println(futureB.get());\n}\n```\n\n场景三handle 和 场景四 thenApply区别：\n\n- handle 是在任务完成后再执行，还可以处理异常的任务\n- thenApply 只可以执行正常的任务，任务出现异常则不执行 thenApply 方法\n\n### 场景五：任务A执行完成后消费结果\n\n先来理解下什么是消费结果，看如下代码，原来futureA返回的是Integer类型，后执行后thenAccept后就只能是Void了。其实是将futureA的结果获取后消费了。\n\n```java\n@org.junit.Test\npublic void testThenAccept() throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> futureA = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            System.out.println(\"任务A执行\");\n            return new Random().nextInt(10);\n        }\n    });\n    CompletableFuture<Void> futureVoid = futureA.thenAccept(new Consumer<Integer>() {\n        @Override\n        public void accept(Integer integer) {\n            System.out.println(\"获取到任务A的结果 ：\" + integer + \" , 并消费\");\n        }\n    });\n    futureVoid.get();\n    \n    //类似thenAccept的方法thenRun，但是他不能传递任务的结果\n    futureA.thenRun(new Runnable() {\n            @Override\n            public void run() {\n\t\t\t\tSystem.out.println(\"无法获取返回值直接消费\");\n            }\n    });\n}\n```\n\n### 场景六：将任务AB合并成一个任务执行\n\nthenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。\n\nthenAcceptBoth 会把 两个 CompletionStage 的任务都执行完成后，然后消费。\n\nthenCombine 和 thenAcceptBoth 区别就在于一个是处理结果，一个是消费(没有返回值)\n\n```java\n@org.junit.Test\npublic void testThenCombine() throws ExecutionException, InterruptedException {\n    CompletableFuture<String> future1 = CompletableFuture.supplyAsync(new Supplier<String>() {\n        @Override\n        public String get() {\n            try {\n                TimeUnit.SECONDS.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"hello\";\n        }\n    });\n    CompletableFuture<String> future2 = CompletableFuture.supplyAsync(new Supplier<String>() {\n        @Override\n        public String get() {\n            try {\n                TimeUnit.SECONDS.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"world\";\n        }\n    });\n    CompletableFuture<String> result = future1.thenCombine(future2, new BiFunction<String, String, String>() {\n        @Override\n        public String apply(String s, String s2) {\n            return s + \" \" + s2;\n        }\n    });\n    long start = System.currentTimeMillis();\n    System.out.println(result.get());\n    System.out.println((System.currentTimeMillis() - start) + \" ms\");\n}\n```\n\n### 场景七：任务A任务B同时执行，看谁快用谁的结果\n\n两个CompletionStage，谁执行返回的结果快，我就用那个CompletionStage的结果进行下一步的消耗操作。\n\nacceptEither\n\n```java\npublic CompletionStage<Void> acceptEither(CompletionStage<? extends T> other,Consumer<? super T> action);\npublic CompletionStage<Void> acceptEitherAsync(CompletionStage<? extends T> other,Consumer<? super T> action);\npublic CompletionStage<Void> acceptEitherAsync(CompletionStage<? extends T> other,Consumer<? super T> action,Executor executor);\n```\n\n**runAfterEither**\n\n```java\npublic CompletionStage<Void> runAfterEither(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> other,Runnable action,Executor executor);\n```\n\nacceptEither 和 runAfterEither 的区别也是有没有返回值\n\n<font color=red>代码测试发现，谁快的话会取快的任务作为结果继续进行消耗操作，但是慢的那个任务还是会继续执行并没有被取消</font>\n\n```java\n@org.junit.Test\npublic void testJoinOr() {\n    CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"任务f1\");\n        return \"f1\";\n    });\n    CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"f2\";\n    });\n    //这里f1.applyToEither(f2  f1在前面还是f2在前面都无所谓\n    CompletableFuture<String> f3 = f1.applyToEither(f2, new Function<String, String>() {\n        @Override\n        public String apply(String s) {\n            return \"最终是哪个任务的值呢 ？ 值是 : \" + s  + \", 获取后可以继续对值做处理\";\n        }\n    });\n    long start = System.currentTimeMillis();\n    System.out.println(f3.join());\n    System.out.println(\"耗时:\" + (System.currentTimeMillis() - start) + \" ms\");\n    try {\n        //这里阻塞20秒发现f1的任务还会继续执行，只是在结果上先取了f2的数据\n        TimeUnit.SECONDS.sleep(20);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n```java\n@org.junit.Test\npublic void testrunAfterEither(){\n    CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"任务f1\");\n        return \"f1\";\n    });\n    CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"f2\";\n    });\n    CompletableFuture<Void> f3 = f1.runAfterEither(f2, new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"f3\");\n        }\n    });\n    long start = System.currentTimeMillis();\n    f3.join();\n    System.out.println(\"耗时:\" + (System.currentTimeMillis() - start) + \" ms\");\n    try {\n        //这里阻塞20秒发现f1的任务还会继续执行，只是在结果上先取了f2的数据\n        TimeUnit.SECONDS.sleep(20);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n### 场景八：两个任务都执行成功后在消费\n\n两个CompletionStage，都完成了计算才会执行下一步的操作（Runnable）\n\n```java\npublic CompletionStage<Void> runAfterBoth(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other,Runnable action,Executor executor);\n```\n\n```java\n@org.junit.Test\npublic void testrunAfterBoth(){\n    CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"f1\";\n    });\n    CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"f2\";\n    });\n    CompletableFuture<Void> f3 = f1.runAfterBoth(f2, new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"f1,f2都执行成功后执行\");\n        }\n    });\n    long start = System.currentTimeMillis();\n    f3.join();\n    System.out.println(\"耗时:\" + (System.currentTimeMillis() - start) + \" ms\");\n}\n```\n\n### 场景九：allOf等待多个任务执行完成\n\n```java\n@org.junit.Test\npublic void testAllOf() throws ExecutionException, InterruptedException {\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    List<CompletableFuture<String>> futureList = Lists.newArrayList();\n    List<String> uuidList = Lists.newArrayList();\n    for (int i = 0; i < 10; i++) {\n        futureList.add(CompletableFuture.supplyAsync(() -> {\n            synchronized (uuidList) {\n                for (int j = 0; j < 100; j++) {\n                    uuidList.add(UUID.randomUUID().toString());\n                }\n            }\n            System.out.println(\"threadID:\" + Thread.currentThread().getId() + \"执行完成\");\n            return null;\n        }, executorService));\n    }\n    CompletableFuture<Void> result = CompletableFuture.allOf(futureList.toArray(new CompletableFuture[futureList.size()]));\n    result.get();\n    System.out.println(uuidList.size());\n}\n```\n\n### 场景十：anyOf 多个任务只要一个任务执行完成\n\n跟acceptEither一样，支持支持多个。\n\n```java\n@org.junit.Test\npublic void testAnyOf() throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"f1 done\");\n            return 1;\n        }\n    });\n    CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            try {\n                TimeUnit.SECONDS.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"f2 done\");\n            return 2;\n        }\n    });\n    CompletableFuture<Integer> f3 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            try {\n                TimeUnit.SECONDS.sleep(15);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"f3 done\");\n            return 3;\n        }\n    });\n\n    CompletableFuture<Object> objectCompletableFuture = CompletableFuture.anyOf(f1, f2, f3);\n    long start = System.currentTimeMillis();\n    Object o = objectCompletableFuture.get();\n    System.out.println(\"result = \" + o + \" 消耗时间:\" + (System.currentTimeMillis() - start) + \" ms\");\n    TimeUnit.SECONDS.sleep(30);\n}\n```\n\n## 注意点\n\n### get()和join()的区别\n\n- join()和get()方法都是用来获取CompletableFuture异步之后的返回值\n- join()方法抛出的是uncheck异常（即未经检查的异常),不会强制开发者抛出\n- get()方法抛出的是经过检查的异常，ExecutionException, InterruptedException 需要用户手动处理（抛出或者 try catch）\n\n### 带Async和不带Async后缀的区别\n\n通常而言，名称中不带 Async 的方法和它的前一个任务一样，在同一个线程中运行。而名称以 Async 结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。\n\n### 带Executor executor和不带的方法如何抉择？\n\nCompletableFuture提供的方法都包括了带<font color=red>Executor executor</font>参数和不带的。那到底怎么选择呢？来看一下不带Executor的方法的底层。如果不传Executor的话，使用的是ForkJoinPool线程池，而ForkJoinPool线程池的大小取决与CPU核数。\n\n```java\nprivate static final Executor asyncPool = useCommonPool ?\n        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {\n        return asyncSupplyStage(asyncPool, supplier);\n    }\n```\n\n- 如果是CPU密集型任务，直接使用ForkJoinPool就可以了\n- 如果是IO密集型任务，ForkJoinPool无法达到最佳性能，使用自己传的线程池","source":"_posts/completable-future.md","raw":"---\ntitle: CompletableFuture使用详解\ntags:\n  - java并发\n  - java8\ncategories:  java\ndescription : CompletableFuture使用详解\ndate: 2019-07-18 10:00:00\n---\n## CompletableFuture介绍\nCompletableFuture是JDK8新出来一种异步组合式编程。\nFuture接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：\n- 将多个异步计算的结果合并成一个\n- 等待Future集合中的所有任务都完成\n- Future完成事件（即，任务完成以后触发执行动作）\n<!--more-->\n## CompletableFuture使用\n### 场景一：普通异步使用\nCompletableFuture提供了4个方法用来执行异步调用。一组是有返回值的，一组是无返回值的\n```java\npublic static CompletableFuture<Void> runAsync(Runnable runnable)\npublic static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)\n```\n\n- runAsync 和 supplyAsync 的区别是有没有返回值\n- 没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。\n- 如何判断是自己传线程池还是用ForkJoinPool线程池呢？\n  - ThreadPool：多见于线程并发，阻塞时延比较长的，这种线程池比较常用，一般设置的线程个数根据业务性能要求会比较多\n  - ForkJoinPool：特点是少量线程完成大量任务，一般用于非阻塞的，能快速处理的业务，或阻塞时延比较少的\n\n```java\n@org.junit.Test\npublic void runOrsupply() throws ExecutionException, InterruptedException {\n    //无返回值\n    CompletableFuture<Void> voidCompletableFuture = CompletableFuture.runAsync(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"!!!\");\n        }\n    } , Executors.newCachedThreadPool());\n    voidCompletableFuture.get();\n   \n    //有返回值\n    CompletableFuture<String> stringCompletableFuture = CompletableFuture.supplyAsync(new Supplier<String>() {\n        @Override\n        public String get() {\n            return \"success\";\n        }\n    });\n    System.out.println(stringCompletableFuture.get());\n}\n```\n\n### 场景二：任务执行后回调方法\n\n当CompletableFuture任务完成时或抛出异常时执行特定的回调方法。\n\n- whenComplete 和 whenCompleteAsync 表示在任务完成时执行的方法\n- exceptionally表示任务异常时回调方法\n\n```java\npublic CompletableFuture<T> whenComplete(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action)\npublic CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor)\npublic CompletableFuture<T> exceptionally(Function<Throwable,? extends T> fn)\n```\n\n```java\n@org.junit.Test\npublic void testWhenComplete2() throws ExecutionException, InterruptedException {\n    CompletableFuture<String> stringCompletableFuture = CompletableFuture.supplyAsync(new Supplier<String>() {\n        @Override\n        public String get() {\n            int i = 1 / 0; //发生异常\n            return \"xuzy\";\n        }\n    }).whenComplete(new BiConsumer<String, Throwable>() {\n        @Override\n        public void accept(String s, Throwable throwable) {\n            System.out.println(\"获取supplyAsync返回的值 = \" + s);\n        }\n    }).exceptionally(new Function<Throwable, String>() {\n        @Override\n        public String apply(Throwable throwable) {\n            //当supplyAsync失败时，捕获异常并返回值\n            return \"xuzy is fail\";\n        }\n    });\n    System.out.println(stringCompletableFuture.get());\n}\n```\n\n### 场景三：任务执行后对任务结果再进行处理\n\nhandle 是执行任务完成时对结果的处理。\n\n```java\npublic <U> CompletionStage<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);\npublic <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);\npublic <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn,Executor executor);\n```\n\n```java\n@org.junit.Test\npublic void testHandle() throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> future = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            int i = 1 / 0; //发生异常\n            return new RandomUtils().nextInt(0, 10);\n        }\n    }).handle(new BiFunction<Integer, Throwable, Integer>() {\n        @Override\n        public Integer apply(Integer integer, Throwable throwable) {\n            int result = -1;\n            //获取到任务的结果，如果没异常则值*2后返回，如果有异常就打印异常并返回-1\n            if (throwable == null) {\n                result = integer * 2;\n            } else {\n                System.out.println(throwable.getMessage());\n            }\n            return result;\n        }\n    });\n    Integer result = future.get();\n    System.out.println(result);\n}\n```\n\n### 场景四 ： 一个线程依赖另一个线程的结果\n\n当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。<font color=red>如果线程A出现异常则不会再执行thenApply</font>。\n\n```java\n@org.junit.Test\npublic void testThenApply() throws ExecutionException, InterruptedException {\n    //任务A\n    CompletableFuture<Long> futureA = CompletableFuture.supplyAsync(new Supplier<Long>() {\n        @Override\n        public Long get() {\n            return RandomUtils.nextLong(0, 100);\n        }\n    });\n    //任务B\n    CompletableFuture<String> futureB = futureA.thenApply(new Function<Long, String>() {\n        @Override\n        public String apply(Long aLong) {\n            long result = aLong * 5;\n            return \"xuzy-\" + result;\n        }\n    });\n    System.out.println(futureB.get());\n}\n```\n\n场景三handle 和 场景四 thenApply区别：\n\n- handle 是在任务完成后再执行，还可以处理异常的任务\n- thenApply 只可以执行正常的任务，任务出现异常则不执行 thenApply 方法\n\n### 场景五：任务A执行完成后消费结果\n\n先来理解下什么是消费结果，看如下代码，原来futureA返回的是Integer类型，后执行后thenAccept后就只能是Void了。其实是将futureA的结果获取后消费了。\n\n```java\n@org.junit.Test\npublic void testThenAccept() throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> futureA = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            System.out.println(\"任务A执行\");\n            return new Random().nextInt(10);\n        }\n    });\n    CompletableFuture<Void> futureVoid = futureA.thenAccept(new Consumer<Integer>() {\n        @Override\n        public void accept(Integer integer) {\n            System.out.println(\"获取到任务A的结果 ：\" + integer + \" , 并消费\");\n        }\n    });\n    futureVoid.get();\n    \n    //类似thenAccept的方法thenRun，但是他不能传递任务的结果\n    futureA.thenRun(new Runnable() {\n            @Override\n            public void run() {\n\t\t\t\tSystem.out.println(\"无法获取返回值直接消费\");\n            }\n    });\n}\n```\n\n### 场景六：将任务AB合并成一个任务执行\n\nthenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。\n\nthenAcceptBoth 会把 两个 CompletionStage 的任务都执行完成后，然后消费。\n\nthenCombine 和 thenAcceptBoth 区别就在于一个是处理结果，一个是消费(没有返回值)\n\n```java\n@org.junit.Test\npublic void testThenCombine() throws ExecutionException, InterruptedException {\n    CompletableFuture<String> future1 = CompletableFuture.supplyAsync(new Supplier<String>() {\n        @Override\n        public String get() {\n            try {\n                TimeUnit.SECONDS.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"hello\";\n        }\n    });\n    CompletableFuture<String> future2 = CompletableFuture.supplyAsync(new Supplier<String>() {\n        @Override\n        public String get() {\n            try {\n                TimeUnit.SECONDS.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"world\";\n        }\n    });\n    CompletableFuture<String> result = future1.thenCombine(future2, new BiFunction<String, String, String>() {\n        @Override\n        public String apply(String s, String s2) {\n            return s + \" \" + s2;\n        }\n    });\n    long start = System.currentTimeMillis();\n    System.out.println(result.get());\n    System.out.println((System.currentTimeMillis() - start) + \" ms\");\n}\n```\n\n### 场景七：任务A任务B同时执行，看谁快用谁的结果\n\n两个CompletionStage，谁执行返回的结果快，我就用那个CompletionStage的结果进行下一步的消耗操作。\n\nacceptEither\n\n```java\npublic CompletionStage<Void> acceptEither(CompletionStage<? extends T> other,Consumer<? super T> action);\npublic CompletionStage<Void> acceptEitherAsync(CompletionStage<? extends T> other,Consumer<? super T> action);\npublic CompletionStage<Void> acceptEitherAsync(CompletionStage<? extends T> other,Consumer<? super T> action,Executor executor);\n```\n\n**runAfterEither**\n\n```java\npublic CompletionStage<Void> runAfterEither(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterEitherAsync(CompletionStage<?> other,Runnable action,Executor executor);\n```\n\nacceptEither 和 runAfterEither 的区别也是有没有返回值\n\n<font color=red>代码测试发现，谁快的话会取快的任务作为结果继续进行消耗操作，但是慢的那个任务还是会继续执行并没有被取消</font>\n\n```java\n@org.junit.Test\npublic void testJoinOr() {\n    CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"任务f1\");\n        return \"f1\";\n    });\n    CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"f2\";\n    });\n    //这里f1.applyToEither(f2  f1在前面还是f2在前面都无所谓\n    CompletableFuture<String> f3 = f1.applyToEither(f2, new Function<String, String>() {\n        @Override\n        public String apply(String s) {\n            return \"最终是哪个任务的值呢 ？ 值是 : \" + s  + \", 获取后可以继续对值做处理\";\n        }\n    });\n    long start = System.currentTimeMillis();\n    System.out.println(f3.join());\n    System.out.println(\"耗时:\" + (System.currentTimeMillis() - start) + \" ms\");\n    try {\n        //这里阻塞20秒发现f1的任务还会继续执行，只是在结果上先取了f2的数据\n        TimeUnit.SECONDS.sleep(20);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n```java\n@org.junit.Test\npublic void testrunAfterEither(){\n    CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"任务f1\");\n        return \"f1\";\n    });\n    CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"f2\";\n    });\n    CompletableFuture<Void> f3 = f1.runAfterEither(f2, new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"f3\");\n        }\n    });\n    long start = System.currentTimeMillis();\n    f3.join();\n    System.out.println(\"耗时:\" + (System.currentTimeMillis() - start) + \" ms\");\n    try {\n        //这里阻塞20秒发现f1的任务还会继续执行，只是在结果上先取了f2的数据\n        TimeUnit.SECONDS.sleep(20);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n### 场景八：两个任务都执行成功后在消费\n\n两个CompletionStage，都完成了计算才会执行下一步的操作（Runnable）\n\n```java\npublic CompletionStage<Void> runAfterBoth(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other,Runnable action);\npublic CompletionStage<Void> runAfterBothAsync(CompletionStage<?> other,Runnable action,Executor executor);\n```\n\n```java\n@org.junit.Test\npublic void testrunAfterBoth(){\n    CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"f1\";\n    });\n    CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return \"f2\";\n    });\n    CompletableFuture<Void> f3 = f1.runAfterBoth(f2, new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(\"f1,f2都执行成功后执行\");\n        }\n    });\n    long start = System.currentTimeMillis();\n    f3.join();\n    System.out.println(\"耗时:\" + (System.currentTimeMillis() - start) + \" ms\");\n}\n```\n\n### 场景九：allOf等待多个任务执行完成\n\n```java\n@org.junit.Test\npublic void testAllOf() throws ExecutionException, InterruptedException {\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    List<CompletableFuture<String>> futureList = Lists.newArrayList();\n    List<String> uuidList = Lists.newArrayList();\n    for (int i = 0; i < 10; i++) {\n        futureList.add(CompletableFuture.supplyAsync(() -> {\n            synchronized (uuidList) {\n                for (int j = 0; j < 100; j++) {\n                    uuidList.add(UUID.randomUUID().toString());\n                }\n            }\n            System.out.println(\"threadID:\" + Thread.currentThread().getId() + \"执行完成\");\n            return null;\n        }, executorService));\n    }\n    CompletableFuture<Void> result = CompletableFuture.allOf(futureList.toArray(new CompletableFuture[futureList.size()]));\n    result.get();\n    System.out.println(uuidList.size());\n}\n```\n\n### 场景十：anyOf 多个任务只要一个任务执行完成\n\n跟acceptEither一样，支持支持多个。\n\n```java\n@org.junit.Test\npublic void testAnyOf() throws ExecutionException, InterruptedException {\n    CompletableFuture<Integer> f1 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"f1 done\");\n            return 1;\n        }\n    });\n    CompletableFuture<Integer> f2 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            try {\n                TimeUnit.SECONDS.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"f2 done\");\n            return 2;\n        }\n    });\n    CompletableFuture<Integer> f3 = CompletableFuture.supplyAsync(new Supplier<Integer>() {\n        @Override\n        public Integer get() {\n            try {\n                TimeUnit.SECONDS.sleep(15);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"f3 done\");\n            return 3;\n        }\n    });\n\n    CompletableFuture<Object> objectCompletableFuture = CompletableFuture.anyOf(f1, f2, f3);\n    long start = System.currentTimeMillis();\n    Object o = objectCompletableFuture.get();\n    System.out.println(\"result = \" + o + \" 消耗时间:\" + (System.currentTimeMillis() - start) + \" ms\");\n    TimeUnit.SECONDS.sleep(30);\n}\n```\n\n## 注意点\n\n### get()和join()的区别\n\n- join()和get()方法都是用来获取CompletableFuture异步之后的返回值\n- join()方法抛出的是uncheck异常（即未经检查的异常),不会强制开发者抛出\n- get()方法抛出的是经过检查的异常，ExecutionException, InterruptedException 需要用户手动处理（抛出或者 try catch）\n\n### 带Async和不带Async后缀的区别\n\n通常而言，名称中不带 Async 的方法和它的前一个任务一样，在同一个线程中运行。而名称以 Async 结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。\n\n### 带Executor executor和不带的方法如何抉择？\n\nCompletableFuture提供的方法都包括了带<font color=red>Executor executor</font>参数和不带的。那到底怎么选择呢？来看一下不带Executor的方法的底层。如果不传Executor的话，使用的是ForkJoinPool线程池，而ForkJoinPool线程池的大小取决与CPU核数。\n\n```java\nprivate static final Executor asyncPool = useCommonPool ?\n        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\npublic static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier) {\n        return asyncSupplyStage(asyncPool, supplier);\n    }\n```\n\n- 如果是CPU密集型任务，直接使用ForkJoinPool就可以了\n- 如果是IO密集型任务，ForkJoinPool无法达到最佳性能，使用自己传的线程池","slug":"completable-future","published":1,"updated":"2021-04-08T00:47:06.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhuc0005qwv2cft38t6r","content":"<h2 id=\"CompletableFuture介绍\"><a href=\"#CompletableFuture介绍\" class=\"headerlink\" title=\"CompletableFuture介绍\"></a>CompletableFuture介绍</h2><p>CompletableFuture是JDK8新出来一种异步组合式编程。<br>Future接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：</p>\n<ul>\n<li><p>将多个异步计算的结果合并成一个</p>\n</li>\n<li><p>等待Future集合中的所有任务都完成</p>\n</li>\n<li><p>Future完成事件（即，任务完成以后触发执行动作）</p>\n<a id=\"more\"></a>\n<h2 id=\"CompletableFuture使用\"><a href=\"#CompletableFuture使用\" class=\"headerlink\" title=\"CompletableFuture使用\"></a>CompletableFuture使用</h2><h3 id=\"场景一：普通异步使用\"><a href=\"#场景一：普通异步使用\" class=\"headerlink\" title=\"场景一：普通异步使用\"></a>场景一：普通异步使用</h3><p>CompletableFuture提供了4个方法用来执行异步调用。一组是有返回值的，一组是无返回值的</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> CompletableFuture<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">runAsync</span><span class=\"token punctuation\">(</span>Runnable runnable<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> CompletableFuture<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">runAsync</span><span class=\"token punctuation\">(</span>Runnable runnable<span class=\"token punctuation\">,</span> Executor executor<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> CompletableFuture<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> <span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span>Supplier<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> supplier<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> CompletableFuture<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> <span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span>Supplier<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> supplier<span class=\"token punctuation\">,</span> Executor executor<span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li><p>runAsync 和 supplyAsync 的区别是有没有返回值</p>\n</li>\n<li><p>没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。</p>\n</li>\n<li><p>如何判断是自己传线程池还是用ForkJoinPool线程池呢？</p>\n<ul>\n<li>ThreadPool：多见于线程并发，阻塞时延比较长的，这种线程池比较常用，一般设置的线程个数根据业务性能要求会比较多</li>\n<li>ForkJoinPool：特点是少量线程完成大量任务，一般用于非阻塞的，能快速处理的业务，或阻塞时延比较少的</li>\n</ul>\n</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">runOrsupply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//无返回值</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> voidCompletableFuture <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">runAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"!!!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">,</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    voidCompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//有返回值</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> stringCompletableFuture <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> String <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"success\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>stringCompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"场景二：任务执行后回调方法\"><a href=\"#场景二：任务执行后回调方法\" class=\"headerlink\" title=\"场景二：任务执行后回调方法\"></a>场景二：任务执行后回调方法</h3><p>当CompletableFuture任务完成时或抛出异常时执行特定的回调方法。</p>\n<ul>\n<li>whenComplete 和 whenCompleteAsync 表示在任务完成时执行的方法</li>\n<li>exceptionally表示任务异常时回调方法</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> CompletableFuture<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">whenComplete</span><span class=\"token punctuation\">(</span>BiConsumer<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token punctuation\">,</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Throwable<span class=\"token operator\">></span> action<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> CompletableFuture<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">whenCompleteAsync</span><span class=\"token punctuation\">(</span>BiConsumer<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token punctuation\">,</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Throwable<span class=\"token operator\">></span> action<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> CompletableFuture<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">whenCompleteAsync</span><span class=\"token punctuation\">(</span>BiConsumer<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token punctuation\">,</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> Throwable<span class=\"token operator\">></span> action<span class=\"token punctuation\">,</span> Executor executor<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> CompletableFuture<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">exceptionally</span><span class=\"token punctuation\">(</span>Function<span class=\"token operator\">&lt;</span>Throwable<span class=\"token punctuation\">,</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> fn<span class=\"token punctuation\">)</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testWhenComplete2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> stringCompletableFuture <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> String <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">/</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//发生异常</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"xuzy\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">whenComplete</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BiConsumer</span><span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Throwable<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">,</span> Throwable throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"获取supplyAsync返回的值 = \"</span> <span class=\"token operator\">+</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">exceptionally</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token operator\">&lt;</span>Throwable<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> String <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>Throwable throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//当supplyAsync失败时，捕获异常并返回值</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"xuzy is fail\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>stringCompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"场景三：任务执行后对任务结果再进行处理\"><a href=\"#场景三：任务执行后对任务结果再进行处理\" class=\"headerlink\" title=\"场景三：任务执行后对任务结果再进行处理\"></a>场景三：任务执行后对任务结果再进行处理</h3><p>handle 是执行任务完成时对结果的处理。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> CompletionStage<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> <span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>BiFunction<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token punctuation\">,</span> Throwable<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">U</span><span class=\"token operator\">></span> fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> CompletionStage<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> <span class=\"token function\">handleAsync</span><span class=\"token punctuation\">(</span>BiFunction<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token punctuation\">,</span> Throwable<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">U</span><span class=\"token operator\">></span> fn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> CompletionStage<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> <span class=\"token function\">handleAsync</span><span class=\"token punctuation\">(</span>BiFunction<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token punctuation\">,</span> Throwable<span class=\"token punctuation\">,</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">U</span><span class=\"token operator\">></span> fn<span class=\"token punctuation\">,</span>Executor executor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testHandle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> future <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Integer <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">/</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//发生异常</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RandomUtils</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">BiFunction</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token punctuation\">,</span> Throwable<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Integer <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>Integer integer<span class=\"token punctuation\">,</span> Throwable throwable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> result <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//获取到任务的结果，如果没异常则值*2后返回，如果有异常就打印异常并返回-1</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>throwable <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                result <span class=\"token operator\">=</span> integer <span class=\"token operator\">*</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>throwable<span class=\"token punctuation\">.</span><span class=\"token function\">getMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Integer result <span class=\"token operator\">=</span> future<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"场景四-：-一个线程依赖另一个线程的结果\"><a href=\"#场景四-：-一个线程依赖另一个线程的结果\" class=\"headerlink\" title=\"场景四 ： 一个线程依赖另一个线程的结果\"></a>场景四 ： 一个线程依赖另一个线程的结果</h3><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。<font color=\"red\">如果线程A出现异常则不会再执行thenApply</font>。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testThenApply</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//任务A</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Long<span class=\"token operator\">></span> futureA <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>Long<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Long <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> RandomUtils<span class=\"token punctuation\">.</span><span class=\"token function\">nextLong</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//任务B</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> futureB <span class=\"token operator\">=</span> futureA<span class=\"token punctuation\">.</span><span class=\"token function\">thenApply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token operator\">&lt;</span>Long<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> String <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>Long aLong<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">long</span> result <span class=\"token operator\">=</span> aLong <span class=\"token operator\">*</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"xuzy-\"</span> <span class=\"token operator\">+</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>futureB<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>场景三handle 和 场景四 thenApply区别：</p>\n<ul>\n<li>handle 是在任务完成后再执行，还可以处理异常的任务</li>\n<li>thenApply 只可以执行正常的任务，任务出现异常则不执行 thenApply 方法</li>\n</ul>\n<h3 id=\"场景五：任务A执行完成后消费结果\"><a href=\"#场景五：任务A执行完成后消费结果\" class=\"headerlink\" title=\"场景五：任务A执行完成后消费结果\"></a>场景五：任务A执行完成后消费结果</h3><p>先来理解下什么是消费结果，看如下代码，原来futureA返回的是Integer类型，后执行后thenAccept后就只能是Void了。其实是将futureA的结果获取后消费了。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testThenAccept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> futureA <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Integer <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"任务A执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> futureVoid <span class=\"token operator\">=</span> futureA<span class=\"token punctuation\">.</span><span class=\"token function\">thenAccept</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Consumer</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">accept</span><span class=\"token punctuation\">(</span>Integer integer<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"获取到任务A的结果 ：\"</span> <span class=\"token operator\">+</span> integer <span class=\"token operator\">+</span> <span class=\"token string\">\" , 并消费\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    futureVoid<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//类似thenAccept的方法thenRun，但是他不能传递任务的结果</span>\n    futureA<span class=\"token punctuation\">.</span><span class=\"token function\">thenRun</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"无法获取返回值直接消费\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"场景六：将任务AB合并成一个任务执行\"><a href=\"#场景六：将任务AB合并成一个任务执行\" class=\"headerlink\" title=\"场景六：将任务AB合并成一个任务执行\"></a>场景六：将任务AB合并成一个任务执行</h3><p>thenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。</p>\n<p>thenAcceptBoth 会把 两个 CompletionStage 的任务都执行完成后，然后消费。</p>\n<p>thenCombine 和 thenAcceptBoth 区别就在于一个是处理结果，一个是消费(没有返回值)</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testThenCombine</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> future1 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> String <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> future2 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> String <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"world\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> result <span class=\"token operator\">=</span> future1<span class=\"token punctuation\">.</span><span class=\"token function\">thenCombine</span><span class=\"token punctuation\">(</span>future2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BiFunction</span><span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> String <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">,</span> String s2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> s <span class=\"token operator\">+</span> <span class=\"token string\">\" \"</span> <span class=\"token operator\">+</span> s2<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"场景七：任务A任务B同时执行，看谁快用谁的结果\"><a href=\"#场景七：任务A任务B同时执行，看谁快用谁的结果\" class=\"headerlink\" title=\"场景七：任务A任务B同时执行，看谁快用谁的结果\"></a>场景七：任务A任务B同时执行，看谁快用谁的结果</h3><p>两个CompletionStage，谁执行返回的结果快，我就用那个CompletionStage的结果进行下一步的消耗操作。</p>\n<p>acceptEither</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> CompletionStage<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">acceptEither</span><span class=\"token punctuation\">(</span>CompletionStage<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">,</span>Consumer<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token operator\">></span> action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> CompletionStage<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">acceptEitherAsync</span><span class=\"token punctuation\">(</span>CompletionStage<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">,</span>Consumer<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token operator\">></span> action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> CompletionStage<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">acceptEitherAsync</span><span class=\"token punctuation\">(</span>CompletionStage<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">T</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">,</span>Consumer<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span> <span class=\"token keyword\">super</span> T<span class=\"token operator\">></span> action<span class=\"token punctuation\">,</span>Executor executor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><strong>runAfterEither</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> CompletionStage<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">runAfterEither</span><span class=\"token punctuation\">(</span>CompletionStage<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">,</span>Runnable action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> CompletionStage<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">runAfterEitherAsync</span><span class=\"token punctuation\">(</span>CompletionStage<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">,</span>Runnable action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> CompletionStage<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">runAfterEitherAsync</span><span class=\"token punctuation\">(</span>CompletionStage<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">,</span>Runnable action<span class=\"token punctuation\">,</span>Executor executor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>acceptEither 和 runAfterEither 的区别也是有没有返回值</p>\n<p><font color=\"red\">代码测试发现，谁快的话会取快的任务作为结果继续进行消耗操作，但是慢的那个任务还是会继续执行并没有被取消</font></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testJoinOr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> f1 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"任务f1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"f1\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> f2 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"f2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//这里f1.applyToEither(f2  f1在前面还是f2在前面都无所谓</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> f3 <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">.</span><span class=\"token function\">applyToEither</span><span class=\"token punctuation\">(</span>f2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Function</span><span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> String <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>String s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"最终是哪个任务的值呢 ？ 值是 : \"</span> <span class=\"token operator\">+</span> s  <span class=\"token operator\">+</span> <span class=\"token string\">\", 获取后可以继续对值做处理\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>f3<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"耗时:\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这里阻塞20秒发现f1的任务还会继续执行，只是在结果上先取了f2的数据</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testrunAfterEither</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> f1 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"任务f1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"f1\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> f2 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"f2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> f3 <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">.</span><span class=\"token function\">runAfterEither</span><span class=\"token punctuation\">(</span>f2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"f3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    f3<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"耗时:\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这里阻塞20秒发现f1的任务还会继续执行，只是在结果上先取了f2的数据</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"场景八：两个任务都执行成功后在消费\"><a href=\"#场景八：两个任务都执行成功后在消费\" class=\"headerlink\" title=\"场景八：两个任务都执行成功后在消费\"></a>场景八：两个任务都执行成功后在消费</h3><p>两个CompletionStage，都完成了计算才会执行下一步的操作（Runnable）</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> CompletionStage<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">runAfterBoth</span><span class=\"token punctuation\">(</span>CompletionStage<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">,</span>Runnable action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> CompletionStage<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">runAfterBothAsync</span><span class=\"token punctuation\">(</span>CompletionStage<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">,</span>Runnable action<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> CompletionStage<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> <span class=\"token function\">runAfterBothAsync</span><span class=\"token punctuation\">(</span>CompletionStage<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> other<span class=\"token punctuation\">,</span>Runnable action<span class=\"token punctuation\">,</span>Executor executor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testrunAfterBoth</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> f1 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"f1\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> f2 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"f2\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> f3 <span class=\"token operator\">=</span> f1<span class=\"token punctuation\">.</span><span class=\"token function\">runAfterBoth</span><span class=\"token punctuation\">(</span>f2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"f1,f2都执行成功后执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    f3<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"耗时:\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"场景九：allOf等待多个任务执行完成\"><a href=\"#场景九：allOf等待多个任务执行完成\" class=\"headerlink\" title=\"场景九：allOf等待多个任务执行完成\"></a>场景九：allOf等待多个任务执行完成</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testAllOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    ExecutorService executorService <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    List<span class=\"token operator\">&lt;</span>CompletableFuture<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">>></span> futureList <span class=\"token operator\">=</span> Lists<span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> uuidList <span class=\"token operator\">=</span> Lists<span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        futureList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>uuidList<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    uuidList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"threadID:\"</span> <span class=\"token operator\">+</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"执行完成\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> executorService<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> result <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">allOf</span><span class=\"token punctuation\">(</span>futureList<span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">CompletableFuture</span><span class=\"token punctuation\">[</span>futureList<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>uuidList<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"场景十：anyOf-多个任务只要一个任务执行完成\"><a href=\"#场景十：anyOf-多个任务只要一个任务执行完成\" class=\"headerlink\" title=\"场景十：anyOf 多个任务只要一个任务执行完成\"></a>场景十：anyOf 多个任务只要一个任务执行完成</h3><p>跟acceptEither一样，支持支持多个。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@org</span><span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testAnyOf</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> f1 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Integer <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"f1 done\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> f2 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Integer <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"f2 done\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    CompletableFuture<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> f3 <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Supplier</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> Integer <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"f3 done\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    CompletableFuture<span class=\"token operator\">&lt;</span>Object<span class=\"token operator\">></span> objectCompletableFuture <span class=\"token operator\">=</span> CompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">anyOf</span><span class=\"token punctuation\">(</span>f1<span class=\"token punctuation\">,</span> f2<span class=\"token punctuation\">,</span> f3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Object o <span class=\"token operator\">=</span> objectCompletableFuture<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"result = \"</span> <span class=\"token operator\">+</span> o <span class=\"token operator\">+</span> <span class=\"token string\">\" 消耗时间:\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><h3 id=\"get-和join-的区别\"><a href=\"#get-和join-的区别\" class=\"headerlink\" title=\"get()和join()的区别\"></a>get()和join()的区别</h3><ul>\n<li>join()和get()方法都是用来获取CompletableFuture异步之后的返回值</li>\n<li>join()方法抛出的是uncheck异常（即未经检查的异常),不会强制开发者抛出</li>\n<li>get()方法抛出的是经过检查的异常，ExecutionException, InterruptedException 需要用户手动处理（抛出或者 try catch）</li>\n</ul>\n<h3 id=\"带Async和不带Async后缀的区别\"><a href=\"#带Async和不带Async后缀的区别\" class=\"headerlink\" title=\"带Async和不带Async后缀的区别\"></a>带Async和不带Async后缀的区别</h3><p>通常而言，名称中不带 Async 的方法和它的前一个任务一样，在同一个线程中运行。而名称以 Async 结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。</p>\n<h3 id=\"带Executor-executor和不带的方法如何抉择？\"><a href=\"#带Executor-executor和不带的方法如何抉择？\" class=\"headerlink\" title=\"带Executor executor和不带的方法如何抉择？\"></a>带Executor executor和不带的方法如何抉择？</h3><p>CompletableFuture提供的方法都包括了带<font color=\"red\">Executor executor</font>参数和不带的。那到底怎么选择呢？来看一下不带Executor的方法的底层。如果不传Executor的话，使用的是ForkJoinPool线程池，而ForkJoinPool线程池的大小取决与CPU核数。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Executor asyncPool <span class=\"token operator\">=</span> useCommonPool <span class=\"token operator\">?</span>\n        ForkJoinPool<span class=\"token punctuation\">.</span><span class=\"token function\">commonPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPerTaskExecutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> CompletableFuture<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> <span class=\"token function\">supplyAsync</span><span class=\"token punctuation\">(</span>Supplier<span class=\"token operator\">&lt;</span>U<span class=\"token operator\">></span> supplier<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">asyncSupplyStage</span><span class=\"token punctuation\">(</span>asyncPool<span class=\"token punctuation\">,</span> supplier<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>如果是CPU密集型任务，直接使用ForkJoinPool就可以了</li>\n<li>如果是IO密集型任务，ForkJoinPool无法达到最佳性能，使用自己传的线程池</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"CompletableFuture介绍\"><a href=\"#CompletableFuture介绍\" class=\"headerlink\" title=\"CompletableFuture介绍\"></a>CompletableFuture介绍</h2><p>CompletableFuture是JDK8新出来一种异步组合式编程。<br>Future接口可以构建异步应用，但依然有其局限性。它很难直接表述多个Future 结果之间的依赖性。实际开发中，我们经常需要达成以下目的：</p>\n<ul>\n<li><p>将多个异步计算的结果合并成一个</p>\n</li>\n<li><p>等待Future集合中的所有任务都完成</p>\n</li>\n<li><p>Future完成事件（即，任务完成以后触发执行动作）</p></li></ul>","more":"<h2 id=\"CompletableFuture使用\"><a href=\"#CompletableFuture使用\" class=\"headerlink\" title=\"CompletableFuture使用\"></a>CompletableFuture使用</h2><h3 id=\"场景一：普通异步使用\"><a href=\"#场景一：普通异步使用\" class=\"headerlink\" title=\"场景一：普通异步使用\"></a>场景一：普通异步使用</h3><p>CompletableFuture提供了4个方法用来执行异步调用。一组是有返回值的，一组是无返回值的</p>\n<pre><code class=\"java\">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)\npublic static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)\npublic static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)\npublic static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor)</code></pre>\n\n<li><p>runAsync 和 supplyAsync 的区别是有没有返回值</p>\n</li>\n<li><p>没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。</p>\n</li>\n<li><p>如何判断是自己传线程池还是用ForkJoinPool线程池呢？</p>\n<ul>\n<li>ThreadPool：多见于线程并发，阻塞时延比较长的，这种线程池比较常用，一般设置的线程个数根据业务性能要求会比较多</li>\n<li>ForkJoinPool：特点是少量线程完成大量任务，一般用于非阻塞的，能快速处理的业务，或阻塞时延比较少的</li>\n</ul>\n</li>\n\n<pre><code class=\"java\">@org.junit.Test\npublic void runOrsupply() throws ExecutionException, InterruptedException {\n    //无返回值\n    CompletableFuture&lt;Void&gt; voidCompletableFuture = CompletableFuture.runAsync(new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(&quot;!!!&quot;);\n        }\n    } , Executors.newCachedThreadPool());\n    voidCompletableFuture.get();\n\n    //有返回值\n    CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(new Supplier&lt;String&gt;() {\n        @Override\n        public String get() {\n            return &quot;success&quot;;\n        }\n    });\n    System.out.println(stringCompletableFuture.get());\n}</code></pre>\n<h3 id=\"场景二：任务执行后回调方法\"><a href=\"#场景二：任务执行后回调方法\" class=\"headerlink\" title=\"场景二：任务执行后回调方法\"></a>场景二：任务执行后回调方法</h3><p>当CompletableFuture任务完成时或抛出异常时执行特定的回调方法。</p>\n<ul>\n<li>whenComplete 和 whenCompleteAsync 表示在任务完成时执行的方法</li>\n<li>exceptionally表示任务异常时回调方法</li>\n</ul>\n<pre><code class=\"java\">public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action)\npublic CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action)\npublic CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor)\npublic CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn)</code></pre>\n<pre><code class=\"java\">@org.junit.Test\npublic void testWhenComplete2() throws ExecutionException, InterruptedException {\n    CompletableFuture&lt;String&gt; stringCompletableFuture = CompletableFuture.supplyAsync(new Supplier&lt;String&gt;() {\n        @Override\n        public String get() {\n            int i = 1 / 0; //发生异常\n            return &quot;xuzy&quot;;\n        }\n    }).whenComplete(new BiConsumer&lt;String, Throwable&gt;() {\n        @Override\n        public void accept(String s, Throwable throwable) {\n            System.out.println(&quot;获取supplyAsync返回的值 = &quot; + s);\n        }\n    }).exceptionally(new Function&lt;Throwable, String&gt;() {\n        @Override\n        public String apply(Throwable throwable) {\n            //当supplyAsync失败时，捕获异常并返回值\n            return &quot;xuzy is fail&quot;;\n        }\n    });\n    System.out.println(stringCompletableFuture.get());\n}</code></pre>\n<h3 id=\"场景三：任务执行后对任务结果再进行处理\"><a href=\"#场景三：任务执行后对任务结果再进行处理\" class=\"headerlink\" title=\"场景三：任务执行后对任务结果再进行处理\"></a>场景三：任务执行后对任务结果再进行处理</h3><p>handle 是执行任务完成时对结果的处理。</p>\n<pre><code class=\"java\">public &lt;U&gt; CompletionStage&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);\npublic &lt;U&gt; CompletionStage&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);\npublic &lt;U&gt; CompletionStage&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn,Executor executor);</code></pre>\n<pre><code class=\"java\">@org.junit.Test\npublic void testHandle() throws ExecutionException, InterruptedException {\n    CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(new Supplier&lt;Integer&gt;() {\n        @Override\n        public Integer get() {\n            int i = 1 / 0; //发生异常\n            return new RandomUtils().nextInt(0, 10);\n        }\n    }).handle(new BiFunction&lt;Integer, Throwable, Integer&gt;() {\n        @Override\n        public Integer apply(Integer integer, Throwable throwable) {\n            int result = -1;\n            //获取到任务的结果，如果没异常则值*2后返回，如果有异常就打印异常并返回-1\n            if (throwable == null) {\n                result = integer * 2;\n            } else {\n                System.out.println(throwable.getMessage());\n            }\n            return result;\n        }\n    });\n    Integer result = future.get();\n    System.out.println(result);\n}</code></pre>\n<h3 id=\"场景四-：-一个线程依赖另一个线程的结果\"><a href=\"#场景四-：-一个线程依赖另一个线程的结果\" class=\"headerlink\" title=\"场景四 ： 一个线程依赖另一个线程的结果\"></a>场景四 ： 一个线程依赖另一个线程的结果</h3><p>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行化。<font color=\"red\">如果线程A出现异常则不会再执行thenApply</font>。</p>\n<pre><code class=\"java\">@org.junit.Test\npublic void testThenApply() throws ExecutionException, InterruptedException {\n    //任务A\n    CompletableFuture&lt;Long&gt; futureA = CompletableFuture.supplyAsync(new Supplier&lt;Long&gt;() {\n        @Override\n        public Long get() {\n            return RandomUtils.nextLong(0, 100);\n        }\n    });\n    //任务B\n    CompletableFuture&lt;String&gt; futureB = futureA.thenApply(new Function&lt;Long, String&gt;() {\n        @Override\n        public String apply(Long aLong) {\n            long result = aLong * 5;\n            return &quot;xuzy-&quot; + result;\n        }\n    });\n    System.out.println(futureB.get());\n}</code></pre>\n<p>场景三handle 和 场景四 thenApply区别：</p>\n<ul>\n<li>handle 是在任务完成后再执行，还可以处理异常的任务</li>\n<li>thenApply 只可以执行正常的任务，任务出现异常则不执行 thenApply 方法</li>\n</ul>\n<h3 id=\"场景五：任务A执行完成后消费结果\"><a href=\"#场景五：任务A执行完成后消费结果\" class=\"headerlink\" title=\"场景五：任务A执行完成后消费结果\"></a>场景五：任务A执行完成后消费结果</h3><p>先来理解下什么是消费结果，看如下代码，原来futureA返回的是Integer类型，后执行后thenAccept后就只能是Void了。其实是将futureA的结果获取后消费了。</p>\n<pre><code class=\"java\">@org.junit.Test\npublic void testThenAccept() throws ExecutionException, InterruptedException {\n    CompletableFuture&lt;Integer&gt; futureA = CompletableFuture.supplyAsync(new Supplier&lt;Integer&gt;() {\n        @Override\n        public Integer get() {\n            System.out.println(&quot;任务A执行&quot;);\n            return new Random().nextInt(10);\n        }\n    });\n    CompletableFuture&lt;Void&gt; futureVoid = futureA.thenAccept(new Consumer&lt;Integer&gt;() {\n        @Override\n        public void accept(Integer integer) {\n            System.out.println(&quot;获取到任务A的结果 ：&quot; + integer + &quot; , 并消费&quot;);\n        }\n    });\n    futureVoid.get();\n\n    //类似thenAccept的方法thenRun，但是他不能传递任务的结果\n    futureA.thenRun(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(&quot;无法获取返回值直接消费&quot;);\n            }\n    });\n}</code></pre>\n<h3 id=\"场景六：将任务AB合并成一个任务执行\"><a href=\"#场景六：将任务AB合并成一个任务执行\" class=\"headerlink\" title=\"场景六：将任务AB合并成一个任务执行\"></a>场景六：将任务AB合并成一个任务执行</h3><p>thenCombine 会把 两个 CompletionStage 的任务都执行完成后，把两个任务的结果一块交给 thenCombine 来处理。</p>\n<p>thenAcceptBoth 会把 两个 CompletionStage 的任务都执行完成后，然后消费。</p>\n<p>thenCombine 和 thenAcceptBoth 区别就在于一个是处理结果，一个是消费(没有返回值)</p>\n<pre><code class=\"java\">@org.junit.Test\npublic void testThenCombine() throws ExecutionException, InterruptedException {\n    CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(new Supplier&lt;String&gt;() {\n        @Override\n        public String get() {\n            try {\n                TimeUnit.SECONDS.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return &quot;hello&quot;;\n        }\n    });\n    CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(new Supplier&lt;String&gt;() {\n        @Override\n        public String get() {\n            try {\n                TimeUnit.SECONDS.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return &quot;world&quot;;\n        }\n    });\n    CompletableFuture&lt;String&gt; result = future1.thenCombine(future2, new BiFunction&lt;String, String, String&gt;() {\n        @Override\n        public String apply(String s, String s2) {\n            return s + &quot; &quot; + s2;\n        }\n    });\n    long start = System.currentTimeMillis();\n    System.out.println(result.get());\n    System.out.println((System.currentTimeMillis() - start) + &quot; ms&quot;);\n}</code></pre>\n<h3 id=\"场景七：任务A任务B同时执行，看谁快用谁的结果\"><a href=\"#场景七：任务A任务B同时执行，看谁快用谁的结果\" class=\"headerlink\" title=\"场景七：任务A任务B同时执行，看谁快用谁的结果\"></a>场景七：任务A任务B同时执行，看谁快用谁的结果</h3><p>两个CompletionStage，谁执行返回的结果快，我就用那个CompletionStage的结果进行下一步的消耗操作。</p>\n<p>acceptEither</p>\n<pre><code class=\"java\">public CompletionStage&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? super T&gt; action);\npublic CompletionStage&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? super T&gt; action);\npublic CompletionStage&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? super T&gt; action,Executor executor);</code></pre>\n<p><strong>runAfterEither</strong></p>\n<pre><code class=\"java\">public CompletionStage&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other,Runnable action);\npublic CompletionStage&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other,Runnable action);\npublic CompletionStage&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor);</code></pre>\n<p>acceptEither 和 runAfterEither 的区别也是有没有返回值</p>\n<p><font color=\"red\">代码测试发现，谁快的话会取快的任务作为结果继续进行消耗操作，但是慢的那个任务还是会继续执行并没有被取消</font></p>\n<pre><code class=\"java\">@org.junit.Test\npublic void testJoinOr() {\n    CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; {\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(&quot;任务f1&quot;);\n        return &quot;f1&quot;;\n    });\n    CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return &quot;f2&quot;;\n    });\n    //这里f1.applyToEither(f2  f1在前面还是f2在前面都无所谓\n    CompletableFuture&lt;String&gt; f3 = f1.applyToEither(f2, new Function&lt;String, String&gt;() {\n        @Override\n        public String apply(String s) {\n            return &quot;最终是哪个任务的值呢 ？ 值是 : &quot; + s  + &quot;, 获取后可以继续对值做处理&quot;;\n        }\n    });\n    long start = System.currentTimeMillis();\n    System.out.println(f3.join());\n    System.out.println(&quot;耗时:&quot; + (System.currentTimeMillis() - start) + &quot; ms&quot;);\n    try {\n        //这里阻塞20秒发现f1的任务还会继续执行，只是在结果上先取了f2的数据\n        TimeUnit.SECONDS.sleep(20);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}</code></pre>\n<pre><code class=\"java\">@org.junit.Test\npublic void testrunAfterEither(){\n    CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; {\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(&quot;任务f1&quot;);\n        return &quot;f1&quot;;\n    });\n    CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return &quot;f2&quot;;\n    });\n    CompletableFuture&lt;Void&gt; f3 = f1.runAfterEither(f2, new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(&quot;f3&quot;);\n        }\n    });\n    long start = System.currentTimeMillis();\n    f3.join();\n    System.out.println(&quot;耗时:&quot; + (System.currentTimeMillis() - start) + &quot; ms&quot;);\n    try {\n        //这里阻塞20秒发现f1的任务还会继续执行，只是在结果上先取了f2的数据\n        TimeUnit.SECONDS.sleep(20);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n}</code></pre>\n<h3 id=\"场景八：两个任务都执行成功后在消费\"><a href=\"#场景八：两个任务都执行成功后在消费\" class=\"headerlink\" title=\"场景八：两个任务都执行成功后在消费\"></a>场景八：两个任务都执行成功后在消费</h3><p>两个CompletionStage，都完成了计算才会执行下一步的操作（Runnable）</p>\n<pre><code class=\"java\">public CompletionStage&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other,Runnable action);\npublic CompletionStage&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action);\npublic CompletionStage&lt;Void&gt; runAfterBothAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor);</code></pre>\n<pre><code class=\"java\">@org.junit.Test\npublic void testrunAfterBoth(){\n    CompletableFuture&lt;String&gt; f1 = CompletableFuture.supplyAsync(() -&gt; {\n        try {\n            TimeUnit.SECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return &quot;f1&quot;;\n    });\n    CompletableFuture&lt;String&gt; f2 = CompletableFuture.supplyAsync(() -&gt; {\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        return &quot;f2&quot;;\n    });\n    CompletableFuture&lt;Void&gt; f3 = f1.runAfterBoth(f2, new Runnable() {\n        @Override\n        public void run() {\n            System.out.println(&quot;f1,f2都执行成功后执行&quot;);\n        }\n    });\n    long start = System.currentTimeMillis();\n    f3.join();\n    System.out.println(&quot;耗时:&quot; + (System.currentTimeMillis() - start) + &quot; ms&quot;);\n}</code></pre>\n<h3 id=\"场景九：allOf等待多个任务执行完成\"><a href=\"#场景九：allOf等待多个任务执行完成\" class=\"headerlink\" title=\"场景九：allOf等待多个任务执行完成\"></a>场景九：allOf等待多个任务执行完成</h3><pre><code class=\"java\">@org.junit.Test\npublic void testAllOf() throws ExecutionException, InterruptedException {\n    ExecutorService executorService = Executors.newCachedThreadPool();\n    List&lt;CompletableFuture&lt;String&gt;&gt; futureList = Lists.newArrayList();\n    List&lt;String&gt; uuidList = Lists.newArrayList();\n    for (int i = 0; i &lt; 10; i++) {\n        futureList.add(CompletableFuture.supplyAsync(() -&gt; {\n            synchronized (uuidList) {\n                for (int j = 0; j &lt; 100; j++) {\n                    uuidList.add(UUID.randomUUID().toString());\n                }\n            }\n            System.out.println(&quot;threadID:&quot; + Thread.currentThread().getId() + &quot;执行完成&quot;);\n            return null;\n        }, executorService));\n    }\n    CompletableFuture&lt;Void&gt; result = CompletableFuture.allOf(futureList.toArray(new CompletableFuture[futureList.size()]));\n    result.get();\n    System.out.println(uuidList.size());\n}</code></pre>\n<h3 id=\"场景十：anyOf-多个任务只要一个任务执行完成\"><a href=\"#场景十：anyOf-多个任务只要一个任务执行完成\" class=\"headerlink\" title=\"场景十：anyOf 多个任务只要一个任务执行完成\"></a>场景十：anyOf 多个任务只要一个任务执行完成</h3><p>跟acceptEither一样，支持支持多个。</p>\n<pre><code class=\"java\">@org.junit.Test\npublic void testAnyOf() throws ExecutionException, InterruptedException {\n    CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(new Supplier&lt;Integer&gt;() {\n        @Override\n        public Integer get() {\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(&quot;f1 done&quot;);\n            return 1;\n        }\n    });\n    CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(new Supplier&lt;Integer&gt;() {\n        @Override\n        public Integer get() {\n            try {\n                TimeUnit.SECONDS.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(&quot;f2 done&quot;);\n            return 2;\n        }\n    });\n    CompletableFuture&lt;Integer&gt; f3 = CompletableFuture.supplyAsync(new Supplier&lt;Integer&gt;() {\n        @Override\n        public Integer get() {\n            try {\n                TimeUnit.SECONDS.sleep(15);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(&quot;f3 done&quot;);\n            return 3;\n        }\n    });\n\n    CompletableFuture&lt;Object&gt; objectCompletableFuture = CompletableFuture.anyOf(f1, f2, f3);\n    long start = System.currentTimeMillis();\n    Object o = objectCompletableFuture.get();\n    System.out.println(&quot;result = &quot; + o + &quot; 消耗时间:&quot; + (System.currentTimeMillis() - start) + &quot; ms&quot;);\n    TimeUnit.SECONDS.sleep(30);\n}</code></pre>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><h3 id=\"get-和join-的区别\"><a href=\"#get-和join-的区别\" class=\"headerlink\" title=\"get()和join()的区别\"></a>get()和join()的区别</h3><ul>\n<li>join()和get()方法都是用来获取CompletableFuture异步之后的返回值</li>\n<li>join()方法抛出的是uncheck异常（即未经检查的异常),不会强制开发者抛出</li>\n<li>get()方法抛出的是经过检查的异常，ExecutionException, InterruptedException 需要用户手动处理（抛出或者 try catch）</li>\n</ul>\n<h3 id=\"带Async和不带Async后缀的区别\"><a href=\"#带Async和不带Async后缀的区别\" class=\"headerlink\" title=\"带Async和不带Async后缀的区别\"></a>带Async和不带Async后缀的区别</h3><p>通常而言，名称中不带 Async 的方法和它的前一个任务一样，在同一个线程中运行。而名称以 Async 结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。</p>\n<h3 id=\"带Executor-executor和不带的方法如何抉择？\"><a href=\"#带Executor-executor和不带的方法如何抉择？\" class=\"headerlink\" title=\"带Executor executor和不带的方法如何抉择？\"></a>带Executor executor和不带的方法如何抉择？</h3><p>CompletableFuture提供的方法都包括了带<font color=\"red\">Executor executor</font>参数和不带的。那到底怎么选择呢？来看一下不带Executor的方法的底层。如果不传Executor的话，使用的是ForkJoinPool线程池，而ForkJoinPool线程池的大小取决与CPU核数。</p>\n<pre><code class=\"java\">private static final Executor asyncPool = useCommonPool ?\n        ForkJoinPool.commonPool() : new ThreadPerTaskExecutor();\npublic static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {\n        return asyncSupplyStage(asyncPool, supplier);\n    }</code></pre>\n<ul>\n<li>如果是CPU密集型任务，直接使用ForkJoinPool就可以了</li>\n<li>如果是IO密集型任务，ForkJoinPool无法达到最佳性能，使用自己传的线程池</li>\n</ul>"},{"title":"设计模式之单例模式","description":"设计模式之单例模式","date":"2019-07-18T02:00:00.000Z","_content":"## 单例模式\n### 概念\n单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式\n### 特性\n单例模式有三个特性：\n- 单例类只能有一个实例\n- 单例类必须自行创建自己的唯一的实例\n- 单例类必须给所有其他对象提供这一实例\n\n### 单例模式的几种实现\n#### 懒汉式单例模式\n```java\npublic class SingletonOne {\n    private static SingletonOne singletonOne;\n    private SingletonOne(){}\n    private static SingletonOne getInstance(){\n        if(singletonOne == null)\n            singletonOne = new SingletonOne();\n        return singletonOne;\n    }\n}\npublic static void main(String[] args){\n    SingletonOne singletonOne = SingletonOne.getInstance();\n}\n```\n<!--more-->\n缺陷 ：\n\n- 不支持多线程，在并发环境下会导致创建多个实例\n\n#### 懒汉式线程安全单例模式\n\n```java\npublic class SingletonTwo {\n    private static SingletonTwo singletonTwo;\n    private SingletonTwo(){}\n    private synchronized static SingletonTwo getInstance(){\n        if(singletonTwo == null)\n            singletonTwo = new SingletonTwo();\n        return singletonTwo;\n    }\n}\npublic static void main(String[] args){\n    SingletonTwo singletonOne = SingletonTwo.getInstance();\n}\n```\n\n这种方式是在懒汉式单例模式下加了synchronized关键字保证线程安全\n\n缺陷：\n\n- 虽然能保证线程安全，但是用了synchronized，加锁影响效率\n\n#### 饿汉式单例模式\n\n```java\npublic class SingletonThree {\n    private static SingletonThree singletonThree = new SingletonThree();\n    private SingletonThree(){}\n\n    private static SingletonThree getInstance(){\n        return singletonThree;\n    }\n}\npublic static void main(String[] args){\n    SingletonThree singletonOne = SingletonThree.getInstance();\n}\n```\n\n特点与缺陷：\n\n- 没有加锁，执行效率高\n- 类加载时就初始化，浪费内存\n\n#### 双检查锁单例模式\n\n```java\npublic class SingletonFour {\n    private static volatile SingletonFour singletonFour;\n    private SingletonFour(){}\n    private static SingletonFour getSingleton(){\n        if(singletonFour == null){  //第一次检查\n            synchronized (SingletonFour.class){\n                if(singletonFour == null) //第二次检查\n                    singletonFour = new SingletonFour(); // 标注1\n            }\n        }\n        return singletonFour;\n    }\n}\npublic static void main(String[] args){\n    SingletonFour singletonOne = SingletonFour.getInstance();\n}\n```\n\n这种方式采用了二次检查+ synchronized的方式，且采用了volatile修饰单例。第一次检查可以保证大部分线程不进入synchronized判断，第二次检查保证了少部分进入synchronized的线程不重新new 对象。\n\n**那为什么要用volatile修饰？**\n\n因为singletonFour = new SingletonFour() 包含了如下三步操作。\n\n```java\nmemory = allocate();　　// 1.分配对象的内存空间\nctorInstance(memory);　　// 2.初始化对象\nsInstance = memory;　　// 3.设置sInstance指向刚分配的内存地址\n```\n\n上述伪代码中的2和3之间可能会发生重排序，重排序后的执行顺序如下\n\n```java\nmemory = allocate();　　// 1.分配对象的内存空间\nsInstance = memory;　　// 2.设置sInstance指向刚分配的内存地址，此时对象还没有被初始化\nctorInstance(memory);　　// 3.初始化对象\n```\n\n所以在多线程下，如果发生重排序，singletonFour == null会返回ture，导致进行了两次初始化对象。\n\n#### 静态内部类单例模式\n\n```java\npublic class SingletonFive {\n    private SingletonFive(){}\n    //创建一个内部静态类\n    private static class SingletonHolder{\n        private final static SingletonFive sinleton = new SingletonFive();\n    }\n    public static SingletonFive getSingleton(){\n        return SingletonHolder.sinleton;\n    }\n}\npublic static void main(String[] args){\n    SingletonFive singletonOne = SingletonFive.getInstance();\n}\n```\n\n我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SingletonHolder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）\n\n## 参考\n\n- http://tengj.top/2016/04/06/sjms4singleton/\n\n","source":"_posts/design-pattern-singleton.md","raw":"---\ntitle: 设计模式之单例模式\ntags:\n  - 设计模式\ncategories:  java\ndescription : 设计模式之单例模式\ndate: 2019-07-18 10:00:00\n---\n## 单例模式\n### 概念\n单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式\n### 特性\n单例模式有三个特性：\n- 单例类只能有一个实例\n- 单例类必须自行创建自己的唯一的实例\n- 单例类必须给所有其他对象提供这一实例\n\n### 单例模式的几种实现\n#### 懒汉式单例模式\n```java\npublic class SingletonOne {\n    private static SingletonOne singletonOne;\n    private SingletonOne(){}\n    private static SingletonOne getInstance(){\n        if(singletonOne == null)\n            singletonOne = new SingletonOne();\n        return singletonOne;\n    }\n}\npublic static void main(String[] args){\n    SingletonOne singletonOne = SingletonOne.getInstance();\n}\n```\n<!--more-->\n缺陷 ：\n\n- 不支持多线程，在并发环境下会导致创建多个实例\n\n#### 懒汉式线程安全单例模式\n\n```java\npublic class SingletonTwo {\n    private static SingletonTwo singletonTwo;\n    private SingletonTwo(){}\n    private synchronized static SingletonTwo getInstance(){\n        if(singletonTwo == null)\n            singletonTwo = new SingletonTwo();\n        return singletonTwo;\n    }\n}\npublic static void main(String[] args){\n    SingletonTwo singletonOne = SingletonTwo.getInstance();\n}\n```\n\n这种方式是在懒汉式单例模式下加了synchronized关键字保证线程安全\n\n缺陷：\n\n- 虽然能保证线程安全，但是用了synchronized，加锁影响效率\n\n#### 饿汉式单例模式\n\n```java\npublic class SingletonThree {\n    private static SingletonThree singletonThree = new SingletonThree();\n    private SingletonThree(){}\n\n    private static SingletonThree getInstance(){\n        return singletonThree;\n    }\n}\npublic static void main(String[] args){\n    SingletonThree singletonOne = SingletonThree.getInstance();\n}\n```\n\n特点与缺陷：\n\n- 没有加锁，执行效率高\n- 类加载时就初始化，浪费内存\n\n#### 双检查锁单例模式\n\n```java\npublic class SingletonFour {\n    private static volatile SingletonFour singletonFour;\n    private SingletonFour(){}\n    private static SingletonFour getSingleton(){\n        if(singletonFour == null){  //第一次检查\n            synchronized (SingletonFour.class){\n                if(singletonFour == null) //第二次检查\n                    singletonFour = new SingletonFour(); // 标注1\n            }\n        }\n        return singletonFour;\n    }\n}\npublic static void main(String[] args){\n    SingletonFour singletonOne = SingletonFour.getInstance();\n}\n```\n\n这种方式采用了二次检查+ synchronized的方式，且采用了volatile修饰单例。第一次检查可以保证大部分线程不进入synchronized判断，第二次检查保证了少部分进入synchronized的线程不重新new 对象。\n\n**那为什么要用volatile修饰？**\n\n因为singletonFour = new SingletonFour() 包含了如下三步操作。\n\n```java\nmemory = allocate();　　// 1.分配对象的内存空间\nctorInstance(memory);　　// 2.初始化对象\nsInstance = memory;　　// 3.设置sInstance指向刚分配的内存地址\n```\n\n上述伪代码中的2和3之间可能会发生重排序，重排序后的执行顺序如下\n\n```java\nmemory = allocate();　　// 1.分配对象的内存空间\nsInstance = memory;　　// 2.设置sInstance指向刚分配的内存地址，此时对象还没有被初始化\nctorInstance(memory);　　// 3.初始化对象\n```\n\n所以在多线程下，如果发生重排序，singletonFour == null会返回ture，导致进行了两次初始化对象。\n\n#### 静态内部类单例模式\n\n```java\npublic class SingletonFive {\n    private SingletonFive(){}\n    //创建一个内部静态类\n    private static class SingletonHolder{\n        private final static SingletonFive sinleton = new SingletonFive();\n    }\n    public static SingletonFive getSingleton(){\n        return SingletonHolder.sinleton;\n    }\n}\npublic static void main(String[] args){\n    SingletonFive singletonOne = SingletonFive.getInstance();\n}\n```\n\n我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SingletonHolder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）\n\n## 参考\n\n- http://tengj.top/2016/04/06/sjms4singleton/\n\n","slug":"design-pattern-singleton","published":1,"updated":"2021-04-08T00:47:06.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhue0006qwv2fdat28gv","content":"<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式</p>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>单例模式有三个特性：</p>\n<ul>\n<li>单例类只能有一个实例</li>\n<li>单例类必须自行创建自己的唯一的实例</li>\n<li>单例类必须给所有其他对象提供这一实例</li>\n</ul>\n<h3 id=\"单例模式的几种实现\"><a href=\"#单例模式的几种实现\" class=\"headerlink\" title=\"单例模式的几种实现\"></a>单例模式的几种实现</h3><h4 id=\"懒汉式单例模式\"><a href=\"#懒汉式单例模式\" class=\"headerlink\" title=\"懒汉式单例模式\"></a>懒汉式单例模式</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonOne</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> SingletonOne singletonOne<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token function\">SingletonOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> SingletonOne <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>singletonOne <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            singletonOne <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SingletonOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> singletonOne<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    SingletonOne singletonOne <span class=\"token operator\">=</span> SingletonOne<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<a id=\"more\"></a>\n<p>缺陷 ：</p>\n<ul>\n<li>不支持多线程，在并发环境下会导致创建多个实例</li>\n</ul>\n<h4 id=\"懒汉式线程安全单例模式\"><a href=\"#懒汉式线程安全单例模式\" class=\"headerlink\" title=\"懒汉式线程安全单例模式\"></a>懒汉式线程安全单例模式</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonTwo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> SingletonTwo singletonTwo<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token function\">SingletonTwo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">static</span> SingletonTwo <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>singletonTwo <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            singletonTwo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SingletonTwo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> singletonTwo<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    SingletonTwo singletonOne <span class=\"token operator\">=</span> SingletonTwo<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这种方式是在懒汉式单例模式下加了synchronized关键字保证线程安全</p>\n<p>缺陷：</p>\n<ul>\n<li>虽然能保证线程安全，但是用了synchronized，加锁影响效率</li>\n</ul>\n<h4 id=\"饿汉式单例模式\"><a href=\"#饿汉式单例模式\" class=\"headerlink\" title=\"饿汉式单例模式\"></a>饿汉式单例模式</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonThree</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> SingletonThree singletonThree <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SingletonThree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token function\">SingletonThree</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> SingletonThree <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> singletonThree<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    SingletonThree singletonOne <span class=\"token operator\">=</span> SingletonThree<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>特点与缺陷：</p>\n<ul>\n<li>没有加锁，执行效率高</li>\n<li>类加载时就初始化，浪费内存</li>\n</ul>\n<h4 id=\"双检查锁单例模式\"><a href=\"#双检查锁单例模式\" class=\"headerlink\" title=\"双检查锁单例模式\"></a>双检查锁单例模式</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonFour</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> SingletonFour singletonFour<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token function\">SingletonFour</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> SingletonFour <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>singletonFour <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//第一次检查</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>SingletonFour<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>singletonFour <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//第二次检查</span>\n                    singletonFour <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SingletonFour</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 标注1</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> singletonFour<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    SingletonFour singletonOne <span class=\"token operator\">=</span> SingletonFour<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这种方式采用了二次检查+ synchronized的方式，且采用了volatile修饰单例。第一次检查可以保证大部分线程不进入synchronized判断，第二次检查保证了少部分进入synchronized的线程不重新new 对象。</p>\n<p><strong>那为什么要用volatile修饰？</strong></p>\n<p>因为singletonFour = new SingletonFour() 包含了如下三步操作。</p>\n<pre class=\" language-java\"><code class=\"language-java\">memory <span class=\"token operator\">=</span> <span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">// 1.分配对象的内存空间</span>\n<span class=\"token function\">ctorInstance</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">// 2.初始化对象</span>\nsInstance <span class=\"token operator\">=</span> memory<span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">// 3.设置sInstance指向刚分配的内存地址</span></code></pre>\n<p>上述伪代码中的2和3之间可能会发生重排序，重排序后的执行顺序如下</p>\n<pre class=\" language-java\"><code class=\"language-java\">memory <span class=\"token operator\">=</span> <span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">// 1.分配对象的内存空间</span>\nsInstance <span class=\"token operator\">=</span> memory<span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">// 2.设置sInstance指向刚分配的内存地址，此时对象还没有被初始化</span>\n<span class=\"token function\">ctorInstance</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>　　<span class=\"token comment\" spellcheck=\"true\">// 3.初始化对象</span></code></pre>\n<p>所以在多线程下，如果发生重排序，singletonFour == null会返回ture，导致进行了两次初始化对象。</p>\n<h4 id=\"静态内部类单例模式\"><a href=\"#静态内部类单例模式\" class=\"headerlink\" title=\"静态内部类单例模式\"></a>静态内部类单例模式</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonFive</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token function\">SingletonFive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//创建一个内部静态类</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonHolder</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">static</span> SingletonFive sinleton <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SingletonFive</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> SingletonFive <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> SingletonHolder<span class=\"token punctuation\">.</span>sinleton<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    SingletonFive singletonOne <span class=\"token operator\">=</span> SingletonFive<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SingletonHolder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://tengj.top/2016/04/06/sjms4singleton/\" target=\"_blank\" rel=\"noopener\">http://tengj.top/2016/04/06/sjms4singleton/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><p>单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式</p>\n<h3 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h3><p>单例模式有三个特性：</p>\n<ul>\n<li>单例类只能有一个实例</li>\n<li>单例类必须自行创建自己的唯一的实例</li>\n<li>单例类必须给所有其他对象提供这一实例</li>\n</ul>\n<h3 id=\"单例模式的几种实现\"><a href=\"#单例模式的几种实现\" class=\"headerlink\" title=\"单例模式的几种实现\"></a>单例模式的几种实现</h3><h4 id=\"懒汉式单例模式\"><a href=\"#懒汉式单例模式\" class=\"headerlink\" title=\"懒汉式单例模式\"></a>懒汉式单例模式</h4><pre><code class=\"java\">public class SingletonOne {\n    private static SingletonOne singletonOne;\n    private SingletonOne(){}\n    private static SingletonOne getInstance(){\n        if(singletonOne == null)\n            singletonOne = new SingletonOne();\n        return singletonOne;\n    }\n}\npublic static void main(String[] args){\n    SingletonOne singletonOne = SingletonOne.getInstance();\n}</code></pre>","more":"<p>缺陷 ：</p>\n<ul>\n<li>不支持多线程，在并发环境下会导致创建多个实例</li>\n</ul>\n<h4 id=\"懒汉式线程安全单例模式\"><a href=\"#懒汉式线程安全单例模式\" class=\"headerlink\" title=\"懒汉式线程安全单例模式\"></a>懒汉式线程安全单例模式</h4><pre><code class=\"java\">public class SingletonTwo {\n    private static SingletonTwo singletonTwo;\n    private SingletonTwo(){}\n    private synchronized static SingletonTwo getInstance(){\n        if(singletonTwo == null)\n            singletonTwo = new SingletonTwo();\n        return singletonTwo;\n    }\n}\npublic static void main(String[] args){\n    SingletonTwo singletonOne = SingletonTwo.getInstance();\n}</code></pre>\n<p>这种方式是在懒汉式单例模式下加了synchronized关键字保证线程安全</p>\n<p>缺陷：</p>\n<ul>\n<li>虽然能保证线程安全，但是用了synchronized，加锁影响效率</li>\n</ul>\n<h4 id=\"饿汉式单例模式\"><a href=\"#饿汉式单例模式\" class=\"headerlink\" title=\"饿汉式单例模式\"></a>饿汉式单例模式</h4><pre><code class=\"java\">public class SingletonThree {\n    private static SingletonThree singletonThree = new SingletonThree();\n    private SingletonThree(){}\n\n    private static SingletonThree getInstance(){\n        return singletonThree;\n    }\n}\npublic static void main(String[] args){\n    SingletonThree singletonOne = SingletonThree.getInstance();\n}</code></pre>\n<p>特点与缺陷：</p>\n<ul>\n<li>没有加锁，执行效率高</li>\n<li>类加载时就初始化，浪费内存</li>\n</ul>\n<h4 id=\"双检查锁单例模式\"><a href=\"#双检查锁单例模式\" class=\"headerlink\" title=\"双检查锁单例模式\"></a>双检查锁单例模式</h4><pre><code class=\"java\">public class SingletonFour {\n    private static volatile SingletonFour singletonFour;\n    private SingletonFour(){}\n    private static SingletonFour getSingleton(){\n        if(singletonFour == null){  //第一次检查\n            synchronized (SingletonFour.class){\n                if(singletonFour == null) //第二次检查\n                    singletonFour = new SingletonFour(); // 标注1\n            }\n        }\n        return singletonFour;\n    }\n}\npublic static void main(String[] args){\n    SingletonFour singletonOne = SingletonFour.getInstance();\n}</code></pre>\n<p>这种方式采用了二次检查+ synchronized的方式，且采用了volatile修饰单例。第一次检查可以保证大部分线程不进入synchronized判断，第二次检查保证了少部分进入synchronized的线程不重新new 对象。</p>\n<p><strong>那为什么要用volatile修饰？</strong></p>\n<p>因为singletonFour = new SingletonFour() 包含了如下三步操作。</p>\n<pre><code class=\"java\">memory = allocate();　　// 1.分配对象的内存空间\nctorInstance(memory);　　// 2.初始化对象\nsInstance = memory;　　// 3.设置sInstance指向刚分配的内存地址</code></pre>\n<p>上述伪代码中的2和3之间可能会发生重排序，重排序后的执行顺序如下</p>\n<pre><code class=\"java\">memory = allocate();　　// 1.分配对象的内存空间\nsInstance = memory;　　// 2.设置sInstance指向刚分配的内存地址，此时对象还没有被初始化\nctorInstance(memory);　　// 3.初始化对象</code></pre>\n<p>所以在多线程下，如果发生重排序，singletonFour == null会返回ture，导致进行了两次初始化对象。</p>\n<h4 id=\"静态内部类单例模式\"><a href=\"#静态内部类单例模式\" class=\"headerlink\" title=\"静态内部类单例模式\"></a>静态内部类单例模式</h4><pre><code class=\"java\">public class SingletonFive {\n    private SingletonFive(){}\n    //创建一个内部静态类\n    private static class SingletonHolder{\n        private final static SingletonFive sinleton = new SingletonFive();\n    }\n    public static SingletonFive getSingleton(){\n        return SingletonHolder.sinleton;\n    }\n}\npublic static void main(String[] args){\n    SingletonFive singletonOne = SingletonFive.getInstance();\n}</code></pre>\n<p>我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SingletonHolder，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"http://tengj.top/2016/04/06/sjms4singleton/\" target=\"_blank\" rel=\"noopener\">http://tengj.top/2016/04/06/sjms4singleton/</a></li>\n</ul>"},{"title":"GC日志详解","description":"详解GC日志的结构，性能测试，排查定位问题，JVM调优过程中，都会遇到要分析GC日志，那你看得懂GC日志吗？","date":"2019-02-18T09:14:00.000Z","_content":"## GC日志相关参数\n\n| 参数                   | 详细介绍                                                     |\n| ---------------------- | ------------------------------------------------------------ |\n| -XX:+PrintGCDetails    | 输出GC的详细日志                                             |\n| -XX:+PrintGCTimeStamps | 输出GC的时间戳（以基准时间的形式）                           |\n| -XX:+PrintGCDateStamps | 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） |\n| -XX:+PrintHeapAtGC     | 在进行GC的前后打印出堆的信息                                 |\n| -Xloggc:D:/gc.log      | 日志文件的输出路径                                           |\n| -XX:+PrintGC           | 输出GC日志                                                   |\n<!--more-->\n## YGC日志详解\n\n### 参数配置\n\n```properties\n-XX:+PrintGCDetails -XX:+PrintGCDateStamps\n```\n\n发生GC后输出参数如下\n\n```\n2019-04-18T14:52:06.790+0800: 2.653: [GC (Allocation Failure) [PSYoungGen: 33280K->5113K(38400K)] 33280K->5848K(125952K), 0.0095764 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]\n```\n\n![](gc-log/1.jpg)\n\n### 日志详解\n\n```\n2019-04-18T14:52:06.790+0800（当前时间戳）: 2.653（应用启动基准时间）: [GC (Allocation Failure) [PSYoungGen（表示Young GC）: 33280K（年轻代回收前大小）->5113K（年轻代回收后大小）(38400K（年轻代总大小）)] 33280K（整个堆回收前大小）->5848K（整个堆回收后大小）(125952K（堆总大小）), 0.0095764（耗时） secs] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.01（实际耗时） secs]\n#GC (Allocation Failure) ：表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据\n```\n\n## FGC日志详解\n### 参数配置\n```properties\n-XX:+PrintGCDetails -XX:+PrintGCDateStamps\n```\n发生GC后输出参数如下\n```\n2019-04-18T14:52:15.359+0800: 11.222: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K->0K(143360K)] [ParOldGen: 13088K->13236K(55808K)] 19218K->13236K(199168K), [Metaspace: 20856K->20856K(1069056K)], 0.1216713 secs] [Times: user=0.44 sys=0.02, real=0.12 secs]\n```\n![](gc-log/2.jpg)\n\n### 日志详解\n```\n2019-04-18T14:52:15.359+0800（当前时间戳）: 11.222（应用启动基准时间）: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K（年轻代回收前大小）->0K（年轻代回收后大小）(143360K（年轻代总大小）)] [ParOldGen: 13088K（老年代回收前大小）->13236K（老年代回收后大小）(55808K（老年代总大小）)] 19218K（整个堆回收前大小）->13236K（整个堆回收后大小）(199168K（堆总大小）), [Metaspace: 20856K（持久代回收前大小）->20856K（持久代回收后大小）(1069056K（持久代总大小）)], 0.1216713（耗时） secs] [Times: user=0.44（用户耗时） sys=0.02（系统耗时）, real=0.12（实际耗时） secs]\n```\n## 代码如何查看GC日志\n### 代码\n```java\npublic class TestHandlePromotionFailure {\n    private static final int _1M = 1024 * 1024;\n    /***\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseSerialGC\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseParallelGC\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC\n     * @param args\n     */\n    public static void main(String[] args){\n        byte[] a1,a2,a3,a4;\n        a1 = new byte[2 * _1M];\n        a2 = new byte[2 * _1M];\n        a3 = new byte[2 * _1M];\n        a4 = new byte[4 * _1M];\n    }\n}\n```\n\n### 在IDEA配置GC日志参数\n![](gc-log/3.png)\n### 输出结果\n![](gc-log/4.png)\n","source":"_posts/gc-log.md","raw":"---\ntitle: GC日志详解\ntags:\n  - jvm\ncategories: \n  - java\ndescription : 详解GC日志的结构，性能测试，排查定位问题，JVM调优过程中，都会遇到要分析GC日志，那你看得懂GC日志吗？\ndate: 2019-02-18 17:14:00\n---\n## GC日志相关参数\n\n| 参数                   | 详细介绍                                                     |\n| ---------------------- | ------------------------------------------------------------ |\n| -XX:+PrintGCDetails    | 输出GC的详细日志                                             |\n| -XX:+PrintGCTimeStamps | 输出GC的时间戳（以基准时间的形式）                           |\n| -XX:+PrintGCDateStamps | 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） |\n| -XX:+PrintHeapAtGC     | 在进行GC的前后打印出堆的信息                                 |\n| -Xloggc:D:/gc.log      | 日志文件的输出路径                                           |\n| -XX:+PrintGC           | 输出GC日志                                                   |\n<!--more-->\n## YGC日志详解\n\n### 参数配置\n\n```properties\n-XX:+PrintGCDetails -XX:+PrintGCDateStamps\n```\n\n发生GC后输出参数如下\n\n```\n2019-04-18T14:52:06.790+0800: 2.653: [GC (Allocation Failure) [PSYoungGen: 33280K->5113K(38400K)] 33280K->5848K(125952K), 0.0095764 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]\n```\n\n![](gc-log/1.jpg)\n\n### 日志详解\n\n```\n2019-04-18T14:52:06.790+0800（当前时间戳）: 2.653（应用启动基准时间）: [GC (Allocation Failure) [PSYoungGen（表示Young GC）: 33280K（年轻代回收前大小）->5113K（年轻代回收后大小）(38400K（年轻代总大小）)] 33280K（整个堆回收前大小）->5848K（整个堆回收后大小）(125952K（堆总大小）), 0.0095764（耗时） secs] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.01（实际耗时） secs]\n#GC (Allocation Failure) ：表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据\n```\n\n## FGC日志详解\n### 参数配置\n```properties\n-XX:+PrintGCDetails -XX:+PrintGCDateStamps\n```\n发生GC后输出参数如下\n```\n2019-04-18T14:52:15.359+0800: 11.222: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K->0K(143360K)] [ParOldGen: 13088K->13236K(55808K)] 19218K->13236K(199168K), [Metaspace: 20856K->20856K(1069056K)], 0.1216713 secs] [Times: user=0.44 sys=0.02, real=0.12 secs]\n```\n![](gc-log/2.jpg)\n\n### 日志详解\n```\n2019-04-18T14:52:15.359+0800（当前时间戳）: 11.222（应用启动基准时间）: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K（年轻代回收前大小）->0K（年轻代回收后大小）(143360K（年轻代总大小）)] [ParOldGen: 13088K（老年代回收前大小）->13236K（老年代回收后大小）(55808K（老年代总大小）)] 19218K（整个堆回收前大小）->13236K（整个堆回收后大小）(199168K（堆总大小）), [Metaspace: 20856K（持久代回收前大小）->20856K（持久代回收后大小）(1069056K（持久代总大小）)], 0.1216713（耗时） secs] [Times: user=0.44（用户耗时） sys=0.02（系统耗时）, real=0.12（实际耗时） secs]\n```\n## 代码如何查看GC日志\n### 代码\n```java\npublic class TestHandlePromotionFailure {\n    private static final int _1M = 1024 * 1024;\n    /***\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseSerialGC\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseParallelGC\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC\n     * @param args\n     */\n    public static void main(String[] args){\n        byte[] a1,a2,a3,a4;\n        a1 = new byte[2 * _1M];\n        a2 = new byte[2 * _1M];\n        a3 = new byte[2 * _1M];\n        a4 = new byte[4 * _1M];\n    }\n}\n```\n\n### 在IDEA配置GC日志参数\n![](gc-log/3.png)\n### 输出结果\n![](gc-log/4.png)\n","slug":"gc-log","published":1,"updated":"2021-04-08T00:47:06.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhug0007qwv26zbi3n30","content":"<h2 id=\"GC日志相关参数\"><a href=\"#GC日志相关参数\" class=\"headerlink\" title=\"GC日志相关参数\"></a>GC日志相关参数</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>详细介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-XX:+PrintGCDetails</td>\n<td>输出GC的详细日志</td>\n</tr>\n<tr>\n<td>-XX:+PrintGCTimeStamps</td>\n<td>输出GC的时间戳（以基准时间的形式）</td>\n</tr>\n<tr>\n<td>-XX:+PrintGCDateStamps</td>\n<td>输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</td>\n</tr>\n<tr>\n<td>-XX:+PrintHeapAtGC</td>\n<td>在进行GC的前后打印出堆的信息</td>\n</tr>\n<tr>\n<td>-Xloggc:D:/gc.log</td>\n<td>日志文件的输出路径</td>\n</tr>\n<tr>\n<td>-XX:+PrintGC</td>\n<td>输出GC日志</td>\n</tr>\n<tr>\n<td><a id=\"more\"></a></td>\n<td></td>\n</tr>\n<tr>\n<td>## YGC日志详解</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h3><pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token attr-name\">-XX</span><span class=\"token punctuation\">:</span><span class=\"token attr-value\">+PrintGCDetails -XX:+PrintGCDateStamps</span></code></pre>\n<p>发生GC后输出参数如下</p>\n<pre><code>2019-04-18T14:52:06.790+0800: 2.653: [GC (Allocation Failure) [PSYoungGen: 33280K-&gt;5113K(38400K)] 33280K-&gt;5848K(125952K), 0.0095764 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</code></pre><p><img src=\"/2019/02/18/gc-log/1.jpg\" alt></p>\n<h3 id=\"日志详解\"><a href=\"#日志详解\" class=\"headerlink\" title=\"日志详解\"></a>日志详解</h3><pre><code>2019-04-18T14:52:06.790+0800（当前时间戳）: 2.653（应用启动基准时间）: [GC (Allocation Failure) [PSYoungGen（表示Young GC）: 33280K（年轻代回收前大小）-&gt;5113K（年轻代回收后大小）(38400K（年轻代总大小）)] 33280K（整个堆回收前大小）-&gt;5848K（整个堆回收后大小）(125952K（堆总大小）), 0.0095764（耗时） secs] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.01（实际耗时） secs]\n#GC (Allocation Failure) ：表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据</code></pre><h2 id=\"FGC日志详解\"><a href=\"#FGC日志详解\" class=\"headerlink\" title=\"FGC日志详解\"></a>FGC日志详解</h2><h3 id=\"参数配置-1\"><a href=\"#参数配置-1\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h3><pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token attr-name\">-XX</span><span class=\"token punctuation\">:</span><span class=\"token attr-value\">+PrintGCDetails -XX:+PrintGCDateStamps</span></code></pre>\n<p>发生GC后输出参数如下</p>\n<pre><code>2019-04-18T14:52:15.359+0800: 11.222: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K-&gt;0K(143360K)] [ParOldGen: 13088K-&gt;13236K(55808K)] 19218K-&gt;13236K(199168K), [Metaspace: 20856K-&gt;20856K(1069056K)], 0.1216713 secs] [Times: user=0.44 sys=0.02, real=0.12 secs]</code></pre><p><img src=\"/2019/02/18/gc-log/2.jpg\" alt></p>\n<h3 id=\"日志详解-1\"><a href=\"#日志详解-1\" class=\"headerlink\" title=\"日志详解\"></a>日志详解</h3><pre><code>2019-04-18T14:52:15.359+0800（当前时间戳）: 11.222（应用启动基准时间）: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K（年轻代回收前大小）-&gt;0K（年轻代回收后大小）(143360K（年轻代总大小）)] [ParOldGen: 13088K（老年代回收前大小）-&gt;13236K（老年代回收后大小）(55808K（老年代总大小）)] 19218K（整个堆回收前大小）-&gt;13236K（整个堆回收后大小）(199168K（堆总大小）), [Metaspace: 20856K（持久代回收前大小）-&gt;20856K（持久代回收后大小）(1069056K（持久代总大小）)], 0.1216713（耗时） secs] [Times: user=0.44（用户耗时） sys=0.02（系统耗时）, real=0.12（实际耗时） secs]</code></pre><h2 id=\"代码如何查看GC日志\"><a href=\"#代码如何查看GC日志\" class=\"headerlink\" title=\"代码如何查看GC日志\"></a>代码如何查看GC日志</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestHandlePromotionFailure</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> _1M <span class=\"token operator\">=</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseSerialGC\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseParallelGC\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC\n     * @param args\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a1<span class=\"token punctuation\">,</span>a2<span class=\"token punctuation\">,</span>a3<span class=\"token punctuation\">,</span>a4<span class=\"token punctuation\">;</span>\n        a1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> _1M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        a2 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> _1M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        a3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span> <span class=\"token operator\">*</span> _1M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        a4 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> _1M<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"在IDEA配置GC日志参数\"><a href=\"#在IDEA配置GC日志参数\" class=\"headerlink\" title=\"在IDEA配置GC日志参数\"></a>在IDEA配置GC日志参数</h3><p><img src=\"/2019/02/18/gc-log/3.png\" alt></p>\n<h3 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h3><p><img src=\"/2019/02/18/gc-log/4.png\" alt></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"GC日志相关参数\"><a href=\"#GC日志相关参数\" class=\"headerlink\" title=\"GC日志相关参数\"></a>GC日志相关参数</h2><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>详细介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-XX:+PrintGCDetails</td>\n<td>输出GC的详细日志</td>\n</tr>\n<tr>\n<td>-XX:+PrintGCTimeStamps</td>\n<td>输出GC的时间戳（以基准时间的形式）</td>\n</tr>\n<tr>\n<td>-XX:+PrintGCDateStamps</td>\n<td>输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</td>\n</tr>\n<tr>\n<td>-XX:+PrintHeapAtGC</td>\n<td>在进行GC的前后打印出堆的信息</td>\n</tr>\n<tr>\n<td>-Xloggc:D:/gc.log</td>\n<td>日志文件的输出路径</td>\n</tr>\n<tr>\n<td>-XX:+PrintGC</td>\n<td>输出GC日志</td>\n</tr>\n<tr>\n<td></td></tr></tbody></table>","more":"\n<td></td>\n\n<tr>\n<td>## YGC日志详解</td>\n<td></td>\n</tr>\n\n<h3 id=\"参数配置\"><a href=\"#参数配置\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h3><pre><code class=\"properties\">-XX:+PrintGCDetails -XX:+PrintGCDateStamps</code></pre>\n<p>发生GC后输出参数如下</p>\n<pre><code>2019-04-18T14:52:06.790+0800: 2.653: [GC (Allocation Failure) [PSYoungGen: 33280K-&gt;5113K(38400K)] 33280K-&gt;5848K(125952K), 0.0095764 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]</code></pre><p><img src=\"/2019/02/18/gc-log/1.jpg\" alt></p>\n<h3 id=\"日志详解\"><a href=\"#日志详解\" class=\"headerlink\" title=\"日志详解\"></a>日志详解</h3><pre><code>2019-04-18T14:52:06.790+0800（当前时间戳）: 2.653（应用启动基准时间）: [GC (Allocation Failure) [PSYoungGen（表示Young GC）: 33280K（年轻代回收前大小）-&gt;5113K（年轻代回收后大小）(38400K（年轻代总大小）)] 33280K（整个堆回收前大小）-&gt;5848K（整个堆回收后大小）(125952K（堆总大小）), 0.0095764（耗时） secs] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.01（实际耗时） secs]\n#GC (Allocation Failure) ：表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据</code></pre><h2 id=\"FGC日志详解\"><a href=\"#FGC日志详解\" class=\"headerlink\" title=\"FGC日志详解\"></a>FGC日志详解</h2><h3 id=\"参数配置-1\"><a href=\"#参数配置-1\" class=\"headerlink\" title=\"参数配置\"></a>参数配置</h3><pre><code class=\"properties\">-XX:+PrintGCDetails -XX:+PrintGCDateStamps</code></pre>\n<p>发生GC后输出参数如下</p>\n<pre><code>2019-04-18T14:52:15.359+0800: 11.222: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K-&gt;0K(143360K)] [ParOldGen: 13088K-&gt;13236K(55808K)] 19218K-&gt;13236K(199168K), [Metaspace: 20856K-&gt;20856K(1069056K)], 0.1216713 secs] [Times: user=0.44 sys=0.02, real=0.12 secs]</code></pre><p><img src=\"/2019/02/18/gc-log/2.jpg\" alt></p>\n<h3 id=\"日志详解-1\"><a href=\"#日志详解-1\" class=\"headerlink\" title=\"日志详解\"></a>日志详解</h3><pre><code>2019-04-18T14:52:15.359+0800（当前时间戳）: 11.222（应用启动基准时间）: [Full GC (Metadata GC Threshold) [PSYoungGen: 6129K（年轻代回收前大小）-&gt;0K（年轻代回收后大小）(143360K（年轻代总大小）)] [ParOldGen: 13088K（老年代回收前大小）-&gt;13236K（老年代回收后大小）(55808K（老年代总大小）)] 19218K（整个堆回收前大小）-&gt;13236K（整个堆回收后大小）(199168K（堆总大小）), [Metaspace: 20856K（持久代回收前大小）-&gt;20856K（持久代回收后大小）(1069056K（持久代总大小）)], 0.1216713（耗时） secs] [Times: user=0.44（用户耗时） sys=0.02（系统耗时）, real=0.12（实际耗时） secs]</code></pre><h2 id=\"代码如何查看GC日志\"><a href=\"#代码如何查看GC日志\" class=\"headerlink\" title=\"代码如何查看GC日志\"></a>代码如何查看GC日志</h2><h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><pre><code class=\"java\">public class TestHandlePromotionFailure {\n    private static final int _1M = 1024 * 1024;\n    /***\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseSerialGC\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseParallelGC\n     * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC\n     * @param args\n     */\n    public static void main(String[] args){\n        byte[] a1,a2,a3,a4;\n        a1 = new byte[2 * _1M];\n        a2 = new byte[2 * _1M];\n        a3 = new byte[2 * _1M];\n        a4 = new byte[4 * _1M];\n    }\n}</code></pre>\n<h3 id=\"在IDEA配置GC日志参数\"><a href=\"#在IDEA配置GC日志参数\" class=\"headerlink\" title=\"在IDEA配置GC日志参数\"></a>在IDEA配置GC日志参数</h3><p><img src=\"/2019/02/18/gc-log/3.png\" alt></p>\n<h3 id=\"输出结果\"><a href=\"#输出结果\" class=\"headerlink\" title=\"输出结果\"></a>输出结果</h3><p><img src=\"/2019/02/18/gc-log/4.png\" alt></p>"},{"title":"Fork/join框架你会用吗？","description":"详解Fork/join框架","date":"2020-07-30T08:35:57.000Z","_content":"## Fork/Join框架介绍\n\n### 介绍\n\nFork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork/Join框架要完成两件事情：\n- 任务分割：首先Fork/Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割\n- 执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据\n\n### 使用场景\n\nForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。FokJoinPool主要适用于<font color=red>计算密集型的任务</font>。例如对一个大数组求和，排序等场景。\n<!--more-->\n## 如何使用Fork/Join框架？\n\n使用Fork/Join框架，首先需要创建一个ForkJoin任务。该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集成ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了两个子类:\n\n- RecursiveAction 用于没有返回结果的任务\n- RecursiveTask 用于有返回结果的任务\n\n### 实例一：大数组求和\n\n对一个大数组进行求和。代码如下\n\n```java\n@Test\npublic void test() {\n    long[] numbers = LongStream.rangeClosed(1, 5263).toArray();\n    ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);\n    long start = System.currentTimeMillis();\n    long result = new ForkJoinPool().invoke(task);\n    System.out.println(\"结果 = \" + result  + \", 耗时 = \" + (System.currentTimeMillis() - start) + \" ms\");\n}\n```\n\n```java\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinSumCalculator extends RecursiveTask<Long> {\n    //不再将任务分解为子任务的数组大小\n    public static final long THRESHOLD = 100;\n    private final long[] numbers;\n    private final int start; //起始位置\n    private final int end; //终止位置\n    public ForkJoinSumCalculator(long[] numbers) {\n        this(numbers, 0, numbers.length);\n    }\n    private ForkJoinSumCalculator(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        if (length <= THRESHOLD) {\n            return computeSequentially();\n        }\n        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(numbers,start,start + length / 2);\n        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(numbers, start + length/2, end);\n        invokeAll(leftTask,rightTask);\n        Long rightResult = rightTask.join();\n        Long leftResult = leftTask.join();\n        return leftResult + rightResult;\n    }\n\n    /**\n        求和\n    */\n    private long computeSequentially() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += numbers[i];\n        }\n        return sum;\n    }\n}\n```\n\n### 实例二：大数组排序\n\n对大数组进行从小到大排序\n\n```java\n@Test\npublic void test4() {\n    int MAX = 10000;\n    int inits[] = new int[MAX];\n    for (int i = 0; i < inits.length; i++) {\n        inits[i] = RandomUtils.nextInt(0, MAX);\n    }\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinArraySortTask task = new ForkJoinArraySortTask(inits);\n    int[] result = pool.invoke(task);\n    //打印\n    Arrays.stream(result).forEach(System.out::println);\n}\n```\n\n```java\npublic class ForkJoinArraySortTask extends RecursiveTask<int[]> {\n    private int source[];\n\n    public ForkJoinArraySortTask(int[] source) {\n        this.source = source;\n    }\n\n    @Override\n    protected int[] compute() {\n        int sourceSize = source.length;\n        // 如果条件成立，说明任务中要进行排序的集合还不够小\n        if (sourceSize > 10) {\n            int midIndex = sourceSize / 2;\n            //拆分成两个子任务\n            ForkJoinArraySortTask leftTask = new ForkJoinArraySortTask(Arrays.copyOf(source, midIndex));\n            ForkJoinArraySortTask rightTask = new ForkJoinArraySortTask(Arrays.copyOfRange(source, midIndex, sourceSize));\n            invokeAll(leftTask,rightTask);\n            int result1[] = leftTask.join();\n            int result2[] = rightTask.join();\n            int mer[] = joinInts(result1, result2);\n            return mer;\n        } else {\n            //排序\n            return Arrays.stream(source).sorted().toArray();\n        }\n    }\n\n    /***\n     * 这个方法用于合并两个有序集合\n     * @param result1\n     * @param result2\n     * @return\n     */\n    private int[] joinInts(int[] result1, int[] result2) {\n        //现将两个数组合起来\n        int[] array = ArrayUtils.addAll(result1,result2);\n        //排序并去重\n        return Arrays.stream(array).sorted().toArray();\n    }\n}\n```\n\n### 实例三：大Map拆分对每个值加10\n\n对一个Map采用Fork/join实现value+10\n\n```java\n@Test\npublic void test6(){\n    Map<String, Integer> myMap = Maps.newHashMap();\n    for (int i = 0; i < 526252; i++) {\n        myMap.put(String.valueOf(i), 1);\n    }\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinMapDoTask forkJoinMapDoTask = new ForkJoinMapDoTask(myMap);\n    Map<String, Integer> invoke = pool.invoke(forkJoinMapDoTask);\n    System.out.println(invoke.keySet().size());\n    for(Map.Entry<String,Integer> entry : invoke.entrySet()){\n        if(entry.getValue() != 11){\n            System.out.println(\"不等于\");\n        }\n    }\n}\n```\n\n```java\n/***\n * 对一个大Map进行分割然后值加上10\n */\npublic class ForkJoinMapDoTask extends RecursiveTask<Map<String, Integer>> {\n\n    private static final int TASK_COUNT = 5000; //按照5000个拆分\n\n    private Map<String, Integer> myMap;\n\n    public ForkJoinMapDoTask(Map<String, Integer> myMap) {\n        this.myMap = myMap;\n    }\n\n\n    @Override\n    protected Map<String, Integer> compute() {\n\n        if (myMap.keySet().size() <= TASK_COUNT) {\n            Map<String, Integer> resultMap = Maps.newHashMap();\n            for (Map.Entry<String, Integer> entry : myMap.entrySet()) {\n                resultMap.put(entry.getKey(), entry.getValue() + 10);\n            }\n            return resultMap;\n        } else {\n            List<Map<String,Integer>> mapList = ForkJoinMapDoTask.mapChunk(myMap,2);\n            ForkJoinMapDoTask leftTask = new ForkJoinMapDoTask(mapList.get(0));\n            ForkJoinMapDoTask rightTask = new ForkJoinMapDoTask(mapList.get(1));\n            invokeAll(leftTask,rightTask);\n            Map<String, Integer> lfetMap = leftTask.join();\n            Map<String, Integer> rightMap = rightTask.join();\n            Map<String, Integer> resultMap = Maps.newHashMap();\n            resultMap.putAll(lfetMap);\n            resultMap.putAll(rightMap);\n            return resultMap;\n        }\n    }\n\n\n    public static <k, v> List<Map<k, v>> mapChunk(Map<k, v> chunkMap, int batch) {\n        List<Map<k,v>> resultList = Lists.newArrayList();\n        if(MapUtils.isEmpty(chunkMap)){\n            return Lists.newArrayList();\n        }\n        int keyLength = chunkMap.keySet().size();\n        int pageSize = keyLength % batch == 0 ? (keyLength / batch) : (keyLength / batch + 1);\n        //初始化数据\n        for(int i = 0 ; i < batch; i ++){\n            resultList.add(Maps.newHashMap());\n        }\n        int i = 0, count = 0;\n        for(Map.Entry<k,v> entry : chunkMap.entrySet()){\n            resultList.get(i).put(entry.getKey(),entry.getValue());\n            count++;\n            if(count % pageSize == 0){\n                i++;\n            }\n        }\n        return resultList;\n    }\n}\n```\n\n### Fork/Join框架的实现原理\n\nForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool，而ForkJoinWorkerThread负责执行这些任务;\n\n#### ForkJoinTask的fork方法的实现原理\n\n当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的workQueue中，异步地执行这个任务，然后立即返回结果，代码如下\n\n```java\npublic final ForkJoinTask<V> fork() {\n    Thread t;\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n        ((ForkJoinWorkerThread)t).workQueue.push(this);\n    else\n        ForkJoinPool.common.externalPush(this);\n    return this;\n}\n```\n\npushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：\n\n```java\nfinal void push(ForkJoinTask<?> task) {\n    ForkJoinTask<?>[] a; ForkJoinPool p;\n    int b = base, s = top, n;\n    if ((a = array) != null) {    // ignore if queue removed\n        int m = a.length - 1;     // fenced write for task visibility\n        U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);\n        U.putOrderedInt(this, QTOP, s + 1);\n        if ((n = s - b) <= 1) {\n            if ((p = pool) != null)\n                p.signalWork(p.workQueues, this);\n        }\n        else if (n >= m)\n            growArray();\n    }\n}\n```\n\n#### ForkJoinTask的join方法的实现原理\n\noin方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下：\n\n```java\npublic final V join() {\n\tint s;\n    if ((s = doJoin() & DONE_MASK) != NORMAL){\n    \treportException(s);\n    }\n    return getRawResult();\n}\n```\n\n它首先调用doJoin方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）；\n如果任务状态是已完成，则直接返回任务结果；\n如果任务状态是被取消，则直接抛出CancellationException；\n如果任务状态是抛出异常，则直接抛出对应的异常；\ndoJoin方法的实现，代码如下：\n\n```java\nprivate int doJoin() {\n\tint s;\n\tThread t;\n\tForkJoinWorkerThread wt;\n\tForkJoinPool.WorkQueue w;\n    return (s = status) < 0 ? s :\n            ((t = Thread.currentThread()) instanceof \t\t\t\t\t\t\t\tForkJoinWorkerThread) ? (w = (wt = \t\t\t\t\t\t\t\t\t\t(ForkJoinWorkerThread)t).workQueue).tryUnpush(this) && (s = \t\t\t\tdoExec()) < 0 ? s : wt.pool.awaitJoin(w, this, 0L) : \t\t\t\texternalAwaitDone();\n}\n```\n\ndoExec() :\n\n```java\nfinal int doExec() {\n\tint s; \n\tboolean completed;\n\tif ((s = status) >= 0) {\n\t\ttry {\n\t\t\tcompleted = exec();\n\t\t} catch (Throwable rex) {\n\t\t\treturn setExceptionalCompletion(rex);\n\t\t}\n\t\tif (completed){\n\t\t\ts = setCompletion(NORMAL);\n\t\t}\n\t}\n\treturn s;\n}\n```\n\n在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。","source":"_posts/fork-join.md","raw":"---\ntitle: Fork/join框架你会用吗？\ntags:\n  - java并发\ncategories:  java\ndescription : 详解Fork/join框架\ndate: 2020-07-30 16:35:57\n---\n## Fork/Join框架介绍\n\n### 介绍\n\nFork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork/Join框架要完成两件事情：\n- 任务分割：首先Fork/Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割\n- 执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据\n\n### 使用场景\n\nForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。FokJoinPool主要适用于<font color=red>计算密集型的任务</font>。例如对一个大数组求和，排序等场景。\n<!--more-->\n## 如何使用Fork/Join框架？\n\n使用Fork/Join框架，首先需要创建一个ForkJoin任务。该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集成ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了两个子类:\n\n- RecursiveAction 用于没有返回结果的任务\n- RecursiveTask 用于有返回结果的任务\n\n### 实例一：大数组求和\n\n对一个大数组进行求和。代码如下\n\n```java\n@Test\npublic void test() {\n    long[] numbers = LongStream.rangeClosed(1, 5263).toArray();\n    ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers);\n    long start = System.currentTimeMillis();\n    long result = new ForkJoinPool().invoke(task);\n    System.out.println(\"结果 = \" + result  + \", 耗时 = \" + (System.currentTimeMillis() - start) + \" ms\");\n}\n```\n\n```java\nimport java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinSumCalculator extends RecursiveTask<Long> {\n    //不再将任务分解为子任务的数组大小\n    public static final long THRESHOLD = 100;\n    private final long[] numbers;\n    private final int start; //起始位置\n    private final int end; //终止位置\n    public ForkJoinSumCalculator(long[] numbers) {\n        this(numbers, 0, numbers.length);\n    }\n    private ForkJoinSumCalculator(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        if (length <= THRESHOLD) {\n            return computeSequentially();\n        }\n        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(numbers,start,start + length / 2);\n        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(numbers, start + length/2, end);\n        invokeAll(leftTask,rightTask);\n        Long rightResult = rightTask.join();\n        Long leftResult = leftTask.join();\n        return leftResult + rightResult;\n    }\n\n    /**\n        求和\n    */\n    private long computeSequentially() {\n        long sum = 0;\n        for (int i = start; i < end; i++) {\n            sum += numbers[i];\n        }\n        return sum;\n    }\n}\n```\n\n### 实例二：大数组排序\n\n对大数组进行从小到大排序\n\n```java\n@Test\npublic void test4() {\n    int MAX = 10000;\n    int inits[] = new int[MAX];\n    for (int i = 0; i < inits.length; i++) {\n        inits[i] = RandomUtils.nextInt(0, MAX);\n    }\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinArraySortTask task = new ForkJoinArraySortTask(inits);\n    int[] result = pool.invoke(task);\n    //打印\n    Arrays.stream(result).forEach(System.out::println);\n}\n```\n\n```java\npublic class ForkJoinArraySortTask extends RecursiveTask<int[]> {\n    private int source[];\n\n    public ForkJoinArraySortTask(int[] source) {\n        this.source = source;\n    }\n\n    @Override\n    protected int[] compute() {\n        int sourceSize = source.length;\n        // 如果条件成立，说明任务中要进行排序的集合还不够小\n        if (sourceSize > 10) {\n            int midIndex = sourceSize / 2;\n            //拆分成两个子任务\n            ForkJoinArraySortTask leftTask = new ForkJoinArraySortTask(Arrays.copyOf(source, midIndex));\n            ForkJoinArraySortTask rightTask = new ForkJoinArraySortTask(Arrays.copyOfRange(source, midIndex, sourceSize));\n            invokeAll(leftTask,rightTask);\n            int result1[] = leftTask.join();\n            int result2[] = rightTask.join();\n            int mer[] = joinInts(result1, result2);\n            return mer;\n        } else {\n            //排序\n            return Arrays.stream(source).sorted().toArray();\n        }\n    }\n\n    /***\n     * 这个方法用于合并两个有序集合\n     * @param result1\n     * @param result2\n     * @return\n     */\n    private int[] joinInts(int[] result1, int[] result2) {\n        //现将两个数组合起来\n        int[] array = ArrayUtils.addAll(result1,result2);\n        //排序并去重\n        return Arrays.stream(array).sorted().toArray();\n    }\n}\n```\n\n### 实例三：大Map拆分对每个值加10\n\n对一个Map采用Fork/join实现value+10\n\n```java\n@Test\npublic void test6(){\n    Map<String, Integer> myMap = Maps.newHashMap();\n    for (int i = 0; i < 526252; i++) {\n        myMap.put(String.valueOf(i), 1);\n    }\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinMapDoTask forkJoinMapDoTask = new ForkJoinMapDoTask(myMap);\n    Map<String, Integer> invoke = pool.invoke(forkJoinMapDoTask);\n    System.out.println(invoke.keySet().size());\n    for(Map.Entry<String,Integer> entry : invoke.entrySet()){\n        if(entry.getValue() != 11){\n            System.out.println(\"不等于\");\n        }\n    }\n}\n```\n\n```java\n/***\n * 对一个大Map进行分割然后值加上10\n */\npublic class ForkJoinMapDoTask extends RecursiveTask<Map<String, Integer>> {\n\n    private static final int TASK_COUNT = 5000; //按照5000个拆分\n\n    private Map<String, Integer> myMap;\n\n    public ForkJoinMapDoTask(Map<String, Integer> myMap) {\n        this.myMap = myMap;\n    }\n\n\n    @Override\n    protected Map<String, Integer> compute() {\n\n        if (myMap.keySet().size() <= TASK_COUNT) {\n            Map<String, Integer> resultMap = Maps.newHashMap();\n            for (Map.Entry<String, Integer> entry : myMap.entrySet()) {\n                resultMap.put(entry.getKey(), entry.getValue() + 10);\n            }\n            return resultMap;\n        } else {\n            List<Map<String,Integer>> mapList = ForkJoinMapDoTask.mapChunk(myMap,2);\n            ForkJoinMapDoTask leftTask = new ForkJoinMapDoTask(mapList.get(0));\n            ForkJoinMapDoTask rightTask = new ForkJoinMapDoTask(mapList.get(1));\n            invokeAll(leftTask,rightTask);\n            Map<String, Integer> lfetMap = leftTask.join();\n            Map<String, Integer> rightMap = rightTask.join();\n            Map<String, Integer> resultMap = Maps.newHashMap();\n            resultMap.putAll(lfetMap);\n            resultMap.putAll(rightMap);\n            return resultMap;\n        }\n    }\n\n\n    public static <k, v> List<Map<k, v>> mapChunk(Map<k, v> chunkMap, int batch) {\n        List<Map<k,v>> resultList = Lists.newArrayList();\n        if(MapUtils.isEmpty(chunkMap)){\n            return Lists.newArrayList();\n        }\n        int keyLength = chunkMap.keySet().size();\n        int pageSize = keyLength % batch == 0 ? (keyLength / batch) : (keyLength / batch + 1);\n        //初始化数据\n        for(int i = 0 ; i < batch; i ++){\n            resultList.add(Maps.newHashMap());\n        }\n        int i = 0, count = 0;\n        for(Map.Entry<k,v> entry : chunkMap.entrySet()){\n            resultList.get(i).put(entry.getKey(),entry.getValue());\n            count++;\n            if(count % pageSize == 0){\n                i++;\n            }\n        }\n        return resultList;\n    }\n}\n```\n\n### Fork/Join框架的实现原理\n\nForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool，而ForkJoinWorkerThread负责执行这些任务;\n\n#### ForkJoinTask的fork方法的实现原理\n\n当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的workQueue中，异步地执行这个任务，然后立即返回结果，代码如下\n\n```java\npublic final ForkJoinTask<V> fork() {\n    Thread t;\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n        ((ForkJoinWorkerThread)t).workQueue.push(this);\n    else\n        ForkJoinPool.common.externalPush(this);\n    return this;\n}\n```\n\npushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：\n\n```java\nfinal void push(ForkJoinTask<?> task) {\n    ForkJoinTask<?>[] a; ForkJoinPool p;\n    int b = base, s = top, n;\n    if ((a = array) != null) {    // ignore if queue removed\n        int m = a.length - 1;     // fenced write for task visibility\n        U.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);\n        U.putOrderedInt(this, QTOP, s + 1);\n        if ((n = s - b) <= 1) {\n            if ((p = pool) != null)\n                p.signalWork(p.workQueues, this);\n        }\n        else if (n >= m)\n            growArray();\n    }\n}\n```\n\n#### ForkJoinTask的join方法的实现原理\n\noin方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下：\n\n```java\npublic final V join() {\n\tint s;\n    if ((s = doJoin() & DONE_MASK) != NORMAL){\n    \treportException(s);\n    }\n    return getRawResult();\n}\n```\n\n它首先调用doJoin方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）；\n如果任务状态是已完成，则直接返回任务结果；\n如果任务状态是被取消，则直接抛出CancellationException；\n如果任务状态是抛出异常，则直接抛出对应的异常；\ndoJoin方法的实现，代码如下：\n\n```java\nprivate int doJoin() {\n\tint s;\n\tThread t;\n\tForkJoinWorkerThread wt;\n\tForkJoinPool.WorkQueue w;\n    return (s = status) < 0 ? s :\n            ((t = Thread.currentThread()) instanceof \t\t\t\t\t\t\t\tForkJoinWorkerThread) ? (w = (wt = \t\t\t\t\t\t\t\t\t\t(ForkJoinWorkerThread)t).workQueue).tryUnpush(this) && (s = \t\t\t\tdoExec()) < 0 ? s : wt.pool.awaitJoin(w, this, 0L) : \t\t\t\texternalAwaitDone();\n}\n```\n\ndoExec() :\n\n```java\nfinal int doExec() {\n\tint s; \n\tboolean completed;\n\tif ((s = status) >= 0) {\n\t\ttry {\n\t\t\tcompleted = exec();\n\t\t} catch (Throwable rex) {\n\t\t\treturn setExceptionalCompletion(rex);\n\t\t}\n\t\tif (completed){\n\t\t\ts = setCompletion(NORMAL);\n\t\t}\n\t}\n\treturn s;\n}\n```\n\n在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。","slug":"fork-join","published":1,"updated":"2021-04-08T00:47:06.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhul000bqwv28px8gnnq","content":"<h2 id=\"Fork-Join框架介绍\"><a href=\"#Fork-Join框架介绍\" class=\"headerlink\" title=\"Fork/Join框架介绍\"></a>Fork/Join框架介绍</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork/Join框架要完成两件事情：</p>\n<ul>\n<li>任务分割：首先Fork/Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</li>\n<li>执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据</li>\n</ul>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。FokJoinPool主要适用于<font color=\"red\">计算密集型的任务</font>。例如对一个大数组求和，排序等场景。</p>\n<a id=\"more\"></a>\n<h2 id=\"如何使用Fork-Join框架？\"><a href=\"#如何使用Fork-Join框架？\" class=\"headerlink\" title=\"如何使用Fork/Join框架？\"></a>如何使用Fork/Join框架？</h2><p>使用Fork/Join框架，首先需要创建一个ForkJoin任务。该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集成ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了两个子类:</p>\n<ul>\n<li>RecursiveAction 用于没有返回结果的任务</li>\n<li>RecursiveTask 用于有返回结果的任务</li>\n</ul>\n<h3 id=\"实例一：大数组求和\"><a href=\"#实例一：大数组求和\" class=\"headerlink\" title=\"实例一：大数组求和\"></a>实例一：大数组求和</h3><p>对一个大数组进行求和。代码如下</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">long</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> numbers <span class=\"token operator\">=</span> LongStream<span class=\"token punctuation\">.</span><span class=\"token function\">rangeClosed</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5263</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ForkJoinTask<span class=\"token operator\">&lt;</span>Long<span class=\"token operator\">></span> task <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinSumCalculator</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">long</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"结果 = \"</span> <span class=\"token operator\">+</span> result  <span class=\"token operator\">+</span> <span class=\"token string\">\", 耗时 = \"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>RecursiveTask<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ForkJoinSumCalculator</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RecursiveTask</span><span class=\"token operator\">&lt;</span>Long<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//不再将任务分解为子任务的数组大小</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> THRESHOLD <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> numbers<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//起始位置</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//终止位置</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ForkJoinSumCalculator</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> numbers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> numbers<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">private</span> <span class=\"token function\">ForkJoinSumCalculator</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> numbers<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> start<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> end<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>numbers <span class=\"token operator\">=</span> numbers<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>start <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>end <span class=\"token operator\">=</span> end<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> Long <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> length <span class=\"token operator\">=</span> end <span class=\"token operator\">-</span> start<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>length <span class=\"token operator\">&lt;=</span> THRESHOLD<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">computeSequentially</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        ForkJoinSumCalculator leftTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinSumCalculator</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">,</span>start<span class=\"token punctuation\">,</span>start <span class=\"token operator\">+</span> length <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ForkJoinSumCalculator rightTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinSumCalculator</span><span class=\"token punctuation\">(</span>numbers<span class=\"token punctuation\">,</span> start <span class=\"token operator\">+</span> length<span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> end<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">invokeAll</span><span class=\"token punctuation\">(</span>leftTask<span class=\"token punctuation\">,</span>rightTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Long rightResult <span class=\"token operator\">=</span> rightTask<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Long leftResult <span class=\"token operator\">=</span> leftTask<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> leftResult <span class=\"token operator\">+</span> rightResult<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/**\n        求和\n    */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">long</span> <span class=\"token function\">computeSequentially</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">long</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> start<span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> end<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            sum <span class=\"token operator\">+=</span> numbers<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> sum<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"实例二：大数组排序\"><a href=\"#实例二：大数组排序\" class=\"headerlink\" title=\"实例二：大数组排序\"></a>实例二：大数组排序</h3><p>对大数组进行从小到大排序</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test4</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> MAX <span class=\"token operator\">=</span> <span class=\"token number\">10000</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> inits<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">int</span><span class=\"token punctuation\">[</span>MAX<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> inits<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        inits<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> RandomUtils<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> MAX<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    ForkJoinPool pool <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ForkJoinArraySortTask task <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinArraySortTask</span><span class=\"token punctuation\">(</span>inits<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> result <span class=\"token operator\">=</span> pool<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//打印</span>\n    Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span>out<span class=\"token operator\">:</span><span class=\"token operator\">:</span>println<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ForkJoinArraySortTask</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RecursiveTask</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> source<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ForkJoinArraySortTask</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> source<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>source <span class=\"token operator\">=</span> source<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> sourceSize <span class=\"token operator\">=</span> source<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 如果条件成立，说明任务中要进行排序的集合还不够小</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sourceSize <span class=\"token operator\">></span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> midIndex <span class=\"token operator\">=</span> sourceSize <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//拆分成两个子任务</span>\n            ForkJoinArraySortTask leftTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinArraySortTask</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">,</span> midIndex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ForkJoinArraySortTask rightTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinArraySortTask</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOfRange</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">,</span> midIndex<span class=\"token punctuation\">,</span> sourceSize<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">invokeAll</span><span class=\"token punctuation\">(</span>leftTask<span class=\"token punctuation\">,</span>rightTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> result1<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> leftTask<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> result2<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> rightTask<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">int</span> mer<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">joinInts</span><span class=\"token punctuation\">(</span>result1<span class=\"token punctuation\">,</span> result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> mer<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//排序</span>\n            <span class=\"token keyword\">return</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>source<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sorted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 这个方法用于合并两个有序集合\n     * @param result1\n     * @param result2\n     * @return\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">joinInts</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> result1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> result2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//现将两个数组合起来</span>\n        <span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> array <span class=\"token operator\">=</span> ArrayUtils<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>result1<span class=\"token punctuation\">,</span>result2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//排序并去重</span>\n        <span class=\"token keyword\">return</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sorted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"实例三：大Map拆分对每个值加10\"><a href=\"#实例三：大Map拆分对每个值加10\" class=\"headerlink\" title=\"实例三：大Map拆分对每个值加10\"></a>实例三：大Map拆分对每个值加10</h3><p>对一个Map采用Fork/join实现value+10</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test6</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> myMap <span class=\"token operator\">=</span> Maps<span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">526252</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        myMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    ForkJoinPool pool <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ForkJoinMapDoTask forkJoinMapDoTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinMapDoTask</span><span class=\"token punctuation\">(</span>myMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> invoke <span class=\"token operator\">=</span> pool<span class=\"token punctuation\">.</span><span class=\"token function\">invoke</span><span class=\"token punctuation\">(</span>forkJoinMapDoTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>invoke<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span>Integer<span class=\"token operator\">></span> entry <span class=\"token operator\">:</span> invoke<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">11</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"不等于\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/***\n * 对一个大Map进行分割然后值加上10\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ForkJoinMapDoTask</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">RecursiveTask</span><span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">>></span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> TASK_COUNT <span class=\"token operator\">=</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//按照5000个拆分</span>\n\n    <span class=\"token keyword\">private</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> myMap<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ForkJoinMapDoTask</span><span class=\"token punctuation\">(</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> myMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>myMap <span class=\"token operator\">=</span> myMap<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> <span class=\"token function\">compute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> TASK_COUNT<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> resultMap <span class=\"token operator\">=</span> Maps<span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> entry <span class=\"token operator\">:</span> myMap<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                resultMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">return</span> resultMap<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span>Integer<span class=\"token operator\">>></span> mapList <span class=\"token operator\">=</span> ForkJoinMapDoTask<span class=\"token punctuation\">.</span><span class=\"token function\">mapChunk</span><span class=\"token punctuation\">(</span>myMap<span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ForkJoinMapDoTask leftTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinMapDoTask</span><span class=\"token punctuation\">(</span>mapList<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            ForkJoinMapDoTask rightTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ForkJoinMapDoTask</span><span class=\"token punctuation\">(</span>mapList<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">invokeAll</span><span class=\"token punctuation\">(</span>leftTask<span class=\"token punctuation\">,</span>rightTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> lfetMap <span class=\"token operator\">=</span> leftTask<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> rightMap <span class=\"token operator\">=</span> rightTask<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Integer<span class=\"token operator\">></span> resultMap <span class=\"token operator\">=</span> Maps<span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            resultMap<span class=\"token punctuation\">.</span><span class=\"token function\">putAll</span><span class=\"token punctuation\">(</span>lfetMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            resultMap<span class=\"token punctuation\">.</span><span class=\"token function\">putAll</span><span class=\"token punctuation\">(</span>rightMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> resultMap<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token operator\">&lt;</span>k<span class=\"token punctuation\">,</span> v<span class=\"token operator\">></span> List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>k<span class=\"token punctuation\">,</span> v<span class=\"token operator\">>></span> <span class=\"token function\">mapChunk</span><span class=\"token punctuation\">(</span>Map<span class=\"token operator\">&lt;</span>k<span class=\"token punctuation\">,</span> v<span class=\"token operator\">></span> chunkMap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> batch<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>k<span class=\"token punctuation\">,</span>v<span class=\"token operator\">>></span> resultList <span class=\"token operator\">=</span> Lists<span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>MapUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>chunkMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> Lists<span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">int</span> keyLength <span class=\"token operator\">=</span> chunkMap<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> pageSize <span class=\"token operator\">=</span> keyLength <span class=\"token operator\">%</span> batch <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>keyLength <span class=\"token operator\">/</span> batch<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>keyLength <span class=\"token operator\">/</span> batch <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//初始化数据</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> batch<span class=\"token punctuation\">;</span> i <span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            resultList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>Maps<span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>Map<span class=\"token punctuation\">.</span>Entry<span class=\"token operator\">&lt;</span>k<span class=\"token punctuation\">,</span>v<span class=\"token operator\">></span> entry <span class=\"token operator\">:</span> chunkMap<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            resultList<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>entry<span class=\"token punctuation\">.</span><span class=\"token function\">getValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            count<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">%</span> pageSize <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> resultList<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"Fork-Join框架的实现原理\"><a href=\"#Fork-Join框架的实现原理\" class=\"headerlink\" title=\"Fork/Join框架的实现原理\"></a>Fork/Join框架的实现原理</h3><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool，而ForkJoinWorkerThread负责执行这些任务;</p>\n<h4 id=\"ForkJoinTask的fork方法的实现原理\"><a href=\"#ForkJoinTask的fork方法的实现原理\" class=\"headerlink\" title=\"ForkJoinTask的fork方法的实现原理\"></a>ForkJoinTask的fork方法的实现原理</h4><p>当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的workQueue中，异步地执行这个任务，然后立即返回结果，代码如下</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> ForkJoinTask<span class=\"token operator\">&lt;</span>V<span class=\"token operator\">></span> <span class=\"token function\">fork</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Thread t<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ForkJoinWorkerThread</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ForkJoinWorkerThread<span class=\"token punctuation\">)</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>workQueue<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        ForkJoinPool<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span><span class=\"token function\">externalPush</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">push</span><span class=\"token punctuation\">(</span>ForkJoinTask<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> task<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ForkJoinTask<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> a<span class=\"token punctuation\">;</span> ForkJoinPool p<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> b <span class=\"token operator\">=</span> base<span class=\"token punctuation\">,</span> s <span class=\"token operator\">=</span> top<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a <span class=\"token operator\">=</span> array<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">// ignore if queue removed</span>\n        <span class=\"token keyword\">int</span> m <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\" spellcheck=\"true\">// fenced write for task visibility</span>\n        U<span class=\"token punctuation\">.</span><span class=\"token function\">putOrderedObject</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">&amp;</span> s<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> ASHIFT<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> ABASE<span class=\"token punctuation\">,</span> task<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        U<span class=\"token punctuation\">.</span><span class=\"token function\">putOrderedInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> QTOP<span class=\"token punctuation\">,</span> s <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> s <span class=\"token operator\">-</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> pool<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n                p<span class=\"token punctuation\">.</span><span class=\"token function\">signalWork</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>workQueues<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">>=</span> m<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">growArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"ForkJoinTask的join方法的实现原理\"><a href=\"#ForkJoinTask的join方法的实现原理\" class=\"headerlink\" title=\"ForkJoinTask的join方法的实现原理\"></a>ForkJoinTask的join方法的实现原理</h4><p>oin方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> V <span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>s <span class=\"token operator\">=</span> <span class=\"token function\">doJoin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> DONE_MASK<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> NORMAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">reportException</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">getRawResult</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>它首先调用doJoin方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）；<br>如果任务状态是已完成，则直接返回任务结果；<br>如果任务状态是被取消，则直接抛出CancellationException；<br>如果任务状态是抛出异常，则直接抛出对应的异常；<br>doJoin方法的实现，代码如下：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">doJoin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> s<span class=\"token punctuation\">;</span>\n    Thread t<span class=\"token punctuation\">;</span>\n    ForkJoinWorkerThread wt<span class=\"token punctuation\">;</span>\n    ForkJoinPool<span class=\"token punctuation\">.</span>WorkQueue w<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">=</span> status<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> s <span class=\"token operator\">:</span>\n            <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">instanceof</span>                                 <span class=\"token class-name\">ForkJoinWorkerThread</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token punctuation\">(</span>w <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>wt <span class=\"token operator\">=</span>                                         <span class=\"token punctuation\">(</span>ForkJoinWorkerThread<span class=\"token punctuation\">)</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>workQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">tryUnpush</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">=</span>                 <span class=\"token function\">doExec</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span> <span class=\"token operator\">?</span> s <span class=\"token operator\">:</span> wt<span class=\"token punctuation\">.</span>pool<span class=\"token punctuation\">.</span><span class=\"token function\">awaitJoin</span><span class=\"token punctuation\">(</span>w<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> 0L<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span>                 <span class=\"token function\">externalAwaitDone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>doExec() :</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">doExec</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> s<span class=\"token punctuation\">;</span> \n    <span class=\"token keyword\">boolean</span> completed<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>s <span class=\"token operator\">=</span> status<span class=\"token punctuation\">)</span> <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            completed <span class=\"token operator\">=</span> <span class=\"token function\">exec</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> rex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">setExceptionalCompletion</span><span class=\"token punctuation\">(</span>rex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>completed<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            s <span class=\"token operator\">=</span> <span class=\"token function\">setCompletion</span><span class=\"token punctuation\">(</span>NORMAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Fork-Join框架介绍\"><a href=\"#Fork-Join框架介绍\" class=\"headerlink\" title=\"Fork/Join框架介绍\"></a>Fork/Join框架介绍</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork/Join框架要完成两件事情：</p>\n<ul>\n<li>任务分割：首先Fork/Join框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割</li>\n<li>执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据</li>\n</ul>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>ForkJoinPool 不是为了替代 ExecutorService，而是它的补充，在某些应用场景下性能比 ExecutorService 更好。FokJoinPool主要适用于<font color=\"red\">计算密集型的任务</font>。例如对一个大数组求和，排序等场景。</p>","more":"<h2 id=\"如何使用Fork-Join框架？\"><a href=\"#如何使用Fork-Join框架？\" class=\"headerlink\" title=\"如何使用Fork/Join框架？\"></a>如何使用Fork/Join框架？</h2><p>使用Fork/Join框架，首先需要创建一个ForkJoin任务。该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集成ForkJoinTask类，只需要继承它的子类，Fork/Join框架提供了两个子类:</p>\n<ul>\n<li>RecursiveAction 用于没有返回结果的任务</li>\n<li>RecursiveTask 用于有返回结果的任务</li>\n</ul>\n<h3 id=\"实例一：大数组求和\"><a href=\"#实例一：大数组求和\" class=\"headerlink\" title=\"实例一：大数组求和\"></a>实例一：大数组求和</h3><p>对一个大数组进行求和。代码如下</p>\n<pre><code class=\"java\">@Test\npublic void test() {\n    long[] numbers = LongStream.rangeClosed(1, 5263).toArray();\n    ForkJoinTask&lt;Long&gt; task = new ForkJoinSumCalculator(numbers);\n    long start = System.currentTimeMillis();\n    long result = new ForkJoinPool().invoke(task);\n    System.out.println(&quot;结果 = &quot; + result  + &quot;, 耗时 = &quot; + (System.currentTimeMillis() - start) + &quot; ms&quot;);\n}</code></pre>\n<pre><code class=\"java\">import java.util.concurrent.RecursiveTask;\n\npublic class ForkJoinSumCalculator extends RecursiveTask&lt;Long&gt; {\n    //不再将任务分解为子任务的数组大小\n    public static final long THRESHOLD = 100;\n    private final long[] numbers;\n    private final int start; //起始位置\n    private final int end; //终止位置\n    public ForkJoinSumCalculator(long[] numbers) {\n        this(numbers, 0, numbers.length);\n    }\n    private ForkJoinSumCalculator(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n        if (length &lt;= THRESHOLD) {\n            return computeSequentially();\n        }\n        ForkJoinSumCalculator leftTask = new ForkJoinSumCalculator(numbers,start,start + length / 2);\n        ForkJoinSumCalculator rightTask = new ForkJoinSumCalculator(numbers, start + length/2, end);\n        invokeAll(leftTask,rightTask);\n        Long rightResult = rightTask.join();\n        Long leftResult = leftTask.join();\n        return leftResult + rightResult;\n    }\n\n    /**\n        求和\n    */\n    private long computeSequentially() {\n        long sum = 0;\n        for (int i = start; i &lt; end; i++) {\n            sum += numbers[i];\n        }\n        return sum;\n    }\n}</code></pre>\n<h3 id=\"实例二：大数组排序\"><a href=\"#实例二：大数组排序\" class=\"headerlink\" title=\"实例二：大数组排序\"></a>实例二：大数组排序</h3><p>对大数组进行从小到大排序</p>\n<pre><code class=\"java\">@Test\npublic void test4() {\n    int MAX = 10000;\n    int inits[] = new int[MAX];\n    for (int i = 0; i &lt; inits.length; i++) {\n        inits[i] = RandomUtils.nextInt(0, MAX);\n    }\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinArraySortTask task = new ForkJoinArraySortTask(inits);\n    int[] result = pool.invoke(task);\n    //打印\n    Arrays.stream(result).forEach(System.out::println);\n}</code></pre>\n<pre><code class=\"java\">public class ForkJoinArraySortTask extends RecursiveTask&lt;int[]&gt; {\n    private int source[];\n\n    public ForkJoinArraySortTask(int[] source) {\n        this.source = source;\n    }\n\n    @Override\n    protected int[] compute() {\n        int sourceSize = source.length;\n        // 如果条件成立，说明任务中要进行排序的集合还不够小\n        if (sourceSize &gt; 10) {\n            int midIndex = sourceSize / 2;\n            //拆分成两个子任务\n            ForkJoinArraySortTask leftTask = new ForkJoinArraySortTask(Arrays.copyOf(source, midIndex));\n            ForkJoinArraySortTask rightTask = new ForkJoinArraySortTask(Arrays.copyOfRange(source, midIndex, sourceSize));\n            invokeAll(leftTask,rightTask);\n            int result1[] = leftTask.join();\n            int result2[] = rightTask.join();\n            int mer[] = joinInts(result1, result2);\n            return mer;\n        } else {\n            //排序\n            return Arrays.stream(source).sorted().toArray();\n        }\n    }\n\n    /***\n     * 这个方法用于合并两个有序集合\n     * @param result1\n     * @param result2\n     * @return\n     */\n    private int[] joinInts(int[] result1, int[] result2) {\n        //现将两个数组合起来\n        int[] array = ArrayUtils.addAll(result1,result2);\n        //排序并去重\n        return Arrays.stream(array).sorted().toArray();\n    }\n}</code></pre>\n<h3 id=\"实例三：大Map拆分对每个值加10\"><a href=\"#实例三：大Map拆分对每个值加10\" class=\"headerlink\" title=\"实例三：大Map拆分对每个值加10\"></a>实例三：大Map拆分对每个值加10</h3><p>对一个Map采用Fork/join实现value+10</p>\n<pre><code class=\"java\">@Test\npublic void test6(){\n    Map&lt;String, Integer&gt; myMap = Maps.newHashMap();\n    for (int i = 0; i &lt; 526252; i++) {\n        myMap.put(String.valueOf(i), 1);\n    }\n    ForkJoinPool pool = new ForkJoinPool();\n    ForkJoinMapDoTask forkJoinMapDoTask = new ForkJoinMapDoTask(myMap);\n    Map&lt;String, Integer&gt; invoke = pool.invoke(forkJoinMapDoTask);\n    System.out.println(invoke.keySet().size());\n    for(Map.Entry&lt;String,Integer&gt; entry : invoke.entrySet()){\n        if(entry.getValue() != 11){\n            System.out.println(&quot;不等于&quot;);\n        }\n    }\n}</code></pre>\n<pre><code class=\"java\">/***\n * 对一个大Map进行分割然后值加上10\n */\npublic class ForkJoinMapDoTask extends RecursiveTask&lt;Map&lt;String, Integer&gt;&gt; {\n\n    private static final int TASK_COUNT = 5000; //按照5000个拆分\n\n    private Map&lt;String, Integer&gt; myMap;\n\n    public ForkJoinMapDoTask(Map&lt;String, Integer&gt; myMap) {\n        this.myMap = myMap;\n    }\n\n\n    @Override\n    protected Map&lt;String, Integer&gt; compute() {\n\n        if (myMap.keySet().size() &lt;= TASK_COUNT) {\n            Map&lt;String, Integer&gt; resultMap = Maps.newHashMap();\n            for (Map.Entry&lt;String, Integer&gt; entry : myMap.entrySet()) {\n                resultMap.put(entry.getKey(), entry.getValue() + 10);\n            }\n            return resultMap;\n        } else {\n            List&lt;Map&lt;String,Integer&gt;&gt; mapList = ForkJoinMapDoTask.mapChunk(myMap,2);\n            ForkJoinMapDoTask leftTask = new ForkJoinMapDoTask(mapList.get(0));\n            ForkJoinMapDoTask rightTask = new ForkJoinMapDoTask(mapList.get(1));\n            invokeAll(leftTask,rightTask);\n            Map&lt;String, Integer&gt; lfetMap = leftTask.join();\n            Map&lt;String, Integer&gt; rightMap = rightTask.join();\n            Map&lt;String, Integer&gt; resultMap = Maps.newHashMap();\n            resultMap.putAll(lfetMap);\n            resultMap.putAll(rightMap);\n            return resultMap;\n        }\n    }\n\n\n    public static &lt;k, v&gt; List&lt;Map&lt;k, v&gt;&gt; mapChunk(Map&lt;k, v&gt; chunkMap, int batch) {\n        List&lt;Map&lt;k,v&gt;&gt; resultList = Lists.newArrayList();\n        if(MapUtils.isEmpty(chunkMap)){\n            return Lists.newArrayList();\n        }\n        int keyLength = chunkMap.keySet().size();\n        int pageSize = keyLength % batch == 0 ? (keyLength / batch) : (keyLength / batch + 1);\n        //初始化数据\n        for(int i = 0 ; i &lt; batch; i ++){\n            resultList.add(Maps.newHashMap());\n        }\n        int i = 0, count = 0;\n        for(Map.Entry&lt;k,v&gt; entry : chunkMap.entrySet()){\n            resultList.get(i).put(entry.getKey(),entry.getValue());\n            count++;\n            if(count % pageSize == 0){\n                i++;\n            }\n        }\n        return resultList;\n    }\n}</code></pre>\n<h3 id=\"Fork-Join框架的实现原理\"><a href=\"#Fork-Join框架的实现原理\" class=\"headerlink\" title=\"Fork/Join框架的实现原理\"></a>Fork/Join框架的实现原理</h3><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool，而ForkJoinWorkerThread负责执行这些任务;</p>\n<h4 id=\"ForkJoinTask的fork方法的实现原理\"><a href=\"#ForkJoinTask的fork方法的实现原理\" class=\"headerlink\" title=\"ForkJoinTask的fork方法的实现原理\"></a>ForkJoinTask的fork方法的实现原理</h4><p>当我们调用ForkJoinTask的fork方法时，程序会把任务放在ForkJoinWorkerThread的pushTask的workQueue中，异步地执行这个任务，然后立即返回结果，代码如下</p>\n<pre><code class=\"java\">public final ForkJoinTask&lt;V&gt; fork() {\n    Thread t;\n    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n        ((ForkJoinWorkerThread)t).workQueue.push(this);\n    else\n        ForkJoinPool.common.externalPush(this);\n    return this;\n}</code></pre>\n<p>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代码如下：</p>\n<pre><code class=\"java\">final void push(ForkJoinTask&lt;?&gt; task) {\n    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;\n    int b = base, s = top, n;\n    if ((a = array) != null) {    // ignore if queue removed\n        int m = a.length - 1;     // fenced write for task visibility\n        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);\n        U.putOrderedInt(this, QTOP, s + 1);\n        if ((n = s - b) &lt;= 1) {\n            if ((p = pool) != null)\n                p.signalWork(p.workQueues, this);\n        }\n        else if (n &gt;= m)\n            growArray();\n    }\n}</code></pre>\n<h4 id=\"ForkJoinTask的join方法的实现原理\"><a href=\"#ForkJoinTask的join方法的实现原理\" class=\"headerlink\" title=\"ForkJoinTask的join方法的实现原理\"></a>ForkJoinTask的join方法的实现原理</h4><p>oin方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask的join方法的实现，代码如下：</p>\n<pre><code class=\"java\">public final V join() {\n    int s;\n    if ((s = doJoin() &amp; DONE_MASK) != NORMAL){\n        reportException(s);\n    }\n    return getRawResult();\n}</code></pre>\n<p>它首先调用doJoin方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）；<br>如果任务状态是已完成，则直接返回任务结果；<br>如果任务状态是被取消，则直接抛出CancellationException；<br>如果任务状态是抛出异常，则直接抛出对应的异常；<br>doJoin方法的实现，代码如下：</p>\n<pre><code class=\"java\">private int doJoin() {\n    int s;\n    Thread t;\n    ForkJoinWorkerThread wt;\n    ForkJoinPool.WorkQueue w;\n    return (s = status) &lt; 0 ? s :\n            ((t = Thread.currentThread()) instanceof                                 ForkJoinWorkerThread) ? (w = (wt =                                         (ForkJoinWorkerThread)t).workQueue).tryUnpush(this) &amp;&amp; (s =                 doExec()) &lt; 0 ? s : wt.pool.awaitJoin(w, this, 0L) :                 externalAwaitDone();\n}</code></pre>\n<p>doExec() :</p>\n<pre><code class=\"java\">final int doExec() {\n    int s; \n    boolean completed;\n    if ((s = status) &gt;= 0) {\n        try {\n            completed = exec();\n        } catch (Throwable rex) {\n            return setExceptionalCompletion(rex);\n        }\n        if (completed){\n            s = setCompletion(NORMAL);\n        }\n    }\n    return s;\n}</code></pre>\n<p>在doJoin()方法里，首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；如果没有执行完，则从任务数组里取出任务并执行。如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记录异常，并将任务状态设置为EXCEPTIONAL。</p>"},{"title":"Future、FutureTask实现原理浅析","description":"Future、FutureTask实现原理浅析","date":"2019-07-18T02:00:00.000Z","_content":"## 什么是Future、FutureTask\nfuture在字面上表示未来的意思，在Java中一般通过继承Thread类或者实现Runnable接口这两种方式来创建多线程，但是这两种方式都有个缺陷，就是不能在执行完成后获取执行的结果。然而JDK提供了一种类似ajax的方式，允许提交任务后去做自己的事，在任务执行完成后可以获得执行的结果。总的来说就是实现\"任务的提交\"和\"任务的执行\"相分离。\n<!--more-->\n```java\n    @Test\n    public void test() throws ExecutionException, InterruptedException {\n        FutureTask<String> futureTask = new FutureTask<>(() -> {\n            System.out.println(\"!!!!\");\n            return \"success\";\n        });\n\n        Thread thread = new Thread(futureTask);\n        thread.start();\n        boolean isDone = futureTask.isDone();\n        System.out.println(\"isDone =\" + isDone);\n        long l = System.currentTimeMillis();\n        futureTask.get();\n        System.out.println(\"isDone =\" + isDone);\n        System.out.println(\"耗时 =\" + (System.currentTimeMillis() - l) + \" ms\");\n    }\n```\n\n### 线程池使用FutureTask获取结果\n\n```java\n@Test\npublic void test2(){\n    ExecutorService es = Executors.newCachedThreadPool();\n    List<Future<String>> futureList = Lists.newArrayList();\n    for(int i = 0 ; i < 10 ; i++){\n        Future<String> future = es.submit(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                return UUID.randomUUID().toString();\n            }\n        });\n        futureList.add(future);\n    }\n    futureList.forEach(stringFuture -> {\n        try {\n            System.out.println(stringFuture.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    });\n}\n```\n\n\n\n### FutureTask的继承关系和常用方法\n\nFutureTask继承关系,从继承关系上看，futureTask实现了Future接口和Runnable接口。所以FutureTask实现了表格上方法。\n\n![](futuretask/1.png)\n\n| 方法        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| cancel      | 取消任务                                                     |\n| isCancelled | 判断任务是否已取消                                           |\n| isDone      | 判断任务是否已结束                                           |\n| get         | 以阻塞方式获取任务执行结果，如果任务还没有执行完，调用get（），会被阻塞，直到任务执行完才会被唤醒 |\n| run         | 线程执行的方法                                               |\n\n## FutureTask源码解析\n\n### FutureTask构造函数\n\nFutureTask支持传入Runnable和Callable，但是Runable并不支持返回值。所以在FutureTask(Runnable runnable, V result)构造函数中使用了Executors.callable(runnable, result)方法采用适配器模式将Runnable转成Callable。\n\n![](futuretask/2.png)\n\n```java\npublic static <T> Callable<T> callable(Runnable task, T result) {\n        if (task == null)\n            throw new NullPointerException();\n        return new RunnableAdapter<T>(task, result);\n}\nstatic final class RunnableAdapter<T> implements Callable<T> {\n        final Runnable task;\n        final T result;\n        RunnableAdapter(Runnable task, T result) {\n            this.task = task;\n            this.result = result;\n        }\n        public T call() {\n            task.run();\n            return result;\n        }\n}\n```\n\n通过适配器模式将Runnable转成Callable。\n\n### FutureTask的状态变量\n\n```java\n//表示当前task状态\nprivate volatile int state;\n//当前任务尚未执行\nprivate static final int NEW          = 0;\n//当前任务正在结束，稍微完全结束，一种临界状态\nprivate static final int COMPLETING   = 1;\n//当前任务正常结束\nprivate static final int NORMAL       = 2;\n//当前任务执行过程中发生了异常\nprivate static final int EXCEPTIONAL  = 3;\n//当前任务被取消\nprivate static final int CANCELLED    = 4;\n//当前任务中断中\nprivate static final int INTERRUPTING = 5;\n//当前任务已中断\nprivate static final int INTERRUPTED  = 6;\n//用来存储 \"用户提供的有实在业务逻辑的\" 任务\nprivate Callable<V> callable;\n//用来保存异步计算的结果。正常情况保存返回值，非正常情况保存异常\nprivate Object outcome;\n//当前任务被线程执行期间，保存当前执行任务的线程对象引用\nprivate volatile Thread runner;\n/**\nfutureTask.get是支持多个线程去调用的，这个变量主要是用来存储调用get方法线程的一个队列。当futureTask.run执行完成后会通过这个变量for循环去通知调用的线程结束阻塞\n**/\nprivate volatile WaitNode waiters;\n\n```\n\n### FutureTask主流程\n\n```java\npublic void run() {\n       //如果任务不是NEW状态（如果不是NEW就表示Task已经被执行过或者被取消了）\n       //UNSAFE.compareAndSwapObject表示将当前执行run方法的线程通过CAS方式设置到runnerOffset变量\n       //CAS的特性，如果runnerOffset = null 则将当前线程设置到runnerOffset,成功返回ture失败返回false\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            //callable就是程序员自己写的逻辑\n            Callable<V> c = callable;\n            //c!=null 防止程序员没写自己的逻辑\n            //为什么又判断了一次? 防止期间有外部任务执行了cancel掉了当前任务\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    //执行任务\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    //设置失败\n                    setException(ex);\n                }\n                if (ran)\n                    //任务执行正常，设置结果\n                    set(result);\n            }\n        } finally {\n            // runner must be non-null until state is settled to\n            // prevent concurrent calls to run()\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            //判断当前线程是不是中断中\n            if (s >= INTERRUPTING)\n                //如果是中断中就执行中断\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n```\n\nFutureTask#set()设置执行结果函数\n\n```java\n    protected void set(V v) {\n        //使用CAS，判断当前状态是不是NEW，如果是就设置成COMPLETING。通过CAS保证了只有一个线程\n        //去设置结果\n        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n            //将结果设置给outcome\n            outcome = v;\n            //将结果设置给outcome后，马上将状态设置成NORMAL\n            //putOrderedInt表示设置值 并且马上写入主存\n            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n            //TODO\n            finishCompletion();\n        }\n    }\n```\n\n### FutureTask#get方法\n\n一定不要以为get方法就只有一个线程在获取，可能会有多个。所以有了WaitNodes这个变量。\n\n```java\nstatic final class WaitNode {\n    volatile Thread thread;\n    volatile WaitNode next;\n    WaitNode() { thread = Thread.currentThread(); }\n}\n```\n\n```java\n\n\npublic V get() throws InterruptedException, ExecutionException {\n    //获取当前任务状态\n    int s = state;\n    //如果小于COMPLETING代表是未执行，正在执行，正完成等情况，则会调用awaitDone进行阻塞\n    if (s <= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n//最核心方法，get是如何阻塞的 -- 解析不带超时的情况\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    //引用当前线程封装成WaitNode对象\n    WaitNode q = null;\n    //表示当前线程WaitNode对象有没有入队\n    boolean queued = false;\n    //自旋\n    for (;;) {\n        //假设被唤醒了，就再次自旋\n        //这里如果为ture，说明当前线程唤醒 是被其他线程使用中断这种方式唤醒的\n        if (Thread.interrupted()) {\n            //当前线程node出队\n            removeWaiter(q);\n            //抛出中断异常\n            throw new InterruptedException();\n        }\n        int s = state;\n        //被正常unpark唤醒的情况下，判断当前任务状态，如果大于COMPLETING\n        //说明当前任务已经有结果了\n        if (s > COMPLETING) {\n            if (q != null)\n                q.thread = null;\n            //返回状态\n            return s;\n        }\n        else if (s == COMPLETING) // cannot time out yet\n            Thread.yield();\n        else if (q == null) //第一次自旋应该是先到这里来初始化创建WaitNode对象\n            q = new WaitNode();\n        else if (!queued){ //第二次自旋，当前WaitNode已经创建，但node对象还没有入队\n            //下面代码可以拆成两行\n            //q.next = waiters #将当前线程的next指向头节点\n            //queued = UNSAFE.compareAndSwapObject(this, waitersOffset, waiters, q);\n            //# CAS方式设置waiters指向当前线程node,如果失败表示其他线程先行入队了，如果失败就再次自旋\t\n            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                 q.next = waiters, q);\n        }else if (timed) {\n            nanos = deadline - System.nanoTime();\n            if (nanos <= 0L) {\n                removeWaiter(q);\n                return state;\n            }\n            LockSupport.parkNanos(this, nanos);\n        }\n        else\n            //第三次自旋就是阻塞了\n            LockSupport.park(this);\n           //这里需要注意的是，被唤醒后会继续自旋\n    }\n}\n\n//这个方法就是返回结果或者抛出异常了\nprivate V report(int s) throws ExecutionException {\n    Object x = outcome;\n    //如果是正常完成，则返回结果\n    if (s == NORMAL)\n        return (V)x;\n    //如果是异常就抛出异常\n    if (s >= CANCELLED)\n        throw new CancellationException();\n    throw new ExecutionException((Throwable)x);\n}\n```\n\n总结一下，get方法就是做了两步操作，第一步就是将当前get线程封装成WaitNode入队，然后并调用LockSupport.park(this)进行阻塞。(这里为啥要用WaitNode呢？因为后面唤醒时需要run线程遍历队列进行唤醒)。\n\n### FutureTask#finishCompletion方法\n\n从上面代码分析，我们知道调用get方法的线程被LockSupport.park阻塞了，并将线程存到了WaitNode。所以当run执行成功后需要唤醒。\n\n```java\nprivate void finishCompletion() {\n    // assert state > COMPLETING;\n    //遍历waitNode队列并执行LockSupport.unpark唤醒阻塞的线程\n    for (WaitNode q; (q = waiters) != null;) {\n        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n            for (;;) {\n                Thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    //唤醒线程\n                    LockSupport.unpark(t);\n                }\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n    done(); //预留给用户自己实现\n    callable = null;        // to reduce footprint\n}\n```\n\n","source":"_posts/futuretask.md","raw":"---\ntitle: Future、FutureTask实现原理浅析\ntags:\n  - java并发\ncategories:  java\ndescription : Future、FutureTask实现原理浅析\ndate: 2019-07-18 10:00:00\n---\n## 什么是Future、FutureTask\nfuture在字面上表示未来的意思，在Java中一般通过继承Thread类或者实现Runnable接口这两种方式来创建多线程，但是这两种方式都有个缺陷，就是不能在执行完成后获取执行的结果。然而JDK提供了一种类似ajax的方式，允许提交任务后去做自己的事，在任务执行完成后可以获得执行的结果。总的来说就是实现\"任务的提交\"和\"任务的执行\"相分离。\n<!--more-->\n```java\n    @Test\n    public void test() throws ExecutionException, InterruptedException {\n        FutureTask<String> futureTask = new FutureTask<>(() -> {\n            System.out.println(\"!!!!\");\n            return \"success\";\n        });\n\n        Thread thread = new Thread(futureTask);\n        thread.start();\n        boolean isDone = futureTask.isDone();\n        System.out.println(\"isDone =\" + isDone);\n        long l = System.currentTimeMillis();\n        futureTask.get();\n        System.out.println(\"isDone =\" + isDone);\n        System.out.println(\"耗时 =\" + (System.currentTimeMillis() - l) + \" ms\");\n    }\n```\n\n### 线程池使用FutureTask获取结果\n\n```java\n@Test\npublic void test2(){\n    ExecutorService es = Executors.newCachedThreadPool();\n    List<Future<String>> futureList = Lists.newArrayList();\n    for(int i = 0 ; i < 10 ; i++){\n        Future<String> future = es.submit(new Callable<String>() {\n            @Override\n            public String call() throws Exception {\n                return UUID.randomUUID().toString();\n            }\n        });\n        futureList.add(future);\n    }\n    futureList.forEach(stringFuture -> {\n        try {\n            System.out.println(stringFuture.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    });\n}\n```\n\n\n\n### FutureTask的继承关系和常用方法\n\nFutureTask继承关系,从继承关系上看，futureTask实现了Future接口和Runnable接口。所以FutureTask实现了表格上方法。\n\n![](futuretask/1.png)\n\n| 方法        | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| cancel      | 取消任务                                                     |\n| isCancelled | 判断任务是否已取消                                           |\n| isDone      | 判断任务是否已结束                                           |\n| get         | 以阻塞方式获取任务执行结果，如果任务还没有执行完，调用get（），会被阻塞，直到任务执行完才会被唤醒 |\n| run         | 线程执行的方法                                               |\n\n## FutureTask源码解析\n\n### FutureTask构造函数\n\nFutureTask支持传入Runnable和Callable，但是Runable并不支持返回值。所以在FutureTask(Runnable runnable, V result)构造函数中使用了Executors.callable(runnable, result)方法采用适配器模式将Runnable转成Callable。\n\n![](futuretask/2.png)\n\n```java\npublic static <T> Callable<T> callable(Runnable task, T result) {\n        if (task == null)\n            throw new NullPointerException();\n        return new RunnableAdapter<T>(task, result);\n}\nstatic final class RunnableAdapter<T> implements Callable<T> {\n        final Runnable task;\n        final T result;\n        RunnableAdapter(Runnable task, T result) {\n            this.task = task;\n            this.result = result;\n        }\n        public T call() {\n            task.run();\n            return result;\n        }\n}\n```\n\n通过适配器模式将Runnable转成Callable。\n\n### FutureTask的状态变量\n\n```java\n//表示当前task状态\nprivate volatile int state;\n//当前任务尚未执行\nprivate static final int NEW          = 0;\n//当前任务正在结束，稍微完全结束，一种临界状态\nprivate static final int COMPLETING   = 1;\n//当前任务正常结束\nprivate static final int NORMAL       = 2;\n//当前任务执行过程中发生了异常\nprivate static final int EXCEPTIONAL  = 3;\n//当前任务被取消\nprivate static final int CANCELLED    = 4;\n//当前任务中断中\nprivate static final int INTERRUPTING = 5;\n//当前任务已中断\nprivate static final int INTERRUPTED  = 6;\n//用来存储 \"用户提供的有实在业务逻辑的\" 任务\nprivate Callable<V> callable;\n//用来保存异步计算的结果。正常情况保存返回值，非正常情况保存异常\nprivate Object outcome;\n//当前任务被线程执行期间，保存当前执行任务的线程对象引用\nprivate volatile Thread runner;\n/**\nfutureTask.get是支持多个线程去调用的，这个变量主要是用来存储调用get方法线程的一个队列。当futureTask.run执行完成后会通过这个变量for循环去通知调用的线程结束阻塞\n**/\nprivate volatile WaitNode waiters;\n\n```\n\n### FutureTask主流程\n\n```java\npublic void run() {\n       //如果任务不是NEW状态（如果不是NEW就表示Task已经被执行过或者被取消了）\n       //UNSAFE.compareAndSwapObject表示将当前执行run方法的线程通过CAS方式设置到runnerOffset变量\n       //CAS的特性，如果runnerOffset = null 则将当前线程设置到runnerOffset,成功返回ture失败返回false\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            //callable就是程序员自己写的逻辑\n            Callable<V> c = callable;\n            //c!=null 防止程序员没写自己的逻辑\n            //为什么又判断了一次? 防止期间有外部任务执行了cancel掉了当前任务\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    //执行任务\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    //设置失败\n                    setException(ex);\n                }\n                if (ran)\n                    //任务执行正常，设置结果\n                    set(result);\n            }\n        } finally {\n            // runner must be non-null until state is settled to\n            // prevent concurrent calls to run()\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            //判断当前线程是不是中断中\n            if (s >= INTERRUPTING)\n                //如果是中断中就执行中断\n                handlePossibleCancellationInterrupt(s);\n        }\n    }\n```\n\nFutureTask#set()设置执行结果函数\n\n```java\n    protected void set(V v) {\n        //使用CAS，判断当前状态是不是NEW，如果是就设置成COMPLETING。通过CAS保证了只有一个线程\n        //去设置结果\n        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n            //将结果设置给outcome\n            outcome = v;\n            //将结果设置给outcome后，马上将状态设置成NORMAL\n            //putOrderedInt表示设置值 并且马上写入主存\n            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n            //TODO\n            finishCompletion();\n        }\n    }\n```\n\n### FutureTask#get方法\n\n一定不要以为get方法就只有一个线程在获取，可能会有多个。所以有了WaitNodes这个变量。\n\n```java\nstatic final class WaitNode {\n    volatile Thread thread;\n    volatile WaitNode next;\n    WaitNode() { thread = Thread.currentThread(); }\n}\n```\n\n```java\n\n\npublic V get() throws InterruptedException, ExecutionException {\n    //获取当前任务状态\n    int s = state;\n    //如果小于COMPLETING代表是未执行，正在执行，正完成等情况，则会调用awaitDone进行阻塞\n    if (s <= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n//最核心方法，get是如何阻塞的 -- 解析不带超时的情况\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    //引用当前线程封装成WaitNode对象\n    WaitNode q = null;\n    //表示当前线程WaitNode对象有没有入队\n    boolean queued = false;\n    //自旋\n    for (;;) {\n        //假设被唤醒了，就再次自旋\n        //这里如果为ture，说明当前线程唤醒 是被其他线程使用中断这种方式唤醒的\n        if (Thread.interrupted()) {\n            //当前线程node出队\n            removeWaiter(q);\n            //抛出中断异常\n            throw new InterruptedException();\n        }\n        int s = state;\n        //被正常unpark唤醒的情况下，判断当前任务状态，如果大于COMPLETING\n        //说明当前任务已经有结果了\n        if (s > COMPLETING) {\n            if (q != null)\n                q.thread = null;\n            //返回状态\n            return s;\n        }\n        else if (s == COMPLETING) // cannot time out yet\n            Thread.yield();\n        else if (q == null) //第一次自旋应该是先到这里来初始化创建WaitNode对象\n            q = new WaitNode();\n        else if (!queued){ //第二次自旋，当前WaitNode已经创建，但node对象还没有入队\n            //下面代码可以拆成两行\n            //q.next = waiters #将当前线程的next指向头节点\n            //queued = UNSAFE.compareAndSwapObject(this, waitersOffset, waiters, q);\n            //# CAS方式设置waiters指向当前线程node,如果失败表示其他线程先行入队了，如果失败就再次自旋\t\n            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                 q.next = waiters, q);\n        }else if (timed) {\n            nanos = deadline - System.nanoTime();\n            if (nanos <= 0L) {\n                removeWaiter(q);\n                return state;\n            }\n            LockSupport.parkNanos(this, nanos);\n        }\n        else\n            //第三次自旋就是阻塞了\n            LockSupport.park(this);\n           //这里需要注意的是，被唤醒后会继续自旋\n    }\n}\n\n//这个方法就是返回结果或者抛出异常了\nprivate V report(int s) throws ExecutionException {\n    Object x = outcome;\n    //如果是正常完成，则返回结果\n    if (s == NORMAL)\n        return (V)x;\n    //如果是异常就抛出异常\n    if (s >= CANCELLED)\n        throw new CancellationException();\n    throw new ExecutionException((Throwable)x);\n}\n```\n\n总结一下，get方法就是做了两步操作，第一步就是将当前get线程封装成WaitNode入队，然后并调用LockSupport.park(this)进行阻塞。(这里为啥要用WaitNode呢？因为后面唤醒时需要run线程遍历队列进行唤醒)。\n\n### FutureTask#finishCompletion方法\n\n从上面代码分析，我们知道调用get方法的线程被LockSupport.park阻塞了，并将线程存到了WaitNode。所以当run执行成功后需要唤醒。\n\n```java\nprivate void finishCompletion() {\n    // assert state > COMPLETING;\n    //遍历waitNode队列并执行LockSupport.unpark唤醒阻塞的线程\n    for (WaitNode q; (q = waiters) != null;) {\n        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n            for (;;) {\n                Thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    //唤醒线程\n                    LockSupport.unpark(t);\n                }\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n    done(); //预留给用户自己实现\n    callable = null;        // to reduce footprint\n}\n```\n\n","slug":"futuretask","published":1,"updated":"2021-04-08T00:47:06.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhun000cqwv27tig1h1x","content":"<h2 id=\"什么是Future、FutureTask\"><a href=\"#什么是Future、FutureTask\" class=\"headerlink\" title=\"什么是Future、FutureTask\"></a>什么是Future、FutureTask</h2><p>future在字面上表示未来的意思，在Java中一般通过继承Thread类或者实现Runnable接口这两种方式来创建多线程，但是这两种方式都有个缺陷，就是不能在执行完成后获取执行的结果。然而JDK提供了一种类似ajax的方式，允许提交任务后去做自己的事，在任务执行完成后可以获得执行的结果。总的来说就是实现”任务的提交”和”任务的执行”相分离。</p>\n<a id=\"more\"></a>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token annotation punctuation\">@Test</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException<span class=\"token punctuation\">,</span> InterruptedException <span class=\"token punctuation\">{</span>\n        FutureTask<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> futureTask <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureTask</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"!!!!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token string\">\"success\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        Thread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>futureTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">boolean</span> isDone <span class=\"token operator\">=</span> futureTask<span class=\"token punctuation\">.</span><span class=\"token function\">isDone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"isDone =\"</span> <span class=\"token operator\">+</span> isDone<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">long</span> l <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        futureTask<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"isDone =\"</span> <span class=\"token operator\">+</span> isDone<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"耗时 =\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> l<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\" ms\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"线程池使用FutureTask获取结果\"><a href=\"#线程池使用FutureTask获取结果\" class=\"headerlink\" title=\"线程池使用FutureTask获取结果\"></a>线程池使用FutureTask获取结果</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    ExecutorService es <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    List<span class=\"token operator\">&lt;</span>Future<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">>></span> futureList <span class=\"token operator\">=</span> Lists<span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        Future<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> future <span class=\"token operator\">=</span> es<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Callable</span><span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> String <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        futureList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>future<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    futureList<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>stringFuture <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>stringFuture<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ExecutionException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"FutureTask的继承关系和常用方法\"><a href=\"#FutureTask的继承关系和常用方法\" class=\"headerlink\" title=\"FutureTask的继承关系和常用方法\"></a>FutureTask的继承关系和常用方法</h3><p>FutureTask继承关系,从继承关系上看，futureTask实现了Future接口和Runnable接口。所以FutureTask实现了表格上方法。</p>\n<p><img src=\"/2019/07/18/futuretask/1.png\" alt></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cancel</td>\n<td>取消任务</td>\n</tr>\n<tr>\n<td>isCancelled</td>\n<td>判断任务是否已取消</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>判断任务是否已结束</td>\n</tr>\n<tr>\n<td>get</td>\n<td>以阻塞方式获取任务执行结果，如果任务还没有执行完，调用get（），会被阻塞，直到任务执行完才会被唤醒</td>\n</tr>\n<tr>\n<td>run</td>\n<td>线程执行的方法</td>\n</tr>\n</tbody></table>\n<h2 id=\"FutureTask源码解析\"><a href=\"#FutureTask源码解析\" class=\"headerlink\" title=\"FutureTask源码解析\"></a>FutureTask源码解析</h2><h3 id=\"FutureTask构造函数\"><a href=\"#FutureTask构造函数\" class=\"headerlink\" title=\"FutureTask构造函数\"></a>FutureTask构造函数</h3><p>FutureTask支持传入Runnable和Callable，但是Runable并不支持返回值。所以在FutureTask(Runnable runnable, V result)构造函数中使用了Executors.callable(runnable, result)方法采用适配器模式将Runnable转成Callable。</p>\n<p><img src=\"/2019/07/18/futuretask/2.png\" alt></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> Callable<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token function\">callable</span><span class=\"token punctuation\">(</span>Runnable task<span class=\"token punctuation\">,</span> T result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>task <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointerException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RunnableAdapter</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>task<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RunnableAdapter</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Callable</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> Runnable task<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">final</span> T result<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">RunnableAdapter</span><span class=\"token punctuation\">(</span>Runnable task<span class=\"token punctuation\">,</span> T result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>task <span class=\"token operator\">=</span> task<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>result <span class=\"token operator\">=</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">public</span> T <span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            task<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>通过适配器模式将Runnable转成Callable。</p>\n<h3 id=\"FutureTask的状态变量\"><a href=\"#FutureTask的状态变量\" class=\"headerlink\" title=\"FutureTask的状态变量\"></a>FutureTask的状态变量</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//表示当前task状态</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> state<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前任务尚未执行</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> NEW          <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前任务正在结束，稍微完全结束，一种临界状态</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> COMPLETING   <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前任务正常结束</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> NORMAL       <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前任务执行过程中发生了异常</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> EXCEPTIONAL  <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前任务被取消</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> CANCELLED    <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前任务中断中</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> INTERRUPTING <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前任务已中断</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> INTERRUPTED  <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//用来存储 \"用户提供的有实在业务逻辑的\" 任务</span>\n<span class=\"token keyword\">private</span> Callable<span class=\"token operator\">&lt;</span>V<span class=\"token operator\">></span> callable<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//用来保存异步计算的结果。正常情况保存返回值，非正常情况保存异常</span>\n<span class=\"token keyword\">private</span> Object outcome<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前任务被线程执行期间，保存当前执行任务的线程对象引用</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> Thread runner<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">/**\nfutureTask.get是支持多个线程去调用的，这个变量主要是用来存储调用get方法线程的一个队列。当futureTask.run执行完成后会通过这个变量for循环去通知调用的线程结束阻塞\n**/</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> WaitNode waiters<span class=\"token punctuation\">;</span>\n</code></pre>\n<h3 id=\"FutureTask主流程\"><a href=\"#FutureTask主流程\" class=\"headerlink\" title=\"FutureTask主流程\"></a>FutureTask主流程</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token comment\" spellcheck=\"true\">//如果任务不是NEW状态（如果不是NEW就表示Task已经被执行过或者被取消了）</span>\n       <span class=\"token comment\" spellcheck=\"true\">//UNSAFE.compareAndSwapObject表示将当前执行run方法的线程通过CAS方式设置到runnerOffset变量</span>\n       <span class=\"token comment\" spellcheck=\"true\">//CAS的特性，如果runnerOffset = null 则将当前线程设置到runnerOffset,成功返回ture失败返回false</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>state <span class=\"token operator\">!=</span> NEW <span class=\"token operator\">||</span>\n            <span class=\"token operator\">!</span>UNSAFE<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> runnerOffset<span class=\"token punctuation\">,</span>\n                                         null<span class=\"token punctuation\">,</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//callable就是程序员自己写的逻辑</span>\n            Callable<span class=\"token operator\">&lt;</span>V<span class=\"token operator\">></span> c <span class=\"token operator\">=</span> callable<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//c!=null 防止程序员没写自己的逻辑</span>\n            <span class=\"token comment\" spellcheck=\"true\">//为什么又判断了一次? 防止期间有外部任务执行了cancel掉了当前任务</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> state <span class=\"token operator\">==</span> NEW<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                V result<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">boolean</span> ran<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//执行任务</span>\n                    result <span class=\"token operator\">=</span> c<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    ran <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    result <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                    ran <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//设置失败</span>\n                    <span class=\"token function\">setException</span><span class=\"token punctuation\">(</span>ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ran<span class=\"token punctuation\">)</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//任务执行正常，设置结果</span>\n                    <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// runner must be non-null until state is settled to</span>\n            <span class=\"token comment\" spellcheck=\"true\">// prevent concurrent calls to run()</span>\n            runner <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// state must be re-read after nulling runner to prevent</span>\n            <span class=\"token comment\" spellcheck=\"true\">// leaked interrupts</span>\n            <span class=\"token keyword\">int</span> s <span class=\"token operator\">=</span> state<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//判断当前线程是不是中断中</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">>=</span> INTERRUPTING<span class=\"token punctuation\">)</span>\n                <span class=\"token comment\" spellcheck=\"true\">//如果是中断中就执行中断</span>\n                <span class=\"token function\">handlePossibleCancellationInterrupt</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>FutureTask#set()设置执行结果函数</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>V v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//使用CAS，判断当前状态是不是NEW，如果是就设置成COMPLETING。通过CAS保证了只有一个线程</span>\n        <span class=\"token comment\" spellcheck=\"true\">//去设置结果</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>UNSAFE<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> stateOffset<span class=\"token punctuation\">,</span> NEW<span class=\"token punctuation\">,</span> COMPLETING<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//将结果设置给outcome</span>\n            outcome <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//将结果设置给outcome后，马上将状态设置成NORMAL</span>\n            <span class=\"token comment\" spellcheck=\"true\">//putOrderedInt表示设置值 并且马上写入主存</span>\n            UNSAFE<span class=\"token punctuation\">.</span><span class=\"token function\">putOrderedInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> stateOffset<span class=\"token punctuation\">,</span> NORMAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// final state</span>\n            <span class=\"token comment\" spellcheck=\"true\">//TODO</span>\n            <span class=\"token function\">finishCompletion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"FutureTask-get方法\"><a href=\"#FutureTask-get方法\" class=\"headerlink\" title=\"FutureTask#get方法\"></a>FutureTask#get方法</h3><p>一定不要以为get方法就只有一个线程在获取，可能会有多个。所以有了WaitNodes这个变量。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">WaitNode</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">volatile</span> Thread thread<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">volatile</span> WaitNode next<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">WaitNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> thread <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">\n\n<span class=\"token keyword\">public</span> V <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException<span class=\"token punctuation\">,</span> ExecutionException <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//获取当前任务状态</span>\n    <span class=\"token keyword\">int</span> s <span class=\"token operator\">=</span> state<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果小于COMPLETING代表是未执行，正在执行，正完成等情况，则会调用awaitDone进行阻塞</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">&lt;=</span> COMPLETING<span class=\"token punctuation\">)</span>\n        s <span class=\"token operator\">=</span> <span class=\"token function\">awaitDone</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> 0L<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">report</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//最核心方法，get是如何阻塞的 -- 解析不带超时的情况</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> <span class=\"token function\">awaitDone</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> timed<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> nanos<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> deadline <span class=\"token operator\">=</span> timed <span class=\"token operator\">?</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> nanos <span class=\"token operator\">:</span> 0L<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//引用当前线程封装成WaitNode对象</span>\n    WaitNode q <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//表示当前线程WaitNode对象有没有入队</span>\n    <span class=\"token keyword\">boolean</span> queued <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//自旋</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//假设被唤醒了，就再次自旋</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这里如果为ture，说明当前线程唤醒 是被其他线程使用中断这种方式唤醒的</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//当前线程node出队</span>\n            <span class=\"token function\">removeWaiter</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//抛出中断异常</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterruptedException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">int</span> s <span class=\"token operator\">=</span> state<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//被正常unpark唤醒的情况下，判断当前任务状态，如果大于COMPLETING</span>\n        <span class=\"token comment\" spellcheck=\"true\">//说明当前任务已经有结果了</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">></span> COMPLETING<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n                q<span class=\"token punctuation\">.</span>thread <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//返回状态</span>\n            <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">==</span> COMPLETING<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// cannot time out yet</span>\n            Thread<span class=\"token punctuation\">.</span><span class=\"token function\">yield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//第一次自旋应该是先到这里来初始化创建WaitNode对象</span>\n            q <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WaitNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>queued<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//第二次自旋，当前WaitNode已经创建，但node对象还没有入队</span>\n            <span class=\"token comment\" spellcheck=\"true\">//下面代码可以拆成两行</span>\n            <span class=\"token comment\" spellcheck=\"true\">//q.next = waiters #将当前线程的next指向头节点</span>\n            <span class=\"token comment\" spellcheck=\"true\">//queued = UNSAFE.compareAndSwapObject(this, waitersOffset, waiters, q);</span>\n            <span class=\"token comment\" spellcheck=\"true\">//# CAS方式设置waiters指向当前线程node,如果失败表示其他线程先行入队了，如果失败就再次自旋    </span>\n            queued <span class=\"token operator\">=</span> UNSAFE<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> waitersOffset<span class=\"token punctuation\">,</span>\n                                                 q<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> waiters<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            nanos <span class=\"token operator\">=</span> deadline <span class=\"token operator\">-</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">nanoTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nanos <span class=\"token operator\">&lt;=</span> 0L<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">removeWaiter</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> state<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">parkNanos</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> nanos<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span>\n            <span class=\"token comment\" spellcheck=\"true\">//第三次自旋就是阻塞了</span>\n            LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">park</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n           <span class=\"token comment\" spellcheck=\"true\">//这里需要注意的是，被唤醒后会继续自旋</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//这个方法就是返回结果或者抛出异常了</span>\n<span class=\"token keyword\">private</span> V <span class=\"token function\">report</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> s<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> ExecutionException <span class=\"token punctuation\">{</span>\n    Object x <span class=\"token operator\">=</span> outcome<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果是正常完成，则返回结果</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">==</span> NORMAL<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>V<span class=\"token punctuation\">)</span>x<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果是异常就抛出异常</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">>=</span> CANCELLED<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CancellationException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ExecutionException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>Throwable<span class=\"token punctuation\">)</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>总结一下，get方法就是做了两步操作，第一步就是将当前get线程封装成WaitNode入队，然后并调用LockSupport.park(this)进行阻塞。(这里为啥要用WaitNode呢？因为后面唤醒时需要run线程遍历队列进行唤醒)。</p>\n<h3 id=\"FutureTask-finishCompletion方法\"><a href=\"#FutureTask-finishCompletion方法\" class=\"headerlink\" title=\"FutureTask#finishCompletion方法\"></a>FutureTask#finishCompletion方法</h3><p>从上面代码分析，我们知道调用get方法的线程被LockSupport.park阻塞了，并将线程存到了WaitNode。所以当run执行成功后需要唤醒。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">finishCompletion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// assert state > COMPLETING;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//遍历waitNode队列并执行LockSupport.unpark唤醒阻塞的线程</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>WaitNode q<span class=\"token punctuation\">;</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">=</span> waiters<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>UNSAFE<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapObject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> waitersOffset<span class=\"token punctuation\">,</span> q<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                Thread t <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    q<span class=\"token punctuation\">.</span>thread <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//唤醒线程</span>\n                    LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">unpark</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                WaitNode next <span class=\"token operator\">=</span> q<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>next <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                q<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// unlink to help gc</span>\n                q <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">done</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//预留给用户自己实现</span>\n    callable <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>        <span class=\"token comment\" spellcheck=\"true\">// to reduce footprint</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是Future、FutureTask\"><a href=\"#什么是Future、FutureTask\" class=\"headerlink\" title=\"什么是Future、FutureTask\"></a>什么是Future、FutureTask</h2><p>future在字面上表示未来的意思，在Java中一般通过继承Thread类或者实现Runnable接口这两种方式来创建多线程，但是这两种方式都有个缺陷，就是不能在执行完成后获取执行的结果。然而JDK提供了一种类似ajax的方式，允许提交任务后去做自己的事，在任务执行完成后可以获得执行的结果。总的来说就是实现”任务的提交”和”任务的执行”相分离。</p>","more":"<pre><code class=\"java\">    @Test\n    public void test() throws ExecutionException, InterruptedException {\n        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; {\n            System.out.println(&quot;!!!!&quot;);\n            return &quot;success&quot;;\n        });\n\n        Thread thread = new Thread(futureTask);\n        thread.start();\n        boolean isDone = futureTask.isDone();\n        System.out.println(&quot;isDone =&quot; + isDone);\n        long l = System.currentTimeMillis();\n        futureTask.get();\n        System.out.println(&quot;isDone =&quot; + isDone);\n        System.out.println(&quot;耗时 =&quot; + (System.currentTimeMillis() - l) + &quot; ms&quot;);\n    }</code></pre>\n<h3 id=\"线程池使用FutureTask获取结果\"><a href=\"#线程池使用FutureTask获取结果\" class=\"headerlink\" title=\"线程池使用FutureTask获取结果\"></a>线程池使用FutureTask获取结果</h3><pre><code class=\"java\">@Test\npublic void test2(){\n    ExecutorService es = Executors.newCachedThreadPool();\n    List&lt;Future&lt;String&gt;&gt; futureList = Lists.newArrayList();\n    for(int i = 0 ; i &lt; 10 ; i++){\n        Future&lt;String&gt; future = es.submit(new Callable&lt;String&gt;() {\n            @Override\n            public String call() throws Exception {\n                return UUID.randomUUID().toString();\n            }\n        });\n        futureList.add(future);\n    }\n    futureList.forEach(stringFuture -&gt; {\n        try {\n            System.out.println(stringFuture.get());\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n    });\n}</code></pre>\n<h3 id=\"FutureTask的继承关系和常用方法\"><a href=\"#FutureTask的继承关系和常用方法\" class=\"headerlink\" title=\"FutureTask的继承关系和常用方法\"></a>FutureTask的继承关系和常用方法</h3><p>FutureTask继承关系,从继承关系上看，futureTask实现了Future接口和Runnable接口。所以FutureTask实现了表格上方法。</p>\n<p><img src=\"/2019/07/18/futuretask/1.png\" alt></p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cancel</td>\n<td>取消任务</td>\n</tr>\n<tr>\n<td>isCancelled</td>\n<td>判断任务是否已取消</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>判断任务是否已结束</td>\n</tr>\n<tr>\n<td>get</td>\n<td>以阻塞方式获取任务执行结果，如果任务还没有执行完，调用get（），会被阻塞，直到任务执行完才会被唤醒</td>\n</tr>\n<tr>\n<td>run</td>\n<td>线程执行的方法</td>\n</tr>\n</tbody></table>\n<h2 id=\"FutureTask源码解析\"><a href=\"#FutureTask源码解析\" class=\"headerlink\" title=\"FutureTask源码解析\"></a>FutureTask源码解析</h2><h3 id=\"FutureTask构造函数\"><a href=\"#FutureTask构造函数\" class=\"headerlink\" title=\"FutureTask构造函数\"></a>FutureTask构造函数</h3><p>FutureTask支持传入Runnable和Callable，但是Runable并不支持返回值。所以在FutureTask(Runnable runnable, V result)构造函数中使用了Executors.callable(runnable, result)方法采用适配器模式将Runnable转成Callable。</p>\n<p><img src=\"/2019/07/18/futuretask/2.png\" alt></p>\n<pre><code class=\"java\">public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {\n        if (task == null)\n            throw new NullPointerException();\n        return new RunnableAdapter&lt;T&gt;(task, result);\n}\nstatic final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; {\n        final Runnable task;\n        final T result;\n        RunnableAdapter(Runnable task, T result) {\n            this.task = task;\n            this.result = result;\n        }\n        public T call() {\n            task.run();\n            return result;\n        }\n}</code></pre>\n<p>通过适配器模式将Runnable转成Callable。</p>\n<h3 id=\"FutureTask的状态变量\"><a href=\"#FutureTask的状态变量\" class=\"headerlink\" title=\"FutureTask的状态变量\"></a>FutureTask的状态变量</h3><pre><code class=\"java\">//表示当前task状态\nprivate volatile int state;\n//当前任务尚未执行\nprivate static final int NEW          = 0;\n//当前任务正在结束，稍微完全结束，一种临界状态\nprivate static final int COMPLETING   = 1;\n//当前任务正常结束\nprivate static final int NORMAL       = 2;\n//当前任务执行过程中发生了异常\nprivate static final int EXCEPTIONAL  = 3;\n//当前任务被取消\nprivate static final int CANCELLED    = 4;\n//当前任务中断中\nprivate static final int INTERRUPTING = 5;\n//当前任务已中断\nprivate static final int INTERRUPTED  = 6;\n//用来存储 &quot;用户提供的有实在业务逻辑的&quot; 任务\nprivate Callable&lt;V&gt; callable;\n//用来保存异步计算的结果。正常情况保存返回值，非正常情况保存异常\nprivate Object outcome;\n//当前任务被线程执行期间，保存当前执行任务的线程对象引用\nprivate volatile Thread runner;\n/**\nfutureTask.get是支持多个线程去调用的，这个变量主要是用来存储调用get方法线程的一个队列。当futureTask.run执行完成后会通过这个变量for循环去通知调用的线程结束阻塞\n**/\nprivate volatile WaitNode waiters;\n</code></pre>\n<h3 id=\"FutureTask主流程\"><a href=\"#FutureTask主流程\" class=\"headerlink\" title=\"FutureTask主流程\"></a>FutureTask主流程</h3><pre><code class=\"java\">public void run() {\n       //如果任务不是NEW状态（如果不是NEW就表示Task已经被执行过或者被取消了）\n       //UNSAFE.compareAndSwapObject表示将当前执行run方法的线程通过CAS方式设置到runnerOffset变量\n       //CAS的特性，如果runnerOffset = null 则将当前线程设置到runnerOffset,成功返回ture失败返回false\n        if (state != NEW ||\n            !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                         null, Thread.currentThread()))\n            return;\n        try {\n            //callable就是程序员自己写的逻辑\n            Callable&lt;V&gt; c = callable;\n            //c!=null 防止程序员没写自己的逻辑\n            //为什么又判断了一次? 防止期间有外部任务执行了cancel掉了当前任务\n            if (c != null &amp;&amp; state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    //执行任务\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    //设置失败\n                    setException(ex);\n                }\n                if (ran)\n                    //任务执行正常，设置结果\n                    set(result);\n            }\n        } finally {\n            // runner must be non-null until state is settled to\n            // prevent concurrent calls to run()\n            runner = null;\n            // state must be re-read after nulling runner to prevent\n            // leaked interrupts\n            int s = state;\n            //判断当前线程是不是中断中\n            if (s &gt;= INTERRUPTING)\n                //如果是中断中就执行中断\n                handlePossibleCancellationInterrupt(s);\n        }\n    }</code></pre>\n<p>FutureTask#set()设置执行结果函数</p>\n<pre><code class=\"java\">    protected void set(V v) {\n        //使用CAS，判断当前状态是不是NEW，如果是就设置成COMPLETING。通过CAS保证了只有一个线程\n        //去设置结果\n        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n            //将结果设置给outcome\n            outcome = v;\n            //将结果设置给outcome后，马上将状态设置成NORMAL\n            //putOrderedInt表示设置值 并且马上写入主存\n            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n            //TODO\n            finishCompletion();\n        }\n    }</code></pre>\n<h3 id=\"FutureTask-get方法\"><a href=\"#FutureTask-get方法\" class=\"headerlink\" title=\"FutureTask#get方法\"></a>FutureTask#get方法</h3><p>一定不要以为get方法就只有一个线程在获取，可能会有多个。所以有了WaitNodes这个变量。</p>\n<pre><code class=\"java\">static final class WaitNode {\n    volatile Thread thread;\n    volatile WaitNode next;\n    WaitNode() { thread = Thread.currentThread(); }\n}</code></pre>\n<pre><code class=\"java\">\n\npublic V get() throws InterruptedException, ExecutionException {\n    //获取当前任务状态\n    int s = state;\n    //如果小于COMPLETING代表是未执行，正在执行，正完成等情况，则会调用awaitDone进行阻塞\n    if (s &lt;= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n//最核心方法，get是如何阻塞的 -- 解析不带超时的情况\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    //引用当前线程封装成WaitNode对象\n    WaitNode q = null;\n    //表示当前线程WaitNode对象有没有入队\n    boolean queued = false;\n    //自旋\n    for (;;) {\n        //假设被唤醒了，就再次自旋\n        //这里如果为ture，说明当前线程唤醒 是被其他线程使用中断这种方式唤醒的\n        if (Thread.interrupted()) {\n            //当前线程node出队\n            removeWaiter(q);\n            //抛出中断异常\n            throw new InterruptedException();\n        }\n        int s = state;\n        //被正常unpark唤醒的情况下，判断当前任务状态，如果大于COMPLETING\n        //说明当前任务已经有结果了\n        if (s &gt; COMPLETING) {\n            if (q != null)\n                q.thread = null;\n            //返回状态\n            return s;\n        }\n        else if (s == COMPLETING) // cannot time out yet\n            Thread.yield();\n        else if (q == null) //第一次自旋应该是先到这里来初始化创建WaitNode对象\n            q = new WaitNode();\n        else if (!queued){ //第二次自旋，当前WaitNode已经创建，但node对象还没有入队\n            //下面代码可以拆成两行\n            //q.next = waiters #将当前线程的next指向头节点\n            //queued = UNSAFE.compareAndSwapObject(this, waitersOffset, waiters, q);\n            //# CAS方式设置waiters指向当前线程node,如果失败表示其他线程先行入队了，如果失败就再次自旋    \n            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                 q.next = waiters, q);\n        }else if (timed) {\n            nanos = deadline - System.nanoTime();\n            if (nanos &lt;= 0L) {\n                removeWaiter(q);\n                return state;\n            }\n            LockSupport.parkNanos(this, nanos);\n        }\n        else\n            //第三次自旋就是阻塞了\n            LockSupport.park(this);\n           //这里需要注意的是，被唤醒后会继续自旋\n    }\n}\n\n//这个方法就是返回结果或者抛出异常了\nprivate V report(int s) throws ExecutionException {\n    Object x = outcome;\n    //如果是正常完成，则返回结果\n    if (s == NORMAL)\n        return (V)x;\n    //如果是异常就抛出异常\n    if (s &gt;= CANCELLED)\n        throw new CancellationException();\n    throw new ExecutionException((Throwable)x);\n}</code></pre>\n<p>总结一下，get方法就是做了两步操作，第一步就是将当前get线程封装成WaitNode入队，然后并调用LockSupport.park(this)进行阻塞。(这里为啥要用WaitNode呢？因为后面唤醒时需要run线程遍历队列进行唤醒)。</p>\n<h3 id=\"FutureTask-finishCompletion方法\"><a href=\"#FutureTask-finishCompletion方法\" class=\"headerlink\" title=\"FutureTask#finishCompletion方法\"></a>FutureTask#finishCompletion方法</h3><p>从上面代码分析，我们知道调用get方法的线程被LockSupport.park阻塞了，并将线程存到了WaitNode。所以当run执行成功后需要唤醒。</p>\n<pre><code class=\"java\">private void finishCompletion() {\n    // assert state &gt; COMPLETING;\n    //遍历waitNode队列并执行LockSupport.unpark唤醒阻塞的线程\n    for (WaitNode q; (q = waiters) != null;) {\n        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n            for (;;) {\n                Thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    //唤醒线程\n                    LockSupport.unpark(t);\n                }\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n    done(); //预留给用户自己实现\n    callable = null;        // to reduce footprint\n}</code></pre>"},{"title":"IO知识详解","description":"IO知识详解","date":"2020-12-10T01:05:24.000Z","_content":"\n### 用户空间和内核空间\n由于CPU某些指令比较危险，如果错用会导致系统崩溃，为了保护系统，操作系统将内存空间划分为了两部分：`内核空间`，`用户空间`。\n\n### IO操作流程\n\n假设现在一个网络请求想访问服务器上的一个文件，那么他涉及的过程是怎么样的？\n\n#### **传统IO**\n1. 处理进程发起一个系统调用sys_read读取磁盘文件。\n2. CPU向DMA发送IO请求\n3. DMA将磁盘文件数据<font color=red>拷贝</font>到内核空间的read缓冲区。\n4. CPU把内核空间read缓冲区数据<font color=red>拷贝</font>到用户空间的缓冲区。\n5. 进程发起一个系统调用socket_write，向网卡写数据。\n6. CPU把用户空间缓冲区的数据<font color=red>拷贝</font>到内核空间的socket缓冲区。\n7. DMA把内核空间的socket缓冲区数据<font color=red>拷贝</font>到网卡。\n传统的IO模型整个过程总共发生了四次拷贝和四次的用户态和内核态的切换。\n\n![IO读取数据用户/内核空间](io/1.png)\n\n#### **零拷贝IO**\n1. 处理进程发起一个系统调用sys_read读取磁盘文件。\n2. CPU向DMA发送IO请求\n3. DMA将磁盘文件数据<font color=red>拷贝</font>到内核空间的read缓冲区。\n4. CPU把内核空间read缓冲区数据<font color=red>拷贝</font>到内核空间的socket缓冲区。\n5. DMA把内核空间的socket缓冲区数据<font color=red>拷贝</font>到网卡。\n零拷贝IO模型整个过程总共发生了三次拷贝和两次的用户态和内核态的切换。\n\n![IO读取数据用户/内核空间](io/2.png)\n\n注 : DMA即直接存储器访问，可以看作CPU的一个辅助硬件访问的芯片，在进行内存与IO设备数据传输时，不需要CPU来控制，直接通过DMA进行。\n\n### IO模型介绍\n\n#### **传统阻塞IO**\n当用户进程调用了recv()/recvfrom()这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。\n\n<img src=\"io/3.png\" style=\"zoom:50%;\" />\n\n```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class OtherTest {\n    static byte[] bs = new byte[1024];\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(6379);\n        while (true){\n            Socket socket = serverSocket.accept(); // 阻塞\n            socket.getInputStream().read(bs); // 阻塞\n            System.out.println(bs);\n        }\n    }\n}\n```\n如上代码可见，程序一次只能执行一个IO，当一个TCP连接上但是没有发送数据那么将会阻塞在read方法上，其他的TCP连接将得不到执行。所以有了`阻塞IO` + `多线程`的方式。\n\n但这种方式也有缺点，当连接多时，会导致新建大量的线程，性能下降。\n\n```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class OtherTest {\n    static byte[] bs = new byte[1024];\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(6379);\n        while (true){\n            Socket socket = serverSocket.accept(); // 阻塞\n            //得到一个TCP连接后就较给一个线程处理\n            Thread t = new Thread(() -> {\n                try {\n                    socket.getInputStream().read(bs);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            t.start();\n        }\n    }\n}\n```\n\n#### **非阻塞IO**\n当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。\n\n<img src=\"io/4.png\" style=\"zoom:50%;\" />\n\n根据非阻塞的特性，accept()，read()不在阻塞，如果没有TCP连接或者没有数据可读取则直接返回。上面就是非阻塞的模型，而在实际使用上，由于accept()，read()不在阻塞，我们代码上就需要通过记录下已建立连接的TCP，然后每次for循环去判断是否可读取。\n这种的方式我们也能知道缺点，如果有1W个TCP建立连接，且之后10个有发送数据，由于**for循环没法判断哪些连接有发送数据，所以需要不断的空轮询，轮询消耗大量的CPU时间**。\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class OtherTest {\n    static List<SocketChannel> socketChannelList = new ArrayList<>();\n    static ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel serverSocket = ServerSocketChannel.open();\n        SocketAddress socketAddress = new InetSocketAddress(\"loaclhost\",6379);\n        serverSocket.bind(socketAddress);\n        serverSocket.configureBlocking(false); //设置成非阻塞\n        while (true){\n            for(SocketChannel socketChannel: socketChannelList){\n                int read = socketChannel.read(byteBuffer);\n                if(read > 0){\n                    byte[] bs = new byte[read];\n                    byteBuffer.get(bs);\n                    byteBuffer.flip();\n                }\n            }\n            SocketChannel socket = serverSocket.accept();\n            if(socket != null){\n                socket.configureBlocking(false); //设置成非阻塞\n                socketChannelList.add(socket);\n            }\n        }\n    }\n}\n```\n#### **IO多路复用**\n多路复用？不懂意思。但是我们可以对比上面的非阻塞模型，由于非阻塞模型的方式需要用户进程那边不断的消耗CPU做轮询检查用户态的缓冲区是否收到了内核缓冲区的的数据。<font color=red>试想一下，如果内核那边能直接帮我们去检查并通知我们就好了。</font>UNIX/Linux 下的 select、poll、epoll 就是干这个的，监视的事情交给了内核，内核负责数据到达的处理。\n\n- select函数，同时对多个IO端口进行监听，当有I/O事件（文件描述符fd）发生了才轮询。他与非阻塞的区别在于，他是在有IO事件的时候才去轮询。\n- poll函数，和select函数没区别，只是**它没有最大连接数的限制，因是它是基于链表来存储的**。\n- epoll函数，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以他是采用了**事件驱动模式**。\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class OtherTest {\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        Selector selector = Selector.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress(6379));\n        //设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        //把ServerSocketChannel注册到selector上，关心的事件是OP_ACCEPT(连接事件)\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        //循环等待客户端连接\n        while (true) {\n            if (selector.select(1000) == 0) { //select函数，就是帮我们做监听的函数 select,poll,epoll的实现\n                System.out.println(\"========服务器等待1s,无连接=======\");\n                continue;\n            }\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = selectionKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey key = iterator.next();\n                //根据key对应的通道对应的事件\n                if (key.isAcceptable()) { //如果是OP_ACCEPT事件，其实就是有客户端连接的话\n                    //该客户端生成一个SoecktChannel\n                    try {\n                        SocketChannel socketChannel = serverSocketChannel.accept();\n                        socketChannel.configureBlocking(false);\n                        //将socketChannel注册到selector上,关注的事件是读，同时给socketChannel关联一个buffer\n                        socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果事件是一个读事件\n                if (key.isReadable()) {\n                    //通过key反向获取到对应的channel\n                    SocketChannel channel = (SocketChannel) key.channel();\n                    //获取到通过关联的buffer\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    try {\n                        channel.read(buffer);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(\"客户端发过来的消息是:\" + new String(buffer.array()));\n                }\n                //删除selectionKey,防止重复操作\n                iterator.remove();\n\n            }\n        }\n    }\n}\n```\n\n\n\n### 参考\n\n- https://www.jianshu.com/p/486b0965c296","source":"_posts/io.md","raw":"---\ntitle: IO知识详解\ntags:\n  - linux\ncategories:  linux\ndescription : IO知识详解\ndate: 2020-12-10 09:05:24\n---\n\n### 用户空间和内核空间\n由于CPU某些指令比较危险，如果错用会导致系统崩溃，为了保护系统，操作系统将内存空间划分为了两部分：`内核空间`，`用户空间`。\n\n### IO操作流程\n\n假设现在一个网络请求想访问服务器上的一个文件，那么他涉及的过程是怎么样的？\n\n#### **传统IO**\n1. 处理进程发起一个系统调用sys_read读取磁盘文件。\n2. CPU向DMA发送IO请求\n3. DMA将磁盘文件数据<font color=red>拷贝</font>到内核空间的read缓冲区。\n4. CPU把内核空间read缓冲区数据<font color=red>拷贝</font>到用户空间的缓冲区。\n5. 进程发起一个系统调用socket_write，向网卡写数据。\n6. CPU把用户空间缓冲区的数据<font color=red>拷贝</font>到内核空间的socket缓冲区。\n7. DMA把内核空间的socket缓冲区数据<font color=red>拷贝</font>到网卡。\n传统的IO模型整个过程总共发生了四次拷贝和四次的用户态和内核态的切换。\n\n![IO读取数据用户/内核空间](io/1.png)\n\n#### **零拷贝IO**\n1. 处理进程发起一个系统调用sys_read读取磁盘文件。\n2. CPU向DMA发送IO请求\n3. DMA将磁盘文件数据<font color=red>拷贝</font>到内核空间的read缓冲区。\n4. CPU把内核空间read缓冲区数据<font color=red>拷贝</font>到内核空间的socket缓冲区。\n5. DMA把内核空间的socket缓冲区数据<font color=red>拷贝</font>到网卡。\n零拷贝IO模型整个过程总共发生了三次拷贝和两次的用户态和内核态的切换。\n\n![IO读取数据用户/内核空间](io/2.png)\n\n注 : DMA即直接存储器访问，可以看作CPU的一个辅助硬件访问的芯片，在进行内存与IO设备数据传输时，不需要CPU来控制，直接通过DMA进行。\n\n### IO模型介绍\n\n#### **传统阻塞IO**\n当用户进程调用了recv()/recvfrom()这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。\n\n<img src=\"io/3.png\" style=\"zoom:50%;\" />\n\n```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class OtherTest {\n    static byte[] bs = new byte[1024];\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(6379);\n        while (true){\n            Socket socket = serverSocket.accept(); // 阻塞\n            socket.getInputStream().read(bs); // 阻塞\n            System.out.println(bs);\n        }\n    }\n}\n```\n如上代码可见，程序一次只能执行一个IO，当一个TCP连接上但是没有发送数据那么将会阻塞在read方法上，其他的TCP连接将得不到执行。所以有了`阻塞IO` + `多线程`的方式。\n\n但这种方式也有缺点，当连接多时，会导致新建大量的线程，性能下降。\n\n```java\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class OtherTest {\n    static byte[] bs = new byte[1024];\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(6379);\n        while (true){\n            Socket socket = serverSocket.accept(); // 阻塞\n            //得到一个TCP连接后就较给一个线程处理\n            Thread t = new Thread(() -> {\n                try {\n                    socket.getInputStream().read(bs);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            t.start();\n        }\n    }\n}\n```\n\n#### **非阻塞IO**\n当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。\n\n<img src=\"io/4.png\" style=\"zoom:50%;\" />\n\n根据非阻塞的特性，accept()，read()不在阻塞，如果没有TCP连接或者没有数据可读取则直接返回。上面就是非阻塞的模型，而在实际使用上，由于accept()，read()不在阻塞，我们代码上就需要通过记录下已建立连接的TCP，然后每次for循环去判断是否可读取。\n这种的方式我们也能知道缺点，如果有1W个TCP建立连接，且之后10个有发送数据，由于**for循环没法判断哪些连接有发送数据，所以需要不断的空轮询，轮询消耗大量的CPU时间**。\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class OtherTest {\n    static List<SocketChannel> socketChannelList = new ArrayList<>();\n    static ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel serverSocket = ServerSocketChannel.open();\n        SocketAddress socketAddress = new InetSocketAddress(\"loaclhost\",6379);\n        serverSocket.bind(socketAddress);\n        serverSocket.configureBlocking(false); //设置成非阻塞\n        while (true){\n            for(SocketChannel socketChannel: socketChannelList){\n                int read = socketChannel.read(byteBuffer);\n                if(read > 0){\n                    byte[] bs = new byte[read];\n                    byteBuffer.get(bs);\n                    byteBuffer.flip();\n                }\n            }\n            SocketChannel socket = serverSocket.accept();\n            if(socket != null){\n                socket.configureBlocking(false); //设置成非阻塞\n                socketChannelList.add(socket);\n            }\n        }\n    }\n}\n```\n#### **IO多路复用**\n多路复用？不懂意思。但是我们可以对比上面的非阻塞模型，由于非阻塞模型的方式需要用户进程那边不断的消耗CPU做轮询检查用户态的缓冲区是否收到了内核缓冲区的的数据。<font color=red>试想一下，如果内核那边能直接帮我们去检查并通知我们就好了。</font>UNIX/Linux 下的 select、poll、epoll 就是干这个的，监视的事情交给了内核，内核负责数据到达的处理。\n\n- select函数，同时对多个IO端口进行监听，当有I/O事件（文件描述符fd）发生了才轮询。他与非阻塞的区别在于，他是在有IO事件的时候才去轮询。\n- poll函数，和select函数没区别，只是**它没有最大连接数的限制，因是它是基于链表来存储的**。\n- epoll函数，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以他是采用了**事件驱动模式**。\n\n```java\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class OtherTest {\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        Selector selector = Selector.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress(6379));\n        //设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        //把ServerSocketChannel注册到selector上，关心的事件是OP_ACCEPT(连接事件)\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        //循环等待客户端连接\n        while (true) {\n            if (selector.select(1000) == 0) { //select函数，就是帮我们做监听的函数 select,poll,epoll的实现\n                System.out.println(\"========服务器等待1s,无连接=======\");\n                continue;\n            }\n            Set<SelectionKey> selectionKeys = selector.selectedKeys();\n            Iterator<SelectionKey> iterator = selectionKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey key = iterator.next();\n                //根据key对应的通道对应的事件\n                if (key.isAcceptable()) { //如果是OP_ACCEPT事件，其实就是有客户端连接的话\n                    //该客户端生成一个SoecktChannel\n                    try {\n                        SocketChannel socketChannel = serverSocketChannel.accept();\n                        socketChannel.configureBlocking(false);\n                        //将socketChannel注册到selector上,关注的事件是读，同时给socketChannel关联一个buffer\n                        socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果事件是一个读事件\n                if (key.isReadable()) {\n                    //通过key反向获取到对应的channel\n                    SocketChannel channel = (SocketChannel) key.channel();\n                    //获取到通过关联的buffer\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    try {\n                        channel.read(buffer);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(\"客户端发过来的消息是:\" + new String(buffer.array()));\n                }\n                //删除selectionKey,防止重复操作\n                iterator.remove();\n\n            }\n        }\n    }\n}\n```\n\n\n\n### 参考\n\n- https://www.jianshu.com/p/486b0965c296","slug":"io","published":1,"updated":"2021-04-08T00:47:06.757Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhuq000hqwv2d2ae5br4","content":"<h3 id=\"用户空间和内核空间\"><a href=\"#用户空间和内核空间\" class=\"headerlink\" title=\"用户空间和内核空间\"></a>用户空间和内核空间</h3><p>由于CPU某些指令比较危险，如果错用会导致系统崩溃，为了保护系统，操作系统将内存空间划分为了两部分：<code>内核空间</code>，<code>用户空间</code>。</p>\n<h3 id=\"IO操作流程\"><a href=\"#IO操作流程\" class=\"headerlink\" title=\"IO操作流程\"></a>IO操作流程</h3><p>假设现在一个网络请求想访问服务器上的一个文件，那么他涉及的过程是怎么样的？</p>\n<h4 id=\"传统IO\"><a href=\"#传统IO\" class=\"headerlink\" title=\"传统IO\"></a><strong>传统IO</strong></h4><ol>\n<li>处理进程发起一个系统调用sys_read读取磁盘文件。</li>\n<li>CPU向DMA发送IO请求</li>\n<li>DMA将磁盘文件数据<font color=\"red\">拷贝</font>到内核空间的read缓冲区。</li>\n<li>CPU把内核空间read缓冲区数据<font color=\"red\">拷贝</font>到用户空间的缓冲区。</li>\n<li>进程发起一个系统调用socket_write，向网卡写数据。</li>\n<li>CPU把用户空间缓冲区的数据<font color=\"red\">拷贝</font>到内核空间的socket缓冲区。</li>\n<li>DMA把内核空间的socket缓冲区数据<font color=\"red\">拷贝</font>到网卡。<br>传统的IO模型整个过程总共发生了四次拷贝和四次的用户态和内核态的切换。</li>\n</ol>\n<p><img src=\"/2020/12/10/io/1.png\" alt=\"IO读取数据用户/内核空间\"></p>\n<h4 id=\"零拷贝IO\"><a href=\"#零拷贝IO\" class=\"headerlink\" title=\"零拷贝IO\"></a><strong>零拷贝IO</strong></h4><ol>\n<li>处理进程发起一个系统调用sys_read读取磁盘文件。</li>\n<li>CPU向DMA发送IO请求</li>\n<li>DMA将磁盘文件数据<font color=\"red\">拷贝</font>到内核空间的read缓冲区。</li>\n<li>CPU把内核空间read缓冲区数据<font color=\"red\">拷贝</font>到内核空间的socket缓冲区。</li>\n<li>DMA把内核空间的socket缓冲区数据<font color=\"red\">拷贝</font>到网卡。<br>零拷贝IO模型整个过程总共发生了三次拷贝和两次的用户态和内核态的切换。</li>\n</ol>\n<p><img src=\"/2020/12/10/io/2.png\" alt=\"IO读取数据用户/内核空间\"></p>\n<p>注 : DMA即直接存储器访问，可以看作CPU的一个辅助硬件访问的芯片，在进行内存与IO设备数据传输时，不需要CPU来控制，直接通过DMA进行。</p>\n<h3 id=\"IO模型介绍\"><a href=\"#IO模型介绍\" class=\"headerlink\" title=\"IO模型介绍\"></a>IO模型介绍</h3><h4 id=\"传统阻塞IO\"><a href=\"#传统阻塞IO\" class=\"headerlink\" title=\"传统阻塞IO\"></a><strong>传统阻塞IO</strong></h4><p>当用户进程调用了recv()/recvfrom()这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>\n<img src=\"/2020/12/10/io/3.png\" style=\"zoom:50%;\">\n\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span>IOException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>ServerSocket<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>Socket<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bs <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        ServerSocket serverSocket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServerSocket</span><span class=\"token punctuation\">(</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            Socket socket <span class=\"token operator\">=</span> serverSocket<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 阻塞</span>\n            socket<span class=\"token punctuation\">.</span><span class=\"token function\">getInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>bs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 阻塞</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>bs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>如上代码可见，程序一次只能执行一个IO，当一个TCP连接上但是没有发送数据那么将会阻塞在read方法上，其他的TCP连接将得不到执行。所以有了<code>阻塞IO</code> + <code>多线程</code>的方式。</p>\n<p>但这种方式也有缺点，当连接多时，会导致新建大量的线程，性能下降。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span>IOException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>ServerSocket<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>Socket<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bs <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        ServerSocket serverSocket <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServerSocket</span><span class=\"token punctuation\">(</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            Socket socket <span class=\"token operator\">=</span> serverSocket<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 阻塞</span>\n            <span class=\"token comment\" spellcheck=\"true\">//得到一个TCP连接后就较给一个线程处理</span>\n            Thread t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    socket<span class=\"token punctuation\">.</span><span class=\"token function\">getInputStream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>bs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"非阻塞IO\"><a href=\"#非阻塞IO\" class=\"headerlink\" title=\"非阻塞IO\"></a><strong>非阻塞IO</strong></h4><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>\n<img src=\"/2020/12/10/io/4.png\" style=\"zoom:50%;\">\n\n<p>根据非阻塞的特性，accept()，read()不在阻塞，如果没有TCP连接或者没有数据可读取则直接返回。上面就是非阻塞的模型，而在实际使用上，由于accept()，read()不在阻塞，我们代码上就需要通过记录下已建立连接的TCP，然后每次for循环去判断是否可读取。<br>这种的方式我们也能知道缺点，如果有1W个TCP建立连接，且之后10个有发送数据，由于<strong>for循环没法判断哪些连接有发送数据，所以需要不断的空轮询，轮询消耗大量的CPU时间</strong>。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span>IOException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>InetSocketAddress<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>SocketAddress<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>ByteBuffer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>ServerSocketChannel<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>SocketChannel<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>ArrayList<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>List<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> List<span class=\"token operator\">&lt;</span>SocketChannel<span class=\"token operator\">></span> socketChannelList <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> ByteBuffer byteBuffer <span class=\"token operator\">=</span> ByteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        ServerSocketChannel serverSocket <span class=\"token operator\">=</span> ServerSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        SocketAddress socketAddress <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"loaclhost\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        serverSocket<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>socketAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        serverSocket<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//设置成非阻塞</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span>SocketChannel socketChannel<span class=\"token operator\">:</span> socketChannelList<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">int</span> read <span class=\"token operator\">=</span> socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>byteBuffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>read <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bs <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span>read<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n                    byteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>bs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    byteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">flip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            SocketChannel socket <span class=\"token operator\">=</span> serverSocket<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>socket <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                socket<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//设置成非阻塞</span>\n                socketChannelList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>socket<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a><strong>IO多路复用</strong></h4><p>多路复用？不懂意思。但是我们可以对比上面的非阻塞模型，由于非阻塞模型的方式需要用户进程那边不断的消耗CPU做轮询检查用户态的缓冲区是否收到了内核缓冲区的的数据。<font color=\"red\">试想一下，如果内核那边能直接帮我们去检查并通知我们就好了。</font>UNIX/Linux 下的 select、poll、epoll 就是干这个的，监视的事情交给了内核，内核负责数据到达的处理。</p>\n<ul>\n<li>select函数，同时对多个IO端口进行监听，当有I/O事件（文件描述符fd）发生了才轮询。他与非阻塞的区别在于，他是在有IO事件的时候才去轮询。</li>\n<li>poll函数，和select函数没区别，只是<strong>它没有最大连接数的限制，因是它是基于链表来存储的</strong>。</li>\n<li>epoll函数，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以他是采用了<strong>事件驱动模式</strong>。</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span>IOException<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>net<span class=\"token punctuation\">.</span>InetSocketAddress<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>ByteBuffer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>SelectionKey<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>Selector<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>ServerSocketChannel<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>nio<span class=\"token punctuation\">.</span>channels<span class=\"token punctuation\">.</span>SocketChannel<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Iterator<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Set<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> IOException <span class=\"token punctuation\">{</span>\n        ServerSocketChannel serverSocketChannel <span class=\"token operator\">=</span> ServerSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Selector selector <span class=\"token operator\">=</span> Selector<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">socket</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">InetSocketAddress</span><span class=\"token punctuation\">(</span><span class=\"token number\">6379</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//设置为非阻塞</span>\n        serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//把ServerSocketChannel注册到selector上，关心的事件是OP_ACCEPT(连接事件)</span>\n        serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> SelectionKey<span class=\"token punctuation\">.</span>OP_ACCEPT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//循环等待客户端连接</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//select函数，就是帮我们做监听的函数 select,poll,epoll的实现</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"========服务器等待1s,无连接=======\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            Set<span class=\"token operator\">&lt;</span>SelectionKey<span class=\"token operator\">></span> selectionKeys <span class=\"token operator\">=</span> selector<span class=\"token punctuation\">.</span><span class=\"token function\">selectedKeys</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Iterator<span class=\"token operator\">&lt;</span>SelectionKey<span class=\"token operator\">></span> iterator <span class=\"token operator\">=</span> selectionKeys<span class=\"token punctuation\">.</span><span class=\"token function\">iterator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>iterator<span class=\"token punctuation\">.</span><span class=\"token function\">hasNext</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                SelectionKey key <span class=\"token operator\">=</span> iterator<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//根据key对应的通道对应的事件</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isAcceptable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//如果是OP_ACCEPT事件，其实就是有客户端连接的话</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//该客户端生成一个SoecktChannel</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        SocketChannel socketChannel <span class=\"token operator\">=</span> serverSocketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">configureBlocking</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token comment\" spellcheck=\"true\">//将socketChannel注册到selector上,关注的事件是读，同时给socketChannel关联一个buffer</span>\n                        socketChannel<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>selector<span class=\"token punctuation\">,</span> SelectionKey<span class=\"token punctuation\">.</span>OP_READ<span class=\"token punctuation\">,</span> ByteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token comment\" spellcheck=\"true\">//如果事件是一个读事件</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">isReadable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//通过key反向获取到对应的channel</span>\n                    SocketChannel channel <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>SocketChannel<span class=\"token punctuation\">)</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">channel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//获取到通过关联的buffer</span>\n                    ByteBuffer buffer <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>ByteBuffer<span class=\"token punctuation\">)</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">attachment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        channel<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"客户端发过来的消息是:\"</span> <span class=\"token operator\">+</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">.</span><span class=\"token function\">array</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token comment\" spellcheck=\"true\">//删除selectionKey,防止重复操作</span>\n                iterator<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/486b0965c296\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/486b0965c296</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"用户空间和内核空间\"><a href=\"#用户空间和内核空间\" class=\"headerlink\" title=\"用户空间和内核空间\"></a>用户空间和内核空间</h3><p>由于CPU某些指令比较危险，如果错用会导致系统崩溃，为了保护系统，操作系统将内存空间划分为了两部分：<code>内核空间</code>，<code>用户空间</code>。</p>\n<h3 id=\"IO操作流程\"><a href=\"#IO操作流程\" class=\"headerlink\" title=\"IO操作流程\"></a>IO操作流程</h3><p>假设现在一个网络请求想访问服务器上的一个文件，那么他涉及的过程是怎么样的？</p>\n<h4 id=\"传统IO\"><a href=\"#传统IO\" class=\"headerlink\" title=\"传统IO\"></a><strong>传统IO</strong></h4><ol>\n<li>处理进程发起一个系统调用sys_read读取磁盘文件。</li>\n<li>CPU向DMA发送IO请求</li>\n<li>DMA将磁盘文件数据<font color=\"red\">拷贝</font>到内核空间的read缓冲区。</li>\n<li>CPU把内核空间read缓冲区数据<font color=\"red\">拷贝</font>到用户空间的缓冲区。</li>\n<li>进程发起一个系统调用socket_write，向网卡写数据。</li>\n<li>CPU把用户空间缓冲区的数据<font color=\"red\">拷贝</font>到内核空间的socket缓冲区。</li>\n<li>DMA把内核空间的socket缓冲区数据<font color=\"red\">拷贝</font>到网卡。<br>传统的IO模型整个过程总共发生了四次拷贝和四次的用户态和内核态的切换。</li>\n</ol>\n<p><img src=\"/2020/12/10/io/1.png\" alt=\"IO读取数据用户/内核空间\"></p>\n<h4 id=\"零拷贝IO\"><a href=\"#零拷贝IO\" class=\"headerlink\" title=\"零拷贝IO\"></a><strong>零拷贝IO</strong></h4><ol>\n<li>处理进程发起一个系统调用sys_read读取磁盘文件。</li>\n<li>CPU向DMA发送IO请求</li>\n<li>DMA将磁盘文件数据<font color=\"red\">拷贝</font>到内核空间的read缓冲区。</li>\n<li>CPU把内核空间read缓冲区数据<font color=\"red\">拷贝</font>到内核空间的socket缓冲区。</li>\n<li>DMA把内核空间的socket缓冲区数据<font color=\"red\">拷贝</font>到网卡。<br>零拷贝IO模型整个过程总共发生了三次拷贝和两次的用户态和内核态的切换。</li>\n</ol>\n<p><img src=\"/2020/12/10/io/2.png\" alt=\"IO读取数据用户/内核空间\"></p>\n<p>注 : DMA即直接存储器访问，可以看作CPU的一个辅助硬件访问的芯片，在进行内存与IO设备数据传输时，不需要CPU来控制，直接通过DMA进行。</p>\n<h3 id=\"IO模型介绍\"><a href=\"#IO模型介绍\" class=\"headerlink\" title=\"IO模型介绍\"></a>IO模型介绍</h3><h4 id=\"传统阻塞IO\"><a href=\"#传统阻塞IO\" class=\"headerlink\" title=\"传统阻塞IO\"></a><strong>传统阻塞IO</strong></h4><p>当用户进程调用了recv()/recvfrom()这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>\n<img src=\"/2020/12/10/io/3.png\" style=\"zoom:50%;\">\n\n<pre><code class=\"java\">import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class OtherTest {\n    static byte[] bs = new byte[1024];\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(6379);\n        while (true){\n            Socket socket = serverSocket.accept(); // 阻塞\n            socket.getInputStream().read(bs); // 阻塞\n            System.out.println(bs);\n        }\n    }\n}</code></pre>\n<p>如上代码可见，程序一次只能执行一个IO，当一个TCP连接上但是没有发送数据那么将会阻塞在read方法上，其他的TCP连接将得不到执行。所以有了<code>阻塞IO</code> + <code>多线程</code>的方式。</p>\n<p>但这种方式也有缺点，当连接多时，会导致新建大量的线程，性能下降。</p>\n<pre><code class=\"java\">import java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class OtherTest {\n    static byte[] bs = new byte[1024];\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(6379);\n        while (true){\n            Socket socket = serverSocket.accept(); // 阻塞\n            //得到一个TCP连接后就较给一个线程处理\n            Thread t = new Thread(() -&gt; {\n                try {\n                    socket.getInputStream().read(bs);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            });\n            t.start();\n        }\n    }\n}</code></pre>\n<h4 id=\"非阻塞IO\"><a href=\"#非阻塞IO\" class=\"headerlink\" title=\"非阻塞IO\"></a><strong>非阻塞IO</strong></h4><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>\n<img src=\"/2020/12/10/io/4.png\" style=\"zoom:50%;\">\n\n<p>根据非阻塞的特性，accept()，read()不在阻塞，如果没有TCP连接或者没有数据可读取则直接返回。上面就是非阻塞的模型，而在实际使用上，由于accept()，read()不在阻塞，我们代码上就需要通过记录下已建立连接的TCP，然后每次for循环去判断是否可读取。<br>这种的方式我们也能知道缺点，如果有1W个TCP建立连接，且之后10个有发送数据，由于<strong>for循环没法判断哪些连接有发送数据，所以需要不断的空轮询，轮询消耗大量的CPU时间</strong>。</p>\n<pre><code class=\"java\">import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class OtherTest {\n    static List&lt;SocketChannel&gt; socketChannelList = new ArrayList&lt;&gt;();\n    static ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel serverSocket = ServerSocketChannel.open();\n        SocketAddress socketAddress = new InetSocketAddress(&quot;loaclhost&quot;,6379);\n        serverSocket.bind(socketAddress);\n        serverSocket.configureBlocking(false); //设置成非阻塞\n        while (true){\n            for(SocketChannel socketChannel: socketChannelList){\n                int read = socketChannel.read(byteBuffer);\n                if(read &gt; 0){\n                    byte[] bs = new byte[read];\n                    byteBuffer.get(bs);\n                    byteBuffer.flip();\n                }\n            }\n            SocketChannel socket = serverSocket.accept();\n            if(socket != null){\n                socket.configureBlocking(false); //设置成非阻塞\n                socketChannelList.add(socket);\n            }\n        }\n    }\n}</code></pre>\n<h4 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a><strong>IO多路复用</strong></h4><p>多路复用？不懂意思。但是我们可以对比上面的非阻塞模型，由于非阻塞模型的方式需要用户进程那边不断的消耗CPU做轮询检查用户态的缓冲区是否收到了内核缓冲区的的数据。<font color=\"red\">试想一下，如果内核那边能直接帮我们去检查并通知我们就好了。</font>UNIX/Linux 下的 select、poll、epoll 就是干这个的，监视的事情交给了内核，内核负责数据到达的处理。</p>\n<ul>\n<li>select函数，同时对多个IO端口进行监听，当有I/O事件（文件描述符fd）发生了才轮询。他与非阻塞的区别在于，他是在有IO事件的时候才去轮询。</li>\n<li>poll函数，和select函数没区别，只是<strong>它没有最大连接数的限制，因是它是基于链表来存储的</strong>。</li>\n<li>epoll函数，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以他是采用了<strong>事件驱动模式</strong>。</li>\n</ul>\n<pre><code class=\"java\">import java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.Iterator;\nimport java.util.Set;\n\npublic class OtherTest {\n    public static void main(String[] args) throws IOException {\n        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n        Selector selector = Selector.open();\n        serverSocketChannel.socket().bind(new InetSocketAddress(6379));\n        //设置为非阻塞\n        serverSocketChannel.configureBlocking(false);\n        //把ServerSocketChannel注册到selector上，关心的事件是OP_ACCEPT(连接事件)\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        //循环等待客户端连接\n        while (true) {\n            if (selector.select(1000) == 0) { //select函数，就是帮我们做监听的函数 select,poll,epoll的实现\n                System.out.println(&quot;========服务器等待1s,无连接=======&quot;);\n                continue;\n            }\n            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();\n            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();\n            while (iterator.hasNext()) {\n                SelectionKey key = iterator.next();\n                //根据key对应的通道对应的事件\n                if (key.isAcceptable()) { //如果是OP_ACCEPT事件，其实就是有客户端连接的话\n                    //该客户端生成一个SoecktChannel\n                    try {\n                        SocketChannel socketChannel = serverSocketChannel.accept();\n                        socketChannel.configureBlocking(false);\n                        //将socketChannel注册到selector上,关注的事件是读，同时给socketChannel关联一个buffer\n                        socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(1024));\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                //如果事件是一个读事件\n                if (key.isReadable()) {\n                    //通过key反向获取到对应的channel\n                    SocketChannel channel = (SocketChannel) key.channel();\n                    //获取到通过关联的buffer\n                    ByteBuffer buffer = (ByteBuffer) key.attachment();\n                    try {\n                        channel.read(buffer);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(&quot;客户端发过来的消息是:&quot; + new String(buffer.array()));\n                }\n                //删除selectionKey,防止重复操作\n                iterator.remove();\n\n            }\n        }\n    }\n}</code></pre>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/486b0965c296\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/486b0965c296</a></li>\n</ul>\n"},{"title":"HashMap原理浅析","description":"HashMap原理浅析","date":"2020-07-27T16:00:00.000Z","_content":"## 基础\n### 数组的优点缺点\n- 数组在内存空间上连续。能实现快速访问某个下标的值。\n- 数组空间的大小一旦确定后就不能更改，如果需要增大减小需要新建数组重新设值。\n\n### 链表的优点缺点\n\n- 链表在内存空间上是不连续的。插入删除某个值速度快\n- 链表不能随机查找，必须从第一个开始遍历，查找效率低\n\n### HashMap散列表结构\n\nHashMap采用了散列表结构，结合了数组和链表的优点。\n\n![HashMap结构](hashmap/1.png)\n<!--more-->\n### 什么是哈希？\n\nHash也称之为散列。基本原理是把<font color=red>任意长度</font>的输入，通过Hash算法变成<font color=red>固定长度</font>的输出。这个映射的规则就是对应的<font color=red>Hash算法</font>，而原始数据映射后的<font color=red>二进制串</font>就是哈希值。\n\nHash的特点\n\n- 从hash值不可以反向推导出原始的数据\n- 输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值\n- 哈希算法的执行效率要高效，长本文也能快速的计算出哈希值\n- hash算法的冲突概率要小\n\n由于hash的原理是将输入空间的值映射到hash空间中，而hash值的控件远小于输入的空间。根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。\n\n## HashMap原理讲解\n### HahMap的继承体系\n\nHashMap实现了Map接口，Cloneable接口，Serializable接口\n\n![HashMap继承体系](hashmap/2.png)\n\n### Node数据结构分析\n\nHashMap的Node结构是一个单链表结构。Hash发生碰撞时，此时元素没法放在同一个数组下标，就会将相同hash的Node组成一个单链表。\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; //这个hash是通过获取key的hashCode然后经过\"扰动\"后的结果\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n}\n```\n\n### 底层存储结构介绍\n\n底层存储结构是<font color=red>数组+单链表+红黑树</font>的结构。\n\n什么情况下链表会转化成红黑树?<font color=red>当单链表长度达到8，且数组的长度大于64时</font>\n\n![HashMap底层存储结构](hashmap/3.png)\n\n### put方法原理分析\n\n![put方法原理](hashmap/4.png)\n\n### JDK8为什么引入红黑树\n\n由于hash碰撞的原因，可能导致同一个数组下标下的单链表长度很长时，查询效率变低。这时候将链表转成红黑树来保证查询的效率。\n\n## Hash重要源码分析\n\n### HashMap核心属性分析\n\n```java\n//缺省数组大小,默认16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n//数组最大大小\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n//缺省负载因子\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n//树化阈值\nstatic final int TREEIFY_THRESHOLD = 8;\n//树降级为链表的阈值\nstatic final int UNTREEIFY_THRESHOLD = 6;\n//待定\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n//hash表\ntransient Node<K,V>[] table;\n//当前hash表中元素个数\ntransient int size;\n//当前hash表结构的修改次数\ntransient int modCount;\n//扩容阈值，当你的哈希表中的元素超过阈值时，触发扩容\nint threshold;\n//负载因子, threshold = capacity(数组长度) * loadFactor\nfinal float loadFactor;\n```\n\n### 构造方法分析\n\n```java\n\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\npublic HashMap(int initialCapacity, float loadFactor) {\n    //数组长度不能小于0\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    //数组长度不能大于最大值\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    //负载因子不能小于0\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n    //初始化负载因子\n    this.loadFactor = loadFactor;\n    //传入数组大小 计算扩容阈值 \n    //这里初始化的threshold也是第一次初始化HashMap的初始长度\n    this.threshold = tableSizeFor(initialCapacity);\n}\n\n//由于我们传入的initialCapacity是随机的，但是Hashmap要求数组的长度必须是2的次方，所以通过此函数进行转换\n//作用 : 返回一个大于等于当前cap的数字，且这个数字是2的次方数\nstatic final int tableSizeFor(int cap) {\n        int n = cap - 1; \n        n |= n >>> 1; \n        n |= n >>> 2; \n        n |= n >>> 4; \n        n |= n >>> 8; \n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n```\n\n### put方法分析\n\n```java\npublic V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n}\n```\n\n```java\n//hash扰动函数，使hash更加散列\n//作用:让key的hash值的高16位也参与运算\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n```java\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    \t//tab -- 当前hashMap的散列表\n    \t//p -- 当前散列表的元素\n    \t//n -- 表示散列表数组的长度， i -- 表示路由寻址结果\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    \t//当散列表==null时调用resize方法进行初始化\n    \t//这里hashMap是延迟初始化\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n    \n    \t// (n - 1) & hash 是路由算法\n    \t// 最简单的一种情况，寻址找到的桶位刚好是null,这个时候直接newNode\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            //e -- node临时元素，k -- 表示临时的一个key\n            Node<K,V> e; K k;\n            //p表示桶上第一个元素\n            //表示桶位中的该元素与你当前插入的元素的key完全一致，就用e = p,后续做替换操作\n            //这里需要注意的是判断你是否一致使用equal方法,所以hashMap判断会用到equal方法，那么我们重写时要注意\n            if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            \n            //如果这个p已经是红黑树了，那用红黑树的方法\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            \n            else {\n                //到这一步，表示现在桶上是一个链表，那么接下去要for链表看看上面有没有跟你一致的key，如果有做替换。\n                //当前链表的情况是链表的头元素与我们插入的key不一致，要接下去判断链表上其他元素的key是否一致\n                for (int binCount = 0; ; ++binCount) {\n                    //到这一步表示到了链表的末尾了还是没有一致的\n                    if ((e = p.next) == null) {\n                        //把key-value加到最后一个元素上\n                        p.next = newNode(hash, key, value, null);\n                        //这里判断是否进行树化，链表的长度>=8就转成红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    //找到了链表上一个元素与要出入的元素的key一致\n                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            \n            //进行value的替换\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount; //记录操作次次数\n    \t//如果全部元素 > 扩容阈值 的话 就进行扩容\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n}\n```\n\n### 扩容方法分析\n\n![长度16扩容成32](hashmap/5.png)\n\n从图可以看出，<font color=red>同一个桶上的元素扩容后要嘛在原来15的位置，要嘛在31的位置</font>。\n\n这里根据路由寻址函数【hash & (table.length - 1)】，可以分析出<font color=red>扩容后元素的去向有两种，一种还是原来的下标，另外一种是原来下标+扩容之前数组的长度</font>\n\n例如上面这个例子，原来数组长度是16， 对于下标为15的元素，他扩容后的去向要嘛是15，要嘛是31（15 + 16）。\n\n```java\n//扩容方法，为了解决哈希冲突导致链化影响查询效率，扩容解决该方法\nfinal Node<K,V>[] resize() {\n    //oldTab -- 扩容之前的哈希表\n    Node<K,V>[] oldTab = table;\n    //oldCap -- 扩容之前哈希表的长度\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    //oldThr -- 表示扩容之前的阈值，触发本次扩容的阈值\n    int oldThr = threshold;\n    //newCap -- 扩容之后哈希表的长度\n    //newThr -- 扩容之后下次触发扩容的条件\n    int newCap, newThr = 0;\n    \n    //===================这一段就是用来算newCap，newThr=============================\n    //条件如果成立，表示散列表已经初始化过了，这次是一次正常扩容\n    if (oldCap > 0) {\n        //如果当前的哈希表数组长度已经到最大长度了，那就不能在扩容了,且设置扩容条件为int最大值\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //newCap = oldCap << 1 表示我要把数组扩大一倍\n        //新的数组的长度小于最大值限制 且 扩容之前哈希表的长度 >= 16 就设置新的扩容阈值，否则不设置\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1;\n    }\n    //oldCap = 0 , 说明hashmap的散列表还没初始化，走到下面这一步一般是通过new HashMap(15)这样初始化的。这种初始化只有设置了扩容阈值\n    //这里oldThr是旧的扩容阈值，这里别以为扩容阈值我们在new hashmap的时候就设置值了，其实如果是不带参数的new HashMap时候，这个扩容阈值是等于0，如果扩容值已经有了，那就设定要初始化的数组的大小为旧的扩容阈值\n    else if (oldThr > 0)\n        newCap = oldThr;\n    else {\n        //oldThr = 0 的时候，默认要初始化的数组的大小为16，然后下一次的扩容阈值是 16 * 0.75\n        //进来这里，一般是通过new HashMap()，没带任何参数创建的时候\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    //newThr == 0,通过newCap 和 loadFactor计算出一个newThr\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    //==========================================================================\n   \n    threshold = newThr; //赋值新的扩容阈值\n    // 初始化哈希表\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; \n    table = newTab;\n    //oldTab =! null 说明hashmap本次扩容之前，table不是null,说明是扩容而不是初始化\n    if (oldTab != null) {\n        //遍历扩容前的哈希数组\n        for (int j = 0; j < oldCap; ++j) {\n            //e -- 当前Node节点\n            Node<K,V> e;\n            // 这个条件满足，说明当前桶位上有数据，但是不清楚是单个数据、链表还是红黑树\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                //这个条件满足的话，表示桶位上只有一个元素\n                if (e.next == null){\n                    //根据路由寻址算法计算出新桶位并迁移元素\n                    newTab[e.hash & (newCap - 1)] = e;\n                }\n                else if (e instanceof TreeNode){\n                    //如果是红黑树，则按照红黑树的方式\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                }else {\n                    //这个条件就是 桶位上是链表的情况\n                    //低位链表:存放在扩容之后的数组的下标位置，与当前数组的下标位置一致\n                    Node<K,V> loHead = null, loTail = null;\n                    //高位链表:存放在扩容之后的数组的下标位置，为当前数组的下标位置 + 扩容之前数组的长度\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    \n                    do {\n                        next = e.next;\n                        //下面这个(e.hash & oldCap) == 0 用来判断该元素扩容后是在高位链表还是低位链表\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    \n                    //通过上面的赋值，如果低位有量就进行转移\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                     //通过上面的赋值，如果高位有量就进行转移\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n### get方法分析\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    // tab : 引用当前hashMap的散列表\n    //first : 桶位中的头元素\n    //n : 数组的长度\n    //e : 临时node元素\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    \n    if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) {\n        //第一种情况:定位出来的第一个桶位元素是我们要的元素，就直接返回\n        if (first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        //第二种情况:如果是链表或者红黑树的情况\n        if ((e = first.next) != null) {\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            //下面for循环就是遍历链表获取要取的数据\n            do {\n                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))) )\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n### remove方法分析\n\n```java\npublic V remove(Object key) {\n    Node<K,V> e;\n    return (e = removeNode(hash(key), key, null, false, true)) == null ?\n        null : e.value;\n}\n\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                           boolean matchValue, boolean movable) {\n    //tab : 引用当前hashmap的散列表\n    //p : 当前node元素\n    //n : 散列表长度\n    //index ：寻址的数组下标\n    Node<K,V>[] tab; Node<K,V> p; int n, index;\n    //下面就是判断并赋值各种情况，例如散列表已经初始化，桶位有值等\n    if ((tab = table) != null && (n = tab.length) > 0 && (p = tab[index = (n - 1) & hash]) != null ) {\n        //node : 用来记录查找到的的元素\n        //e : 当前Node的下一个元素\n        Node<K,V> node = null, e; K k; V v;\n        //这种情况就是第一个元素就是要找的元素\n        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))){\n            node = p;\n        }else if ((e = p.next) != null) {\n            if (p instanceof TreeNode){\n                //红黑的情况\n                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n            }else {\n                //链表的情况，就是遍历查找了\n                do {\n                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) {\n                        node = e;\n                        break;\n                    }\n                    p = e;\n                } while ((e = e.next) != null);\n            }\n        }\n        //下面就是对应的删除逻辑了\n        if (node != null && (!matchValue || (v = node.value) == value ||\n                             (value != null && value.equals(v)))) {\n            if (node instanceof TreeNode)\n                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n            else if (node == p)\n                tab[index] = node.next;\n            else\n                p.next = node.next;\n            ++modCount;\n            --size;\n            afterNodeRemoval(node);\n            return node;\n        }\n    }\n    return null;\n}\n```\n\n\n\n## 总结\n\n- 当单链表长度达到8，且数组的长度大于64时链表会转成红黑树\n- HashMap的初始化是在第一次插入数据时初始化的，所以Hash是<font color=red>懒加载初始化</font>\n- 如果是HashMap没带参数的初始化，那默认刚开始初始化的数组大小位16，且下次的扩容阈值是 16  * 0.75 = 12\n- 每次扩容都是将数组的大小增加一倍，扩容的阈值也是增加一倍\n- HashMap决定元素在哪个数组下标的路由寻址算法 : hash[<font color=red>扰动函数处理过的hash值</font>] & (table.length[<font color=red>一定是2的次方</font>] - 1) \n- 扩容后元素的去向有两种，一种还是原来的下标，另外一种是原来下标+扩容之前数组的长度\n\n## HashMap灵魂拷问\n\n### 如果两个对象hashCode相等，或者equals()方法相等会怎么样？\n\n首先先来了解下hashCode和equals方法的关系，前提是没有重写的情况下。\n\n- 如果两个对象equals相等，那么他们的hashCode一定相等。（**equals比较的是内存地址，内存地址一样的话，通过内存地址做哈希函数后得到的hashCode就一定是一样的**）\n- 如果两个对象equals不相等，那么hashCode有可能相等也有可能不相等。\n- 如果两个对象hashCode不相等，那么equals一定不相等。\n\n在HashMap中，如果两个对象的hashCode相等的话，那么他们在同一个槽内(发生碰撞)，这时候需要继续判断equals方法是否相等，如果相等做替换操作，如果不相等就插入链表尾部操作。\n\n**扩展点 ：hashCode和 equals()的理解**\n\n每个对象都有hashcode，对象的hashcode是怎么得到的呢？\n\n首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，**hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址**，那么对象如何得到hashcode呢？\n\n通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。**所以，hashcode是什么呢？就是在hash表中对应的位置。这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。**\n\n**为什么要有hashcode呢？** 主要是为了查找更快，例如我们需要比较对象是否相等，假设我们有1000个对象，那我要比较是否相等的话需要通过物理地址跟999个对象的物理地址进行比较。那如果有hashCode，假设对象A的物理地址转成整数再通过hash函数落到了hashcode1这个槽上，对象B，E，G也是，那我只要将A跟B，E，G比较就行了。\n\n所以我们就不难理解上面hashCode和equals的关系了。先通过hashCode比较，在通过equals（物理地址）比较。\n\n### HashMap中定位元素在哪个槽下(路由寻址)的操作是什么，为什么？\n\n```java\n^ : 异或 相同结果为0，不同结果为1\n(h = key.hashCode()) ^ (h >>> 16)\n```\n\n在JDK1.8中是通过hashCode()的高16位异或低16位实现的。目的是让高16位参与运算，从而使hash更散列，减少碰撞。\n\n**为什么要用异或操作？**保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。\n\n### HashMap什么时候扩容，每次扩容多少？\n\n当元素个数大于扩容阈值的时候发生扩容。每次扩容是原始数组的两倍，扩容阈值每次增加两倍。\n\n举个例子，假如我们是通过new HashMap()创建的，不带参数。这时候数组长度是16，扩容阈值是16 * 0.75 = 12，如果此时HashMap里面的元素超过12了，那么就会扩容。扩容以后数组变成32，扩容阈值变成24。\n\n### JDK1.7和1.8扩容区别\n\n- JDK1.7采用的是头插法，扩容后链表会发生反转。多线程下扩容会发生链表死循环问题。\n- JDK1.8优化了扩容方式\n  - 如果当前槽只有一个数据（也就是没有发生哈希碰撞），直接通过`hash & (扩容后数组长度 - 1)`来确定新下标\n  - 如果当前槽是链表（也就是发生了哈希冲突，但是还没转成红黑树），把当前槽对应的链表根据`hash & 旧数组长度 == 0 ?`分成两个链表，等于0的是低位链表不需要换下标，而不等于0的是高位链表，需要换下标，下标位置= 原数组位置 + 原数组长度。所以1.8采用更改简单的方式扩容，扩容时不许需要重新计算hash值，扩容后元素的位置分成两种情况：`位置不变`或`原位置+旧容量大小`。\n- 1.7先判断是否需要扩容然后再插入，1.8先插入然后再判断是否需要扩容。\n\n### JDK1.8的优化\n\n**为什么JDK8扩容后不是原来的位置就是原来的位置+原数组长度的位置？**\n\n我们知道确定下标的方法是 ： `hash & (n - 1)`。n为2的次幂。其实神奇的就是这个`n-1`。2的次幂-1转成二进制都是1。所以就会出现如下情况，<font color=red>扩容前后的槽位置相差为原数组长度。</font>\n\n```java\n16 - 1 二进制 ： 1111\n32 - 1 二进制 ： 11111\nint[] number = {19,20,12,34,343,123,33,45,66,234,545};\nfor(int i : number){\n     System.out.println(      (i & (32 -1))         -          (i & (16 -1))           );\n}\n//出来的结果 不是 0 就是 16    \n```\n\n\n\n### 为什么要用红黑树，而不是不用或者用二叉查找树？\n\n- 用红黑树是为了防止链化过深导致查询效率低。\n- 不用二叉树查找树是因为在特殊情况下二叉查找树会变成一条线性，那就是跟链化一样了。但是红黑树会通过左旋右旋来平衡树。\n\n## 参考\n\n- 小刘思源码\n- HashMap源码","source":"_posts/hashmap.md","raw":"---\ntitle: HashMap原理浅析\ntags:\n  - java集合\ncategories:  java\ndescription :  HashMap原理浅析\ndate: 2020-07-28\n---\n## 基础\n### 数组的优点缺点\n- 数组在内存空间上连续。能实现快速访问某个下标的值。\n- 数组空间的大小一旦确定后就不能更改，如果需要增大减小需要新建数组重新设值。\n\n### 链表的优点缺点\n\n- 链表在内存空间上是不连续的。插入删除某个值速度快\n- 链表不能随机查找，必须从第一个开始遍历，查找效率低\n\n### HashMap散列表结构\n\nHashMap采用了散列表结构，结合了数组和链表的优点。\n\n![HashMap结构](hashmap/1.png)\n<!--more-->\n### 什么是哈希？\n\nHash也称之为散列。基本原理是把<font color=red>任意长度</font>的输入，通过Hash算法变成<font color=red>固定长度</font>的输出。这个映射的规则就是对应的<font color=red>Hash算法</font>，而原始数据映射后的<font color=red>二进制串</font>就是哈希值。\n\nHash的特点\n\n- 从hash值不可以反向推导出原始的数据\n- 输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值\n- 哈希算法的执行效率要高效，长本文也能快速的计算出哈希值\n- hash算法的冲突概率要小\n\n由于hash的原理是将输入空间的值映射到hash空间中，而hash值的控件远小于输入的空间。根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。\n\n## HashMap原理讲解\n### HahMap的继承体系\n\nHashMap实现了Map接口，Cloneable接口，Serializable接口\n\n![HashMap继承体系](hashmap/2.png)\n\n### Node数据结构分析\n\nHashMap的Node结构是一个单链表结构。Hash发生碰撞时，此时元素没法放在同一个数组下标，就会将相同hash的Node组成一个单链表。\n\n```java\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash; //这个hash是通过获取key的hashCode然后经过\"扰动\"后的结果\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n}\n```\n\n### 底层存储结构介绍\n\n底层存储结构是<font color=red>数组+单链表+红黑树</font>的结构。\n\n什么情况下链表会转化成红黑树?<font color=red>当单链表长度达到8，且数组的长度大于64时</font>\n\n![HashMap底层存储结构](hashmap/3.png)\n\n### put方法原理分析\n\n![put方法原理](hashmap/4.png)\n\n### JDK8为什么引入红黑树\n\n由于hash碰撞的原因，可能导致同一个数组下标下的单链表长度很长时，查询效率变低。这时候将链表转成红黑树来保证查询的效率。\n\n## Hash重要源码分析\n\n### HashMap核心属性分析\n\n```java\n//缺省数组大小,默认16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n//数组最大大小\nstatic final int MAXIMUM_CAPACITY = 1 << 30;\n//缺省负载因子\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n//树化阈值\nstatic final int TREEIFY_THRESHOLD = 8;\n//树降级为链表的阈值\nstatic final int UNTREEIFY_THRESHOLD = 6;\n//待定\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n//hash表\ntransient Node<K,V>[] table;\n//当前hash表中元素个数\ntransient int size;\n//当前hash表结构的修改次数\ntransient int modCount;\n//扩容阈值，当你的哈希表中的元素超过阈值时，触发扩容\nint threshold;\n//负载因子, threshold = capacity(数组长度) * loadFactor\nfinal float loadFactor;\n```\n\n### 构造方法分析\n\n```java\n\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\npublic HashMap(int initialCapacity, float loadFactor) {\n    //数组长度不能小于0\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal initial capacity: \" +\n                                           initialCapacity);\n    //数组长度不能大于最大值\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    //负载因子不能小于0\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal load factor: \" +\n                                           loadFactor);\n    //初始化负载因子\n    this.loadFactor = loadFactor;\n    //传入数组大小 计算扩容阈值 \n    //这里初始化的threshold也是第一次初始化HashMap的初始长度\n    this.threshold = tableSizeFor(initialCapacity);\n}\n\n//由于我们传入的initialCapacity是随机的，但是Hashmap要求数组的长度必须是2的次方，所以通过此函数进行转换\n//作用 : 返回一个大于等于当前cap的数字，且这个数字是2的次方数\nstatic final int tableSizeFor(int cap) {\n        int n = cap - 1; \n        n |= n >>> 1; \n        n |= n >>> 2; \n        n |= n >>> 4; \n        n |= n >>> 8; \n        n |= n >>> 16;\n        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n```\n\n### put方法分析\n\n```java\npublic V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n}\n```\n\n```java\n//hash扰动函数，使hash更加散列\n//作用:让key的hash值的高16位也参与运算\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n```java\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n    \t//tab -- 当前hashMap的散列表\n    \t//p -- 当前散列表的元素\n    \t//n -- 表示散列表数组的长度， i -- 表示路由寻址结果\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n    \t//当散列表==null时调用resize方法进行初始化\n    \t//这里hashMap是延迟初始化\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n    \n    \t// (n - 1) & hash 是路由算法\n    \t// 最简单的一种情况，寻址找到的桶位刚好是null,这个时候直接newNode\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            //e -- node临时元素，k -- 表示临时的一个key\n            Node<K,V> e; K k;\n            //p表示桶上第一个元素\n            //表示桶位中的该元素与你当前插入的元素的key完全一致，就用e = p,后续做替换操作\n            //这里需要注意的是判断你是否一致使用equal方法,所以hashMap判断会用到equal方法，那么我们重写时要注意\n            if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n            \n            //如果这个p已经是红黑树了，那用红黑树的方法\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            \n            else {\n                //到这一步，表示现在桶上是一个链表，那么接下去要for链表看看上面有没有跟你一致的key，如果有做替换。\n                //当前链表的情况是链表的头元素与我们插入的key不一致，要接下去判断链表上其他元素的key是否一致\n                for (int binCount = 0; ; ++binCount) {\n                    //到这一步表示到了链表的末尾了还是没有一致的\n                    if ((e = p.next) == null) {\n                        //把key-value加到最后一个元素上\n                        p.next = newNode(hash, key, value, null);\n                        //这里判断是否进行树化，链表的长度>=8就转成红黑树\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    //找到了链表上一个元素与要出入的元素的key一致\n                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            \n            //进行value的替换\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount; //记录操作次次数\n    \t//如果全部元素 > 扩容阈值 的话 就进行扩容\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n}\n```\n\n### 扩容方法分析\n\n![长度16扩容成32](hashmap/5.png)\n\n从图可以看出，<font color=red>同一个桶上的元素扩容后要嘛在原来15的位置，要嘛在31的位置</font>。\n\n这里根据路由寻址函数【hash & (table.length - 1)】，可以分析出<font color=red>扩容后元素的去向有两种，一种还是原来的下标，另外一种是原来下标+扩容之前数组的长度</font>\n\n例如上面这个例子，原来数组长度是16， 对于下标为15的元素，他扩容后的去向要嘛是15，要嘛是31（15 + 16）。\n\n```java\n//扩容方法，为了解决哈希冲突导致链化影响查询效率，扩容解决该方法\nfinal Node<K,V>[] resize() {\n    //oldTab -- 扩容之前的哈希表\n    Node<K,V>[] oldTab = table;\n    //oldCap -- 扩容之前哈希表的长度\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    //oldThr -- 表示扩容之前的阈值，触发本次扩容的阈值\n    int oldThr = threshold;\n    //newCap -- 扩容之后哈希表的长度\n    //newThr -- 扩容之后下次触发扩容的条件\n    int newCap, newThr = 0;\n    \n    //===================这一段就是用来算newCap，newThr=============================\n    //条件如果成立，表示散列表已经初始化过了，这次是一次正常扩容\n    if (oldCap > 0) {\n        //如果当前的哈希表数组长度已经到最大长度了，那就不能在扩容了,且设置扩容条件为int最大值\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //newCap = oldCap << 1 表示我要把数组扩大一倍\n        //新的数组的长度小于最大值限制 且 扩容之前哈希表的长度 >= 16 就设置新的扩容阈值，否则不设置\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1;\n    }\n    //oldCap = 0 , 说明hashmap的散列表还没初始化，走到下面这一步一般是通过new HashMap(15)这样初始化的。这种初始化只有设置了扩容阈值\n    //这里oldThr是旧的扩容阈值，这里别以为扩容阈值我们在new hashmap的时候就设置值了，其实如果是不带参数的new HashMap时候，这个扩容阈值是等于0，如果扩容值已经有了，那就设定要初始化的数组的大小为旧的扩容阈值\n    else if (oldThr > 0)\n        newCap = oldThr;\n    else {\n        //oldThr = 0 的时候，默认要初始化的数组的大小为16，然后下一次的扩容阈值是 16 * 0.75\n        //进来这里，一般是通过new HashMap()，没带任何参数创建的时候\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    //newThr == 0,通过newCap 和 loadFactor计算出一个newThr\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    //==========================================================================\n   \n    threshold = newThr; //赋值新的扩容阈值\n    // 初始化哈希表\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap]; \n    table = newTab;\n    //oldTab =! null 说明hashmap本次扩容之前，table不是null,说明是扩容而不是初始化\n    if (oldTab != null) {\n        //遍历扩容前的哈希数组\n        for (int j = 0; j < oldCap; ++j) {\n            //e -- 当前Node节点\n            Node<K,V> e;\n            // 这个条件满足，说明当前桶位上有数据，但是不清楚是单个数据、链表还是红黑树\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                //这个条件满足的话，表示桶位上只有一个元素\n                if (e.next == null){\n                    //根据路由寻址算法计算出新桶位并迁移元素\n                    newTab[e.hash & (newCap - 1)] = e;\n                }\n                else if (e instanceof TreeNode){\n                    //如果是红黑树，则按照红黑树的方式\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                }else {\n                    //这个条件就是 桶位上是链表的情况\n                    //低位链表:存放在扩容之后的数组的下标位置，与当前数组的下标位置一致\n                    Node<K,V> loHead = null, loTail = null;\n                    //高位链表:存放在扩容之后的数组的下标位置，为当前数组的下标位置 + 扩容之前数组的长度\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    \n                    do {\n                        next = e.next;\n                        //下面这个(e.hash & oldCap) == 0 用来判断该元素扩容后是在高位链表还是低位链表\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    \n                    //通过上面的赋值，如果低位有量就进行转移\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                     //通过上面的赋值，如果高位有量就进行转移\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}\n```\n\n### get方法分析\n\n```java\npublic V get(Object key) {\n    Node<K,V> e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node<K,V> getNode(int hash, Object key) {\n    // tab : 引用当前hashMap的散列表\n    //first : 桶位中的头元素\n    //n : 数组的长度\n    //e : 临时node元素\n    Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n    \n    if ((tab = table) != null && (n = tab.length) > 0 && (first = tab[(n - 1) & hash]) != null) {\n        //第一种情况:定位出来的第一个桶位元素是我们要的元素，就直接返回\n        if (first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k))))\n            return first;\n        //第二种情况:如果是链表或者红黑树的情况\n        if ((e = first.next) != null) {\n            if (first instanceof TreeNode)\n                return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n            //下面for循环就是遍历链表获取要取的数据\n            do {\n                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))) )\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}\n```\n\n### remove方法分析\n\n```java\npublic V remove(Object key) {\n    Node<K,V> e;\n    return (e = removeNode(hash(key), key, null, false, true)) == null ?\n        null : e.value;\n}\n\nfinal Node<K,V> removeNode(int hash, Object key, Object value,\n                           boolean matchValue, boolean movable) {\n    //tab : 引用当前hashmap的散列表\n    //p : 当前node元素\n    //n : 散列表长度\n    //index ：寻址的数组下标\n    Node<K,V>[] tab; Node<K,V> p; int n, index;\n    //下面就是判断并赋值各种情况，例如散列表已经初始化，桶位有值等\n    if ((tab = table) != null && (n = tab.length) > 0 && (p = tab[index = (n - 1) & hash]) != null ) {\n        //node : 用来记录查找到的的元素\n        //e : 当前Node的下一个元素\n        Node<K,V> node = null, e; K k; V v;\n        //这种情况就是第一个元素就是要找的元素\n        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))){\n            node = p;\n        }else if ((e = p.next) != null) {\n            if (p instanceof TreeNode){\n                //红黑的情况\n                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);\n            }else {\n                //链表的情况，就是遍历查找了\n                do {\n                    if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) {\n                        node = e;\n                        break;\n                    }\n                    p = e;\n                } while ((e = e.next) != null);\n            }\n        }\n        //下面就是对应的删除逻辑了\n        if (node != null && (!matchValue || (v = node.value) == value ||\n                             (value != null && value.equals(v)))) {\n            if (node instanceof TreeNode)\n                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);\n            else if (node == p)\n                tab[index] = node.next;\n            else\n                p.next = node.next;\n            ++modCount;\n            --size;\n            afterNodeRemoval(node);\n            return node;\n        }\n    }\n    return null;\n}\n```\n\n\n\n## 总结\n\n- 当单链表长度达到8，且数组的长度大于64时链表会转成红黑树\n- HashMap的初始化是在第一次插入数据时初始化的，所以Hash是<font color=red>懒加载初始化</font>\n- 如果是HashMap没带参数的初始化，那默认刚开始初始化的数组大小位16，且下次的扩容阈值是 16  * 0.75 = 12\n- 每次扩容都是将数组的大小增加一倍，扩容的阈值也是增加一倍\n- HashMap决定元素在哪个数组下标的路由寻址算法 : hash[<font color=red>扰动函数处理过的hash值</font>] & (table.length[<font color=red>一定是2的次方</font>] - 1) \n- 扩容后元素的去向有两种，一种还是原来的下标，另外一种是原来下标+扩容之前数组的长度\n\n## HashMap灵魂拷问\n\n### 如果两个对象hashCode相等，或者equals()方法相等会怎么样？\n\n首先先来了解下hashCode和equals方法的关系，前提是没有重写的情况下。\n\n- 如果两个对象equals相等，那么他们的hashCode一定相等。（**equals比较的是内存地址，内存地址一样的话，通过内存地址做哈希函数后得到的hashCode就一定是一样的**）\n- 如果两个对象equals不相等，那么hashCode有可能相等也有可能不相等。\n- 如果两个对象hashCode不相等，那么equals一定不相等。\n\n在HashMap中，如果两个对象的hashCode相等的话，那么他们在同一个槽内(发生碰撞)，这时候需要继续判断equals方法是否相等，如果相等做替换操作，如果不相等就插入链表尾部操作。\n\n**扩展点 ：hashCode和 equals()的理解**\n\n每个对象都有hashcode，对象的hashcode是怎么得到的呢？\n\n首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，**hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址**，那么对象如何得到hashcode呢？\n\n通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。**所以，hashcode是什么呢？就是在hash表中对应的位置。这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。**\n\n**为什么要有hashcode呢？** 主要是为了查找更快，例如我们需要比较对象是否相等，假设我们有1000个对象，那我要比较是否相等的话需要通过物理地址跟999个对象的物理地址进行比较。那如果有hashCode，假设对象A的物理地址转成整数再通过hash函数落到了hashcode1这个槽上，对象B，E，G也是，那我只要将A跟B，E，G比较就行了。\n\n所以我们就不难理解上面hashCode和equals的关系了。先通过hashCode比较，在通过equals（物理地址）比较。\n\n### HashMap中定位元素在哪个槽下(路由寻址)的操作是什么，为什么？\n\n```java\n^ : 异或 相同结果为0，不同结果为1\n(h = key.hashCode()) ^ (h >>> 16)\n```\n\n在JDK1.8中是通过hashCode()的高16位异或低16位实现的。目的是让高16位参与运算，从而使hash更散列，减少碰撞。\n\n**为什么要用异或操作？**保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。\n\n### HashMap什么时候扩容，每次扩容多少？\n\n当元素个数大于扩容阈值的时候发生扩容。每次扩容是原始数组的两倍，扩容阈值每次增加两倍。\n\n举个例子，假如我们是通过new HashMap()创建的，不带参数。这时候数组长度是16，扩容阈值是16 * 0.75 = 12，如果此时HashMap里面的元素超过12了，那么就会扩容。扩容以后数组变成32，扩容阈值变成24。\n\n### JDK1.7和1.8扩容区别\n\n- JDK1.7采用的是头插法，扩容后链表会发生反转。多线程下扩容会发生链表死循环问题。\n- JDK1.8优化了扩容方式\n  - 如果当前槽只有一个数据（也就是没有发生哈希碰撞），直接通过`hash & (扩容后数组长度 - 1)`来确定新下标\n  - 如果当前槽是链表（也就是发生了哈希冲突，但是还没转成红黑树），把当前槽对应的链表根据`hash & 旧数组长度 == 0 ?`分成两个链表，等于0的是低位链表不需要换下标，而不等于0的是高位链表，需要换下标，下标位置= 原数组位置 + 原数组长度。所以1.8采用更改简单的方式扩容，扩容时不许需要重新计算hash值，扩容后元素的位置分成两种情况：`位置不变`或`原位置+旧容量大小`。\n- 1.7先判断是否需要扩容然后再插入，1.8先插入然后再判断是否需要扩容。\n\n### JDK1.8的优化\n\n**为什么JDK8扩容后不是原来的位置就是原来的位置+原数组长度的位置？**\n\n我们知道确定下标的方法是 ： `hash & (n - 1)`。n为2的次幂。其实神奇的就是这个`n-1`。2的次幂-1转成二进制都是1。所以就会出现如下情况，<font color=red>扩容前后的槽位置相差为原数组长度。</font>\n\n```java\n16 - 1 二进制 ： 1111\n32 - 1 二进制 ： 11111\nint[] number = {19,20,12,34,343,123,33,45,66,234,545};\nfor(int i : number){\n     System.out.println(      (i & (32 -1))         -          (i & (16 -1))           );\n}\n//出来的结果 不是 0 就是 16    \n```\n\n\n\n### 为什么要用红黑树，而不是不用或者用二叉查找树？\n\n- 用红黑树是为了防止链化过深导致查询效率低。\n- 不用二叉树查找树是因为在特殊情况下二叉查找树会变成一条线性，那就是跟链化一样了。但是红黑树会通过左旋右旋来平衡树。\n\n## 参考\n\n- 小刘思源码\n- HashMap源码","slug":"hashmap","published":1,"updated":"2021-11-23T06:25:51.471Z","_id":"ckn9yvhur000kqwv2a85nbo4u","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"数组的优点缺点\"><a href=\"#数组的优点缺点\" class=\"headerlink\" title=\"数组的优点缺点\"></a>数组的优点缺点</h3><ul>\n<li>数组在内存空间上连续。能实现快速访问某个下标的值。</li>\n<li>数组空间的大小一旦确定后就不能更改，如果需要增大减小需要新建数组重新设值。</li>\n</ul>\n<h3 id=\"链表的优点缺点\"><a href=\"#链表的优点缺点\" class=\"headerlink\" title=\"链表的优点缺点\"></a>链表的优点缺点</h3><ul>\n<li>链表在内存空间上是不连续的。插入删除某个值速度快</li>\n<li>链表不能随机查找，必须从第一个开始遍历，查找效率低</li>\n</ul>\n<h3 id=\"HashMap散列表结构\"><a href=\"#HashMap散列表结构\" class=\"headerlink\" title=\"HashMap散列表结构\"></a>HashMap散列表结构</h3><p>HashMap采用了散列表结构，结合了数组和链表的优点。</p>\n<p><img src=\"/2020/07/28/hashmap/1.png\" alt=\"HashMap结构\"></p>\n<a id=\"more\"></a>\n<h3 id=\"什么是哈希？\"><a href=\"#什么是哈希？\" class=\"headerlink\" title=\"什么是哈希？\"></a>什么是哈希？</h3><p>Hash也称之为散列。基本原理是把<font color=\"red\">任意长度</font>的输入，通过Hash算法变成<font color=\"red\">固定长度</font>的输出。这个映射的规则就是对应的<font color=\"red\">Hash算法</font>，而原始数据映射后的<font color=\"red\">二进制串</font>就是哈希值。</p>\n<p>Hash的特点</p>\n<ul>\n<li>从hash值不可以反向推导出原始的数据</li>\n<li>输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值</li>\n<li>哈希算法的执行效率要高效，长本文也能快速的计算出哈希值</li>\n<li>hash算法的冲突概率要小</li>\n</ul>\n<p>由于hash的原理是将输入空间的值映射到hash空间中，而hash值的控件远小于输入的空间。根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。</p>\n<h2 id=\"HashMap原理讲解\"><a href=\"#HashMap原理讲解\" class=\"headerlink\" title=\"HashMap原理讲解\"></a>HashMap原理讲解</h2><h3 id=\"HahMap的继承体系\"><a href=\"#HahMap的继承体系\" class=\"headerlink\" title=\"HahMap的继承体系\"></a>HahMap的继承体系</h3><p>HashMap实现了Map接口，Cloneable接口，Serializable接口</p>\n<p><img src=\"/2020/07/28/hashmap/2.png\" alt=\"HashMap继承体系\"></p>\n<h3 id=\"Node数据结构分析\"><a href=\"#Node数据结构分析\" class=\"headerlink\" title=\"Node数据结构分析\"></a>Node数据结构分析</h3><p>HashMap的Node结构是一个单链表结构。Hash发生碰撞时，此时元素没法放在同一个数组下标，就会将相同hash的Node组成一个单链表。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Map<span class=\"token punctuation\">.</span>Entry</span><span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//这个hash是通过获取key的hashCode然后经过\"扰动\"后的结果</span>\n    <span class=\"token keyword\">final</span> K key<span class=\"token punctuation\">;</span>\n    V value<span class=\"token punctuation\">;</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> next<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> K key<span class=\"token punctuation\">,</span> V value<span class=\"token punctuation\">,</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> next<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hash <span class=\"token operator\">=</span> hash<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> next<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> Objects<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"底层存储结构介绍\"><a href=\"#底层存储结构介绍\" class=\"headerlink\" title=\"底层存储结构介绍\"></a>底层存储结构介绍</h3><p>底层存储结构是<font color=\"red\">数组+单链表+红黑树</font>的结构。</p>\n<p>什么情况下链表会转化成红黑树?<font color=\"red\">当单链表长度达到8，且数组的长度大于64时</font></p>\n<p><img src=\"/2020/07/28/hashmap/3.png\" alt=\"HashMap底层存储结构\"></p>\n<h3 id=\"put方法原理分析\"><a href=\"#put方法原理分析\" class=\"headerlink\" title=\"put方法原理分析\"></a>put方法原理分析</h3><p><img src=\"/2020/07/28/hashmap/4.png\" alt=\"put方法原理\"></p>\n<h3 id=\"JDK8为什么引入红黑树\"><a href=\"#JDK8为什么引入红黑树\" class=\"headerlink\" title=\"JDK8为什么引入红黑树\"></a>JDK8为什么引入红黑树</h3><p>由于hash碰撞的原因，可能导致同一个数组下标下的单链表长度很长时，查询效率变低。这时候将链表转成红黑树来保证查询的效率。</p>\n<h2 id=\"Hash重要源码分析\"><a href=\"#Hash重要源码分析\" class=\"headerlink\" title=\"Hash重要源码分析\"></a>Hash重要源码分析</h2><h3 id=\"HashMap核心属性分析\"><a href=\"#HashMap核心属性分析\" class=\"headerlink\" title=\"HashMap核心属性分析\"></a>HashMap核心属性分析</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//缺省数组大小,默认16</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> DEFAULT_INITIAL_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// aka 16</span>\n<span class=\"token comment\" spellcheck=\"true\">//数组最大大小</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MAXIMUM_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//缺省负载因子</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> DEFAULT_LOAD_FACTOR <span class=\"token operator\">=</span> <span class=\"token number\">0.75f</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//树化阈值</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> TREEIFY_THRESHOLD <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//树降级为链表的阈值</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> UNTREEIFY_THRESHOLD <span class=\"token operator\">=</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//待定</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> MIN_TREEIFY_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">64</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//hash表</span>\n<span class=\"token keyword\">transient</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> table<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前hash表中元素个数</span>\n<span class=\"token keyword\">transient</span> <span class=\"token keyword\">int</span> size<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前hash表结构的修改次数</span>\n<span class=\"token keyword\">transient</span> <span class=\"token keyword\">int</span> modCount<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//扩容阈值，当你的哈希表中的元素超过阈值时，触发扩容</span>\n<span class=\"token keyword\">int</span> threshold<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//负载因子, threshold = capacity(数组长度) * loadFactor</span>\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"构造方法分析\"><a href=\"#构造方法分析\" class=\"headerlink\" title=\"构造方法分析\"></a>构造方法分析</h3><pre class=\" language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">public</span> <span class=\"token function\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>loadFactor <span class=\"token operator\">=</span> DEFAULT_LOAD_FACTOR<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// all other fields defaulted</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token function\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initialCapacity<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>initialCapacity<span class=\"token punctuation\">,</span> DEFAULT_LOAD_FACTOR<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token function\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> initialCapacity<span class=\"token punctuation\">,</span> <span class=\"token keyword\">float</span> loadFactor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//数组长度不能小于0</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>initialCapacity <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Illegal initial capacity: \"</span> <span class=\"token operator\">+</span>\n                                           initialCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//数组长度不能大于最大值</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>initialCapacity <span class=\"token operator\">></span> MAXIMUM_CAPACITY<span class=\"token punctuation\">)</span>\n        initialCapacity <span class=\"token operator\">=</span> MAXIMUM_CAPACITY<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//负载因子不能小于0</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loadFactor <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> Float<span class=\"token punctuation\">.</span><span class=\"token function\">isNaN</span><span class=\"token punctuation\">(</span>loadFactor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Illegal load factor: \"</span> <span class=\"token operator\">+</span>\n                                           loadFactor<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化负载因子</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>loadFactor <span class=\"token operator\">=</span> loadFactor<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//传入数组大小 计算扩容阈值 </span>\n    <span class=\"token comment\" spellcheck=\"true\">//这里初始化的threshold也是第一次初始化HashMap的初始长度</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>threshold <span class=\"token operator\">=</span> <span class=\"token function\">tableSizeFor</span><span class=\"token punctuation\">(</span>initialCapacity<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//由于我们传入的initialCapacity是随机的，但是Hashmap要求数组的长度必须是2的次方，所以通过此函数进行转换</span>\n<span class=\"token comment\" spellcheck=\"true\">//作用 : 返回一个大于等于当前cap的数字，且这个数字是2的次方数</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">tableSizeFor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> cap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> n <span class=\"token operator\">=</span> cap <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n        n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n        n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> \n        n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> \n        n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span> \n        n <span class=\"token operator\">|=</span> n <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">>=</span> MAXIMUM_CAPACITY<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> MAXIMUM_CAPACITY <span class=\"token operator\">:</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"put方法分析\"><a href=\"#put方法分析\" class=\"headerlink\" title=\"put方法分析\"></a>put方法分析</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> V <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>K key<span class=\"token punctuation\">,</span> V value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//hash扰动函数，使hash更加散列</span>\n<span class=\"token comment\" spellcheck=\"true\">//作用:让key的hash值的高16位也参与运算</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>Object key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> h<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\">\n<span class=\"token keyword\">final</span> V <span class=\"token function\">putVal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> K key<span class=\"token punctuation\">,</span> V value<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> onlyIfAbsent<span class=\"token punctuation\">,</span>\n                   <span class=\"token keyword\">boolean</span> evict<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//tab -- 当前hashMap的散列表</span>\n        <span class=\"token comment\" spellcheck=\"true\">//p -- 当前散列表的元素</span>\n        <span class=\"token comment\" spellcheck=\"true\">//n -- 表示散列表数组的长度， i -- 表示路由寻址结果</span>\n        Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">;</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> p<span class=\"token punctuation\">;</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//当散列表==null时调用resize方法进行初始化</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这里hashMap是延迟初始化</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            n <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// (n - 1) &amp; hash 是路由算法</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 最简单的一种情况，寻址找到的桶位刚好是null,这个时候直接newNode</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span>i <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n            tab<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">newNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//e -- node临时元素，k -- 表示临时的一个key</span>\n            Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> e<span class=\"token punctuation\">;</span> K k<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//p表示桶上第一个元素</span>\n            <span class=\"token comment\" spellcheck=\"true\">//表示桶位中的该元素与你当前插入的元素的key完全一致，就用e = p,后续做替换操作</span>\n            <span class=\"token comment\" spellcheck=\"true\">//这里需要注意的是判断你是否一致使用equal方法,所以hashMap判断会用到equal方法，那么我们重写时要注意</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                e <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//如果这个p已经是红黑树了，那用红黑树的方法</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span>\n                e <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">putTreeVal</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> tab<span class=\"token punctuation\">,</span> hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//到这一步，表示现在桶上是一个链表，那么接下去要for链表看看上面有没有跟你一致的key，如果有做替换。</span>\n                <span class=\"token comment\" spellcheck=\"true\">//当前链表的情况是链表的头元素与我们插入的key不一致，要接下去判断链表上其他元素的key是否一致</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> binCount <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>binCount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//到这一步表示到了链表的末尾了还是没有一致的</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token comment\" spellcheck=\"true\">//把key-value加到最后一个元素上</span>\n                        p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> <span class=\"token function\">newNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token comment\" spellcheck=\"true\">//这里判断是否进行树化，链表的长度>=8就转成红黑树</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>binCount <span class=\"token operator\">>=</span> TREEIFY_THRESHOLD <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// -1 for 1st</span>\n                            <span class=\"token function\">treeifyBin</span><span class=\"token punctuation\">(</span>tab<span class=\"token punctuation\">,</span> hash<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//找到了链表上一个元素与要出入的元素的key一致</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                    p <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//进行value的替换</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">// existing mapping for key</span>\n                V oldValue <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>onlyIfAbsent <span class=\"token operator\">||</span> oldValue <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n                    e<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n                <span class=\"token function\">afterNodeAccess</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> oldValue<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token operator\">++</span>modCount<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//记录操作次次数</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果全部元素 > 扩容阈值 的话 就进行扩容</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>size <span class=\"token operator\">></span> threshold<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">afterNodeInsertion</span><span class=\"token punctuation\">(</span>evict<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"扩容方法分析\"><a href=\"#扩容方法分析\" class=\"headerlink\" title=\"扩容方法分析\"></a>扩容方法分析</h3><p><img src=\"/2020/07/28/hashmap/5.png\" alt=\"长度16扩容成32\"></p>\n<p>从图可以看出，<font color=\"red\">同一个桶上的元素扩容后要嘛在原来15的位置，要嘛在31的位置</font>。</p>\n<p>这里根据路由寻址函数【hash &amp; (table.length - 1)】，可以分析出<font color=\"red\">扩容后元素的去向有两种，一种还是原来的下标，另外一种是原来下标+扩容之前数组的长度</font></p>\n<p>例如上面这个例子，原来数组长度是16， 对于下标为15的元素，他扩容后的去向要嘛是15，要嘛是31（15 + 16）。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//扩容方法，为了解决哈希冲突导致链化影响查询效率，扩容解决该方法</span>\n<span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">resize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//oldTab -- 扩容之前的哈希表</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> oldTab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//oldCap -- 扩容之前哈希表的长度</span>\n    <span class=\"token keyword\">int</span> oldCap <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>oldTab <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token operator\">:</span> oldTab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//oldThr -- 表示扩容之前的阈值，触发本次扩容的阈值</span>\n    <span class=\"token keyword\">int</span> oldThr <span class=\"token operator\">=</span> threshold<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//newCap -- 扩容之后哈希表的长度</span>\n    <span class=\"token comment\" spellcheck=\"true\">//newThr -- 扩容之后下次触发扩容的条件</span>\n    <span class=\"token keyword\">int</span> newCap<span class=\"token punctuation\">,</span> newThr <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//===================这一段就是用来算newCap，newThr=============================</span>\n    <span class=\"token comment\" spellcheck=\"true\">//条件如果成立，表示散列表已经初始化过了，这次是一次正常扩容</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldCap <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果当前的哈希表数组长度已经到最大长度了，那就不能在扩容了,且设置扩容条件为int最大值</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldCap <span class=\"token operator\">>=</span> MAXIMUM_CAPACITY<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            threshold <span class=\"token operator\">=</span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> oldTab<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//newCap = oldCap &lt;&lt; 1 表示我要把数组扩大一倍</span>\n        <span class=\"token comment\" spellcheck=\"true\">//新的数组的长度小于最大值限制 且 扩容之前哈希表的长度 >= 16 就设置新的扩容阈值，否则不设置</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>newCap <span class=\"token operator\">=</span> oldCap <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> MAXIMUM_CAPACITY <span class=\"token operator\">&amp;&amp;</span> oldCap <span class=\"token operator\">>=</span> DEFAULT_INITIAL_CAPACITY<span class=\"token punctuation\">)</span>\n            newThr <span class=\"token operator\">=</span> oldThr <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//oldCap = 0 , 说明hashmap的散列表还没初始化，走到下面这一步一般是通过new HashMap(15)这样初始化的。这种初始化只有设置了扩容阈值</span>\n    <span class=\"token comment\" spellcheck=\"true\">//这里oldThr是旧的扩容阈值，这里别以为扩容阈值我们在new hashmap的时候就设置值了，其实如果是不带参数的new HashMap时候，这个扩容阈值是等于0，如果扩容值已经有了，那就设定要初始化的数组的大小为旧的扩容阈值</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldThr <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n        newCap <span class=\"token operator\">=</span> oldThr<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//oldThr = 0 的时候，默认要初始化的数组的大小为16，然后下一次的扩容阈值是 16 * 0.75</span>\n        <span class=\"token comment\" spellcheck=\"true\">//进来这里，一般是通过new HashMap()，没带任何参数创建的时候</span>\n        newCap <span class=\"token operator\">=</span> DEFAULT_INITIAL_CAPACITY<span class=\"token punctuation\">;</span>\n        newThr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>DEFAULT_LOAD_FACTOR <span class=\"token operator\">*</span> DEFAULT_INITIAL_CAPACITY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//newThr == 0,通过newCap 和 loadFactor计算出一个newThr</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newThr <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">float</span> ft <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>newCap <span class=\"token operator\">*</span> loadFactor<span class=\"token punctuation\">;</span>\n        newThr <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>newCap <span class=\"token operator\">&lt;</span> MAXIMUM_CAPACITY <span class=\"token operator\">&amp;&amp;</span> ft <span class=\"token operator\">&lt;</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">float</span><span class=\"token punctuation\">)</span>MAXIMUM_CAPACITY <span class=\"token operator\">?</span>\n                  <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span>ft <span class=\"token operator\">:</span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//==========================================================================</span>\n\n    threshold <span class=\"token operator\">=</span> newThr<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//赋值新的扩容阈值</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 初始化哈希表</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newTab <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">[</span>newCap<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> \n    table <span class=\"token operator\">=</span> newTab<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//oldTab =! null 说明hashmap本次扩容之前，table不是null,说明是扩容而不是初始化</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>oldTab <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//遍历扩容前的哈希数组</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> oldCap<span class=\"token punctuation\">;</span> <span class=\"token operator\">++</span>j<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//e -- 当前Node节点</span>\n            Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> e<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 这个条件满足，说明当前桶位上有数据，但是不清楚是单个数据、链表还是红黑树</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> oldTab<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                oldTab<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//这个条件满足的话，表示桶位上只有一个元素</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>next <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//根据路由寻址算法计算出新桶位并迁移元素</span>\n                    newTab<span class=\"token punctuation\">[</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>newCap <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//如果是红黑树，则按照红黑树的方式</span>\n                    <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> newTab<span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">,</span> oldCap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//这个条件就是 桶位上是链表的情况</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//低位链表:存放在扩容之后的数组的下标位置，与当前数组的下标位置一致</span>\n                    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> loHead <span class=\"token operator\">=</span> null<span class=\"token punctuation\">,</span> loTail <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//高位链表:存放在扩容之后的数组的下标位置，为当前数组的下标位置 + 扩容之前数组的长度</span>\n                    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> hiHead <span class=\"token operator\">=</span> null<span class=\"token punctuation\">,</span> hiTail <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> next<span class=\"token punctuation\">;</span>\n\n                    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                        next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n                        <span class=\"token comment\" spellcheck=\"true\">//下面这个(e.hash &amp; oldCap) == 0 用来判断该元素扩容后是在高位链表还是低位链表</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">&amp;</span> oldCap<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loTail <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n                                loHead <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">else</span>\n                                loTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                            loTail <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hiTail <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span>\n                                hiHead <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">else</span>\n                                hiTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                            hiTail <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                    <span class=\"token comment\" spellcheck=\"true\">//通过上面的赋值，如果低位有量就进行转移</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loTail <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        loTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                        newTab<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> loHead<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                     <span class=\"token comment\" spellcheck=\"true\">//通过上面的赋值，如果高位有量就进行转移</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hiTail <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        hiTail<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n                        newTab<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> oldCap<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> hiHead<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> newTab<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"get方法分析\"><a href=\"#get方法分析\" class=\"headerlink\" title=\"get方法分析\"></a>get方法分析</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> V <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>Object key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> <span class=\"token function\">getNode</span><span class=\"token punctuation\">(</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">?</span> null <span class=\"token operator\">:</span> e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token function\">getNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> Object key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// tab : 引用当前hashMap的散列表</span>\n    <span class=\"token comment\" spellcheck=\"true\">//first : 桶位中的头元素</span>\n    <span class=\"token comment\" spellcheck=\"true\">//n : 数组的长度</span>\n    <span class=\"token comment\" spellcheck=\"true\">//e : 临时node元素</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">;</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> first<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">;</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span> K k<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>first <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//第一种情况:定位出来的第一个桶位元素是我们要的元素，就直接返回</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">return</span> first<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//第二种情况:如果是链表或者红黑树的情况</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> first<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>first <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>first<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTreeNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//下面for循环就是遍历链表获取要取的数据</span>\n            <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">return</span> e<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"remove方法分析\"><a href=\"#remove方法分析\" class=\"headerlink\" title=\"remove方法分析\"></a>remove方法分析</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> V <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>Object key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> e<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> <span class=\"token function\">removeNode</span><span class=\"token punctuation\">(</span><span class=\"token function\">hash</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null <span class=\"token operator\">?</span>\n        null <span class=\"token operator\">:</span> e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">final</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> <span class=\"token function\">removeNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> hash<span class=\"token punctuation\">,</span> Object key<span class=\"token punctuation\">,</span> Object value<span class=\"token punctuation\">,</span>\n                           <span class=\"token keyword\">boolean</span> matchValue<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> movable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//tab : 引用当前hashmap的散列表</span>\n    <span class=\"token comment\" spellcheck=\"true\">//p : 当前node元素</span>\n    <span class=\"token comment\" spellcheck=\"true\">//n : 散列表长度</span>\n    <span class=\"token comment\" spellcheck=\"true\">//index ：寻址的数组下标</span>\n    Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab<span class=\"token punctuation\">;</span> Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> p<span class=\"token punctuation\">;</span> <span class=\"token keyword\">int</span> n<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//下面就是判断并赋值各种情况，例如散列表已经初始化，桶位有值等</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span>index <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> hash<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//node : 用来记录查找到的的元素</span>\n        <span class=\"token comment\" spellcheck=\"true\">//e : 当前Node的下一个元素</span>\n        Node<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span> node <span class=\"token operator\">=</span> null<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">;</span> K k<span class=\"token punctuation\">;</span> V v<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这种情况就是第一个元素就是要找的元素</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            node <span class=\"token operator\">=</span> p<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> p<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//红黑的情况</span>\n                node <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTreeNode</span><span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//链表的情况，就是遍历查找了</span>\n                <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">.</span>hash <span class=\"token operator\">==</span> hash <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>key<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> key <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>key <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        node <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                        <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    p <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//下面就是对应的删除逻辑了</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>matchValue <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>v <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> value <span class=\"token operator\">||</span>\n                             <span class=\"token punctuation\">(</span>value <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">TreeNode</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>TreeNode<span class=\"token operator\">&lt;</span>K<span class=\"token punctuation\">,</span>V<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">removeTreeNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> tab<span class=\"token punctuation\">,</span> movable<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>node <span class=\"token operator\">==</span> p<span class=\"token punctuation\">)</span>\n                tab<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">else</span>\n                p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">++</span>modCount<span class=\"token punctuation\">;</span>\n            <span class=\"token operator\">--</span>size<span class=\"token punctuation\">;</span>\n            <span class=\"token function\">afterNodeRemoval</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>当单链表长度达到8，且数组的长度大于64时链表会转成红黑树</li>\n<li>HashMap的初始化是在第一次插入数据时初始化的，所以Hash是<font color=\"red\">懒加载初始化</font></li>\n<li>如果是HashMap没带参数的初始化，那默认刚开始初始化的数组大小位16，且下次的扩容阈值是 16  * 0.75 = 12</li>\n<li>每次扩容都是将数组的大小增加一倍，扩容的阈值也是增加一倍</li>\n<li>HashMap决定元素在哪个数组下标的路由寻址算法 : hash[<font color=\"red\">扰动函数处理过的hash值</font>] &amp; (table.length[<font color=\"red\">一定是2的次方</font>] - 1) </li>\n<li>扩容后元素的去向有两种，一种还是原来的下标，另外一种是原来下标+扩容之前数组的长度</li>\n</ul>\n<h2 id=\"HashMap灵魂拷问\"><a href=\"#HashMap灵魂拷问\" class=\"headerlink\" title=\"HashMap灵魂拷问\"></a>HashMap灵魂拷问</h2><h3 id=\"如果两个对象hashCode相等，或者equals-方法相等会怎么样？\"><a href=\"#如果两个对象hashCode相等，或者equals-方法相等会怎么样？\" class=\"headerlink\" title=\"如果两个对象hashCode相等，或者equals()方法相等会怎么样？\"></a>如果两个对象hashCode相等，或者equals()方法相等会怎么样？</h3><p>首先先来了解下hashCode和equals方法的关系，前提是没有重写的情况下。</p>\n<ul>\n<li>如果两个对象equals相等，那么他们的hashCode一定相等。（<strong>equals比较的是内存地址，内存地址一样的话，通过内存地址做哈希函数后得到的hashCode就一定是一样的</strong>）</li>\n<li>如果两个对象equals不相等，那么hashCode有可能相等也有可能不相等。</li>\n<li>如果两个对象hashCode不相等，那么equals一定不相等。</li>\n</ul>\n<p>在HashMap中，如果两个对象的hashCode相等的话，那么他们在同一个槽内(发生碰撞)，这时候需要继续判断equals方法是否相等，如果相等做替换操作，如果不相等就插入链表尾部操作。</p>\n<p><strong>扩展点 ：hashCode和 equals()的理解</strong></p>\n<p>每个对象都有hashcode，对象的hashcode是怎么得到的呢？</p>\n<p>首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，<strong>hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址</strong>，那么对象如何得到hashcode呢？</p>\n<p>通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。<strong>所以，hashcode是什么呢？就是在hash表中对应的位置。这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。</strong></p>\n<p><strong>为什么要有hashcode呢？</strong> 主要是为了查找更快，例如我们需要比较对象是否相等，假设我们有1000个对象，那我要比较是否相等的话需要通过物理地址跟999个对象的物理地址进行比较。那如果有hashCode，假设对象A的物理地址转成整数再通过hash函数落到了hashcode1这个槽上，对象B，E，G也是，那我只要将A跟B，E，G比较就行了。</p>\n<p>所以我们就不难理解上面hashCode和equals的关系了。先通过hashCode比较，在通过equals（物理地址）比较。</p>\n<h3 id=\"HashMap中定位元素在哪个槽下-路由寻址-的操作是什么，为什么？\"><a href=\"#HashMap中定位元素在哪个槽下-路由寻址-的操作是什么，为什么？\" class=\"headerlink\" title=\"HashMap中定位元素在哪个槽下(路由寻址)的操作是什么，为什么？\"></a>HashMap中定位元素在哪个槽下(路由寻址)的操作是什么，为什么？</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">^</span> <span class=\"token operator\">:</span> 异或 相同结果为<span class=\"token number\">0</span>，不同结果为<span class=\"token function\">1</span>\n<span class=\"token punctuation\">(</span>h <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">hashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">>>></span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span></code></pre>\n<p>在JDK1.8中是通过hashCode()的高16位异或低16位实现的。目的是让高16位参与运算，从而使hash更散列，减少碰撞。</p>\n<p><strong>为什么要用异或操作？</strong>保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。</p>\n<h3 id=\"HashMap什么时候扩容，每次扩容多少？\"><a href=\"#HashMap什么时候扩容，每次扩容多少？\" class=\"headerlink\" title=\"HashMap什么时候扩容，每次扩容多少？\"></a>HashMap什么时候扩容，每次扩容多少？</h3><p>当元素个数大于扩容阈值的时候发生扩容。每次扩容是原始数组的两倍，扩容阈值每次增加两倍。</p>\n<p>举个例子，假如我们是通过new HashMap()创建的，不带参数。这时候数组长度是16，扩容阈值是16 * 0.75 = 12，如果此时HashMap里面的元素超过12了，那么就会扩容。扩容以后数组变成32，扩容阈值变成24。</p>\n<h3 id=\"JDK1-7和1-8扩容区别\"><a href=\"#JDK1-7和1-8扩容区别\" class=\"headerlink\" title=\"JDK1.7和1.8扩容区别\"></a>JDK1.7和1.8扩容区别</h3><ul>\n<li>JDK1.7采用的是头插法，扩容后链表会发生反转。多线程下扩容会发生链表死循环问题。</li>\n<li>JDK1.8优化了扩容方式<ul>\n<li>如果当前槽只有一个数据（也就是没有发生哈希碰撞），直接通过<code>hash &amp; (扩容后数组长度 - 1)</code>来确定新下标</li>\n<li>如果当前槽是链表（也就是发生了哈希冲突，但是还没转成红黑树），把当前槽对应的链表根据<code>hash &amp; 旧数组长度 == 0 ?</code>分成两个链表，等于0的是低位链表不需要换下标，而不等于0的是高位链表，需要换下标，下标位置= 原数组位置 + 原数组长度。所以1.8采用更改简单的方式扩容，扩容时不许需要重新计算hash值，扩容后元素的位置分成两种情况：<code>位置不变</code>或<code>原位置+旧容量大小</code>。</li>\n</ul>\n</li>\n<li>1.7先判断是否需要扩容然后再插入，1.8先插入然后再判断是否需要扩容。</li>\n</ul>\n<h3 id=\"JDK1-8的优化\"><a href=\"#JDK1-8的优化\" class=\"headerlink\" title=\"JDK1.8的优化\"></a>JDK1.8的优化</h3><p><strong>为什么JDK8扩容后不是原来的位置就是原来的位置+原数组长度的位置？</strong></p>\n<p>我们知道确定下标的方法是 ： <code>hash &amp; (n - 1)</code>。n为2的次幂。其实神奇的就是这个<code>n-1</code>。2的次幂-1转成二进制都是1。所以就会出现如下情况，<font color=\"red\">扩容前后的槽位置相差为原数组长度。</font></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token number\">16</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> 二进制 ： <span class=\"token number\">1111</span>\n<span class=\"token number\">32</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span> 二进制 ： <span class=\"token number\">11111</span>\n<span class=\"token keyword\">int</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> number <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token number\">19</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span><span class=\"token number\">12</span><span class=\"token punctuation\">,</span><span class=\"token number\">34</span><span class=\"token punctuation\">,</span><span class=\"token number\">343</span><span class=\"token punctuation\">,</span><span class=\"token number\">123</span><span class=\"token punctuation\">,</span><span class=\"token number\">33</span><span class=\"token punctuation\">,</span><span class=\"token number\">45</span><span class=\"token punctuation\">,</span><span class=\"token number\">66</span><span class=\"token punctuation\">,</span><span class=\"token number\">234</span><span class=\"token punctuation\">,</span><span class=\"token number\">545</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">:</span> number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n     System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>      <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token number\">32</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>         <span class=\"token operator\">-</span>          <span class=\"token punctuation\">(</span>i <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span><span class=\"token number\">16</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>           <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//出来的结果 不是 0 就是 16    </span></code></pre>\n<h3 id=\"为什么要用红黑树，而不是不用或者用二叉查找树？\"><a href=\"#为什么要用红黑树，而不是不用或者用二叉查找树？\" class=\"headerlink\" title=\"为什么要用红黑树，而不是不用或者用二叉查找树？\"></a>为什么要用红黑树，而不是不用或者用二叉查找树？</h3><ul>\n<li>用红黑树是为了防止链化过深导致查询效率低。</li>\n<li>不用二叉树查找树是因为在特殊情况下二叉查找树会变成一条线性，那就是跟链化一样了。但是红黑树会通过左旋右旋来平衡树。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>小刘思源码</li>\n<li>HashMap源码</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"数组的优点缺点\"><a href=\"#数组的优点缺点\" class=\"headerlink\" title=\"数组的优点缺点\"></a>数组的优点缺点</h3><ul>\n<li>数组在内存空间上连续。能实现快速访问某个下标的值。</li>\n<li>数组空间的大小一旦确定后就不能更改，如果需要增大减小需要新建数组重新设值。</li>\n</ul>\n<h3 id=\"链表的优点缺点\"><a href=\"#链表的优点缺点\" class=\"headerlink\" title=\"链表的优点缺点\"></a>链表的优点缺点</h3><ul>\n<li>链表在内存空间上是不连续的。插入删除某个值速度快</li>\n<li>链表不能随机查找，必须从第一个开始遍历，查找效率低</li>\n</ul>\n<h3 id=\"HashMap散列表结构\"><a href=\"#HashMap散列表结构\" class=\"headerlink\" title=\"HashMap散列表结构\"></a>HashMap散列表结构</h3><p>HashMap采用了散列表结构，结合了数组和链表的优点。</p>\n<p><img src=\"/2020/07/28/hashmap/1.png\" alt=\"HashMap结构\"></p>","more":"<h3 id=\"什么是哈希？\"><a href=\"#什么是哈希？\" class=\"headerlink\" title=\"什么是哈希？\"></a>什么是哈希？</h3><p>Hash也称之为散列。基本原理是把<font color=\"red\">任意长度</font>的输入，通过Hash算法变成<font color=\"red\">固定长度</font>的输出。这个映射的规则就是对应的<font color=\"red\">Hash算法</font>，而原始数据映射后的<font color=\"red\">二进制串</font>就是哈希值。</p>\n<p>Hash的特点</p>\n<ul>\n<li>从hash值不可以反向推导出原始的数据</li>\n<li>输入数据的微小变化会得到完全不同的hash值，相同的数据会得到相同的值</li>\n<li>哈希算法的执行效率要高效，长本文也能快速的计算出哈希值</li>\n<li>hash算法的冲突概率要小</li>\n</ul>\n<p>由于hash的原理是将输入空间的值映射到hash空间中，而hash值的控件远小于输入的空间。根据抽屉原理，一定会存在不同的输入被映射成相同输出的情况。</p>\n<h2 id=\"HashMap原理讲解\"><a href=\"#HashMap原理讲解\" class=\"headerlink\" title=\"HashMap原理讲解\"></a>HashMap原理讲解</h2><h3 id=\"HahMap的继承体系\"><a href=\"#HahMap的继承体系\" class=\"headerlink\" title=\"HahMap的继承体系\"></a>HahMap的继承体系</h3><p>HashMap实现了Map接口，Cloneable接口，Serializable接口</p>\n<p><img src=\"/2020/07/28/hashmap/2.png\" alt=\"HashMap继承体系\"></p>\n<h3 id=\"Node数据结构分析\"><a href=\"#Node数据结构分析\" class=\"headerlink\" title=\"Node数据结构分析\"></a>Node数据结构分析</h3><p>HashMap的Node结构是一个单链表结构。Hash发生碰撞时，此时元素没法放在同一个数组下标，就会将相同hash的Node组成一个单链表。</p>\n<pre><code class=\"java\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n    final int hash; //这个hash是通过获取key的hashCode然后经过&quot;扰动&quot;后的结果\n    final K key;\n    V value;\n    Node&lt;K,V&gt; next;\n\n    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n}</code></pre>\n<h3 id=\"底层存储结构介绍\"><a href=\"#底层存储结构介绍\" class=\"headerlink\" title=\"底层存储结构介绍\"></a>底层存储结构介绍</h3><p>底层存储结构是<font color=\"red\">数组+单链表+红黑树</font>的结构。</p>\n<p>什么情况下链表会转化成红黑树?<font color=\"red\">当单链表长度达到8，且数组的长度大于64时</font></p>\n<p><img src=\"/2020/07/28/hashmap/3.png\" alt=\"HashMap底层存储结构\"></p>\n<h3 id=\"put方法原理分析\"><a href=\"#put方法原理分析\" class=\"headerlink\" title=\"put方法原理分析\"></a>put方法原理分析</h3><p><img src=\"/2020/07/28/hashmap/4.png\" alt=\"put方法原理\"></p>\n<h3 id=\"JDK8为什么引入红黑树\"><a href=\"#JDK8为什么引入红黑树\" class=\"headerlink\" title=\"JDK8为什么引入红黑树\"></a>JDK8为什么引入红黑树</h3><p>由于hash碰撞的原因，可能导致同一个数组下标下的单链表长度很长时，查询效率变低。这时候将链表转成红黑树来保证查询的效率。</p>\n<h2 id=\"Hash重要源码分析\"><a href=\"#Hash重要源码分析\" class=\"headerlink\" title=\"Hash重要源码分析\"></a>Hash重要源码分析</h2><h3 id=\"HashMap核心属性分析\"><a href=\"#HashMap核心属性分析\" class=\"headerlink\" title=\"HashMap核心属性分析\"></a>HashMap核心属性分析</h3><pre><code class=\"java\">//缺省数组大小,默认16\nstatic final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16\n//数组最大大小\nstatic final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;\n//缺省负载因子\nstatic final float DEFAULT_LOAD_FACTOR = 0.75f;\n//树化阈值\nstatic final int TREEIFY_THRESHOLD = 8;\n//树降级为链表的阈值\nstatic final int UNTREEIFY_THRESHOLD = 6;\n//待定\nstatic final int MIN_TREEIFY_CAPACITY = 64;\n//hash表\ntransient Node&lt;K,V&gt;[] table;\n//当前hash表中元素个数\ntransient int size;\n//当前hash表结构的修改次数\ntransient int modCount;\n//扩容阈值，当你的哈希表中的元素超过阈值时，触发扩容\nint threshold;\n//负载因子, threshold = capacity(数组长度) * loadFactor\nfinal float loadFactor;</code></pre>\n<h3 id=\"构造方法分析\"><a href=\"#构造方法分析\" class=\"headerlink\" title=\"构造方法分析\"></a>构造方法分析</h3><pre><code class=\"java\">\npublic HashMap() {\n    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted\n}\n\npublic HashMap(int initialCapacity) {\n    this(initialCapacity, DEFAULT_LOAD_FACTOR);\n}\n\npublic HashMap(int initialCapacity, float loadFactor) {\n    //数组长度不能小于0\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                           initialCapacity);\n    //数组长度不能大于最大值\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n    //负载因子不能小于0\n    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                           loadFactor);\n    //初始化负载因子\n    this.loadFactor = loadFactor;\n    //传入数组大小 计算扩容阈值 \n    //这里初始化的threshold也是第一次初始化HashMap的初始长度\n    this.threshold = tableSizeFor(initialCapacity);\n}\n\n//由于我们传入的initialCapacity是随机的，但是Hashmap要求数组的长度必须是2的次方，所以通过此函数进行转换\n//作用 : 返回一个大于等于当前cap的数字，且这个数字是2的次方数\nstatic final int tableSizeFor(int cap) {\n        int n = cap - 1; \n        n |= n &gt;&gt;&gt; 1; \n        n |= n &gt;&gt;&gt; 2; \n        n |= n &gt;&gt;&gt; 4; \n        n |= n &gt;&gt;&gt; 8; \n        n |= n &gt;&gt;&gt; 16;\n        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}</code></pre>\n<h3 id=\"put方法分析\"><a href=\"#put方法分析\" class=\"headerlink\" title=\"put方法分析\"></a>put方法分析</h3><pre><code class=\"java\">public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n}</code></pre>\n<pre><code class=\"java\">//hash扰动函数，使hash更加散列\n//作用:让key的hash值的高16位也参与运算\nstatic final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n}</code></pre>\n<pre><code class=\"java\">\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        //tab -- 当前hashMap的散列表\n        //p -- 当前散列表的元素\n        //n -- 表示散列表数组的长度， i -- 表示路由寻址结果\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n        //当散列表==null时调用resize方法进行初始化\n        //这里hashMap是延迟初始化\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n\n        // (n - 1) &amp; hash 是路由算法\n        // 最简单的一种情况，寻址找到的桶位刚好是null,这个时候直接newNode\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {\n            //e -- node临时元素，k -- 表示临时的一个key\n            Node&lt;K,V&gt; e; K k;\n            //p表示桶上第一个元素\n            //表示桶位中的该元素与你当前插入的元素的key完全一致，就用e = p,后续做替换操作\n            //这里需要注意的是判断你是否一致使用equal方法,所以hashMap判断会用到equal方法，那么我们重写时要注意\n            if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n\n            //如果这个p已经是红黑树了，那用红黑树的方法\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n\n            else {\n                //到这一步，表示现在桶上是一个链表，那么接下去要for链表看看上面有没有跟你一致的key，如果有做替换。\n                //当前链表的情况是链表的头元素与我们插入的key不一致，要接下去判断链表上其他元素的key是否一致\n                for (int binCount = 0; ; ++binCount) {\n                    //到这一步表示到了链表的末尾了还是没有一致的\n                    if ((e = p.next) == null) {\n                        //把key-value加到最后一个元素上\n                        p.next = newNode(hash, key, value, null);\n                        //这里判断是否进行树化，链表的长度&gt;=8就转成红黑树\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    //找到了链表上一个元素与要出入的元素的key一致\n                    if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n\n            //进行value的替换\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount; //记录操作次次数\n        //如果全部元素 &gt; 扩容阈值 的话 就进行扩容\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n}</code></pre>\n<h3 id=\"扩容方法分析\"><a href=\"#扩容方法分析\" class=\"headerlink\" title=\"扩容方法分析\"></a>扩容方法分析</h3><p><img src=\"/2020/07/28/hashmap/5.png\" alt=\"长度16扩容成32\"></p>\n<p>从图可以看出，<font color=\"red\">同一个桶上的元素扩容后要嘛在原来15的位置，要嘛在31的位置</font>。</p>\n<p>这里根据路由寻址函数【hash &amp; (table.length - 1)】，可以分析出<font color=\"red\">扩容后元素的去向有两种，一种还是原来的下标，另外一种是原来下标+扩容之前数组的长度</font></p>\n<p>例如上面这个例子，原来数组长度是16， 对于下标为15的元素，他扩容后的去向要嘛是15，要嘛是31（15 + 16）。</p>\n<pre><code class=\"java\">//扩容方法，为了解决哈希冲突导致链化影响查询效率，扩容解决该方法\nfinal Node&lt;K,V&gt;[] resize() {\n    //oldTab -- 扩容之前的哈希表\n    Node&lt;K,V&gt;[] oldTab = table;\n    //oldCap -- 扩容之前哈希表的长度\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    //oldThr -- 表示扩容之前的阈值，触发本次扩容的阈值\n    int oldThr = threshold;\n    //newCap -- 扩容之后哈希表的长度\n    //newThr -- 扩容之后下次触发扩容的条件\n    int newCap, newThr = 0;\n\n    //===================这一段就是用来算newCap，newThr=============================\n    //条件如果成立，表示散列表已经初始化过了，这次是一次正常扩容\n    if (oldCap &gt; 0) {\n        //如果当前的哈希表数组长度已经到最大长度了，那就不能在扩容了,且设置扩容条件为int最大值\n        if (oldCap &gt;= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //newCap = oldCap &lt;&lt; 1 表示我要把数组扩大一倍\n        //新的数组的长度小于最大值限制 且 扩容之前哈希表的长度 &gt;= 16 就设置新的扩容阈值，否则不设置\n        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr &lt;&lt; 1;\n    }\n    //oldCap = 0 , 说明hashmap的散列表还没初始化，走到下面这一步一般是通过new HashMap(15)这样初始化的。这种初始化只有设置了扩容阈值\n    //这里oldThr是旧的扩容阈值，这里别以为扩容阈值我们在new hashmap的时候就设置值了，其实如果是不带参数的new HashMap时候，这个扩容阈值是等于0，如果扩容值已经有了，那就设定要初始化的数组的大小为旧的扩容阈值\n    else if (oldThr &gt; 0)\n        newCap = oldThr;\n    else {\n        //oldThr = 0 的时候，默认要初始化的数组的大小为16，然后下一次的扩容阈值是 16 * 0.75\n        //进来这里，一般是通过new HashMap()，没带任何参数创建的时候\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    //newThr == 0,通过newCap 和 loadFactor计算出一个newThr\n    if (newThr == 0) {\n        float ft = (float)newCap * loadFactor;\n        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    }\n    //==========================================================================\n\n    threshold = newThr; //赋值新的扩容阈值\n    // 初始化哈希表\n    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; \n    table = newTab;\n    //oldTab =! null 说明hashmap本次扩容之前，table不是null,说明是扩容而不是初始化\n    if (oldTab != null) {\n        //遍历扩容前的哈希数组\n        for (int j = 0; j &lt; oldCap; ++j) {\n            //e -- 当前Node节点\n            Node&lt;K,V&gt; e;\n            // 这个条件满足，说明当前桶位上有数据，但是不清楚是单个数据、链表还是红黑树\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                //这个条件满足的话，表示桶位上只有一个元素\n                if (e.next == null){\n                    //根据路由寻址算法计算出新桶位并迁移元素\n                    newTab[e.hash &amp; (newCap - 1)] = e;\n                }\n                else if (e instanceof TreeNode){\n                    //如果是红黑树，则按照红黑树的方式\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                }else {\n                    //这个条件就是 桶位上是链表的情况\n                    //低位链表:存放在扩容之后的数组的下标位置，与当前数组的下标位置一致\n                    Node&lt;K,V&gt; loHead = null, loTail = null;\n                    //高位链表:存放在扩容之后的数组的下标位置，为当前数组的下标位置 + 扩容之前数组的长度\n                    Node&lt;K,V&gt; hiHead = null, hiTail = null;\n                    Node&lt;K,V&gt; next;\n\n                    do {\n                        next = e.next;\n                        //下面这个(e.hash &amp; oldCap) == 0 用来判断该元素扩容后是在高位链表还是低位链表\n                        if ((e.hash &amp; oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n\n                    //通过上面的赋值，如果低位有量就进行转移\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                     //通过上面的赋值，如果高位有量就进行转移\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    return newTab;\n}</code></pre>\n<h3 id=\"get方法分析\"><a href=\"#get方法分析\" class=\"headerlink\" title=\"get方法分析\"></a>get方法分析</h3><pre><code class=\"java\">public V get(Object key) {\n    Node&lt;K,V&gt; e;\n    return (e = getNode(hash(key), key)) == null ? null : e.value;\n}\n\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) {\n    // tab : 引用当前hashMap的散列表\n    //first : 桶位中的头元素\n    //n : 数组的长度\n    //e : 临时node元素\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n\n    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {\n        //第一种情况:定位出来的第一个桶位元素是我们要的元素，就直接返回\n        if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))\n            return first;\n        //第二种情况:如果是链表或者红黑树的情况\n        if ((e = first.next) != null) {\n            if (first instanceof TreeNode)\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            //下面for循环就是遍历链表获取要取的数据\n            do {\n                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))) )\n                    return e;\n            } while ((e = e.next) != null);\n        }\n    }\n    return null;\n}</code></pre>\n<h3 id=\"remove方法分析\"><a href=\"#remove方法分析\" class=\"headerlink\" title=\"remove方法分析\"></a>remove方法分析</h3><pre><code class=\"java\">public V remove(Object key) {\n    Node&lt;K,V&gt; e;\n    return (e = removeNode(hash(key), key, null, false, true)) == null ?\n        null : e.value;\n}\n\nfinal Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,\n                           boolean matchValue, boolean movable) {\n    //tab : 引用当前hashmap的散列表\n    //p : 当前node元素\n    //n : 散列表长度\n    //index ：寻址的数组下标\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;\n    //下面就是判断并赋值各种情况，例如散列表已经初始化，桶位有值等\n    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null ) {\n        //node : 用来记录查找到的的元素\n        //e : 当前Node的下一个元素\n        Node&lt;K,V&gt; node = null, e; K k; V v;\n        //这种情况就是第一个元素就是要找的元素\n        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))){\n            node = p;\n        }else if ((e = p.next) != null) {\n            if (p instanceof TreeNode){\n                //红黑的情况\n                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);\n            }else {\n                //链表的情况，就是遍历查找了\n                do {\n                    if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) {\n                        node = e;\n                        break;\n                    }\n                    p = e;\n                } while ((e = e.next) != null);\n            }\n        }\n        //下面就是对应的删除逻辑了\n        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||\n                             (value != null &amp;&amp; value.equals(v)))) {\n            if (node instanceof TreeNode)\n                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);\n            else if (node == p)\n                tab[index] = node.next;\n            else\n                p.next = node.next;\n            ++modCount;\n            --size;\n            afterNodeRemoval(node);\n            return node;\n        }\n    }\n    return null;\n}</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>当单链表长度达到8，且数组的长度大于64时链表会转成红黑树</li>\n<li>HashMap的初始化是在第一次插入数据时初始化的，所以Hash是<font color=\"red\">懒加载初始化</font></li>\n<li>如果是HashMap没带参数的初始化，那默认刚开始初始化的数组大小位16，且下次的扩容阈值是 16  * 0.75 = 12</li>\n<li>每次扩容都是将数组的大小增加一倍，扩容的阈值也是增加一倍</li>\n<li>HashMap决定元素在哪个数组下标的路由寻址算法 : hash[<font color=\"red\">扰动函数处理过的hash值</font>] &amp; (table.length[<font color=\"red\">一定是2的次方</font>] - 1) </li>\n<li>扩容后元素的去向有两种，一种还是原来的下标，另外一种是原来下标+扩容之前数组的长度</li>\n</ul>\n<h2 id=\"HashMap灵魂拷问\"><a href=\"#HashMap灵魂拷问\" class=\"headerlink\" title=\"HashMap灵魂拷问\"></a>HashMap灵魂拷问</h2><h3 id=\"如果两个对象hashCode相等，或者equals-方法相等会怎么样？\"><a href=\"#如果两个对象hashCode相等，或者equals-方法相等会怎么样？\" class=\"headerlink\" title=\"如果两个对象hashCode相等，或者equals()方法相等会怎么样？\"></a>如果两个对象hashCode相等，或者equals()方法相等会怎么样？</h3><p>首先先来了解下hashCode和equals方法的关系，前提是没有重写的情况下。</p>\n<ul>\n<li>如果两个对象equals相等，那么他们的hashCode一定相等。（<strong>equals比较的是内存地址，内存地址一样的话，通过内存地址做哈希函数后得到的hashCode就一定是一样的</strong>）</li>\n<li>如果两个对象equals不相等，那么hashCode有可能相等也有可能不相等。</li>\n<li>如果两个对象hashCode不相等，那么equals一定不相等。</li>\n</ul>\n<p>在HashMap中，如果两个对象的hashCode相等的话，那么他们在同一个槽内(发生碰撞)，这时候需要继续判断equals方法是否相等，如果相等做替换操作，如果不相等就插入链表尾部操作。</p>\n<p><strong>扩展点 ：hashCode和 equals()的理解</strong></p>\n<p>每个对象都有hashcode，对象的hashcode是怎么得到的呢？</p>\n<p>首先一个对象肯定有物理地址，在别的博文中会hashcode说成是代表对象的地址，这里肯定会让读者形成误区，对象的物理地址跟这个hashcode地址不一样，<strong>hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址</strong>，那么对象如何得到hashcode呢？</p>\n<p>通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode。<strong>所以，hashcode是什么呢？就是在hash表中对应的位置。这里如果还不是很清楚的话，举个例子，hash表中有 hashcode为1、hashcode为2、(…)3、4、5、6、7、8这样八个位置，有一个对象A，A的物理地址转换为一个整数17(这是假如)，就通过直接取余算法，17%8=1，那么A的hashcode就为1，且A就在hash表中1的位置。</strong></p>\n<p><strong>为什么要有hashcode呢？</strong> 主要是为了查找更快，例如我们需要比较对象是否相等，假设我们有1000个对象，那我要比较是否相等的话需要通过物理地址跟999个对象的物理地址进行比较。那如果有hashCode，假设对象A的物理地址转成整数再通过hash函数落到了hashcode1这个槽上，对象B，E，G也是，那我只要将A跟B，E，G比较就行了。</p>\n<p>所以我们就不难理解上面hashCode和equals的关系了。先通过hashCode比较，在通过equals（物理地址）比较。</p>\n<h3 id=\"HashMap中定位元素在哪个槽下-路由寻址-的操作是什么，为什么？\"><a href=\"#HashMap中定位元素在哪个槽下-路由寻址-的操作是什么，为什么？\" class=\"headerlink\" title=\"HashMap中定位元素在哪个槽下(路由寻址)的操作是什么，为什么？\"></a>HashMap中定位元素在哪个槽下(路由寻址)的操作是什么，为什么？</h3><pre><code class=\"java\">^ : 异或 相同结果为0，不同结果为1\n(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></pre>\n<p>在JDK1.8中是通过hashCode()的高16位异或低16位实现的。目的是让高16位参与运算，从而使hash更散列，减少碰撞。</p>\n<p><strong>为什么要用异或操作？</strong>保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。</p>\n<h3 id=\"HashMap什么时候扩容，每次扩容多少？\"><a href=\"#HashMap什么时候扩容，每次扩容多少？\" class=\"headerlink\" title=\"HashMap什么时候扩容，每次扩容多少？\"></a>HashMap什么时候扩容，每次扩容多少？</h3><p>当元素个数大于扩容阈值的时候发生扩容。每次扩容是原始数组的两倍，扩容阈值每次增加两倍。</p>\n<p>举个例子，假如我们是通过new HashMap()创建的，不带参数。这时候数组长度是16，扩容阈值是16 * 0.75 = 12，如果此时HashMap里面的元素超过12了，那么就会扩容。扩容以后数组变成32，扩容阈值变成24。</p>\n<h3 id=\"JDK1-7和1-8扩容区别\"><a href=\"#JDK1-7和1-8扩容区别\" class=\"headerlink\" title=\"JDK1.7和1.8扩容区别\"></a>JDK1.7和1.8扩容区别</h3><ul>\n<li>JDK1.7采用的是头插法，扩容后链表会发生反转。多线程下扩容会发生链表死循环问题。</li>\n<li>JDK1.8优化了扩容方式<ul>\n<li>如果当前槽只有一个数据（也就是没有发生哈希碰撞），直接通过<code>hash &amp; (扩容后数组长度 - 1)</code>来确定新下标</li>\n<li>如果当前槽是链表（也就是发生了哈希冲突，但是还没转成红黑树），把当前槽对应的链表根据<code>hash &amp; 旧数组长度 == 0 ?</code>分成两个链表，等于0的是低位链表不需要换下标，而不等于0的是高位链表，需要换下标，下标位置= 原数组位置 + 原数组长度。所以1.8采用更改简单的方式扩容，扩容时不许需要重新计算hash值，扩容后元素的位置分成两种情况：<code>位置不变</code>或<code>原位置+旧容量大小</code>。</li>\n</ul>\n</li>\n<li>1.7先判断是否需要扩容然后再插入，1.8先插入然后再判断是否需要扩容。</li>\n</ul>\n<h3 id=\"JDK1-8的优化\"><a href=\"#JDK1-8的优化\" class=\"headerlink\" title=\"JDK1.8的优化\"></a>JDK1.8的优化</h3><p><strong>为什么JDK8扩容后不是原来的位置就是原来的位置+原数组长度的位置？</strong></p>\n<p>我们知道确定下标的方法是 ： <code>hash &amp; (n - 1)</code>。n为2的次幂。其实神奇的就是这个<code>n-1</code>。2的次幂-1转成二进制都是1。所以就会出现如下情况，<font color=\"red\">扩容前后的槽位置相差为原数组长度。</font></p>\n<pre><code class=\"java\">16 - 1 二进制 ： 1111\n32 - 1 二进制 ： 11111\nint[] number = {19,20,12,34,343,123,33,45,66,234,545};\nfor(int i : number){\n     System.out.println(      (i &amp; (32 -1))         -          (i &amp; (16 -1))           );\n}\n//出来的结果 不是 0 就是 16    </code></pre>\n<h3 id=\"为什么要用红黑树，而不是不用或者用二叉查找树？\"><a href=\"#为什么要用红黑树，而不是不用或者用二叉查找树？\" class=\"headerlink\" title=\"为什么要用红黑树，而不是不用或者用二叉查找树？\"></a>为什么要用红黑树，而不是不用或者用二叉查找树？</h3><ul>\n<li>用红黑树是为了防止链化过深导致查询效率低。</li>\n<li>不用二叉树查找树是因为在特殊情况下二叉查找树会变成一条线性，那就是跟链化一样了。但是红黑树会通过左旋右旋来平衡树。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>小刘思源码</li>\n<li>HashMap源码</li>\n</ul>"},{"title":"java并发之AQS(抽象队列同步器)详解","description":"详解AQS(抽象队列同步器)","date":"2020-09-06T01:19:19.000Z","_content":"\n## 概述\n\nJava中提供了AbstractQueuedSynchronizer类，简称抽象队列同步器。这个类封装了各种底层的同步细节程序员想自定义自己的同步工具的时候，只需要定义这个类的子类并覆盖它提供的一些方法就好了。**ReentrantLock**类就是借助AQS实现的。\n\n### AQS工作原理大概流程\n\nAQS中维护了一个**<font color=red>state</font>**字段，我们可以通过修改`state`字段代表的`同步状态`来实现多线程的`独占模式`或者`共享模式`。\n\n**独占模式**\n\n在独占模式下，我们可以把state的初始值设置为0，每当一个线程要进行某项独占操作时，判断state==0？，如果是0则通过**CAS**操作将state改成1并进入独占操作。当另一个线程也需要独占操作时，由于state!=0，意味着已经有线程在进行独占模式，则该线程会被封装成一个Node存到一个同步队列中去并阻塞。当第一个线程完成独占操作后，会将state设置成0并通知同步队列里的线程。这样同步队列里的线程就可以挨个进行独占操作。\n\n**共享模式**\n\n共享模式和独占模式差不多，也是判断state，需要阻塞的线程也是封装到同步队列中。比如说某项操作我们允许`10`个线程同时，那么就将state的初始值设置成10，线程需要独占操作时就将state减少1，当state小于0时，后续的线程才需要阻塞。\n<!--more-->\n## 原理和源码解析\n\n### 通过AQS实现一个锁\n\n```java\nimport com.google.common.collect.Maps;\n\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.AbstractQueuedSynchronizer;\n\n/***\n * 根据AQS实现一个先进先出可重入锁\n */\npublic class PlainLock {\n    private Sync sync = new Sync();\n\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    public void unlock() {\n        sync.release(1);\n    }\n   /****\n     * 继承AQS\n     */\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            return compareAndSetState(0, 1);\n        }\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        int NUMBER = 100;\n        PlainLock lock = new PlainLock();\n        Map<String,String> myMap = Maps.newHashMap();\n        for (int i = 0; i < NUMBER; i++) {\n            new Thread(new Runner(lock,myMap),\"线程\" + i).start();\n        }\n        TimeUnit.SECONDS.sleep(20);\n        System.out.println(myMap.entrySet().size());\n\n    }\n\n    private static class Runner implements Runnable {\n        PlainLock lock;\n        Map<String, String> myMap;\n\n        public Runner(PlainLock plainLock, Map<String, String> myMap) {\n            this.lock = plainLock;\n            this.myMap = myMap;\n        }\n\n        @Override\n        public void run() {\n            try {\n                lock.lock();\n                System.out.println(Thread.currentThread().getName() + \"..开始执行\");\n                for (int i = 0; i < 1000; i++) {\n                    myMap.put(UUID.randomUUID().toString(), \"1\");\n                }\n            } catch (Exception e) {\n\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n}\n```\n\n**加锁逻辑示意图**\n\n![](java-aqs/1.png)\n\n\n\n### 同步状态\n\n在AbstractQueuedSynchronizer类中维护这一个state同步状态，使用voatite修饰。\n\n```java\nprivate volatile int state;\n```\n\n并提供了几个访问该同步状态的方法，<font color=red>这些方法使用final修饰，不能被重写</font>。开发者只需要根据AQS提供给我们的方法操作state。\n\n| 方法名                                                       | 描述                     |\n| ------------------------------------------------------------ | ------------------------ |\n| protected final int getState()                               | 获取state的值            |\n| protected final void setState(int newState)                  | 设置state的值            |\n| protected final boolean compareAndSetState(int expect,int update) | 使用CAS方式更新state的值 |\n\n### 同步状态获取与释放\n\n在AbstractQueuedSynchronizer提供了获取同步状态与释放同步状态的方式，开发者根据需求决定是采用独占模式还是共享模式，<font color=red>在子类中重写对应的方法</font>。例如上面的Sync类。\n\n| 方法名                                      | 描述                                     |\n| ------------------------------------------- | ---------------------------------------- |\n| protected boolean tryAcquire(int arg)       | 独占式的获取同步状态，成功true,失败false |\n| protected boolean tryRelease(int arg)       | 独占式的释放同步状态，成功true,失败false |\n| protected boolean tryAcquireShared(int arg) | 共享式的获取同步状态，成功true,失败false |\n| protected boolean tryReleaseShared(int arg) | 共享式的释放同步状态，成功true,失败false |\n\n### 同步队列\n\n上面说过，当一个线程获取同步状态失败后会将该线程封装成一个Node放到同步队列中去。在AbstractQueuedSynchronizer定义了一个Node类用来表示。\n\n当一个线程获取同步状态失败之后，就把这个线程阻塞并包装成`Node`节点插入到这个`同步队列`中，当获取同步状态成功的线程释放同步状态的时候，同时通知在队列中下一个未获取到同步状态的节点，让该节点的线程再次去获取同步状态。\n\n![](java-aqs/2.png)\n\n```java\nprivate transient volatile Node head; //同步队列头节点\nprivate transient volatile Node tail; //同步队列尾节点\nstatic final class Node {\n    static final Node SHARED = new Node();\n    static final Node EXCLUSIVE = null;\n    static final int CANCELLED =  1;\n    static final int SIGNAL    = -1;\n    static final int CONDITION = -2;\n    static final int PROPAGATE = -3;\n    volatile int waitStatus; //Node的状态\n    volatile Node prev; //指向上一个Node\n    volatile Node next; //指向下一个Node\n    volatile Thread thread;  //存储线程 每一个节点都代表一个线程\n    Node nextWaiter;\n    Node() {\n    }\n    Node(Thread thread, Node mode) {\n        this.thread = thread;\n    }\n\n    Node(Thread thread, int waitStatus) {\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n```\n\n### 独占式同步状态获取与释放\n\n#### **入同步队列并阻塞**\n\n我们知道，整个获取同步状态或加入同步队列最终是调用了AQS中的acquire方法。AQS共提供了几种方法。\n\n| 方法名                                         | 描述                                                         |\n| ---------------------------------------------- | ------------------------------------------------------------ |\n| public void acquire(int arg)                   | 独占式获取同步状态，如果获取成功则返回，失败则将线程包装成Node放入同步队列 |\n| public void acquireInterruptibly(int arg)      | 跟上面功能类似，只不过这个方法在执行过程中被别的过程中断，会抛错误 |\n| public void tryAcqureNanos(int arg.long nanos) | 跟上面功能类似，加了超时机制                                 |\n| boolean release(int arg)                       | 这个方法属于释放同步状态                                     |\n\n**分析acquire方法**\n\n```java\npublic final void acquire(int arg) {\n    //tryAcquire(arg) 获取同步状态，这个需要子类重写\n    //addWaiter(Node.EXCLUSIVE) 如果tryAcquire获取失败，则将当前节点加入到同步队列中\n    //acquireQueued 线程阻塞，唤醒都在这方法里面\n    //Node.EXCLUSIVE 标识节点当前在独占模式下\n    if (!tryAcquire(arg) &&\n       acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n       selfInterrupt();\n}\n```\n\ntryAcquire方法是子类重写的方法，主要是尝试获取同步状态，例如上面的例子\n\n```java\nprotected boolean tryAcquire(int arg) {\n    //使用CAS更新state,如果更新成功返回true,否则返回false\n    return compareAndSetState(0, 1);\n}\n protected final boolean compareAndSetState(int expect, int update) {\n    // See below for intrinsics setup to support this\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n```\n\n**addWaiter**，当执行tryAcquire没有获取到同步状态时，将线程加入到同步队列中。\n\n```java\nprivate Node addWaiter(Node mode) {\n\t//构造一个新节点,线程为当前线程\n    Node node = new Node(Thread.currentThread(), mode);  \n    //以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后\n    Node pred = tail;\n    if (pred != null) { //尾节点不为空，插入到队列最后\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {  //更新tail，并且把新节点插入到列表最后\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node); //同步队列为空，或者有线程竞争入队时才会走到这里\n    return node;\n}\n\n//采用自旋的方式入队\n//到这个方法只有两种可能：等待队列为空，或者有线程竞争入队\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) {    //tail节点为空，初始化队列，这里延迟初始化\n            if (compareAndSetHead(new Node()))  //设置head节点\n                tail = head;\n        } else {    //tail节点不为空，开始真正插入节点\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n\n所以这一步做的事情主要是两个：\n\n1. 如果同步队列还没初始化就进行初始化\n2. 将线程封装成Node插入到队列的最后，并调整head和tail指针\n\n所以经过这一步后，同步队列如下，第一个节点是空节点。\n\n![](java-aqs/1.jpg)\n\n\n\n**acquireQueued方法**\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();  //获取前一个节点\n            //前一个节点是头节点再次尝试获取同步状态\n            //如果前一个节点是头节点就尝试获取一下同步队列\n            //这个主要是怕获取同步状态的线程很快就把同步状态给释放了,\n            //所以在当前线程阻塞之前抱着侥幸的心理再试试能不能成功获取到同步状态，\n            //如果侥幸可以获取，那就调用setHead方法把头节点换成自己\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            //到这里，说明上面的if分支没有成功，要么当前node本来就不是队头\n            //要么就是tryAcquire(arg)没有抢赢别人\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n//对Node节点中的waitStatus的各种操作\n//prod -- 前驱节点 node -- 新插入同步队列的节点\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;   //前一个节点的状态\n    //Node.SIGNAL的值是-1,说明前驱节点状态正常，当前线程需要挂起\n    if (ws == Node.SIGNAL)  \n        return true;\n    //当前线程已被取消操作，把处于取消状态的节点都移除掉\n    if (ws > 0) {  \n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {    \n        //设置前一个节点的状态为-1\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n//这个方法主要是用来进行阻塞\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n```\n\n**waitStatus状态**\n\n| 静态变量       | 值   | 描述                                           |\n| -------------- | ---- | ---------------------------------------------- |\n| Node.CANCELLED | 1    | 节点对应的线程已被取消                         |\n| Node.SIGNAL    | -1   | 表示后边的节点对应的线程处于等待状态           |\n| Node.CONDITION | -2   | 表示节点在等待队列中                           |\n| Node.PROPAGATE | -3   | 表示下一次共享式同步状态获取将被无条件传播下去 |\n| 无             | 0    | 初始状态                                       |\n\n这里解释一下整个acquireQueued过程，假设当前节点是节点1，在一开始，所有的`Node`节点的`waitStatus`都是`0`，所以在第一次调用`shouldParkAfterFailedAcquire`方法时，当前节点的前一个节点，也就是`0号节点`的`waitStatus`会被设置成`Node.SIGNAL`立即返回`false`，这个状态的意思就是说`0号节点`后边的节点都处于等待状态，现在的队列已经变成了这个样子。\n\n![](java-aqs/2.jpg)\n\n由于acquireQueued是一个循环，第二次进来后，由于0号节点已经是-1了，所以返回true，接着执行parkAndCheckInterrupt，节点1被阻塞。如果此时再来一个节点2，那么节点1就是节点2的前驱节点。那么在处理中也会将节点1的状态设置成-1。所以图示如下\n\n![](java-aqs/3.jpg)\n\n#### **同步状态释放**\n\n在获得同步锁的线程执行完操作后就会释放同步状态并唤醒同步队列。\n\n```java\npublic final boolean release(int arg) {\n    //释放同步状态，如果成功返回true\n    if (tryRelease(arg)) {\n        Node h = head;\n        //\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n//唤醒后继节点\n//node - head头节点\nprivate void unparkSuccessor(Node node) {\n        int ws = node.waitStatus;   //节点的等待状态\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n    \t//获取head节点的下一个节点\n        Node s = node.next; \n        if (s == null || s.waitStatus > 0) {    //如果node为最后一个节点或者node的后继节点被取消了\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)   \n                if (t.waitStatus <= 0)  //找到离头节点最近的waitStatus为负数的节点\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);   //唤醒该节点对应的线程\n}\n```\n\n## ReentrantLock实现\n\nReentrantLock内部使用了AQS实现加锁。看下非公平可重入方式是如何实现的。\n\n```java\n \n static final class NonfairSync extends Sync {\n     private static final long serialVersionUID = 7316153563782823691L;\n     final void lock() {\n         //先CAS更新同步状态，如果获取成功就设置当前线程加锁\n         if (compareAndSetState(0, 1))\n             setExclusiveOwnerThread(Thread.currentThread());\n         else\n             //使用AQS\n             acquire(1);\n     }\n\n     protected final boolean tryAcquire(int acquires) {\n         return nonfairTryAcquire(acquires);\n     }\n }\n\n\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        //调用tryAcquire时判断下同步状态是不是为0，如果为0就CAS操作同步状态\n        //这里就是为什么是不公平锁的体现。当一个新的线程过来获取锁时，他会尝试着先抢夺一下state\n        //如果这时候恰好执行独占操作的线程释放了state，他刚好抢夺到后就直接进入独占操作。\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //可重入的关键，如果是当前线程的话就操作同步状态+1\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n","source":"_posts/java-aqs.md","raw":"---\ntitle: java并发之AQS(抽象队列同步器)详解\ntags:\n  - java并发\ncategories:  java\ndescription : 详解AQS(抽象队列同步器)\ndate: 2020-09-06 09:19:19\n---\n\n## 概述\n\nJava中提供了AbstractQueuedSynchronizer类，简称抽象队列同步器。这个类封装了各种底层的同步细节程序员想自定义自己的同步工具的时候，只需要定义这个类的子类并覆盖它提供的一些方法就好了。**ReentrantLock**类就是借助AQS实现的。\n\n### AQS工作原理大概流程\n\nAQS中维护了一个**<font color=red>state</font>**字段，我们可以通过修改`state`字段代表的`同步状态`来实现多线程的`独占模式`或者`共享模式`。\n\n**独占模式**\n\n在独占模式下，我们可以把state的初始值设置为0，每当一个线程要进行某项独占操作时，判断state==0？，如果是0则通过**CAS**操作将state改成1并进入独占操作。当另一个线程也需要独占操作时，由于state!=0，意味着已经有线程在进行独占模式，则该线程会被封装成一个Node存到一个同步队列中去并阻塞。当第一个线程完成独占操作后，会将state设置成0并通知同步队列里的线程。这样同步队列里的线程就可以挨个进行独占操作。\n\n**共享模式**\n\n共享模式和独占模式差不多，也是判断state，需要阻塞的线程也是封装到同步队列中。比如说某项操作我们允许`10`个线程同时，那么就将state的初始值设置成10，线程需要独占操作时就将state减少1，当state小于0时，后续的线程才需要阻塞。\n<!--more-->\n## 原理和源码解析\n\n### 通过AQS实现一个锁\n\n```java\nimport com.google.common.collect.Maps;\n\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.AbstractQueuedSynchronizer;\n\n/***\n * 根据AQS实现一个先进先出可重入锁\n */\npublic class PlainLock {\n    private Sync sync = new Sync();\n\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    public void unlock() {\n        sync.release(1);\n    }\n   /****\n     * 继承AQS\n     */\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            return compareAndSetState(0, 1);\n        }\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        int NUMBER = 100;\n        PlainLock lock = new PlainLock();\n        Map<String,String> myMap = Maps.newHashMap();\n        for (int i = 0; i < NUMBER; i++) {\n            new Thread(new Runner(lock,myMap),\"线程\" + i).start();\n        }\n        TimeUnit.SECONDS.sleep(20);\n        System.out.println(myMap.entrySet().size());\n\n    }\n\n    private static class Runner implements Runnable {\n        PlainLock lock;\n        Map<String, String> myMap;\n\n        public Runner(PlainLock plainLock, Map<String, String> myMap) {\n            this.lock = plainLock;\n            this.myMap = myMap;\n        }\n\n        @Override\n        public void run() {\n            try {\n                lock.lock();\n                System.out.println(Thread.currentThread().getName() + \"..开始执行\");\n                for (int i = 0; i < 1000; i++) {\n                    myMap.put(UUID.randomUUID().toString(), \"1\");\n                }\n            } catch (Exception e) {\n\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n}\n```\n\n**加锁逻辑示意图**\n\n![](java-aqs/1.png)\n\n\n\n### 同步状态\n\n在AbstractQueuedSynchronizer类中维护这一个state同步状态，使用voatite修饰。\n\n```java\nprivate volatile int state;\n```\n\n并提供了几个访问该同步状态的方法，<font color=red>这些方法使用final修饰，不能被重写</font>。开发者只需要根据AQS提供给我们的方法操作state。\n\n| 方法名                                                       | 描述                     |\n| ------------------------------------------------------------ | ------------------------ |\n| protected final int getState()                               | 获取state的值            |\n| protected final void setState(int newState)                  | 设置state的值            |\n| protected final boolean compareAndSetState(int expect,int update) | 使用CAS方式更新state的值 |\n\n### 同步状态获取与释放\n\n在AbstractQueuedSynchronizer提供了获取同步状态与释放同步状态的方式，开发者根据需求决定是采用独占模式还是共享模式，<font color=red>在子类中重写对应的方法</font>。例如上面的Sync类。\n\n| 方法名                                      | 描述                                     |\n| ------------------------------------------- | ---------------------------------------- |\n| protected boolean tryAcquire(int arg)       | 独占式的获取同步状态，成功true,失败false |\n| protected boolean tryRelease(int arg)       | 独占式的释放同步状态，成功true,失败false |\n| protected boolean tryAcquireShared(int arg) | 共享式的获取同步状态，成功true,失败false |\n| protected boolean tryReleaseShared(int arg) | 共享式的释放同步状态，成功true,失败false |\n\n### 同步队列\n\n上面说过，当一个线程获取同步状态失败后会将该线程封装成一个Node放到同步队列中去。在AbstractQueuedSynchronizer定义了一个Node类用来表示。\n\n当一个线程获取同步状态失败之后，就把这个线程阻塞并包装成`Node`节点插入到这个`同步队列`中，当获取同步状态成功的线程释放同步状态的时候，同时通知在队列中下一个未获取到同步状态的节点，让该节点的线程再次去获取同步状态。\n\n![](java-aqs/2.png)\n\n```java\nprivate transient volatile Node head; //同步队列头节点\nprivate transient volatile Node tail; //同步队列尾节点\nstatic final class Node {\n    static final Node SHARED = new Node();\n    static final Node EXCLUSIVE = null;\n    static final int CANCELLED =  1;\n    static final int SIGNAL    = -1;\n    static final int CONDITION = -2;\n    static final int PROPAGATE = -3;\n    volatile int waitStatus; //Node的状态\n    volatile Node prev; //指向上一个Node\n    volatile Node next; //指向下一个Node\n    volatile Thread thread;  //存储线程 每一个节点都代表一个线程\n    Node nextWaiter;\n    Node() {\n    }\n    Node(Thread thread, Node mode) {\n        this.thread = thread;\n    }\n\n    Node(Thread thread, int waitStatus) {\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}\n```\n\n### 独占式同步状态获取与释放\n\n#### **入同步队列并阻塞**\n\n我们知道，整个获取同步状态或加入同步队列最终是调用了AQS中的acquire方法。AQS共提供了几种方法。\n\n| 方法名                                         | 描述                                                         |\n| ---------------------------------------------- | ------------------------------------------------------------ |\n| public void acquire(int arg)                   | 独占式获取同步状态，如果获取成功则返回，失败则将线程包装成Node放入同步队列 |\n| public void acquireInterruptibly(int arg)      | 跟上面功能类似，只不过这个方法在执行过程中被别的过程中断，会抛错误 |\n| public void tryAcqureNanos(int arg.long nanos) | 跟上面功能类似，加了超时机制                                 |\n| boolean release(int arg)                       | 这个方法属于释放同步状态                                     |\n\n**分析acquire方法**\n\n```java\npublic final void acquire(int arg) {\n    //tryAcquire(arg) 获取同步状态，这个需要子类重写\n    //addWaiter(Node.EXCLUSIVE) 如果tryAcquire获取失败，则将当前节点加入到同步队列中\n    //acquireQueued 线程阻塞，唤醒都在这方法里面\n    //Node.EXCLUSIVE 标识节点当前在独占模式下\n    if (!tryAcquire(arg) &&\n       acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n       selfInterrupt();\n}\n```\n\ntryAcquire方法是子类重写的方法，主要是尝试获取同步状态，例如上面的例子\n\n```java\nprotected boolean tryAcquire(int arg) {\n    //使用CAS更新state,如果更新成功返回true,否则返回false\n    return compareAndSetState(0, 1);\n}\n protected final boolean compareAndSetState(int expect, int update) {\n    // See below for intrinsics setup to support this\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n```\n\n**addWaiter**，当执行tryAcquire没有获取到同步状态时，将线程加入到同步队列中。\n\n```java\nprivate Node addWaiter(Node mode) {\n\t//构造一个新节点,线程为当前线程\n    Node node = new Node(Thread.currentThread(), mode);  \n    //以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后\n    Node pred = tail;\n    if (pred != null) { //尾节点不为空，插入到队列最后\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {  //更新tail，并且把新节点插入到列表最后\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node); //同步队列为空，或者有线程竞争入队时才会走到这里\n    return node;\n}\n\n//采用自旋的方式入队\n//到这个方法只有两种可能：等待队列为空，或者有线程竞争入队\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) {    //tail节点为空，初始化队列，这里延迟初始化\n            if (compareAndSetHead(new Node()))  //设置head节点\n                tail = head;\n        } else {    //tail节点不为空，开始真正插入节点\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n```\n\n所以这一步做的事情主要是两个：\n\n1. 如果同步队列还没初始化就进行初始化\n2. 将线程封装成Node插入到队列的最后，并调整head和tail指针\n\n所以经过这一步后，同步队列如下，第一个节点是空节点。\n\n![](java-aqs/1.jpg)\n\n\n\n**acquireQueued方法**\n\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();  //获取前一个节点\n            //前一个节点是头节点再次尝试获取同步状态\n            //如果前一个节点是头节点就尝试获取一下同步队列\n            //这个主要是怕获取同步状态的线程很快就把同步状态给释放了,\n            //所以在当前线程阻塞之前抱着侥幸的心理再试试能不能成功获取到同步状态，\n            //如果侥幸可以获取，那就调用setHead方法把头节点换成自己\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            //到这里，说明上面的if分支没有成功，要么当前node本来就不是队头\n            //要么就是tryAcquire(arg)没有抢赢别人\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n//对Node节点中的waitStatus的各种操作\n//prod -- 前驱节点 node -- 新插入同步队列的节点\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;   //前一个节点的状态\n    //Node.SIGNAL的值是-1,说明前驱节点状态正常，当前线程需要挂起\n    if (ws == Node.SIGNAL)  \n        return true;\n    //当前线程已被取消操作，把处于取消状态的节点都移除掉\n    if (ws > 0) {  \n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {    \n        //设置前一个节点的状态为-1\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n//这个方法主要是用来进行阻塞\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n```\n\n**waitStatus状态**\n\n| 静态变量       | 值   | 描述                                           |\n| -------------- | ---- | ---------------------------------------------- |\n| Node.CANCELLED | 1    | 节点对应的线程已被取消                         |\n| Node.SIGNAL    | -1   | 表示后边的节点对应的线程处于等待状态           |\n| Node.CONDITION | -2   | 表示节点在等待队列中                           |\n| Node.PROPAGATE | -3   | 表示下一次共享式同步状态获取将被无条件传播下去 |\n| 无             | 0    | 初始状态                                       |\n\n这里解释一下整个acquireQueued过程，假设当前节点是节点1，在一开始，所有的`Node`节点的`waitStatus`都是`0`，所以在第一次调用`shouldParkAfterFailedAcquire`方法时，当前节点的前一个节点，也就是`0号节点`的`waitStatus`会被设置成`Node.SIGNAL`立即返回`false`，这个状态的意思就是说`0号节点`后边的节点都处于等待状态，现在的队列已经变成了这个样子。\n\n![](java-aqs/2.jpg)\n\n由于acquireQueued是一个循环，第二次进来后，由于0号节点已经是-1了，所以返回true，接着执行parkAndCheckInterrupt，节点1被阻塞。如果此时再来一个节点2，那么节点1就是节点2的前驱节点。那么在处理中也会将节点1的状态设置成-1。所以图示如下\n\n![](java-aqs/3.jpg)\n\n#### **同步状态释放**\n\n在获得同步锁的线程执行完操作后就会释放同步状态并唤醒同步队列。\n\n```java\npublic final boolean release(int arg) {\n    //释放同步状态，如果成功返回true\n    if (tryRelease(arg)) {\n        Node h = head;\n        //\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n//唤醒后继节点\n//node - head头节点\nprivate void unparkSuccessor(Node node) {\n        int ws = node.waitStatus;   //节点的等待状态\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n    \t//获取head节点的下一个节点\n        Node s = node.next; \n        if (s == null || s.waitStatus > 0) {    //如果node为最后一个节点或者node的后继节点被取消了\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)   \n                if (t.waitStatus <= 0)  //找到离头节点最近的waitStatus为负数的节点\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);   //唤醒该节点对应的线程\n}\n```\n\n## ReentrantLock实现\n\nReentrantLock内部使用了AQS实现加锁。看下非公平可重入方式是如何实现的。\n\n```java\n \n static final class NonfairSync extends Sync {\n     private static final long serialVersionUID = 7316153563782823691L;\n     final void lock() {\n         //先CAS更新同步状态，如果获取成功就设置当前线程加锁\n         if (compareAndSetState(0, 1))\n             setExclusiveOwnerThread(Thread.currentThread());\n         else\n             //使用AQS\n             acquire(1);\n     }\n\n     protected final boolean tryAcquire(int acquires) {\n         return nonfairTryAcquire(acquires);\n     }\n }\n\n\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        //调用tryAcquire时判断下同步状态是不是为0，如果为0就CAS操作同步状态\n        //这里就是为什么是不公平锁的体现。当一个新的线程过来获取锁时，他会尝试着先抢夺一下state\n        //如果这时候恰好执行独占操作的线程释放了state，他刚好抢夺到后就直接进入独占操作。\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //可重入的关键，如果是当前线程的话就操作同步状态+1\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error(\"Maximum lock count exceeded\");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n```\n\n","slug":"java-aqs","published":1,"updated":"2021-04-08T00:47:06.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhut000pqwv2cy3f903v","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Java中提供了AbstractQueuedSynchronizer类，简称抽象队列同步器。这个类封装了各种底层的同步细节程序员想自定义自己的同步工具的时候，只需要定义这个类的子类并覆盖它提供的一些方法就好了。<strong>ReentrantLock</strong>类就是借助AQS实现的。</p>\n<h3 id=\"AQS工作原理大概流程\"><a href=\"#AQS工作原理大概流程\" class=\"headerlink\" title=\"AQS工作原理大概流程\"></a>AQS工作原理大概流程</h3><p>AQS中维护了一个<strong><font color=\"red\">state</font></strong>字段，我们可以通过修改<code>state</code>字段代表的<code>同步状态</code>来实现多线程的<code>独占模式</code>或者<code>共享模式</code>。</p>\n<p><strong>独占模式</strong></p>\n<p>在独占模式下，我们可以把state的初始值设置为0，每当一个线程要进行某项独占操作时，判断state==0？，如果是0则通过<strong>CAS</strong>操作将state改成1并进入独占操作。当另一个线程也需要独占操作时，由于state!=0，意味着已经有线程在进行独占模式，则该线程会被封装成一个Node存到一个同步队列中去并阻塞。当第一个线程完成独占操作后，会将state设置成0并通知同步队列里的线程。这样同步队列里的线程就可以挨个进行独占操作。</p>\n<p><strong>共享模式</strong></p>\n<p>共享模式和独占模式差不多，也是判断state，需要阻塞的线程也是封装到同步队列中。比如说某项操作我们允许<code>10</code>个线程同时，那么就将state的初始值设置成10，线程需要独占操作时就将state减少1，当state小于0时，后续的线程才需要阻塞。</p>\n<a id=\"more\"></a>\n<h2 id=\"原理和源码解析\"><a href=\"#原理和源码解析\" class=\"headerlink\" title=\"原理和源码解析\"></a>原理和源码解析</h2><h3 id=\"通过AQS实现一个锁\"><a href=\"#通过AQS实现一个锁\" class=\"headerlink\" title=\"通过AQS实现一个锁\"></a>通过AQS实现一个锁</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>google<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>collect<span class=\"token punctuation\">.</span>Maps<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Map<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>UUID<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>locks<span class=\"token punctuation\">.</span>AbstractQueuedSynchronizer<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/***\n * 根据AQS实现一个先进先出可重入锁\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PlainLock</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Sync sync <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Sync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sync<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        sync<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n   <span class=\"token comment\" spellcheck=\"true\">/****\n     * 继承AQS\n     */</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Sync</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractQueuedSynchronizer</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isHeldExclusively</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> NUMBER <span class=\"token operator\">=</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n        PlainLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PlainLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span>String<span class=\"token operator\">></span> myMap <span class=\"token operator\">=</span> Maps<span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> NUMBER<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runner</span><span class=\"token punctuation\">(</span>lock<span class=\"token punctuation\">,</span>myMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"线程\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>myMap<span class=\"token punctuation\">.</span><span class=\"token function\">entrySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Runner</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n        PlainLock lock<span class=\"token punctuation\">;</span>\n        Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> myMap<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">Runner</span><span class=\"token punctuation\">(</span>PlainLock plainLock<span class=\"token punctuation\">,</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> myMap<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock <span class=\"token operator\">=</span> plainLock<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>myMap <span class=\"token operator\">=</span> myMap<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"..开始执行\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    myMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>加锁逻辑示意图</strong></p>\n<p><img src=\"/2020/09/06/java-aqs/1.png\" alt></p>\n<h3 id=\"同步状态\"><a href=\"#同步状态\" class=\"headerlink\" title=\"同步状态\"></a>同步状态</h3><p>在AbstractQueuedSynchronizer类中维护这一个state同步状态，使用voatite修饰。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> state<span class=\"token punctuation\">;</span></code></pre>\n<p>并提供了几个访问该同步状态的方法，<font color=\"red\">这些方法使用final修饰，不能被重写</font>。开发者只需要根据AQS提供给我们的方法操作state。</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>protected final int getState()</td>\n<td>获取state的值</td>\n</tr>\n<tr>\n<td>protected final void setState(int newState)</td>\n<td>设置state的值</td>\n</tr>\n<tr>\n<td>protected final boolean compareAndSetState(int expect,int update)</td>\n<td>使用CAS方式更新state的值</td>\n</tr>\n</tbody></table>\n<h3 id=\"同步状态获取与释放\"><a href=\"#同步状态获取与释放\" class=\"headerlink\" title=\"同步状态获取与释放\"></a>同步状态获取与释放</h3><p>在AbstractQueuedSynchronizer提供了获取同步状态与释放同步状态的方式，开发者根据需求决定是采用独占模式还是共享模式，<font color=\"red\">在子类中重写对应的方法</font>。例如上面的Sync类。</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>protected boolean tryAcquire(int arg)</td>\n<td>独占式的获取同步状态，成功true,失败false</td>\n</tr>\n<tr>\n<td>protected boolean tryRelease(int arg)</td>\n<td>独占式的释放同步状态，成功true,失败false</td>\n</tr>\n<tr>\n<td>protected boolean tryAcquireShared(int arg)</td>\n<td>共享式的获取同步状态，成功true,失败false</td>\n</tr>\n<tr>\n<td>protected boolean tryReleaseShared(int arg)</td>\n<td>共享式的释放同步状态，成功true,失败false</td>\n</tr>\n</tbody></table>\n<h3 id=\"同步队列\"><a href=\"#同步队列\" class=\"headerlink\" title=\"同步队列\"></a>同步队列</h3><p>上面说过，当一个线程获取同步状态失败后会将该线程封装成一个Node放到同步队列中去。在AbstractQueuedSynchronizer定义了一个Node类用来表示。</p>\n<p>当一个线程获取同步状态失败之后，就把这个线程阻塞并包装成<code>Node</code>节点插入到这个<code>同步队列</code>中，当获取同步状态成功的线程释放同步状态的时候，同时通知在队列中下一个未获取到同步状态的节点，让该节点的线程再次去获取同步状态。</p>\n<p><img src=\"/2020/09/06/java-aqs/2.png\" alt></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> <span class=\"token keyword\">volatile</span> Node head<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//同步队列头节点</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">transient</span> <span class=\"token keyword\">volatile</span> Node tail<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//同步队列尾节点</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Node SHARED <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Node EXCLUSIVE <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> CANCELLED <span class=\"token operator\">=</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> SIGNAL    <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> CONDITION <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> PROPAGATE <span class=\"token operator\">=</span> <span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">int</span> waitStatus<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//Node的状态</span>\n    <span class=\"token keyword\">volatile</span> Node prev<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//指向上一个Node</span>\n    <span class=\"token keyword\">volatile</span> Node next<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//指向下一个Node</span>\n    <span class=\"token keyword\">volatile</span> Thread thread<span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//存储线程 每一个节点都代表一个线程</span>\n    Node nextWaiter<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>Thread thread<span class=\"token punctuation\">,</span> Node mode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>thread <span class=\"token operator\">=</span> thread<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">Node</span><span class=\"token punctuation\">(</span>Thread thread<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> waitStatus<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">=</span> waitStatus<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>thread <span class=\"token operator\">=</span> thread<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"独占式同步状态获取与释放\"><a href=\"#独占式同步状态获取与释放\" class=\"headerlink\" title=\"独占式同步状态获取与释放\"></a>独占式同步状态获取与释放</h3><h4 id=\"入同步队列并阻塞\"><a href=\"#入同步队列并阻塞\" class=\"headerlink\" title=\"入同步队列并阻塞\"></a><strong>入同步队列并阻塞</strong></h4><p>我们知道，整个获取同步状态或加入同步队列最终是调用了AQS中的acquire方法。AQS共提供了几种方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public void acquire(int arg)</td>\n<td>独占式获取同步状态，如果获取成功则返回，失败则将线程包装成Node放入同步队列</td>\n</tr>\n<tr>\n<td>public void acquireInterruptibly(int arg)</td>\n<td>跟上面功能类似，只不过这个方法在执行过程中被别的过程中断，会抛错误</td>\n</tr>\n<tr>\n<td>public void tryAcqureNanos(int arg.long nanos)</td>\n<td>跟上面功能类似，加了超时机制</td>\n</tr>\n<tr>\n<td>boolean release(int arg)</td>\n<td>这个方法属于释放同步状态</td>\n</tr>\n</tbody></table>\n<p><strong>分析acquire方法</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//tryAcquire(arg) 获取同步状态，这个需要子类重写</span>\n    <span class=\"token comment\" spellcheck=\"true\">//addWaiter(Node.EXCLUSIVE) 如果tryAcquire获取失败，则将当前节点加入到同步队列中</span>\n    <span class=\"token comment\" spellcheck=\"true\">//acquireQueued 线程阻塞，唤醒都在这方法里面</span>\n    <span class=\"token comment\" spellcheck=\"true\">//Node.EXCLUSIVE 标识节点当前在独占模式下</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n       <span class=\"token function\">acquireQueued</span><span class=\"token punctuation\">(</span><span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span>Node<span class=\"token punctuation\">.</span>EXCLUSIVE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n       <span class=\"token function\">selfInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>tryAcquire方法是子类重写的方法，主要是尝试获取同步状态，例如上面的例子</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//使用CAS更新state,如果更新成功返回true,否则返回false</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> expect<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> update<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// See below for intrinsics setup to support this</span>\n    <span class=\"token keyword\">return</span> unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> stateOffset<span class=\"token punctuation\">,</span> expect<span class=\"token punctuation\">,</span> update<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>addWaiter</strong>，当执行tryAcquire没有获取到同步状态时，将线程加入到同步队列中。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> Node <span class=\"token function\">addWaiter</span><span class=\"token punctuation\">(</span>Node mode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//构造一个新节点,线程为当前线程</span>\n    Node node <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> mode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  \n    <span class=\"token comment\" spellcheck=\"true\">//以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span>\n    Node pred <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>pred <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//尾节点不为空，插入到队列最后</span>\n        node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> pred<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetTail</span><span class=\"token punctuation\">(</span>pred<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//更新tail，并且把新节点插入到列表最后</span>\n            pred<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">enq</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//同步队列为空，或者有线程竞争入队时才会走到这里</span>\n    <span class=\"token keyword\">return</span> node<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//采用自旋的方式入队</span>\n<span class=\"token comment\" spellcheck=\"true\">//到这个方法只有两种可能：等待队列为空，或者有线程竞争入队</span>\n<span class=\"token keyword\">private</span> Node <span class=\"token function\">enq</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Node node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Node t <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//tail节点为空，初始化队列，这里延迟初始化</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetHead</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Node</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//设置head节点</span>\n                tail <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//tail节点不为空，开始真正插入节点</span>\n            node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetTail</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                t<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> t<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>所以这一步做的事情主要是两个：</p>\n<ol>\n<li>如果同步队列还没初始化就进行初始化</li>\n<li>将线程封装成Node插入到队列的最后，并调整head和tail指针</li>\n</ol>\n<p>所以经过这一步后，同步队列如下，第一个节点是空节点。</p>\n<p><img src=\"/2020/09/06/java-aqs/1.jpg\" alt></p>\n<p><strong>acquireQueued方法</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">acquireQueued</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Node node<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">boolean</span> failed <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">boolean</span> interrupted <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> Node p <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span><span class=\"token function\">predecessor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//获取前一个节点</span>\n            <span class=\"token comment\" spellcheck=\"true\">//前一个节点是头节点再次尝试获取同步状态</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果前一个节点是头节点就尝试获取一下同步队列</span>\n            <span class=\"token comment\" spellcheck=\"true\">//这个主要是怕获取同步状态的线程很快就把同步状态给释放了,</span>\n            <span class=\"token comment\" spellcheck=\"true\">//所以在当前线程阻塞之前抱着侥幸的心理再试试能不能成功获取到同步状态，</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果侥幸可以获取，那就调用setHead方法把头节点换成自己</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>p <span class=\"token operator\">==</span> head <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">setHead</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                p<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// help GC</span>\n                failed <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> interrupted<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//到这里，说明上面的if分支没有成功，要么当前node本来就不是队头</span>\n            <span class=\"token comment\" spellcheck=\"true\">//要么就是tryAcquire(arg)没有抢赢别人</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">shouldParkAfterFailedAcquire</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n                <span class=\"token function\">parkAndCheckInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                interrupted <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>failed<span class=\"token punctuation\">)</span>\n            <span class=\"token function\">cancelAcquire</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//对Node节点中的waitStatus的各种操作</span>\n<span class=\"token comment\" spellcheck=\"true\">//prod -- 前驱节点 node -- 新插入同步队列的节点</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">shouldParkAfterFailedAcquire</span><span class=\"token punctuation\">(</span>Node pred<span class=\"token punctuation\">,</span> Node node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> ws <span class=\"token operator\">=</span> pred<span class=\"token punctuation\">.</span>waitStatus<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//前一个节点的状态</span>\n    <span class=\"token comment\" spellcheck=\"true\">//Node.SIGNAL的值是-1,说明前驱节点状态正常，当前线程需要挂起</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ws <span class=\"token operator\">==</span> Node<span class=\"token punctuation\">.</span>SIGNAL<span class=\"token punctuation\">)</span>  \n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//当前线程已被取消操作，把处于取消状态的节点都移除掉</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ws <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  \n        <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n            node<span class=\"token punctuation\">.</span>prev <span class=\"token operator\">=</span> pred <span class=\"token operator\">=</span> pred<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>pred<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        pred<span class=\"token punctuation\">.</span>next <span class=\"token operator\">=</span> node<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>    \n        <span class=\"token comment\" spellcheck=\"true\">//设置前一个节点的状态为-1</span>\n        <span class=\"token function\">compareAndSetWaitStatus</span><span class=\"token punctuation\">(</span>pred<span class=\"token punctuation\">,</span> ws<span class=\"token punctuation\">,</span> Node<span class=\"token punctuation\">.</span>SIGNAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//这个方法主要是用来进行阻塞</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">parkAndCheckInterrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">park</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>waitStatus状态</strong></p>\n<table>\n<thead>\n<tr>\n<th>静态变量</th>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node.CANCELLED</td>\n<td>1</td>\n<td>节点对应的线程已被取消</td>\n</tr>\n<tr>\n<td>Node.SIGNAL</td>\n<td>-1</td>\n<td>表示后边的节点对应的线程处于等待状态</td>\n</tr>\n<tr>\n<td>Node.CONDITION</td>\n<td>-2</td>\n<td>表示节点在等待队列中</td>\n</tr>\n<tr>\n<td>Node.PROPAGATE</td>\n<td>-3</td>\n<td>表示下一次共享式同步状态获取将被无条件传播下去</td>\n</tr>\n<tr>\n<td>无</td>\n<td>0</td>\n<td>初始状态</td>\n</tr>\n</tbody></table>\n<p>这里解释一下整个acquireQueued过程，假设当前节点是节点1，在一开始，所有的<code>Node</code>节点的<code>waitStatus</code>都是<code>0</code>，所以在第一次调用<code>shouldParkAfterFailedAcquire</code>方法时，当前节点的前一个节点，也就是<code>0号节点</code>的<code>waitStatus</code>会被设置成<code>Node.SIGNAL</code>立即返回<code>false</code>，这个状态的意思就是说<code>0号节点</code>后边的节点都处于等待状态，现在的队列已经变成了这个样子。</p>\n<p><img src=\"/2020/09/06/java-aqs/2.jpg\" alt></p>\n<p>由于acquireQueued是一个循环，第二次进来后，由于0号节点已经是-1了，所以返回true，接着执行parkAndCheckInterrupt，节点1被阻塞。如果此时再来一个节点2，那么节点1就是节点2的前驱节点。那么在处理中也会将节点1的状态设置成-1。所以图示如下</p>\n<p><img src=\"/2020/09/06/java-aqs/3.jpg\" alt></p>\n<h4 id=\"同步状态释放\"><a href=\"#同步状态释放\" class=\"headerlink\" title=\"同步状态释放\"></a><strong>同步状态释放</strong></h4><p>在获得同步锁的线程执行完操作后就会释放同步状态并唤醒同步队列。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> arg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//释放同步状态，如果成功返回true</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span>arg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Node h <span class=\"token operator\">=</span> head<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>h <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> h<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">unparkSuccessor</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//唤醒后继节点</span>\n<span class=\"token comment\" spellcheck=\"true\">//node - head头节点</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">unparkSuccessor</span><span class=\"token punctuation\">(</span>Node node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> ws <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>waitStatus<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//节点的等待状态</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ws <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">compareAndSetWaitStatus</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">,</span> ws<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//获取head节点的下一个节点</span>\n        Node s <span class=\"token operator\">=</span> node<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span> \n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> s<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\" spellcheck=\"true\">//如果node为最后一个节点或者node的后继节点被取消了</span>\n            s <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Node t <span class=\"token operator\">=</span> tail<span class=\"token punctuation\">;</span> t <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> t <span class=\"token operator\">!=</span> node<span class=\"token punctuation\">;</span> t <span class=\"token operator\">=</span> t<span class=\"token punctuation\">.</span>prev<span class=\"token punctuation\">)</span>   \n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">.</span>waitStatus <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//找到离头节点最近的waitStatus为负数的节点</span>\n                    s <span class=\"token operator\">=</span> t<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>s <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n            LockSupport<span class=\"token punctuation\">.</span><span class=\"token function\">unpark</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>thread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//唤醒该节点对应的线程</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"ReentrantLock实现\"><a href=\"#ReentrantLock实现\" class=\"headerlink\" title=\"ReentrantLock实现\"></a>ReentrantLock实现</h2><p>ReentrantLock内部使用了AQS实现加锁。看下非公平可重入方式是如何实现的。</p>\n<pre class=\" language-java\"><code class=\"language-java\">\n <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NonfairSync</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Sync</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">long</span> serialVersionUID <span class=\"token operator\">=</span> 7316153563782823691L<span class=\"token punctuation\">;</span>\n     <span class=\"token keyword\">final</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token comment\" spellcheck=\"true\">//先CAS更新同步状态，如果获取成功就设置当前线程加锁</span>\n         <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n             <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">else</span>\n             <span class=\"token comment\" spellcheck=\"true\">//使用AQS</span>\n             <span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n\n     <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> acquires<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token keyword\">return</span> <span class=\"token function\">nonfairTryAcquire</span><span class=\"token punctuation\">(</span>acquires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n <span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">nonfairTryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> acquires<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> Thread current <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//调用tryAcquire时判断下同步状态是不是为0，如果为0就CAS操作同步状态</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这里就是为什么是不公平锁的体现。当一个新的线程过来获取锁时，他会尝试着先抢夺一下state</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果这时候恰好执行独占操作的线程释放了state，他刚好抢夺到后就直接进入独占操作。</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> acquires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//可重入的关键，如果是当前线程的话就操作同步状态+1</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">==</span> <span class=\"token function\">getExclusiveOwnerThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> nextc <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> acquires<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextc <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// overflow</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Maximum lock count exceeded\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>nextc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Java中提供了AbstractQueuedSynchronizer类，简称抽象队列同步器。这个类封装了各种底层的同步细节程序员想自定义自己的同步工具的时候，只需要定义这个类的子类并覆盖它提供的一些方法就好了。<strong>ReentrantLock</strong>类就是借助AQS实现的。</p>\n<h3 id=\"AQS工作原理大概流程\"><a href=\"#AQS工作原理大概流程\" class=\"headerlink\" title=\"AQS工作原理大概流程\"></a>AQS工作原理大概流程</h3><p>AQS中维护了一个<strong><font color=\"red\">state</font></strong>字段，我们可以通过修改<code>state</code>字段代表的<code>同步状态</code>来实现多线程的<code>独占模式</code>或者<code>共享模式</code>。</p>\n<p><strong>独占模式</strong></p>\n<p>在独占模式下，我们可以把state的初始值设置为0，每当一个线程要进行某项独占操作时，判断state==0？，如果是0则通过<strong>CAS</strong>操作将state改成1并进入独占操作。当另一个线程也需要独占操作时，由于state!=0，意味着已经有线程在进行独占模式，则该线程会被封装成一个Node存到一个同步队列中去并阻塞。当第一个线程完成独占操作后，会将state设置成0并通知同步队列里的线程。这样同步队列里的线程就可以挨个进行独占操作。</p>\n<p><strong>共享模式</strong></p>\n<p>共享模式和独占模式差不多，也是判断state，需要阻塞的线程也是封装到同步队列中。比如说某项操作我们允许<code>10</code>个线程同时，那么就将state的初始值设置成10，线程需要独占操作时就将state减少1，当state小于0时，后续的线程才需要阻塞。</p>","more":"<h2 id=\"原理和源码解析\"><a href=\"#原理和源码解析\" class=\"headerlink\" title=\"原理和源码解析\"></a>原理和源码解析</h2><h3 id=\"通过AQS实现一个锁\"><a href=\"#通过AQS实现一个锁\" class=\"headerlink\" title=\"通过AQS实现一个锁\"></a>通过AQS实现一个锁</h3><pre><code class=\"java\">import com.google.common.collect.Maps;\n\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.AbstractQueuedSynchronizer;\n\n/***\n * 根据AQS实现一个先进先出可重入锁\n */\npublic class PlainLock {\n    private Sync sync = new Sync();\n\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    public void unlock() {\n        sync.release(1);\n    }\n   /****\n     * 继承AQS\n     */\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire(int arg) {\n            return compareAndSetState(0, 1);\n        }\n\n        @Override\n        protected boolean tryRelease(int arg) {\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n    }\n\n\n    public static void main(String[] args) throws InterruptedException {\n        int NUMBER = 100;\n        PlainLock lock = new PlainLock();\n        Map&lt;String,String&gt; myMap = Maps.newHashMap();\n        for (int i = 0; i &lt; NUMBER; i++) {\n            new Thread(new Runner(lock,myMap),&quot;线程&quot; + i).start();\n        }\n        TimeUnit.SECONDS.sleep(20);\n        System.out.println(myMap.entrySet().size());\n\n    }\n\n    private static class Runner implements Runnable {\n        PlainLock lock;\n        Map&lt;String, String&gt; myMap;\n\n        public Runner(PlainLock plainLock, Map&lt;String, String&gt; myMap) {\n            this.lock = plainLock;\n            this.myMap = myMap;\n        }\n\n        @Override\n        public void run() {\n            try {\n                lock.lock();\n                System.out.println(Thread.currentThread().getName() + &quot;..开始执行&quot;);\n                for (int i = 0; i &lt; 1000; i++) {\n                    myMap.put(UUID.randomUUID().toString(), &quot;1&quot;);\n                }\n            } catch (Exception e) {\n\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n}</code></pre>\n<p><strong>加锁逻辑示意图</strong></p>\n<p><img src=\"/2020/09/06/java-aqs/1.png\" alt></p>\n<h3 id=\"同步状态\"><a href=\"#同步状态\" class=\"headerlink\" title=\"同步状态\"></a>同步状态</h3><p>在AbstractQueuedSynchronizer类中维护这一个state同步状态，使用voatite修饰。</p>\n<pre><code class=\"java\">private volatile int state;</code></pre>\n<p>并提供了几个访问该同步状态的方法，<font color=\"red\">这些方法使用final修饰，不能被重写</font>。开发者只需要根据AQS提供给我们的方法操作state。</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>protected final int getState()</td>\n<td>获取state的值</td>\n</tr>\n<tr>\n<td>protected final void setState(int newState)</td>\n<td>设置state的值</td>\n</tr>\n<tr>\n<td>protected final boolean compareAndSetState(int expect,int update)</td>\n<td>使用CAS方式更新state的值</td>\n</tr>\n</tbody></table>\n<h3 id=\"同步状态获取与释放\"><a href=\"#同步状态获取与释放\" class=\"headerlink\" title=\"同步状态获取与释放\"></a>同步状态获取与释放</h3><p>在AbstractQueuedSynchronizer提供了获取同步状态与释放同步状态的方式，开发者根据需求决定是采用独占模式还是共享模式，<font color=\"red\">在子类中重写对应的方法</font>。例如上面的Sync类。</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>protected boolean tryAcquire(int arg)</td>\n<td>独占式的获取同步状态，成功true,失败false</td>\n</tr>\n<tr>\n<td>protected boolean tryRelease(int arg)</td>\n<td>独占式的释放同步状态，成功true,失败false</td>\n</tr>\n<tr>\n<td>protected boolean tryAcquireShared(int arg)</td>\n<td>共享式的获取同步状态，成功true,失败false</td>\n</tr>\n<tr>\n<td>protected boolean tryReleaseShared(int arg)</td>\n<td>共享式的释放同步状态，成功true,失败false</td>\n</tr>\n</tbody></table>\n<h3 id=\"同步队列\"><a href=\"#同步队列\" class=\"headerlink\" title=\"同步队列\"></a>同步队列</h3><p>上面说过，当一个线程获取同步状态失败后会将该线程封装成一个Node放到同步队列中去。在AbstractQueuedSynchronizer定义了一个Node类用来表示。</p>\n<p>当一个线程获取同步状态失败之后，就把这个线程阻塞并包装成<code>Node</code>节点插入到这个<code>同步队列</code>中，当获取同步状态成功的线程释放同步状态的时候，同时通知在队列中下一个未获取到同步状态的节点，让该节点的线程再次去获取同步状态。</p>\n<p><img src=\"/2020/09/06/java-aqs/2.png\" alt></p>\n<pre><code class=\"java\">private transient volatile Node head; //同步队列头节点\nprivate transient volatile Node tail; //同步队列尾节点\nstatic final class Node {\n    static final Node SHARED = new Node();\n    static final Node EXCLUSIVE = null;\n    static final int CANCELLED =  1;\n    static final int SIGNAL    = -1;\n    static final int CONDITION = -2;\n    static final int PROPAGATE = -3;\n    volatile int waitStatus; //Node的状态\n    volatile Node prev; //指向上一个Node\n    volatile Node next; //指向下一个Node\n    volatile Thread thread;  //存储线程 每一个节点都代表一个线程\n    Node nextWaiter;\n    Node() {\n    }\n    Node(Thread thread, Node mode) {\n        this.thread = thread;\n    }\n\n    Node(Thread thread, int waitStatus) {\n        this.waitStatus = waitStatus;\n        this.thread = thread;\n    }\n}</code></pre>\n<h3 id=\"独占式同步状态获取与释放\"><a href=\"#独占式同步状态获取与释放\" class=\"headerlink\" title=\"独占式同步状态获取与释放\"></a>独占式同步状态获取与释放</h3><h4 id=\"入同步队列并阻塞\"><a href=\"#入同步队列并阻塞\" class=\"headerlink\" title=\"入同步队列并阻塞\"></a><strong>入同步队列并阻塞</strong></h4><p>我们知道，整个获取同步状态或加入同步队列最终是调用了AQS中的acquire方法。AQS共提供了几种方法。</p>\n<table>\n<thead>\n<tr>\n<th>方法名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>public void acquire(int arg)</td>\n<td>独占式获取同步状态，如果获取成功则返回，失败则将线程包装成Node放入同步队列</td>\n</tr>\n<tr>\n<td>public void acquireInterruptibly(int arg)</td>\n<td>跟上面功能类似，只不过这个方法在执行过程中被别的过程中断，会抛错误</td>\n</tr>\n<tr>\n<td>public void tryAcqureNanos(int arg.long nanos)</td>\n<td>跟上面功能类似，加了超时机制</td>\n</tr>\n<tr>\n<td>boolean release(int arg)</td>\n<td>这个方法属于释放同步状态</td>\n</tr>\n</tbody></table>\n<p><strong>分析acquire方法</strong></p>\n<pre><code class=\"java\">public final void acquire(int arg) {\n    //tryAcquire(arg) 获取同步状态，这个需要子类重写\n    //addWaiter(Node.EXCLUSIVE) 如果tryAcquire获取失败，则将当前节点加入到同步队列中\n    //acquireQueued 线程阻塞，唤醒都在这方法里面\n    //Node.EXCLUSIVE 标识节点当前在独占模式下\n    if (!tryAcquire(arg) &amp;&amp;\n       acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n       selfInterrupt();\n}</code></pre>\n<p>tryAcquire方法是子类重写的方法，主要是尝试获取同步状态，例如上面的例子</p>\n<pre><code class=\"java\">protected boolean tryAcquire(int arg) {\n    //使用CAS更新state,如果更新成功返回true,否则返回false\n    return compareAndSetState(0, 1);\n}\n protected final boolean compareAndSetState(int expect, int update) {\n    // See below for intrinsics setup to support this\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}</code></pre>\n<p><strong>addWaiter</strong>，当执行tryAcquire没有获取到同步状态时，将线程加入到同步队列中。</p>\n<pre><code class=\"java\">private Node addWaiter(Node mode) {\n    //构造一个新节点,线程为当前线程\n    Node node = new Node(Thread.currentThread(), mode);  \n    //以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后\n    Node pred = tail;\n    if (pred != null) { //尾节点不为空，插入到队列最后\n        node.prev = pred;\n        if (compareAndSetTail(pred, node)) {  //更新tail，并且把新节点插入到列表最后\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node); //同步队列为空，或者有线程竞争入队时才会走到这里\n    return node;\n}\n\n//采用自旋的方式入队\n//到这个方法只有两种可能：等待队列为空，或者有线程竞争入队\nprivate Node enq(final Node node) {\n    for (;;) {\n        Node t = tail;\n        if (t == null) {    //tail节点为空，初始化队列，这里延迟初始化\n            if (compareAndSetHead(new Node()))  //设置head节点\n                tail = head;\n        } else {    //tail节点不为空，开始真正插入节点\n            node.prev = t;\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}</code></pre>\n<p>所以这一步做的事情主要是两个：</p>\n<ol>\n<li>如果同步队列还没初始化就进行初始化</li>\n<li>将线程封装成Node插入到队列的最后，并调整head和tail指针</li>\n</ol>\n<p>所以经过这一步后，同步队列如下，第一个节点是空节点。</p>\n<p><img src=\"/2020/09/06/java-aqs/1.jpg\" alt></p>\n<p><strong>acquireQueued方法</strong></p>\n<pre><code class=\"java\">final boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();  //获取前一个节点\n            //前一个节点是头节点再次尝试获取同步状态\n            //如果前一个节点是头节点就尝试获取一下同步队列\n            //这个主要是怕获取同步状态的线程很快就把同步状态给释放了,\n            //所以在当前线程阻塞之前抱着侥幸的心理再试试能不能成功获取到同步状态，\n            //如果侥幸可以获取，那就调用setHead方法把头节点换成自己\n            if (p == head &amp;&amp; tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            //到这里，说明上面的if分支没有成功，要么当前node本来就不是队头\n            //要么就是tryAcquire(arg)没有抢赢别人\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n//对Node节点中的waitStatus的各种操作\n//prod -- 前驱节点 node -- 新插入同步队列的节点\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;   //前一个节点的状态\n    //Node.SIGNAL的值是-1,说明前驱节点状态正常，当前线程需要挂起\n    if (ws == Node.SIGNAL)  \n        return true;\n    //当前线程已被取消操作，把处于取消状态的节点都移除掉\n    if (ws &gt; 0) {  \n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus &gt; 0);\n        pred.next = node;\n    } else {    \n        //设置前一个节点的状态为-1\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n//这个方法主要是用来进行阻塞\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}</code></pre>\n<p><strong>waitStatus状态</strong></p>\n<table>\n<thead>\n<tr>\n<th>静态变量</th>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Node.CANCELLED</td>\n<td>1</td>\n<td>节点对应的线程已被取消</td>\n</tr>\n<tr>\n<td>Node.SIGNAL</td>\n<td>-1</td>\n<td>表示后边的节点对应的线程处于等待状态</td>\n</tr>\n<tr>\n<td>Node.CONDITION</td>\n<td>-2</td>\n<td>表示节点在等待队列中</td>\n</tr>\n<tr>\n<td>Node.PROPAGATE</td>\n<td>-3</td>\n<td>表示下一次共享式同步状态获取将被无条件传播下去</td>\n</tr>\n<tr>\n<td>无</td>\n<td>0</td>\n<td>初始状态</td>\n</tr>\n</tbody></table>\n<p>这里解释一下整个acquireQueued过程，假设当前节点是节点1，在一开始，所有的<code>Node</code>节点的<code>waitStatus</code>都是<code>0</code>，所以在第一次调用<code>shouldParkAfterFailedAcquire</code>方法时，当前节点的前一个节点，也就是<code>0号节点</code>的<code>waitStatus</code>会被设置成<code>Node.SIGNAL</code>立即返回<code>false</code>，这个状态的意思就是说<code>0号节点</code>后边的节点都处于等待状态，现在的队列已经变成了这个样子。</p>\n<p><img src=\"/2020/09/06/java-aqs/2.jpg\" alt></p>\n<p>由于acquireQueued是一个循环，第二次进来后，由于0号节点已经是-1了，所以返回true，接着执行parkAndCheckInterrupt，节点1被阻塞。如果此时再来一个节点2，那么节点1就是节点2的前驱节点。那么在处理中也会将节点1的状态设置成-1。所以图示如下</p>\n<p><img src=\"/2020/09/06/java-aqs/3.jpg\" alt></p>\n<h4 id=\"同步状态释放\"><a href=\"#同步状态释放\" class=\"headerlink\" title=\"同步状态释放\"></a><strong>同步状态释放</strong></h4><p>在获得同步锁的线程执行完操作后就会释放同步状态并唤醒同步队列。</p>\n<pre><code class=\"java\">public final boolean release(int arg) {\n    //释放同步状态，如果成功返回true\n    if (tryRelease(arg)) {\n        Node h = head;\n        //\n        if (h != null &amp;&amp; h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n//唤醒后继节点\n//node - head头节点\nprivate void unparkSuccessor(Node node) {\n        int ws = node.waitStatus;   //节点的等待状态\n        if (ws &lt; 0)\n            compareAndSetWaitStatus(node, ws, 0);\n        //获取head节点的下一个节点\n        Node s = node.next; \n        if (s == null || s.waitStatus &gt; 0) {    //如果node为最后一个节点或者node的后继节点被取消了\n            s = null;\n            for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)   \n                if (t.waitStatus &lt;= 0)  //找到离头节点最近的waitStatus为负数的节点\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);   //唤醒该节点对应的线程\n}</code></pre>\n<h2 id=\"ReentrantLock实现\"><a href=\"#ReentrantLock实现\" class=\"headerlink\" title=\"ReentrantLock实现\"></a>ReentrantLock实现</h2><p>ReentrantLock内部使用了AQS实现加锁。看下非公平可重入方式是如何实现的。</p>\n<pre><code class=\"java\">\n static final class NonfairSync extends Sync {\n     private static final long serialVersionUID = 7316153563782823691L;\n     final void lock() {\n         //先CAS更新同步状态，如果获取成功就设置当前线程加锁\n         if (compareAndSetState(0, 1))\n             setExclusiveOwnerThread(Thread.currentThread());\n         else\n             //使用AQS\n             acquire(1);\n     }\n\n     protected final boolean tryAcquire(int acquires) {\n         return nonfairTryAcquire(acquires);\n     }\n }\n\n\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        //调用tryAcquire时判断下同步状态是不是为0，如果为0就CAS操作同步状态\n        //这里就是为什么是不公平锁的体现。当一个新的线程过来获取锁时，他会尝试着先抢夺一下state\n        //如果这时候恰好执行独占操作的线程释放了state，他刚好抢夺到后就直接进入独占操作。\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //可重入的关键，如果是当前线程的话就操作同步状态+1\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc &lt; 0) // overflow\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        setState(nextc);\n        return true;\n    }\n    return false;\n}</code></pre>"},{"title":"Kafka概念与架构知识点汇总（一）","description":"Kafka概念与架构知识点汇总","date":"2020-10-09T11:44:41.000Z","_content":"\n## 概述\n### 介绍\n\nKafka是一个**分布式**，**分区**，**多副本**，**发布-订阅模式**，**基于zookeeper协调**的分布式日志系统，消息队列（MQ）。主要应用场景是：日志收集系统和消息系统。\n\n### 术语\n\n- Broker（服务器），Kafka的服务器被称为Broker，一个集群中包含一个或多个Broker。\n- Topic（主题），每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。\n- Partition（分区），一个Topic被分成多个分区，这也是Kafka吞吐量高的原因之一，负载均衡。\n- Producer（生产者），数据的发布者，将消息发布到topic中。\n- Consumer（消费者），从topic中消费消息，一个消费者可以消费多个不同的Topic或者多个不同的Partition\n- Consumer Group（消费者组），每个Consumer属于一个特定的Consumer Group。\n- Replica（副本），一个分区有多个Replica，这也是Kafka高可用的原因。\n- Leader（领导者副本），当前负责数据的读写的partition。\n- Follower（追随者副本），负责从Leader获取数据并存储，不负责读写，作为一个冷备份，当Leader挂的时候就会从Follower中选举一个出来当Leader。\n- LogSegemnt（数据段），消息的持久化方式。\n- AR（Assigned Repllicas），分区中的所有副本统称为AR。\n- ISR（in-sync Replica），所有与leader副本保持一定程度同步的副本（包括Leader）称之为ISR。\n- Controller（控制者），负责管理整个集群中分区和副本的状态。\n<!--more-->\n### 关系解析\n\n**Topic（主题）和 Partition（分区）**\n\n主题是我们逻辑上的说法，分区是物理上的说法。例如我们在Kafka创建了一个主题`Test`并指定3个分区。那么在实际存储上这个主题会被分成3个分区。这样的好处是为了负载均衡，且Kafka支持根据key路由到特定分区。例如现在这个Test主题存储VIP消息和普通消息，就可以根据将VIP消息存到分区0上，普通消息存在分区1上。\n\n**Partition（分区）和 Replica（副本） 和 Leader（领导者副本） 和 Follower（追随者副本）**\n\n一个分区可以有一个或多个副本，多个副本中又分成leader和follower。leader负责数据的读写，follower负责从leader同步数据。kafka副本的概念是实现高可用的方式。\n\n**Consumer（消费者）和 Consumer Group（消费者组）**\n\n一个消费者组里有一个或多个消费者。一个分区只能被同一个消费者组的其中一个消费者消费，不能被同一个消费者组的多个消费者同时消费。假设一个主题有3个分区，一个消费者组有4个消费者，那么将有一个消费者无法消费。\n\n![kafka关系图解](kafka-base/1.png)\n\n**Controller（控制者）和 Broker（服务器）**\n\nKafka集群中多个broker，有一个会被选举为Controller leader，Controller负责管理整个集群中分区和副本的状态，比如partition的leader 副本故障，由controller 负责为该partition重新选举新的leader 副本；当检测到ISR列表发生变化，有controller通知集群中所有broker更新其MetadataCache信息；或者增加某个topic分区的时候也会由controller管理分区的重新分配工作。\n\n## 架构\n\n### 消息分区机制原理\n\nKafka的消息组织方式实际上是三级结构：主题-分区-消息。主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份。\n\n![](kafka-base/2.png)\n\n如图所示，其实分区的作用就是提供**负载均衡**的能力，不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。写消息时，采用**追加的方式**写入保证同一个分区下的消息的顺序性。至于消息具体是写到哪个分区，kafka提供了多种分区策略包括：轮询，随机，自定义。\n\n总结一下，Kafka采用分区的方式的好处是提供了负载均衡的能力，达到了高性能的目的，且分区可以增加减少，可扩展能力强。\n\n### 持久化数据\n\n生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。总的来说，Kafka使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。<font color=red>因为只能追加写入，故避免了缓慢的随机I/O操作，改为性能较好的顺序I/O写操作，这也是实现Kafka高吞吐量特性的一个重要手段</font>。\n\n![](kafka-base/3.png)\n\n每一个分区中的消息以Log的形式存在，但Log并不是日志存储和操作的最底层单元,kafka消息最底层的单元的是日志段，即LogSegemnt， Log和LogSegement的关系如上图所示。这里需要注意的是，kafka的日志段并不是一个物理概念，而是一个逻辑概念，一个日志段包括一个消息日志文件和若干索引文件组成，即一个.log和多个.xxxindex文件。\n\n![](kafka-base/4.png)\n\n### 副本机制\n\nKafka中一个分区上有多个副本。提供数据冗余实现高可用性和高持久性。在Kafka中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本（<font color=red>追随者副本是不对外提供服务</font>）。\n\n**如何将所有Replica均匀分布到整个集群？**\n\n为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。假设一个集群由3台Broker，3个分区，6个副本，那么一个分区对应2个副本。如果一个分区的副本同时在一台Broker将达不到高可用。所以需要按照一定的算法将不同的副本分配到不同的Broker上，Kafka分配Replica的算法如下 ：\n\n1. 将所有Broker（假设共n个Broker）和待分配的Partition排序。\n2. 将第i个Partition分配到第（i mod n）个Broker上。\n3. 将第i个Partition的第j个Replica分配到第（(i + j) mode n）个Broker上。\n\n### 消息传递策略\n\nProducer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。\n\n为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费。\n\n## 附录\n\n- Kafka的缓存不是在内存中保存尽可能多的数据并在需要时将这些数刷新到文件系统，而是做完全相反的事情，将所有的数据立即写入文件系统中的持久化的日志中，但不进行刷新数据的调用，实际这么做意味着数据被传输到os内核的页面缓存中去了，随后在根据配置刷新到硬盘。","source":"_posts/kafka-base.md","raw":"---\ntitle: Kafka概念与架构知识点汇总（一）\ntags:\n  - kafka\ncategories:  kafka\ndescription : Kafka概念与架构知识点汇总\ndate: 2020-10-09 19:44:41\n---\n\n## 概述\n### 介绍\n\nKafka是一个**分布式**，**分区**，**多副本**，**发布-订阅模式**，**基于zookeeper协调**的分布式日志系统，消息队列（MQ）。主要应用场景是：日志收集系统和消息系统。\n\n### 术语\n\n- Broker（服务器），Kafka的服务器被称为Broker，一个集群中包含一个或多个Broker。\n- Topic（主题），每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。\n- Partition（分区），一个Topic被分成多个分区，这也是Kafka吞吐量高的原因之一，负载均衡。\n- Producer（生产者），数据的发布者，将消息发布到topic中。\n- Consumer（消费者），从topic中消费消息，一个消费者可以消费多个不同的Topic或者多个不同的Partition\n- Consumer Group（消费者组），每个Consumer属于一个特定的Consumer Group。\n- Replica（副本），一个分区有多个Replica，这也是Kafka高可用的原因。\n- Leader（领导者副本），当前负责数据的读写的partition。\n- Follower（追随者副本），负责从Leader获取数据并存储，不负责读写，作为一个冷备份，当Leader挂的时候就会从Follower中选举一个出来当Leader。\n- LogSegemnt（数据段），消息的持久化方式。\n- AR（Assigned Repllicas），分区中的所有副本统称为AR。\n- ISR（in-sync Replica），所有与leader副本保持一定程度同步的副本（包括Leader）称之为ISR。\n- Controller（控制者），负责管理整个集群中分区和副本的状态。\n<!--more-->\n### 关系解析\n\n**Topic（主题）和 Partition（分区）**\n\n主题是我们逻辑上的说法，分区是物理上的说法。例如我们在Kafka创建了一个主题`Test`并指定3个分区。那么在实际存储上这个主题会被分成3个分区。这样的好处是为了负载均衡，且Kafka支持根据key路由到特定分区。例如现在这个Test主题存储VIP消息和普通消息，就可以根据将VIP消息存到分区0上，普通消息存在分区1上。\n\n**Partition（分区）和 Replica（副本） 和 Leader（领导者副本） 和 Follower（追随者副本）**\n\n一个分区可以有一个或多个副本，多个副本中又分成leader和follower。leader负责数据的读写，follower负责从leader同步数据。kafka副本的概念是实现高可用的方式。\n\n**Consumer（消费者）和 Consumer Group（消费者组）**\n\n一个消费者组里有一个或多个消费者。一个分区只能被同一个消费者组的其中一个消费者消费，不能被同一个消费者组的多个消费者同时消费。假设一个主题有3个分区，一个消费者组有4个消费者，那么将有一个消费者无法消费。\n\n![kafka关系图解](kafka-base/1.png)\n\n**Controller（控制者）和 Broker（服务器）**\n\nKafka集群中多个broker，有一个会被选举为Controller leader，Controller负责管理整个集群中分区和副本的状态，比如partition的leader 副本故障，由controller 负责为该partition重新选举新的leader 副本；当检测到ISR列表发生变化，有controller通知集群中所有broker更新其MetadataCache信息；或者增加某个topic分区的时候也会由controller管理分区的重新分配工作。\n\n## 架构\n\n### 消息分区机制原理\n\nKafka的消息组织方式实际上是三级结构：主题-分区-消息。主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份。\n\n![](kafka-base/2.png)\n\n如图所示，其实分区的作用就是提供**负载均衡**的能力，不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。写消息时，采用**追加的方式**写入保证同一个分区下的消息的顺序性。至于消息具体是写到哪个分区，kafka提供了多种分区策略包括：轮询，随机，自定义。\n\n总结一下，Kafka采用分区的方式的好处是提供了负载均衡的能力，达到了高性能的目的，且分区可以增加减少，可扩展能力强。\n\n### 持久化数据\n\n生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。总的来说，Kafka使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。<font color=red>因为只能追加写入，故避免了缓慢的随机I/O操作，改为性能较好的顺序I/O写操作，这也是实现Kafka高吞吐量特性的一个重要手段</font>。\n\n![](kafka-base/3.png)\n\n每一个分区中的消息以Log的形式存在，但Log并不是日志存储和操作的最底层单元,kafka消息最底层的单元的是日志段，即LogSegemnt， Log和LogSegement的关系如上图所示。这里需要注意的是，kafka的日志段并不是一个物理概念，而是一个逻辑概念，一个日志段包括一个消息日志文件和若干索引文件组成，即一个.log和多个.xxxindex文件。\n\n![](kafka-base/4.png)\n\n### 副本机制\n\nKafka中一个分区上有多个副本。提供数据冗余实现高可用性和高持久性。在Kafka中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本（<font color=red>追随者副本是不对外提供服务</font>）。\n\n**如何将所有Replica均匀分布到整个集群？**\n\n为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。假设一个集群由3台Broker，3个分区，6个副本，那么一个分区对应2个副本。如果一个分区的副本同时在一台Broker将达不到高可用。所以需要按照一定的算法将不同的副本分配到不同的Broker上，Kafka分配Replica的算法如下 ：\n\n1. 将所有Broker（假设共n个Broker）和待分配的Partition排序。\n2. 将第i个Partition分配到第（i mod n）个Broker上。\n3. 将第i个Partition的第j个Replica分配到第（(i + j) mode n）个Broker上。\n\n### 消息传递策略\n\nProducer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。\n\n为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费。\n\n## 附录\n\n- Kafka的缓存不是在内存中保存尽可能多的数据并在需要时将这些数刷新到文件系统，而是做完全相反的事情，将所有的数据立即写入文件系统中的持久化的日志中，但不进行刷新数据的调用，实际这么做意味着数据被传输到os内核的页面缓存中去了，随后在根据配置刷新到硬盘。","slug":"kafka-base","published":1,"updated":"2021-04-08T00:47:06.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhuv000rqwv23h4c5d88","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Kafka是一个<strong>分布式</strong>，<strong>分区</strong>，<strong>多副本</strong>，<strong>发布-订阅模式</strong>，<strong>基于zookeeper协调</strong>的分布式日志系统，消息队列（MQ）。主要应用场景是：日志收集系统和消息系统。</p>\n<h3 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h3><ul>\n<li>Broker（服务器），Kafka的服务器被称为Broker，一个集群中包含一个或多个Broker。</li>\n<li>Topic（主题），每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。</li>\n<li>Partition（分区），一个Topic被分成多个分区，这也是Kafka吞吐量高的原因之一，负载均衡。</li>\n<li>Producer（生产者），数据的发布者，将消息发布到topic中。</li>\n<li>Consumer（消费者），从topic中消费消息，一个消费者可以消费多个不同的Topic或者多个不同的Partition</li>\n<li>Consumer Group（消费者组），每个Consumer属于一个特定的Consumer Group。</li>\n<li>Replica（副本），一个分区有多个Replica，这也是Kafka高可用的原因。</li>\n<li>Leader（领导者副本），当前负责数据的读写的partition。</li>\n<li>Follower（追随者副本），负责从Leader获取数据并存储，不负责读写，作为一个冷备份，当Leader挂的时候就会从Follower中选举一个出来当Leader。</li>\n<li>LogSegemnt（数据段），消息的持久化方式。</li>\n<li>AR（Assigned Repllicas），分区中的所有副本统称为AR。</li>\n<li>ISR（in-sync Replica），所有与leader副本保持一定程度同步的副本（包括Leader）称之为ISR。</li>\n<li>Controller（控制者），负责管理整个集群中分区和副本的状态。<a id=\"more\"></a>\n<h3 id=\"关系解析\"><a href=\"#关系解析\" class=\"headerlink\" title=\"关系解析\"></a>关系解析</h3></li>\n</ul>\n<p><strong>Topic（主题）和 Partition（分区）</strong></p>\n<p>主题是我们逻辑上的说法，分区是物理上的说法。例如我们在Kafka创建了一个主题<code>Test</code>并指定3个分区。那么在实际存储上这个主题会被分成3个分区。这样的好处是为了负载均衡，且Kafka支持根据key路由到特定分区。例如现在这个Test主题存储VIP消息和普通消息，就可以根据将VIP消息存到分区0上，普通消息存在分区1上。</p>\n<p><strong>Partition（分区）和 Replica（副本） 和 Leader（领导者副本） 和 Follower（追随者副本）</strong></p>\n<p>一个分区可以有一个或多个副本，多个副本中又分成leader和follower。leader负责数据的读写，follower负责从leader同步数据。kafka副本的概念是实现高可用的方式。</p>\n<p><strong>Consumer（消费者）和 Consumer Group（消费者组）</strong></p>\n<p>一个消费者组里有一个或多个消费者。一个分区只能被同一个消费者组的其中一个消费者消费，不能被同一个消费者组的多个消费者同时消费。假设一个主题有3个分区，一个消费者组有4个消费者，那么将有一个消费者无法消费。</p>\n<p><img src=\"/2020/10/09/kafka-base/1.png\" alt=\"kafka关系图解\"></p>\n<p><strong>Controller（控制者）和 Broker（服务器）</strong></p>\n<p>Kafka集群中多个broker，有一个会被选举为Controller leader，Controller负责管理整个集群中分区和副本的状态，比如partition的leader 副本故障，由controller 负责为该partition重新选举新的leader 副本；当检测到ISR列表发生变化，有controller通知集群中所有broker更新其MetadataCache信息；或者增加某个topic分区的时候也会由controller管理分区的重新分配工作。</p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"消息分区机制原理\"><a href=\"#消息分区机制原理\" class=\"headerlink\" title=\"消息分区机制原理\"></a>消息分区机制原理</h3><p>Kafka的消息组织方式实际上是三级结构：主题-分区-消息。主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份。</p>\n<p><img src=\"/2020/10/09/kafka-base/2.png\" alt></p>\n<p>如图所示，其实分区的作用就是提供<strong>负载均衡</strong>的能力，不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。写消息时，采用<strong>追加的方式</strong>写入保证同一个分区下的消息的顺序性。至于消息具体是写到哪个分区，kafka提供了多种分区策略包括：轮询，随机，自定义。</p>\n<p>总结一下，Kafka采用分区的方式的好处是提供了负载均衡的能力，达到了高性能的目的，且分区可以增加减少，可扩展能力强。</p>\n<h3 id=\"持久化数据\"><a href=\"#持久化数据\" class=\"headerlink\" title=\"持久化数据\"></a>持久化数据</h3><p>生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。总的来说，Kafka使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。<font color=\"red\">因为只能追加写入，故避免了缓慢的随机I/O操作，改为性能较好的顺序I/O写操作，这也是实现Kafka高吞吐量特性的一个重要手段</font>。</p>\n<p><img src=\"/2020/10/09/kafka-base/3.png\" alt></p>\n<p>每一个分区中的消息以Log的形式存在，但Log并不是日志存储和操作的最底层单元,kafka消息最底层的单元的是日志段，即LogSegemnt， Log和LogSegement的关系如上图所示。这里需要注意的是，kafka的日志段并不是一个物理概念，而是一个逻辑概念，一个日志段包括一个消息日志文件和若干索引文件组成，即一个.log和多个.xxxindex文件。</p>\n<p><img src=\"/2020/10/09/kafka-base/4.png\" alt></p>\n<h3 id=\"副本机制\"><a href=\"#副本机制\" class=\"headerlink\" title=\"副本机制\"></a>副本机制</h3><p>Kafka中一个分区上有多个副本。提供数据冗余实现高可用性和高持久性。在Kafka中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本（<font color=\"red\">追随者副本是不对外提供服务</font>）。</p>\n<p><strong>如何将所有Replica均匀分布到整个集群？</strong></p>\n<p>为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。假设一个集群由3台Broker，3个分区，6个副本，那么一个分区对应2个副本。如果一个分区的副本同时在一台Broker将达不到高可用。所以需要按照一定的算法将不同的副本分配到不同的Broker上，Kafka分配Replica的算法如下 ：</p>\n<ol>\n<li>将所有Broker（假设共n个Broker）和待分配的Partition排序。</li>\n<li>将第i个Partition分配到第（i mod n）个Broker上。</li>\n<li>将第i个Partition的第j个Replica分配到第（(i + j) mode n）个Broker上。</li>\n</ol>\n<h3 id=\"消息传递策略\"><a href=\"#消息传递策略\" class=\"headerlink\" title=\"消息传递策略\"></a>消息传递策略</h3><p>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。</p>\n<p>为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><ul>\n<li>Kafka的缓存不是在内存中保存尽可能多的数据并在需要时将这些数刷新到文件系统，而是做完全相反的事情，将所有的数据立即写入文件系统中的持久化的日志中，但不进行刷新数据的调用，实际这么做意味着数据被传输到os内核的页面缓存中去了，随后在根据配置刷新到硬盘。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>Kafka是一个<strong>分布式</strong>，<strong>分区</strong>，<strong>多副本</strong>，<strong>发布-订阅模式</strong>，<strong>基于zookeeper协调</strong>的分布式日志系统，消息队列（MQ）。主要应用场景是：日志收集系统和消息系统。</p>\n<h3 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h3><ul>\n<li>Broker（服务器），Kafka的服务器被称为Broker，一个集群中包含一个或多个Broker。</li>\n<li>Topic（主题），每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。</li>\n<li>Partition（分区），一个Topic被分成多个分区，这也是Kafka吞吐量高的原因之一，负载均衡。</li>\n<li>Producer（生产者），数据的发布者，将消息发布到topic中。</li>\n<li>Consumer（消费者），从topic中消费消息，一个消费者可以消费多个不同的Topic或者多个不同的Partition</li>\n<li>Consumer Group（消费者组），每个Consumer属于一个特定的Consumer Group。</li>\n<li>Replica（副本），一个分区有多个Replica，这也是Kafka高可用的原因。</li>\n<li>Leader（领导者副本），当前负责数据的读写的partition。</li>\n<li>Follower（追随者副本），负责从Leader获取数据并存储，不负责读写，作为一个冷备份，当Leader挂的时候就会从Follower中选举一个出来当Leader。</li>\n<li>LogSegemnt（数据段），消息的持久化方式。</li>\n<li>AR（Assigned Repllicas），分区中的所有副本统称为AR。</li>\n<li>ISR（in-sync Replica），所有与leader副本保持一定程度同步的副本（包括Leader）称之为ISR。</li>\n<li>Controller（控制者），负责管理整个集群中分区和副本的状态。</li></ul>","more":"<h3 id=\"关系解析\"><a href=\"#关系解析\" class=\"headerlink\" title=\"关系解析\"></a>关系解析</h3>\n\n<p><strong>Topic（主题）和 Partition（分区）</strong></p>\n<p>主题是我们逻辑上的说法，分区是物理上的说法。例如我们在Kafka创建了一个主题<code>Test</code>并指定3个分区。那么在实际存储上这个主题会被分成3个分区。这样的好处是为了负载均衡，且Kafka支持根据key路由到特定分区。例如现在这个Test主题存储VIP消息和普通消息，就可以根据将VIP消息存到分区0上，普通消息存在分区1上。</p>\n<p><strong>Partition（分区）和 Replica（副本） 和 Leader（领导者副本） 和 Follower（追随者副本）</strong></p>\n<p>一个分区可以有一个或多个副本，多个副本中又分成leader和follower。leader负责数据的读写，follower负责从leader同步数据。kafka副本的概念是实现高可用的方式。</p>\n<p><strong>Consumer（消费者）和 Consumer Group（消费者组）</strong></p>\n<p>一个消费者组里有一个或多个消费者。一个分区只能被同一个消费者组的其中一个消费者消费，不能被同一个消费者组的多个消费者同时消费。假设一个主题有3个分区，一个消费者组有4个消费者，那么将有一个消费者无法消费。</p>\n<p><img src=\"/2020/10/09/kafka-base/1.png\" alt=\"kafka关系图解\"></p>\n<p><strong>Controller（控制者）和 Broker（服务器）</strong></p>\n<p>Kafka集群中多个broker，有一个会被选举为Controller leader，Controller负责管理整个集群中分区和副本的状态，比如partition的leader 副本故障，由controller 负责为该partition重新选举新的leader 副本；当检测到ISR列表发生变化，有controller通知集群中所有broker更新其MetadataCache信息；或者增加某个topic分区的时候也会由controller管理分区的重新分配工作。</p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h3 id=\"消息分区机制原理\"><a href=\"#消息分区机制原理\" class=\"headerlink\" title=\"消息分区机制原理\"></a>消息分区机制原理</h3><p>Kafka的消息组织方式实际上是三级结构：主题-分区-消息。主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份。</p>\n<p><img src=\"/2020/10/09/kafka-base/2.png\" alt></p>\n<p>如图所示，其实分区的作用就是提供<strong>负载均衡</strong>的能力，不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。写消息时，采用<strong>追加的方式</strong>写入保证同一个分区下的消息的顺序性。至于消息具体是写到哪个分区，kafka提供了多种分区策略包括：轮询，随机，自定义。</p>\n<p>总结一下，Kafka采用分区的方式的好处是提供了负载均衡的能力，达到了高性能的目的，且分区可以增加减少，可扩展能力强。</p>\n<h3 id=\"持久化数据\"><a href=\"#持久化数据\" class=\"headerlink\" title=\"持久化数据\"></a>持久化数据</h3><p>生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。总的来说，Kafka使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。<font color=\"red\">因为只能追加写入，故避免了缓慢的随机I/O操作，改为性能较好的顺序I/O写操作，这也是实现Kafka高吞吐量特性的一个重要手段</font>。</p>\n<p><img src=\"/2020/10/09/kafka-base/3.png\" alt></p>\n<p>每一个分区中的消息以Log的形式存在，但Log并不是日志存储和操作的最底层单元,kafka消息最底层的单元的是日志段，即LogSegemnt， Log和LogSegement的关系如上图所示。这里需要注意的是，kafka的日志段并不是一个物理概念，而是一个逻辑概念，一个日志段包括一个消息日志文件和若干索引文件组成，即一个.log和多个.xxxindex文件。</p>\n<p><img src=\"/2020/10/09/kafka-base/4.png\" alt></p>\n<h3 id=\"副本机制\"><a href=\"#副本机制\" class=\"headerlink\" title=\"副本机制\"></a>副本机制</h3><p>Kafka中一个分区上有多个副本。提供数据冗余实现高可用性和高持久性。在Kafka中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本（<font color=\"red\">追随者副本是不对外提供服务</font>）。</p>\n<p><strong>如何将所有Replica均匀分布到整个集群？</strong></p>\n<p>为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。假设一个集群由3台Broker，3个分区，6个副本，那么一个分区对应2个副本。如果一个分区的副本同时在一台Broker将达不到高可用。所以需要按照一定的算法将不同的副本分配到不同的Broker上，Kafka分配Replica的算法如下 ：</p>\n<ol>\n<li>将所有Broker（假设共n个Broker）和待分配的Partition排序。</li>\n<li>将第i个Partition分配到第（i mod n）个Broker上。</li>\n<li>将第i个Partition的第j个Replica分配到第（(i + j) mode n）个Broker上。</li>\n</ol>\n<h3 id=\"消息传递策略\"><a href=\"#消息传递策略\" class=\"headerlink\" title=\"消息传递策略\"></a>消息传递策略</h3><p>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。</p>\n<p>为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费。</p>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><ul>\n<li>Kafka的缓存不是在内存中保存尽可能多的数据并在需要时将这些数刷新到文件系统，而是做完全相反的事情，将所有的数据立即写入文件系统中的持久化的日志中，但不进行刷新数据的调用，实际这么做意味着数据被传输到os内核的页面缓存中去了，随后在根据配置刷新到硬盘。</li>\n</ul>"},{"title":"JVM参数详解和调优","description":"JVM参数详解和调优","date":"2020-05-07T07:25:44.000Z","_content":"## JVM常用参数\n### 推和栈大小设置\n\n```shell\n-Xms1024M: 初始堆大小\n-Xmx1024M: 最大堆大小\n-Xmn512M:新生代的大小\n-XX:newSize:新生代初始化内存的大小(注意：该值需要小于-Xms的值)\n-XX:MaxnewSize:新生代可被分配的内存的最大上限(注意：该值需要小于-Xmx的值)\n-Xmn:年轻代的大小(eden + 2 survivor,设置了这就不用设置-XX:NewSize，-XX:MaxNewSize)\n-XX:NewRatio=n: 设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n-XX:SurvivorRatio=n: 年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n-Xss256K: 栈大小设置\n-XX:MetaspaceSize=n 元空间初始大小\n-XX:MaxMetaspaceSize=n 元空间最大大小\n```\n<!--more-->\n典型设置\n\n```shell\njava -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0\n#-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n#-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6\n#-XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。(正常可以不设置)\n```\n\n### 回收器\n\nJVM垃圾回收器按照分类可以分成：串行收集器，并行收集器，并发收集器。\n\n- 串行收集器：一个GC线程进行回收，会暂停所有用户线程，不符合服务器环境。\n- 并行收集器：多个GC线程进行回收，会暂停所有用户线程，适用于大数据，科学计算处理场景。\n- 并发收集器(CMS)：用户线程和GC线程同事执行，不会暂停用户线程，适用于对响应时间要求高的场景。\n\n如何选择垃圾收集器，可以通过如下几点。\n\n1、单CPU小内存 : -XX:+UseSerialGC\n\n2、多CPU，需要大量运算：-XX:+UseParallelGC  -XX:+UseParallelOldGC\n\n3、多CPU，要求快速响应：-XX:+UseParNewGC  -XX:+UseConcMarkSweepGC\n\n在C/S架构中往往我们关注的是**响应时间**。并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。所以我们一般使用的是并发收集器，也就是CMS。配置参考如下\n\n```shell\n-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection\n#-XX:+UseConcMarkSweepGC： 设置年老代为并发收集\n#-XX:+UseParNewGC: 设置年轻代为并行收集。\n#-XX:+UseCMSCompactAtFullCollection 打开对年老代的压缩。可能会影响性能，但是可以消除碎片\n```\n\n### 日志和辅助设置\n\n日志相关参考另外一篇博客：[GC日志详解](https://xuzyblog.top/2019/02/18/gc-log/)\n\n另外一些辅助类的配置，笔者项目中配置的一些优化。\n\n这里顺便说下 : **-XX:+ 这种表示开启什么配置，-XX:- 表示关闭什么配置**\n\n```shell\n-XX:+DisableExplicitGC #加了这个配置后，再代码上使用System.gc()将不会生效，System.gc()会出发FullGC\n-XX:+UseCompressedOops #开启压缩指针，例如压缩指针对象头。开启后可以节省一定的内存空间\n-XX:+CMSParallelRemarkEnabled #降低标记停顿\n-XX:CMSInitiatingOccupancyFraction=70 #使用cms作为垃圾回收,使用70％后开始CMS收集\n```\n\n## JVM调优\n\n### 什么时候才需要调优？\n\n**如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化。**\n\n如果满足下列指标，则一般不需要GC优化（具体情况具体分析）\n\n- Minor GC执行时间不到100ms\n- Minor GC执行不频繁，约5秒一次\n- Full GC执行时间不到1s\n- Full GC执行频率不算频繁，不低于1分钟1次\n\n### 调优目标\n\n- GC的时间足够的小\n- GC的次数足够的少\n- 发生Full GC的周期足够的长\n\n调优准则\n\n- 根据机器情况和服务需求，具体问题具体分析\n- 多数的Java应用不需要在服务器上进行GC优化\n- 减少使用全局变量和大对象 (代码层面)\n- 调整新生代的大小\n- 设置老年代的大小（老年代：新生代=2：1）\n- 选择合适的GC收集器\n- 设置合适线程堆栈大小\n\n例如线上排查Full GC次数频繁。这就要知道什么时候对象会放到老年代。\n\n- YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。这种情况可以适当加大Survivor区的大小。\n- 经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中。这种情况属于对象存活太久，如果大对象在业务上不需要使用那么久最好能够用完即删。\n- 动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。这种情况也是可以适当更改Survivor大小。\n\n### 如何确定新生代和老年代的比例？\n\n- IO交互性系统，互联网上目前大部分的服务都属于该类型，例如分布式 RPC、MQ、HTTP 网关服务等，对内存要求并不大，大部分对象在 TP9999 的时间内都会死亡， Young 区越大越好。\n- 内存计算性系统，主要是分布式数据计算 Hadoop，分布式存储 HBase、Cassandra，自建的分布式缓存等，对内存要求高，对象存活时间长，Old 区越大越好。\n\n## 常见知识点\n\n### 空间分配担保\n\n空间担保指的是老年代进行空间分配担保。在发生Minor GC前，JVM会先检查**老年代最大可用的连续空间是否大于新生代所有对象的总空间**。\n\n- 如果大于，则此次**Minor GC是安全的**。\n- 如果小于，则虚拟机会查看**HandlePromotionFailure**设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于**历次晋升到老年代的对象的平均大小**，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。\n\n**为什么要进行空间担保？**\n\n是因为新生代采用**复制收集算法**，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。**老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象**，但一共有多少对象在内存回收后存活下来是不可预知的，**因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考**。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。\n\n![空间担保机制](jvm-optimization/1.png)\n\n### 什么情况对象直接进老年代\n\n- 在执行YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。\n- 长期存活的对象将进入老年代。经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中，通过-XX：MaxTenuringThreshold = 15设置。\n- 大对象直接进入老年代，通过-XX：PretenureSizeThreshold参数设置，如果大于这个设定值则直接存入老年代，\n- 动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。\n\n### 什么情况下会触发FGC\n\n- 当晋升到老年代的对象大于了老年代的剩余空间时，就会触发FGC（Major GC），**FGC处理的区域同时包括新生代和老年代**。\n- 老年代的内存使用率达到了一定阈值（可通过参数调整），直接触发FGC(-XX:CMSInitiatingOccupancyFraction=70 是指设定CMS在对内存占用率达到70%的时候开始GC）。\n- 空间分配担保：在YGC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明YGC是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC。\n- Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC。\n- System.gc() 或者Runtime.gc() 被显式调用时，触发FGC。（有些第三方插件会有用这个函数）\n\n### 三种内存回收机制优缺点\n\n对于 Java 的内存回收机制我们主要分为 3 种：\n\n- 标记-清除算法\n  - 不足：效率不高，容易产生内存碎片。\n- 复制算法\n  - 效率高，复制成本大。\n  - 不足：如果是 1：1 模型，占用内存。\n  - 分配担保策略\n- 标记-整理算法\n  - 因为老年代的对象生存率高，所以使用复制算法效率会很差，就提出了这个标记-整理算法。\n\n### CMS老年代垃圾回收器详解\n\nCMS是一款并发、使用*<font color=red>标记-清除</font>*算法的老年代垃圾回收器。针对老年代进行回收的GC。<font color=red>以获取最短回收停顿时间【也就是指Stop The World的停顿时间】</font>为目标，多数应用于互联网站或者B/S系统的服务器端上。\n\n**CMS四个过程**：\n\nCMS基于**标记-清除**算法实现。\n\n- 初始标记(<font color=red>Stop The World</font>)。标记一下GC Roots能直接关联到的对象。这一步主要做两件事：\n- - 从GcRoots直接可达的老年代对象\n  - 遍历新生代对象，标记可达的老年代对象\n- 并发标记。遍历初始标记阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。**在运行期间可能发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。**为了提高重新标记的效率，该阶段会把上述对象所在的Card(卡表)标识为Dirty(脏)，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代。\n- 并发预清理。*CMSPrecleaningEnabled*控制是否需要并发预清理，默认启用。**该阶段要尽最大的努力去处理那些在并发阶段被应用线程更新的老年代对象，这样在暂停的重新标记阶段就可以少处理一些，暂停时间也会相应的降低。**\n- 重新标记。为了修正并发标记期间因用户程序继续动作而导致标记产生变动的那一部分对象的标记记录 --- <font color=red>Stop The World</font>\n- 并发清除。\n\n**优缺点**\n\n- 并发收集、低停顿。\n- CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的算能力）而导致应用程序变慢，降低总吞吐量。\n- CMS收集器无法处理浮动垃圾（因为CMS是支持并发的原因，所以允许在过程中用户线程也在运行，会导致判断不准确。 例如可能在判断完成之后在清除之前这个对像已经变成了垃圾对象，所以有可能本该此垃圾被回收但是没有被回收，只能等待下一次GC再将该对象回收）。\n\n**几个优化的参数**\n\n- -XX:+UseCMSInitiatingOccupancyOnly 和 -XX：CMSInitiatingOccupancyFraction的值来用来设置CMS收集器老年代占用百分之多少后执行FullGC，降低内存回收频率，获取更好的性能。\n- -XX:+UseCMSCompactAtFullCollection默认开启，要进行Full GC的时候进行内存碎片整理。\n- -XX:CMSFullGCsBeforeCompaction 每隔多少次不压缩的Full GC后，执行一次带压缩的Full GC。\n- CMSScavengeBeforeRemark 如果开启这个参数，会在进入重新标记阶段之前强制触发一次minor gc。\n- CMSMaxAbortablePrecleanTime = 5 表示并发预清理阶段持续5秒还没等到minor gc就中断并发预清理阶段。\n\n**CMS并发模式失败（Concurrent mode failure）和晋升失败**\n\n- 并发模式失败，CMS的目标就是在回收老年代对象的时候不要停止全部应用线程，在并发周期执行期间，用户的线程依然在运行，如果这时候如果应用线程向老年代请求分配的空间超过预留的空间（担保失败），就回触发concurrent mode failure，然后CMS的并发周期就会被一次Full GC代替。\n- 晋升失败，新生代做minor gc的时候，需要CMS的担保机制确认老年代是否有足够的空间容纳要晋升的对象，担保机制发现不够，则报concurrent mode failure，如果担保机制判断是够的，但是实际上由于碎片问题导致无法分配，就会报晋升失败。\n- 永久代空间（或Java8的元空间）耗尽，默认情况下,CMS不会对永久代进行收集，一旦永久代空间耗尽，就回触发Full GC。\n\n针对并发模式失败的调优 ：\n\n- 想办法增大老年代的空间，增加整个堆的大小，或者减少年轻代的大小。\n- 以更高的频率执行后台的回收线程，即提高CMS并发周期发生的频率，例如调低*CMSInitiatingOccupancyFraction*的值。引用《Java性能权威指南》（**对特定的应用程序，该标志的更优值可以根据 GC 日志中 CMS 周期首次启动失败时的值得到。具体方法是，在垃圾回收日志中寻找并发模式失效，找到后再反向查找 CMS 周期最近的启动记录，然后根据日志来计算这时候的老年代空间占用值，然后设置一个比该值更小的值。**）\n- 增多回收线程的个数CMS默认的垃圾收集线程数是*（CPU个数 + 3）/4*。-XX:ParallelCMSThreads用来设置线程数量。\n\n### JVM动态年龄判断\n\n-XX:MaxTenuringThreshold=3，该参数主要是控制新生代需要经历多少次GC晋升到老年代中的最大阈值。但是不一定是这个阈值才晋升到老年代。因为有动态年龄判断(**Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄**)\n\n### 垃圾回收图解\n\n![垃圾回收过程](jvm-optimization/3.png)\n\n### JVM内存模型\n\n![jvm内存模型](jvm-optimization/4.png)\n\n### 垃圾收集器\n\n![]()![5](jvm-optimization/5.png)\n\n### JAVA内存对象布局\n\n![JAVA内存对象布局](jvm-optimization/6.png)\n\n```java\npackage xzy;\nimport org.openjdk.jol.info.ClassLayout;\npublic class OtherTest {\n    public static void main(String[] args){\n        Object obj = new Object();\n        System.out.println(ClassLayout.parseInstance(obj).toPrintable());\n    }\n}\n//==========================================无指针压缩=========================\n# -XX:-UseCompressedOops\njava.lang.Object object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)Class Pointer                           00 1c 95 1e (00000000 00011100 10010101 00011110) (513088512)\n     12     4        (object header)Class Pointer                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total\n//==========================================指针压缩=========================\njava.lang.Object object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)Class Pointer                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)\n     12     4        (loss due to the next object alignment)对其填充\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n    \n    \npublic class OtherTest {\n    public static void main(String[] args){\n        Object[] obj = new Object[10];\n        System.out.println(ClassLayout.parseInstance(obj).toPrintable());\n    }\n}\n//===============================无指针压缩数组===========================\n[Ljava.lang.Object; object internals:\n OFFSET  SIZE               TYPE DESCRIPTION                               VALUE\n      0     4                    (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4                    (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4                    (object header)Class Pointer                           60 c7 b1 1e (01100000 11000111 10110001 00011110) (514967392)\n     12     4                    (object header)Class Pointer                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n     16     4                    (object header)Class Pointer                           0a 00 00 00 (00001010 00000000 00000000 00000000) (10)\n     20     4                    (alignment/padding gap)对齐填充                  \n     24    80   java.lang.Object Object;.<elements>数组长度(8 * 10)                        N/A\nInstance size: 104 bytes\nSpace losses: 4 bytes internal + 0 bytes external = 4 bytes total\n//===========================指针压缩数组==============================\n [Ljava.lang.Object; object internals:\n OFFSET  SIZE               TYPE DESCRIPTION                               VALUE\n      0     4                    (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4                    (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4                    (object header)Class Pointer                           3c 23 00 f8 (00111100 00100011 00000000 11111000) (-134208708)\n     12     4                    (object header)对齐填充                           0a 00 00 00 (00001010 00000000 00000000 00000000) (10)\n     16    40   java.lang.Object Object;.<elements>数组长度(4 * 10)                        N/A\nInstance size: 56 bytes\nSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total\n```\n\n### 三色标记法\n\n实现并发标记的算法就是三色标记法，三色标记法最大的特点就是可以异步执行，从而可以以中断时间极少的代价或者完全没有中断来进行整个GC。\n\n- 白色：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象。\n- 黑色：本对象已经被GC访问过，且本对象的子引用对象也已经被访问过了。\n- 灰色：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态。\n\n**标记过程**\n\n1. 在GC并发标记刚开始时，所以对象均为白色集合。\n2. 将所有GCRoots直接引用的对象标记为灰色集合。\n3. 判断若灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将其所有的子引用对象放入灰色集合，当前对象放入黑色集合。","source":"_posts/jvm-optimization.md","raw":"---\ntitle: JVM参数详解和调优\ntags:\n  - java并发\ncategories:  java\ndescription : JVM参数详解和调优\ndate: 2020-05-07 15:25:44\n---\n## JVM常用参数\n### 推和栈大小设置\n\n```shell\n-Xms1024M: 初始堆大小\n-Xmx1024M: 最大堆大小\n-Xmn512M:新生代的大小\n-XX:newSize:新生代初始化内存的大小(注意：该值需要小于-Xms的值)\n-XX:MaxnewSize:新生代可被分配的内存的最大上限(注意：该值需要小于-Xmx的值)\n-Xmn:年轻代的大小(eden + 2 survivor,设置了这就不用设置-XX:NewSize，-XX:MaxNewSize)\n-XX:NewRatio=n: 设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n-XX:SurvivorRatio=n: 年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n-Xss256K: 栈大小设置\n-XX:MetaspaceSize=n 元空间初始大小\n-XX:MaxMetaspaceSize=n 元空间最大大小\n```\n<!--more-->\n典型设置\n\n```shell\njava -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0\n#-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n#-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6\n#-XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。(正常可以不设置)\n```\n\n### 回收器\n\nJVM垃圾回收器按照分类可以分成：串行收集器，并行收集器，并发收集器。\n\n- 串行收集器：一个GC线程进行回收，会暂停所有用户线程，不符合服务器环境。\n- 并行收集器：多个GC线程进行回收，会暂停所有用户线程，适用于大数据，科学计算处理场景。\n- 并发收集器(CMS)：用户线程和GC线程同事执行，不会暂停用户线程，适用于对响应时间要求高的场景。\n\n如何选择垃圾收集器，可以通过如下几点。\n\n1、单CPU小内存 : -XX:+UseSerialGC\n\n2、多CPU，需要大量运算：-XX:+UseParallelGC  -XX:+UseParallelOldGC\n\n3、多CPU，要求快速响应：-XX:+UseParNewGC  -XX:+UseConcMarkSweepGC\n\n在C/S架构中往往我们关注的是**响应时间**。并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。所以我们一般使用的是并发收集器，也就是CMS。配置参考如下\n\n```shell\n-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection\n#-XX:+UseConcMarkSweepGC： 设置年老代为并发收集\n#-XX:+UseParNewGC: 设置年轻代为并行收集。\n#-XX:+UseCMSCompactAtFullCollection 打开对年老代的压缩。可能会影响性能，但是可以消除碎片\n```\n\n### 日志和辅助设置\n\n日志相关参考另外一篇博客：[GC日志详解](https://xuzyblog.top/2019/02/18/gc-log/)\n\n另外一些辅助类的配置，笔者项目中配置的一些优化。\n\n这里顺便说下 : **-XX:+ 这种表示开启什么配置，-XX:- 表示关闭什么配置**\n\n```shell\n-XX:+DisableExplicitGC #加了这个配置后，再代码上使用System.gc()将不会生效，System.gc()会出发FullGC\n-XX:+UseCompressedOops #开启压缩指针，例如压缩指针对象头。开启后可以节省一定的内存空间\n-XX:+CMSParallelRemarkEnabled #降低标记停顿\n-XX:CMSInitiatingOccupancyFraction=70 #使用cms作为垃圾回收,使用70％后开始CMS收集\n```\n\n## JVM调优\n\n### 什么时候才需要调优？\n\n**如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化。**\n\n如果满足下列指标，则一般不需要GC优化（具体情况具体分析）\n\n- Minor GC执行时间不到100ms\n- Minor GC执行不频繁，约5秒一次\n- Full GC执行时间不到1s\n- Full GC执行频率不算频繁，不低于1分钟1次\n\n### 调优目标\n\n- GC的时间足够的小\n- GC的次数足够的少\n- 发生Full GC的周期足够的长\n\n调优准则\n\n- 根据机器情况和服务需求，具体问题具体分析\n- 多数的Java应用不需要在服务器上进行GC优化\n- 减少使用全局变量和大对象 (代码层面)\n- 调整新生代的大小\n- 设置老年代的大小（老年代：新生代=2：1）\n- 选择合适的GC收集器\n- 设置合适线程堆栈大小\n\n例如线上排查Full GC次数频繁。这就要知道什么时候对象会放到老年代。\n\n- YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。这种情况可以适当加大Survivor区的大小。\n- 经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中。这种情况属于对象存活太久，如果大对象在业务上不需要使用那么久最好能够用完即删。\n- 动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。这种情况也是可以适当更改Survivor大小。\n\n### 如何确定新生代和老年代的比例？\n\n- IO交互性系统，互联网上目前大部分的服务都属于该类型，例如分布式 RPC、MQ、HTTP 网关服务等，对内存要求并不大，大部分对象在 TP9999 的时间内都会死亡， Young 区越大越好。\n- 内存计算性系统，主要是分布式数据计算 Hadoop，分布式存储 HBase、Cassandra，自建的分布式缓存等，对内存要求高，对象存活时间长，Old 区越大越好。\n\n## 常见知识点\n\n### 空间分配担保\n\n空间担保指的是老年代进行空间分配担保。在发生Minor GC前，JVM会先检查**老年代最大可用的连续空间是否大于新生代所有对象的总空间**。\n\n- 如果大于，则此次**Minor GC是安全的**。\n- 如果小于，则虚拟机会查看**HandlePromotionFailure**设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于**历次晋升到老年代的对象的平均大小**，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。\n\n**为什么要进行空间担保？**\n\n是因为新生代采用**复制收集算法**，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。**老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象**，但一共有多少对象在内存回收后存活下来是不可预知的，**因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考**。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。\n\n![空间担保机制](jvm-optimization/1.png)\n\n### 什么情况对象直接进老年代\n\n- 在执行YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。\n- 长期存活的对象将进入老年代。经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中，通过-XX：MaxTenuringThreshold = 15设置。\n- 大对象直接进入老年代，通过-XX：PretenureSizeThreshold参数设置，如果大于这个设定值则直接存入老年代，\n- 动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。\n\n### 什么情况下会触发FGC\n\n- 当晋升到老年代的对象大于了老年代的剩余空间时，就会触发FGC（Major GC），**FGC处理的区域同时包括新生代和老年代**。\n- 老年代的内存使用率达到了一定阈值（可通过参数调整），直接触发FGC(-XX:CMSInitiatingOccupancyFraction=70 是指设定CMS在对内存占用率达到70%的时候开始GC）。\n- 空间分配担保：在YGC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明YGC是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC。\n- Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC。\n- System.gc() 或者Runtime.gc() 被显式调用时，触发FGC。（有些第三方插件会有用这个函数）\n\n### 三种内存回收机制优缺点\n\n对于 Java 的内存回收机制我们主要分为 3 种：\n\n- 标记-清除算法\n  - 不足：效率不高，容易产生内存碎片。\n- 复制算法\n  - 效率高，复制成本大。\n  - 不足：如果是 1：1 模型，占用内存。\n  - 分配担保策略\n- 标记-整理算法\n  - 因为老年代的对象生存率高，所以使用复制算法效率会很差，就提出了这个标记-整理算法。\n\n### CMS老年代垃圾回收器详解\n\nCMS是一款并发、使用*<font color=red>标记-清除</font>*算法的老年代垃圾回收器。针对老年代进行回收的GC。<font color=red>以获取最短回收停顿时间【也就是指Stop The World的停顿时间】</font>为目标，多数应用于互联网站或者B/S系统的服务器端上。\n\n**CMS四个过程**：\n\nCMS基于**标记-清除**算法实现。\n\n- 初始标记(<font color=red>Stop The World</font>)。标记一下GC Roots能直接关联到的对象。这一步主要做两件事：\n- - 从GcRoots直接可达的老年代对象\n  - 遍历新生代对象，标记可达的老年代对象\n- 并发标记。遍历初始标记阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。**在运行期间可能发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。**为了提高重新标记的效率，该阶段会把上述对象所在的Card(卡表)标识为Dirty(脏)，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代。\n- 并发预清理。*CMSPrecleaningEnabled*控制是否需要并发预清理，默认启用。**该阶段要尽最大的努力去处理那些在并发阶段被应用线程更新的老年代对象，这样在暂停的重新标记阶段就可以少处理一些，暂停时间也会相应的降低。**\n- 重新标记。为了修正并发标记期间因用户程序继续动作而导致标记产生变动的那一部分对象的标记记录 --- <font color=red>Stop The World</font>\n- 并发清除。\n\n**优缺点**\n\n- 并发收集、低停顿。\n- CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的算能力）而导致应用程序变慢，降低总吞吐量。\n- CMS收集器无法处理浮动垃圾（因为CMS是支持并发的原因，所以允许在过程中用户线程也在运行，会导致判断不准确。 例如可能在判断完成之后在清除之前这个对像已经变成了垃圾对象，所以有可能本该此垃圾被回收但是没有被回收，只能等待下一次GC再将该对象回收）。\n\n**几个优化的参数**\n\n- -XX:+UseCMSInitiatingOccupancyOnly 和 -XX：CMSInitiatingOccupancyFraction的值来用来设置CMS收集器老年代占用百分之多少后执行FullGC，降低内存回收频率，获取更好的性能。\n- -XX:+UseCMSCompactAtFullCollection默认开启，要进行Full GC的时候进行内存碎片整理。\n- -XX:CMSFullGCsBeforeCompaction 每隔多少次不压缩的Full GC后，执行一次带压缩的Full GC。\n- CMSScavengeBeforeRemark 如果开启这个参数，会在进入重新标记阶段之前强制触发一次minor gc。\n- CMSMaxAbortablePrecleanTime = 5 表示并发预清理阶段持续5秒还没等到minor gc就中断并发预清理阶段。\n\n**CMS并发模式失败（Concurrent mode failure）和晋升失败**\n\n- 并发模式失败，CMS的目标就是在回收老年代对象的时候不要停止全部应用线程，在并发周期执行期间，用户的线程依然在运行，如果这时候如果应用线程向老年代请求分配的空间超过预留的空间（担保失败），就回触发concurrent mode failure，然后CMS的并发周期就会被一次Full GC代替。\n- 晋升失败，新生代做minor gc的时候，需要CMS的担保机制确认老年代是否有足够的空间容纳要晋升的对象，担保机制发现不够，则报concurrent mode failure，如果担保机制判断是够的，但是实际上由于碎片问题导致无法分配，就会报晋升失败。\n- 永久代空间（或Java8的元空间）耗尽，默认情况下,CMS不会对永久代进行收集，一旦永久代空间耗尽，就回触发Full GC。\n\n针对并发模式失败的调优 ：\n\n- 想办法增大老年代的空间，增加整个堆的大小，或者减少年轻代的大小。\n- 以更高的频率执行后台的回收线程，即提高CMS并发周期发生的频率，例如调低*CMSInitiatingOccupancyFraction*的值。引用《Java性能权威指南》（**对特定的应用程序，该标志的更优值可以根据 GC 日志中 CMS 周期首次启动失败时的值得到。具体方法是，在垃圾回收日志中寻找并发模式失效，找到后再反向查找 CMS 周期最近的启动记录，然后根据日志来计算这时候的老年代空间占用值，然后设置一个比该值更小的值。**）\n- 增多回收线程的个数CMS默认的垃圾收集线程数是*（CPU个数 + 3）/4*。-XX:ParallelCMSThreads用来设置线程数量。\n\n### JVM动态年龄判断\n\n-XX:MaxTenuringThreshold=3，该参数主要是控制新生代需要经历多少次GC晋升到老年代中的最大阈值。但是不一定是这个阈值才晋升到老年代。因为有动态年龄判断(**Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄**)\n\n### 垃圾回收图解\n\n![垃圾回收过程](jvm-optimization/3.png)\n\n### JVM内存模型\n\n![jvm内存模型](jvm-optimization/4.png)\n\n### 垃圾收集器\n\n![]()![5](jvm-optimization/5.png)\n\n### JAVA内存对象布局\n\n![JAVA内存对象布局](jvm-optimization/6.png)\n\n```java\npackage xzy;\nimport org.openjdk.jol.info.ClassLayout;\npublic class OtherTest {\n    public static void main(String[] args){\n        Object obj = new Object();\n        System.out.println(ClassLayout.parseInstance(obj).toPrintable());\n    }\n}\n//==========================================无指针压缩=========================\n# -XX:-UseCompressedOops\njava.lang.Object object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)Class Pointer                           00 1c 95 1e (00000000 00011100 10010101 00011110) (513088512)\n     12     4        (object header)Class Pointer                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total\n//==========================================指针压缩=========================\njava.lang.Object object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)Class Pointer                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)\n     12     4        (loss due to the next object alignment)对其填充\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n    \n    \npublic class OtherTest {\n    public static void main(String[] args){\n        Object[] obj = new Object[10];\n        System.out.println(ClassLayout.parseInstance(obj).toPrintable());\n    }\n}\n//===============================无指针压缩数组===========================\n[Ljava.lang.Object; object internals:\n OFFSET  SIZE               TYPE DESCRIPTION                               VALUE\n      0     4                    (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4                    (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4                    (object header)Class Pointer                           60 c7 b1 1e (01100000 11000111 10110001 00011110) (514967392)\n     12     4                    (object header)Class Pointer                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n     16     4                    (object header)Class Pointer                           0a 00 00 00 (00001010 00000000 00000000 00000000) (10)\n     20     4                    (alignment/padding gap)对齐填充                  \n     24    80   java.lang.Object Object;.<elements>数组长度(8 * 10)                        N/A\nInstance size: 104 bytes\nSpace losses: 4 bytes internal + 0 bytes external = 4 bytes total\n//===========================指针压缩数组==============================\n [Ljava.lang.Object; object internals:\n OFFSET  SIZE               TYPE DESCRIPTION                               VALUE\n      0     4                    (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4                    (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4                    (object header)Class Pointer                           3c 23 00 f8 (00111100 00100011 00000000 11111000) (-134208708)\n     12     4                    (object header)对齐填充                           0a 00 00 00 (00001010 00000000 00000000 00000000) (10)\n     16    40   java.lang.Object Object;.<elements>数组长度(4 * 10)                        N/A\nInstance size: 56 bytes\nSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total\n```\n\n### 三色标记法\n\n实现并发标记的算法就是三色标记法，三色标记法最大的特点就是可以异步执行，从而可以以中断时间极少的代价或者完全没有中断来进行整个GC。\n\n- 白色：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象。\n- 黑色：本对象已经被GC访问过，且本对象的子引用对象也已经被访问过了。\n- 灰色：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态。\n\n**标记过程**\n\n1. 在GC并发标记刚开始时，所以对象均为白色集合。\n2. 将所有GCRoots直接引用的对象标记为灰色集合。\n3. 判断若灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将其所有的子引用对象放入灰色集合，当前对象放入黑色集合。","slug":"jvm-optimization","published":1,"updated":"2021-04-08T00:47:06.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhuy000vqwv29m0m7m80","content":"<h2 id=\"JVM常用参数\"><a href=\"#JVM常用参数\" class=\"headerlink\" title=\"JVM常用参数\"></a>JVM常用参数</h2><h3 id=\"推和栈大小设置\"><a href=\"#推和栈大小设置\" class=\"headerlink\" title=\"推和栈大小设置\"></a>推和栈大小设置</h3><pre class=\" language-shell\"><code class=\"language-shell\">-Xms1024M: 初始堆大小\n-Xmx1024M: 最大堆大小\n-Xmn512M:新生代的大小\n-XX:newSize:新生代初始化内存的大小(注意：该值需要小于-Xms的值)\n-XX:MaxnewSize:新生代可被分配的内存的最大上限(注意：该值需要小于-Xmx的值)\n-Xmn:年轻代的大小(eden + 2 survivor,设置了这就不用设置-XX:NewSize，-XX:MaxNewSize)\n-XX:NewRatio=n: 设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n-XX:SurvivorRatio=n: 年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n-Xss256K: 栈大小设置\n-XX:MetaspaceSize=n 元空间初始大小\n-XX:MaxMetaspaceSize=n 元空间最大大小</code></pre>\n<a id=\"more\"></a>\n<p>典型设置</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0\n#-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n#-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6\n#-XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。(正常可以不设置)</code></pre>\n<h3 id=\"回收器\"><a href=\"#回收器\" class=\"headerlink\" title=\"回收器\"></a>回收器</h3><p>JVM垃圾回收器按照分类可以分成：串行收集器，并行收集器，并发收集器。</p>\n<ul>\n<li>串行收集器：一个GC线程进行回收，会暂停所有用户线程，不符合服务器环境。</li>\n<li>并行收集器：多个GC线程进行回收，会暂停所有用户线程，适用于大数据，科学计算处理场景。</li>\n<li>并发收集器(CMS)：用户线程和GC线程同事执行，不会暂停用户线程，适用于对响应时间要求高的场景。</li>\n</ul>\n<p>如何选择垃圾收集器，可以通过如下几点。</p>\n<p>1、单CPU小内存 : -XX:+UseSerialGC</p>\n<p>2、多CPU，需要大量运算：-XX:+UseParallelGC  -XX:+UseParallelOldGC</p>\n<p>3、多CPU，要求快速响应：-XX:+UseParNewGC  -XX:+UseConcMarkSweepGC</p>\n<p>在C/S架构中往往我们关注的是<strong>响应时间</strong>。并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。所以我们一般使用的是并发收集器，也就是CMS。配置参考如下</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection\n#-XX:+UseConcMarkSweepGC： 设置年老代为并发收集\n#-XX:+UseParNewGC: 设置年轻代为并行收集。\n#-XX:+UseCMSCompactAtFullCollection 打开对年老代的压缩。可能会影响性能，但是可以消除碎片</code></pre>\n<h3 id=\"日志和辅助设置\"><a href=\"#日志和辅助设置\" class=\"headerlink\" title=\"日志和辅助设置\"></a>日志和辅助设置</h3><p>日志相关参考另外一篇博客：<a href=\"https://xuzyblog.top/2019/02/18/gc-log/\" target=\"_blank\" rel=\"noopener\">GC日志详解</a></p>\n<p>另外一些辅助类的配置，笔者项目中配置的一些优化。</p>\n<p>这里顺便说下 : <strong>-XX:+ 这种表示开启什么配置，-XX:- 表示关闭什么配置</strong></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">-XX:+DisableExplicitGC #加了这个配置后，再代码上使用System.gc()将不会生效，System.gc()会出发FullGC\n-XX:+UseCompressedOops #开启压缩指针，例如压缩指针对象头。开启后可以节省一定的内存空间\n-XX:+CMSParallelRemarkEnabled #降低标记停顿\n-XX:CMSInitiatingOccupancyFraction=70 #使用cms作为垃圾回收,使用70％后开始CMS收集</code></pre>\n<h2 id=\"JVM调优\"><a href=\"#JVM调优\" class=\"headerlink\" title=\"JVM调优\"></a>JVM调优</h2><h3 id=\"什么时候才需要调优？\"><a href=\"#什么时候才需要调优？\" class=\"headerlink\" title=\"什么时候才需要调优？\"></a>什么时候才需要调优？</h3><p><strong>如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化。</strong></p>\n<p>如果满足下列指标，则一般不需要GC优化（具体情况具体分析）</p>\n<ul>\n<li>Minor GC执行时间不到100ms</li>\n<li>Minor GC执行不频繁，约5秒一次</li>\n<li>Full GC执行时间不到1s</li>\n<li>Full GC执行频率不算频繁，不低于1分钟1次</li>\n</ul>\n<h3 id=\"调优目标\"><a href=\"#调优目标\" class=\"headerlink\" title=\"调优目标\"></a>调优目标</h3><ul>\n<li>GC的时间足够的小</li>\n<li>GC的次数足够的少</li>\n<li>发生Full GC的周期足够的长</li>\n</ul>\n<p>调优准则</p>\n<ul>\n<li>根据机器情况和服务需求，具体问题具体分析</li>\n<li>多数的Java应用不需要在服务器上进行GC优化</li>\n<li>减少使用全局变量和大对象 (代码层面)</li>\n<li>调整新生代的大小</li>\n<li>设置老年代的大小（老年代：新生代=2：1）</li>\n<li>选择合适的GC收集器</li>\n<li>设置合适线程堆栈大小</li>\n</ul>\n<p>例如线上排查Full GC次数频繁。这就要知道什么时候对象会放到老年代。</p>\n<ul>\n<li>YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。这种情况可以适当加大Survivor区的大小。</li>\n<li>经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中。这种情况属于对象存活太久，如果大对象在业务上不需要使用那么久最好能够用完即删。</li>\n<li>动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。这种情况也是可以适当更改Survivor大小。</li>\n</ul>\n<h3 id=\"如何确定新生代和老年代的比例？\"><a href=\"#如何确定新生代和老年代的比例？\" class=\"headerlink\" title=\"如何确定新生代和老年代的比例？\"></a>如何确定新生代和老年代的比例？</h3><ul>\n<li>IO交互性系统，互联网上目前大部分的服务都属于该类型，例如分布式 RPC、MQ、HTTP 网关服务等，对内存要求并不大，大部分对象在 TP9999 的时间内都会死亡， Young 区越大越好。</li>\n<li>内存计算性系统，主要是分布式数据计算 Hadoop，分布式存储 HBase、Cassandra，自建的分布式缓存等，对内存要求高，对象存活时间长，Old 区越大越好。</li>\n</ul>\n<h2 id=\"常见知识点\"><a href=\"#常见知识点\" class=\"headerlink\" title=\"常见知识点\"></a>常见知识点</h2><h3 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h3><p>空间担保指的是老年代进行空间分配担保。在发生Minor GC前，JVM会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p>\n<ul>\n<li>如果大于，则此次<strong>Minor GC是安全的</strong>。</li>\n<li>如果小于，则虚拟机会查看<strong>HandlePromotionFailure</strong>设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于<strong>历次晋升到老年代的对象的平均大小</strong>，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</li>\n</ul>\n<p><strong>为什么要进行空间担保？</strong></p>\n<p>是因为新生代采用<strong>复制收集算法</strong>，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。<strong>老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象</strong>，但一共有多少对象在内存回收后存活下来是不可预知的，<strong>因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考</strong>。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</p>\n<p><img src=\"/2020/05/07/jvm-optimization/1.png\" alt=\"空间担保机制\"></p>\n<h3 id=\"什么情况对象直接进老年代\"><a href=\"#什么情况对象直接进老年代\" class=\"headerlink\" title=\"什么情况对象直接进老年代\"></a>什么情况对象直接进老年代</h3><ul>\n<li>在执行YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。</li>\n<li>长期存活的对象将进入老年代。经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中，通过-XX：MaxTenuringThreshold = 15设置。</li>\n<li>大对象直接进入老年代，通过-XX：PretenureSizeThreshold参数设置，如果大于这个设定值则直接存入老年代，</li>\n<li>动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。</li>\n</ul>\n<h3 id=\"什么情况下会触发FGC\"><a href=\"#什么情况下会触发FGC\" class=\"headerlink\" title=\"什么情况下会触发FGC\"></a>什么情况下会触发FGC</h3><ul>\n<li>当晋升到老年代的对象大于了老年代的剩余空间时，就会触发FGC（Major GC），<strong>FGC处理的区域同时包括新生代和老年代</strong>。</li>\n<li>老年代的内存使用率达到了一定阈值（可通过参数调整），直接触发FGC(-XX:CMSInitiatingOccupancyFraction=70 是指设定CMS在对内存占用率达到70%的时候开始GC）。</li>\n<li>空间分配担保：在YGC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明YGC是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC。</li>\n<li>Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC。</li>\n<li>System.gc() 或者Runtime.gc() 被显式调用时，触发FGC。（有些第三方插件会有用这个函数）</li>\n</ul>\n<h3 id=\"三种内存回收机制优缺点\"><a href=\"#三种内存回收机制优缺点\" class=\"headerlink\" title=\"三种内存回收机制优缺点\"></a>三种内存回收机制优缺点</h3><p>对于 Java 的内存回收机制我们主要分为 3 种：</p>\n<ul>\n<li>标记-清除算法<ul>\n<li>不足：效率不高，容易产生内存碎片。</li>\n</ul>\n</li>\n<li>复制算法<ul>\n<li>效率高，复制成本大。</li>\n<li>不足：如果是 1：1 模型，占用内存。</li>\n<li>分配担保策略</li>\n</ul>\n</li>\n<li>标记-整理算法<ul>\n<li>因为老年代的对象生存率高，所以使用复制算法效率会很差，就提出了这个标记-整理算法。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CMS老年代垃圾回收器详解\"><a href=\"#CMS老年代垃圾回收器详解\" class=\"headerlink\" title=\"CMS老年代垃圾回收器详解\"></a>CMS老年代垃圾回收器详解</h3><p>CMS是一款并发、使用*<font color=\"red\">标记-清除</font>*算法的老年代垃圾回收器。针对老年代进行回收的GC。<font color=\"red\">以获取最短回收停顿时间【也就是指Stop The World的停顿时间】</font>为目标，多数应用于互联网站或者B/S系统的服务器端上。</p>\n<p><strong>CMS四个过程</strong>：</p>\n<p>CMS基于<strong>标记-清除</strong>算法实现。</p>\n<ul>\n<li>初始标记(<font color=\"red\">Stop The World</font>)。标记一下GC Roots能直接关联到的对象。这一步主要做两件事：</li>\n<li><ul>\n<li>从GcRoots直接可达的老年代对象</li>\n<li>遍历新生代对象，标记可达的老年代对象</li>\n</ul>\n</li>\n<li>并发标记。遍历初始标记阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。<strong>在运行期间可能发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。</strong>为了提高重新标记的效率，该阶段会把上述对象所在的Card(卡表)标识为Dirty(脏)，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代。</li>\n<li>并发预清理。<em>CMSPrecleaningEnabled</em>控制是否需要并发预清理，默认启用。<strong>该阶段要尽最大的努力去处理那些在并发阶段被应用线程更新的老年代对象，这样在暂停的重新标记阶段就可以少处理一些，暂停时间也会相应的降低。</strong></li>\n<li>重新标记。为了修正并发标记期间因用户程序继续动作而导致标记产生变动的那一部分对象的标记记录 — <font color=\"red\">Stop The World</font></li>\n<li>并发清除。</li>\n</ul>\n<p><strong>优缺点</strong></p>\n<ul>\n<li>并发收集、低停顿。</li>\n<li>CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的算能力）而导致应用程序变慢，降低总吞吐量。</li>\n<li>CMS收集器无法处理浮动垃圾（因为CMS是支持并发的原因，所以允许在过程中用户线程也在运行，会导致判断不准确。 例如可能在判断完成之后在清除之前这个对像已经变成了垃圾对象，所以有可能本该此垃圾被回收但是没有被回收，只能等待下一次GC再将该对象回收）。</li>\n</ul>\n<p><strong>几个优化的参数</strong></p>\n<ul>\n<li>-XX:+UseCMSInitiatingOccupancyOnly 和 -XX：CMSInitiatingOccupancyFraction的值来用来设置CMS收集器老年代占用百分之多少后执行FullGC，降低内存回收频率，获取更好的性能。</li>\n<li>-XX:+UseCMSCompactAtFullCollection默认开启，要进行Full GC的时候进行内存碎片整理。</li>\n<li>-XX:CMSFullGCsBeforeCompaction 每隔多少次不压缩的Full GC后，执行一次带压缩的Full GC。</li>\n<li>CMSScavengeBeforeRemark 如果开启这个参数，会在进入重新标记阶段之前强制触发一次minor gc。</li>\n<li>CMSMaxAbortablePrecleanTime = 5 表示并发预清理阶段持续5秒还没等到minor gc就中断并发预清理阶段。</li>\n</ul>\n<p><strong>CMS并发模式失败（Concurrent mode failure）和晋升失败</strong></p>\n<ul>\n<li>并发模式失败，CMS的目标就是在回收老年代对象的时候不要停止全部应用线程，在并发周期执行期间，用户的线程依然在运行，如果这时候如果应用线程向老年代请求分配的空间超过预留的空间（担保失败），就回触发concurrent mode failure，然后CMS的并发周期就会被一次Full GC代替。</li>\n<li>晋升失败，新生代做minor gc的时候，需要CMS的担保机制确认老年代是否有足够的空间容纳要晋升的对象，担保机制发现不够，则报concurrent mode failure，如果担保机制判断是够的，但是实际上由于碎片问题导致无法分配，就会报晋升失败。</li>\n<li>永久代空间（或Java8的元空间）耗尽，默认情况下,CMS不会对永久代进行收集，一旦永久代空间耗尽，就回触发Full GC。</li>\n</ul>\n<p>针对并发模式失败的调优 ：</p>\n<ul>\n<li>想办法增大老年代的空间，增加整个堆的大小，或者减少年轻代的大小。</li>\n<li>以更高的频率执行后台的回收线程，即提高CMS并发周期发生的频率，例如调低<em>CMSInitiatingOccupancyFraction</em>的值。引用《Java性能权威指南》（<strong>对特定的应用程序，该标志的更优值可以根据 GC 日志中 CMS 周期首次启动失败时的值得到。具体方法是，在垃圾回收日志中寻找并发模式失效，找到后再反向查找 CMS 周期最近的启动记录，然后根据日志来计算这时候的老年代空间占用值，然后设置一个比该值更小的值。</strong>）</li>\n<li>增多回收线程的个数CMS默认的垃圾收集线程数是<em>（CPU个数 + 3）/4</em>。-XX:ParallelCMSThreads用来设置线程数量。</li>\n</ul>\n<h3 id=\"JVM动态年龄判断\"><a href=\"#JVM动态年龄判断\" class=\"headerlink\" title=\"JVM动态年龄判断\"></a>JVM动态年龄判断</h3><p>-XX:MaxTenuringThreshold=3，该参数主要是控制新生代需要经历多少次GC晋升到老年代中的最大阈值。但是不一定是这个阈值才晋升到老年代。因为有动态年龄判断(<strong>Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</strong>)</p>\n<h3 id=\"垃圾回收图解\"><a href=\"#垃圾回收图解\" class=\"headerlink\" title=\"垃圾回收图解\"></a>垃圾回收图解</h3><p><img src=\"/2020/05/07/jvm-optimization/3.png\" alt=\"垃圾回收过程\"></p>\n<h3 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h3><p><img src=\"/2020/05/07/jvm-optimization/4.png\" alt=\"jvm内存模型\"></p>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src alt>)<img src=\"/2020/05/07/jvm-optimization/5.png\" alt=\"5\"></p>\n<h3 id=\"JAVA内存对象布局\"><a href=\"#JAVA内存对象布局\" class=\"headerlink\" title=\"JAVA内存对象布局\"></a>JAVA内存对象布局</h3><p><img src=\"/2020/05/07/jvm-optimization/6.png\" alt=\"JAVA内存对象布局\"></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> xzy<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>openjdk<span class=\"token punctuation\">.</span>jol<span class=\"token punctuation\">.</span>info<span class=\"token punctuation\">.</span>ClassLayout<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        Object obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>ClassLayout<span class=\"token punctuation\">.</span><span class=\"token function\">parseInstance</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toPrintable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//==========================================无指针压缩=========================</span>\n# <span class=\"token operator\">-</span>XX<span class=\"token operator\">:</span><span class=\"token operator\">-</span>UseCompressedOops\njava<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Object object internals<span class=\"token operator\">:</span>\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      <span class=\"token number\">0</span>     <span class=\"token function\">4</span>        <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>对象头                           <span class=\"token number\">01</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000001</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token number\">4</span>     <span class=\"token function\">4</span>        <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>对象头                           <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n      <span class=\"token number\">8</span>     <span class=\"token function\">4</span>        <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>Class <span class=\"token class-name\">Pointer</span>                           <span class=\"token number\">00</span> 1c <span class=\"token number\">95</span> <span class=\"token function\">1e</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000000</span> <span class=\"token number\">00011100</span> <span class=\"token number\">10010101</span> <span class=\"token number\">00011110</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">513088512</span><span class=\"token punctuation\">)</span>\n     <span class=\"token number\">12</span>     <span class=\"token function\">4</span>        <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>Class <span class=\"token class-name\">Pointer</span>                           <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nInstance size<span class=\"token operator\">:</span> <span class=\"token number\">16</span> bytes\nSpace losses<span class=\"token operator\">:</span> <span class=\"token number\">0</span> bytes internal <span class=\"token operator\">+</span> <span class=\"token number\">0</span> bytes external <span class=\"token operator\">=</span> <span class=\"token number\">0</span> bytes total\n<span class=\"token comment\" spellcheck=\"true\">//==========================================指针压缩=========================</span>\njava<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Object object internals<span class=\"token operator\">:</span>\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      <span class=\"token number\">0</span>     <span class=\"token function\">4</span>        <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>对象头                           <span class=\"token number\">01</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000001</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token number\">4</span>     <span class=\"token function\">4</span>        <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>对象头                           <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n      <span class=\"token number\">8</span>     <span class=\"token function\">4</span>        <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>Class <span class=\"token class-name\">Pointer</span>                           e5 <span class=\"token number\">01</span> <span class=\"token number\">00</span> <span class=\"token function\">f8</span> <span class=\"token punctuation\">(</span><span class=\"token number\">11100101</span> <span class=\"token number\">00000001</span> <span class=\"token number\">00000000</span> <span class=\"token number\">11111000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">134217243</span><span class=\"token punctuation\">)</span>\n     <span class=\"token number\">12</span>     <span class=\"token function\">4</span>        <span class=\"token punctuation\">(</span>loss due to the next object alignment<span class=\"token punctuation\">)</span>对其填充\nInstance size<span class=\"token operator\">:</span> <span class=\"token number\">16</span> bytes\nSpace losses<span class=\"token operator\">:</span> <span class=\"token number\">0</span> bytes internal <span class=\"token operator\">+</span> <span class=\"token number\">4</span> bytes external <span class=\"token operator\">=</span> <span class=\"token number\">4</span> bytes total\n\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> obj <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">[</span><span class=\"token number\">10</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>ClassLayout<span class=\"token punctuation\">.</span><span class=\"token function\">parseInstance</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toPrintable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//===============================无指针压缩数组===========================</span>\n<span class=\"token punctuation\">[</span>Ljava<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Object<span class=\"token punctuation\">;</span> object internals<span class=\"token operator\">:</span>\n OFFSET  SIZE               TYPE DESCRIPTION                               VALUE\n      <span class=\"token number\">0</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>对象头                           <span class=\"token number\">01</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000001</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token number\">4</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>对象头                           <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n      <span class=\"token number\">8</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>Class <span class=\"token class-name\">Pointer</span>                           <span class=\"token number\">60</span> c7 b1 <span class=\"token function\">1e</span> <span class=\"token punctuation\">(</span><span class=\"token number\">01100000</span> <span class=\"token number\">11000111</span> <span class=\"token number\">10110001</span> <span class=\"token number\">00011110</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">514967392</span><span class=\"token punctuation\">)</span>\n     <span class=\"token number\">12</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>Class <span class=\"token class-name\">Pointer</span>                           <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n     <span class=\"token number\">16</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>Class <span class=\"token class-name\">Pointer</span>                           0a <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00001010</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n     <span class=\"token number\">20</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>alignment<span class=\"token operator\">/</span>padding gap<span class=\"token punctuation\">)</span>对齐填充                  \n     <span class=\"token number\">24</span>    <span class=\"token number\">80</span>   java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Object Object<span class=\"token punctuation\">;</span><span class=\"token punctuation\">.</span>&lt;elements<span class=\"token operator\">></span>数组长度<span class=\"token punctuation\">(</span><span class=\"token number\">8</span> <span class=\"token operator\">*</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>                        N<span class=\"token operator\">/</span>A\nInstance size<span class=\"token operator\">:</span> <span class=\"token number\">104</span> bytes\nSpace losses<span class=\"token operator\">:</span> <span class=\"token number\">4</span> bytes internal <span class=\"token operator\">+</span> <span class=\"token number\">0</span> bytes external <span class=\"token operator\">=</span> <span class=\"token number\">4</span> bytes total\n<span class=\"token comment\" spellcheck=\"true\">//===========================指针压缩数组==============================</span>\n <span class=\"token punctuation\">[</span>Ljava<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Object<span class=\"token punctuation\">;</span> object internals<span class=\"token operator\">:</span>\n OFFSET  SIZE               TYPE DESCRIPTION                               VALUE\n      <span class=\"token number\">0</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>对象头                           <span class=\"token number\">01</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000001</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token number\">4</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>对象头                           <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n      <span class=\"token number\">8</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>Class <span class=\"token class-name\">Pointer</span>                           3c <span class=\"token number\">23</span> <span class=\"token number\">00</span> <span class=\"token function\">f8</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00111100</span> <span class=\"token number\">00100011</span> <span class=\"token number\">00000000</span> <span class=\"token number\">11111000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">-</span><span class=\"token number\">134208708</span><span class=\"token punctuation\">)</span>\n     <span class=\"token number\">12</span>     <span class=\"token function\">4</span>                    <span class=\"token punctuation\">(</span>object header<span class=\"token punctuation\">)</span>对齐填充                           0a <span class=\"token number\">00</span> <span class=\"token number\">00</span> <span class=\"token function\">00</span> <span class=\"token punctuation\">(</span><span class=\"token number\">00001010</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span> <span class=\"token number\">00000000</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n     <span class=\"token number\">16</span>    <span class=\"token number\">40</span>   java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Object Object<span class=\"token punctuation\">;</span><span class=\"token punctuation\">.</span>&lt;elements<span class=\"token operator\">></span>数组长度<span class=\"token punctuation\">(</span><span class=\"token number\">4</span> <span class=\"token operator\">*</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span>                        N<span class=\"token operator\">/</span>A\nInstance size<span class=\"token operator\">:</span> <span class=\"token number\">56</span> bytes\nSpace losses<span class=\"token operator\">:</span> <span class=\"token number\">0</span> bytes internal <span class=\"token operator\">+</span> <span class=\"token number\">0</span> bytes external <span class=\"token operator\">=</span> <span class=\"token number\">0</span> bytes total</code></pre>\n<h3 id=\"三色标记法\"><a href=\"#三色标记法\" class=\"headerlink\" title=\"三色标记法\"></a>三色标记法</h3><p>实现并发标记的算法就是三色标记法，三色标记法最大的特点就是可以异步执行，从而可以以中断时间极少的代价或者完全没有中断来进行整个GC。</p>\n<ul>\n<li>白色：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象。</li>\n<li>黑色：本对象已经被GC访问过，且本对象的子引用对象也已经被访问过了。</li>\n<li>灰色：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态。</li>\n</ul>\n<p><strong>标记过程</strong></p>\n<ol>\n<li>在GC并发标记刚开始时，所以对象均为白色集合。</li>\n<li>将所有GCRoots直接引用的对象标记为灰色集合。</li>\n<li>判断若灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将其所有的子引用对象放入灰色集合，当前对象放入黑色集合。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"JVM常用参数\"><a href=\"#JVM常用参数\" class=\"headerlink\" title=\"JVM常用参数\"></a>JVM常用参数</h2><h3 id=\"推和栈大小设置\"><a href=\"#推和栈大小设置\" class=\"headerlink\" title=\"推和栈大小设置\"></a>推和栈大小设置</h3><pre><code class=\"shell\">-Xms1024M: 初始堆大小\n-Xmx1024M: 最大堆大小\n-Xmn512M:新生代的大小\n-XX:newSize:新生代初始化内存的大小(注意：该值需要小于-Xms的值)\n-XX:MaxnewSize:新生代可被分配的内存的最大上限(注意：该值需要小于-Xmx的值)\n-Xmn:年轻代的大小(eden + 2 survivor,设置了这就不用设置-XX:NewSize，-XX:MaxNewSize)\n-XX:NewRatio=n: 设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4\n-XX:SurvivorRatio=n: 年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5\n-Xss256K: 栈大小设置\n-XX:MetaspaceSize=n 元空间初始大小\n-XX:MaxMetaspaceSize=n 元空间最大大小</code></pre>","more":"<p>典型设置</p>\n<pre><code class=\"shell\">java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxTenuringThreshold=0\n#-XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5\n#-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6\n#-XX:MaxTenuringThreshold=0： 设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。(正常可以不设置)</code></pre>\n<h3 id=\"回收器\"><a href=\"#回收器\" class=\"headerlink\" title=\"回收器\"></a>回收器</h3><p>JVM垃圾回收器按照分类可以分成：串行收集器，并行收集器，并发收集器。</p>\n<ul>\n<li>串行收集器：一个GC线程进行回收，会暂停所有用户线程，不符合服务器环境。</li>\n<li>并行收集器：多个GC线程进行回收，会暂停所有用户线程，适用于大数据，科学计算处理场景。</li>\n<li>并发收集器(CMS)：用户线程和GC线程同事执行，不会暂停用户线程，适用于对响应时间要求高的场景。</li>\n</ul>\n<p>如何选择垃圾收集器，可以通过如下几点。</p>\n<p>1、单CPU小内存 : -XX:+UseSerialGC</p>\n<p>2、多CPU，需要大量运算：-XX:+UseParallelGC  -XX:+UseParallelOldGC</p>\n<p>3、多CPU，要求快速响应：-XX:+UseParNewGC  -XX:+UseConcMarkSweepGC</p>\n<p>在C/S架构中往往我们关注的是<strong>响应时间</strong>。并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。所以我们一般使用的是并发收集器，也就是CMS。配置参考如下</p>\n<pre><code class=\"shell\">-Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+UseCMSCompactAtFullCollection\n#-XX:+UseConcMarkSweepGC： 设置年老代为并发收集\n#-XX:+UseParNewGC: 设置年轻代为并行收集。\n#-XX:+UseCMSCompactAtFullCollection 打开对年老代的压缩。可能会影响性能，但是可以消除碎片</code></pre>\n<h3 id=\"日志和辅助设置\"><a href=\"#日志和辅助设置\" class=\"headerlink\" title=\"日志和辅助设置\"></a>日志和辅助设置</h3><p>日志相关参考另外一篇博客：<a href=\"https://xuzyblog.top/2019/02/18/gc-log/\" target=\"_blank\" rel=\"noopener\">GC日志详解</a></p>\n<p>另外一些辅助类的配置，笔者项目中配置的一些优化。</p>\n<p>这里顺便说下 : <strong>-XX:+ 这种表示开启什么配置，-XX:- 表示关闭什么配置</strong></p>\n<pre><code class=\"shell\">-XX:+DisableExplicitGC #加了这个配置后，再代码上使用System.gc()将不会生效，System.gc()会出发FullGC\n-XX:+UseCompressedOops #开启压缩指针，例如压缩指针对象头。开启后可以节省一定的内存空间\n-XX:+CMSParallelRemarkEnabled #降低标记停顿\n-XX:CMSInitiatingOccupancyFraction=70 #使用cms作为垃圾回收,使用70％后开始CMS收集</code></pre>\n<h2 id=\"JVM调优\"><a href=\"#JVM调优\" class=\"headerlink\" title=\"JVM调优\"></a>JVM调优</h2><h3 id=\"什么时候才需要调优？\"><a href=\"#什么时候才需要调优？\" class=\"headerlink\" title=\"什么时候才需要调优？\"></a>什么时候才需要调优？</h3><p><strong>如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化。</strong></p>\n<p>如果满足下列指标，则一般不需要GC优化（具体情况具体分析）</p>\n<ul>\n<li>Minor GC执行时间不到100ms</li>\n<li>Minor GC执行不频繁，约5秒一次</li>\n<li>Full GC执行时间不到1s</li>\n<li>Full GC执行频率不算频繁，不低于1分钟1次</li>\n</ul>\n<h3 id=\"调优目标\"><a href=\"#调优目标\" class=\"headerlink\" title=\"调优目标\"></a>调优目标</h3><ul>\n<li>GC的时间足够的小</li>\n<li>GC的次数足够的少</li>\n<li>发生Full GC的周期足够的长</li>\n</ul>\n<p>调优准则</p>\n<ul>\n<li>根据机器情况和服务需求，具体问题具体分析</li>\n<li>多数的Java应用不需要在服务器上进行GC优化</li>\n<li>减少使用全局变量和大对象 (代码层面)</li>\n<li>调整新生代的大小</li>\n<li>设置老年代的大小（老年代：新生代=2：1）</li>\n<li>选择合适的GC收集器</li>\n<li>设置合适线程堆栈大小</li>\n</ul>\n<p>例如线上排查Full GC次数频繁。这就要知道什么时候对象会放到老年代。</p>\n<ul>\n<li>YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。这种情况可以适当加大Survivor区的大小。</li>\n<li>经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中。这种情况属于对象存活太久，如果大对象在业务上不需要使用那么久最好能够用完即删。</li>\n<li>动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。这种情况也是可以适当更改Survivor大小。</li>\n</ul>\n<h3 id=\"如何确定新生代和老年代的比例？\"><a href=\"#如何确定新生代和老年代的比例？\" class=\"headerlink\" title=\"如何确定新生代和老年代的比例？\"></a>如何确定新生代和老年代的比例？</h3><ul>\n<li>IO交互性系统，互联网上目前大部分的服务都属于该类型，例如分布式 RPC、MQ、HTTP 网关服务等，对内存要求并不大，大部分对象在 TP9999 的时间内都会死亡， Young 区越大越好。</li>\n<li>内存计算性系统，主要是分布式数据计算 Hadoop，分布式存储 HBase、Cassandra，自建的分布式缓存等，对内存要求高，对象存活时间长，Old 区越大越好。</li>\n</ul>\n<h2 id=\"常见知识点\"><a href=\"#常见知识点\" class=\"headerlink\" title=\"常见知识点\"></a>常见知识点</h2><h3 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h3><p>空间担保指的是老年代进行空间分配担保。在发生Minor GC前，JVM会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>。</p>\n<ul>\n<li>如果大于，则此次<strong>Minor GC是安全的</strong>。</li>\n<li>如果小于，则虚拟机会查看<strong>HandlePromotionFailure</strong>设置值是否允许担保失败。如果HandlePromotionFailure=true，那么会继续检查老年代最大可用连续空间是否大于<strong>历次晋升到老年代的对象的平均大小</strong>，如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；如果小于或者HandlePromotionFailure=false，则改为进行一次Full GC。</li>\n</ul>\n<p><strong>为什么要进行空间担保？</strong></p>\n<p>是因为新生代采用<strong>复制收集算法</strong>，假如大量对象在Minor GC后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而Survivor空间是比较小的，这时就需要老年代进行分配担保，把Survivor无法容纳的对象放到老年代。<strong>老年代要进行空间分配担保，前提是老年代得有足够空间来容纳这些对象</strong>，但一共有多少对象在内存回收后存活下来是不可预知的，<strong>因此只好取之前每次垃圾回收后晋升到老年代的对象大小的平均值作为参考</strong>。使用这个平均值与老年代剩余空间进行比较，来决定是否进行Full GC来让老年代腾出更多空间。</p>\n<p><img src=\"/2020/05/07/jvm-optimization/1.png\" alt=\"空间担保机制\"></p>\n<h3 id=\"什么情况对象直接进老年代\"><a href=\"#什么情况对象直接进老年代\" class=\"headerlink\" title=\"什么情况对象直接进老年代\"></a>什么情况对象直接进老年代</h3><ul>\n<li>在执行YGC时，To Survivor区不足以存放存活的对象，对象会直接进入到老年代。</li>\n<li>长期存活的对象将进入老年代。经过多次YGC后，如果存活对象的年龄达到了设定阈值，则会晋升到老年代中，通过-XX：MaxTenuringThreshold = 15设置。</li>\n<li>大对象直接进入老年代，通过-XX：PretenureSizeThreshold参数设置，如果大于这个设定值则直接存入老年代，</li>\n<li>动态年龄判定规则，To Survivor区中相同年龄的对象，如果其大小之和占到了 To Survivor区一半以上的空间，那么大于此年龄的对象会直接进入老年代，而不需要达到默认的分代年龄。</li>\n</ul>\n<h3 id=\"什么情况下会触发FGC\"><a href=\"#什么情况下会触发FGC\" class=\"headerlink\" title=\"什么情况下会触发FGC\"></a>什么情况下会触发FGC</h3><ul>\n<li>当晋升到老年代的对象大于了老年代的剩余空间时，就会触发FGC（Major GC），<strong>FGC处理的区域同时包括新生代和老年代</strong>。</li>\n<li>老年代的内存使用率达到了一定阈值（可通过参数调整），直接触发FGC(-XX:CMSInitiatingOccupancyFraction=70 是指设定CMS在对内存占用率达到70%的时候开始GC）。</li>\n<li>空间分配担保：在YGC之前，会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。如果小于，说明YGC是不安全的，则会查看参数 HandlePromotionFailure 是否被设置成了允许担保失败，如果不允许则直接触发Full GC；如果允许，那么会进一步检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于也会触发 Full GC。</li>\n<li>Metaspace（元空间）在空间不足时会进行扩容，当扩容到了-XX:MetaspaceSize 参数的指定值时，也会触发FGC。</li>\n<li>System.gc() 或者Runtime.gc() 被显式调用时，触发FGC。（有些第三方插件会有用这个函数）</li>\n</ul>\n<h3 id=\"三种内存回收机制优缺点\"><a href=\"#三种内存回收机制优缺点\" class=\"headerlink\" title=\"三种内存回收机制优缺点\"></a>三种内存回收机制优缺点</h3><p>对于 Java 的内存回收机制我们主要分为 3 种：</p>\n<ul>\n<li>标记-清除算法<ul>\n<li>不足：效率不高，容易产生内存碎片。</li>\n</ul>\n</li>\n<li>复制算法<ul>\n<li>效率高，复制成本大。</li>\n<li>不足：如果是 1：1 模型，占用内存。</li>\n<li>分配担保策略</li>\n</ul>\n</li>\n<li>标记-整理算法<ul>\n<li>因为老年代的对象生存率高，所以使用复制算法效率会很差，就提出了这个标记-整理算法。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CMS老年代垃圾回收器详解\"><a href=\"#CMS老年代垃圾回收器详解\" class=\"headerlink\" title=\"CMS老年代垃圾回收器详解\"></a>CMS老年代垃圾回收器详解</h3><p>CMS是一款并发、使用*<font color=\"red\">标记-清除</font>*算法的老年代垃圾回收器。针对老年代进行回收的GC。<font color=\"red\">以获取最短回收停顿时间【也就是指Stop The World的停顿时间】</font>为目标，多数应用于互联网站或者B/S系统的服务器端上。</p>\n<p><strong>CMS四个过程</strong>：</p>\n<p>CMS基于<strong>标记-清除</strong>算法实现。</p>\n<ul>\n<li>初始标记(<font color=\"red\">Stop The World</font>)。标记一下GC Roots能直接关联到的对象。这一步主要做两件事：</li>\n<li><ul>\n<li>从GcRoots直接可达的老年代对象</li>\n<li>遍历新生代对象，标记可达的老年代对象</li>\n</ul>\n</li>\n<li>并发标记。遍历初始标记阶段标记出来的存活对象，然后继续递归标记这些对象可达的对象。<strong>在运行期间可能发生新生代的对象晋升到老年代、或者是直接在老年代分配对象、或者更新老年代对象的引用关系等等，对于这些对象，都是需要进行重新标记的，否则有些对象就会被遗漏，发生漏标的情况。</strong>为了提高重新标记的效率，该阶段会把上述对象所在的Card(卡表)标识为Dirty(脏)，后续只需扫描这些Dirty Card的对象，避免扫描整个老年代。</li>\n<li>并发预清理。<em>CMSPrecleaningEnabled</em>控制是否需要并发预清理，默认启用。<strong>该阶段要尽最大的努力去处理那些在并发阶段被应用线程更新的老年代对象，这样在暂停的重新标记阶段就可以少处理一些，暂停时间也会相应的降低。</strong></li>\n<li>重新标记。为了修正并发标记期间因用户程序继续动作而导致标记产生变动的那一部分对象的标记记录 — <font color=\"red\">Stop The World</font></li>\n<li>并发清除。</li>\n</ul>\n<p><strong>优缺点</strong></p>\n<ul>\n<li>并发收集、低停顿。</li>\n<li>CMS收集器对处理器资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的算能力）而导致应用程序变慢，降低总吞吐量。</li>\n<li>CMS收集器无法处理浮动垃圾（因为CMS是支持并发的原因，所以允许在过程中用户线程也在运行，会导致判断不准确。 例如可能在判断完成之后在清除之前这个对像已经变成了垃圾对象，所以有可能本该此垃圾被回收但是没有被回收，只能等待下一次GC再将该对象回收）。</li>\n</ul>\n<p><strong>几个优化的参数</strong></p>\n<ul>\n<li>-XX:+UseCMSInitiatingOccupancyOnly 和 -XX：CMSInitiatingOccupancyFraction的值来用来设置CMS收集器老年代占用百分之多少后执行FullGC，降低内存回收频率，获取更好的性能。</li>\n<li>-XX:+UseCMSCompactAtFullCollection默认开启，要进行Full GC的时候进行内存碎片整理。</li>\n<li>-XX:CMSFullGCsBeforeCompaction 每隔多少次不压缩的Full GC后，执行一次带压缩的Full GC。</li>\n<li>CMSScavengeBeforeRemark 如果开启这个参数，会在进入重新标记阶段之前强制触发一次minor gc。</li>\n<li>CMSMaxAbortablePrecleanTime = 5 表示并发预清理阶段持续5秒还没等到minor gc就中断并发预清理阶段。</li>\n</ul>\n<p><strong>CMS并发模式失败（Concurrent mode failure）和晋升失败</strong></p>\n<ul>\n<li>并发模式失败，CMS的目标就是在回收老年代对象的时候不要停止全部应用线程，在并发周期执行期间，用户的线程依然在运行，如果这时候如果应用线程向老年代请求分配的空间超过预留的空间（担保失败），就回触发concurrent mode failure，然后CMS的并发周期就会被一次Full GC代替。</li>\n<li>晋升失败，新生代做minor gc的时候，需要CMS的担保机制确认老年代是否有足够的空间容纳要晋升的对象，担保机制发现不够，则报concurrent mode failure，如果担保机制判断是够的，但是实际上由于碎片问题导致无法分配，就会报晋升失败。</li>\n<li>永久代空间（或Java8的元空间）耗尽，默认情况下,CMS不会对永久代进行收集，一旦永久代空间耗尽，就回触发Full GC。</li>\n</ul>\n<p>针对并发模式失败的调优 ：</p>\n<ul>\n<li>想办法增大老年代的空间，增加整个堆的大小，或者减少年轻代的大小。</li>\n<li>以更高的频率执行后台的回收线程，即提高CMS并发周期发生的频率，例如调低<em>CMSInitiatingOccupancyFraction</em>的值。引用《Java性能权威指南》（<strong>对特定的应用程序，该标志的更优值可以根据 GC 日志中 CMS 周期首次启动失败时的值得到。具体方法是，在垃圾回收日志中寻找并发模式失效，找到后再反向查找 CMS 周期最近的启动记录，然后根据日志来计算这时候的老年代空间占用值，然后设置一个比该值更小的值。</strong>）</li>\n<li>增多回收线程的个数CMS默认的垃圾收集线程数是<em>（CPU个数 + 3）/4</em>。-XX:ParallelCMSThreads用来设置线程数量。</li>\n</ul>\n<h3 id=\"JVM动态年龄判断\"><a href=\"#JVM动态年龄判断\" class=\"headerlink\" title=\"JVM动态年龄判断\"></a>JVM动态年龄判断</h3><p>-XX:MaxTenuringThreshold=3，该参数主要是控制新生代需要经历多少次GC晋升到老年代中的最大阈值。但是不一定是这个阈值才晋升到老年代。因为有动态年龄判断(<strong>Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</strong>)</p>\n<h3 id=\"垃圾回收图解\"><a href=\"#垃圾回收图解\" class=\"headerlink\" title=\"垃圾回收图解\"></a>垃圾回收图解</h3><p><img src=\"/2020/05/07/jvm-optimization/3.png\" alt=\"垃圾回收过程\"></p>\n<h3 id=\"JVM内存模型\"><a href=\"#JVM内存模型\" class=\"headerlink\" title=\"JVM内存模型\"></a>JVM内存模型</h3><p><img src=\"/2020/05/07/jvm-optimization/4.png\" alt=\"jvm内存模型\"></p>\n<h3 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h3><p><img src alt>)<img src=\"/2020/05/07/jvm-optimization/5.png\" alt=\"5\"></p>\n<h3 id=\"JAVA内存对象布局\"><a href=\"#JAVA内存对象布局\" class=\"headerlink\" title=\"JAVA内存对象布局\"></a>JAVA内存对象布局</h3><p><img src=\"/2020/05/07/jvm-optimization/6.png\" alt=\"JAVA内存对象布局\"></p>\n<pre><code class=\"java\">package xzy;\nimport org.openjdk.jol.info.ClassLayout;\npublic class OtherTest {\n    public static void main(String[] args){\n        Object obj = new Object();\n        System.out.println(ClassLayout.parseInstance(obj).toPrintable());\n    }\n}\n//==========================================无指针压缩=========================\n# -XX:-UseCompressedOops\njava.lang.Object object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)Class Pointer                           00 1c 95 1e (00000000 00011100 10010101 00011110) (513088512)\n     12     4        (object header)Class Pointer                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total\n//==========================================指针压缩=========================\njava.lang.Object object internals:\n OFFSET  SIZE   TYPE DESCRIPTION                               VALUE\n      0     4        (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4        (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4        (object header)Class Pointer                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)\n     12     4        (loss due to the next object alignment)对其填充\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\n\npublic class OtherTest {\n    public static void main(String[] args){\n        Object[] obj = new Object[10];\n        System.out.println(ClassLayout.parseInstance(obj).toPrintable());\n    }\n}\n//===============================无指针压缩数组===========================\n[Ljava.lang.Object; object internals:\n OFFSET  SIZE               TYPE DESCRIPTION                               VALUE\n      0     4                    (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4                    (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4                    (object header)Class Pointer                           60 c7 b1 1e (01100000 11000111 10110001 00011110) (514967392)\n     12     4                    (object header)Class Pointer                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n     16     4                    (object header)Class Pointer                           0a 00 00 00 (00001010 00000000 00000000 00000000) (10)\n     20     4                    (alignment/padding gap)对齐填充                  \n     24    80   java.lang.Object Object;.&lt;elements&gt;数组长度(8 * 10)                        N/A\nInstance size: 104 bytes\nSpace losses: 4 bytes internal + 0 bytes external = 4 bytes total\n//===========================指针压缩数组==============================\n [Ljava.lang.Object; object internals:\n OFFSET  SIZE               TYPE DESCRIPTION                               VALUE\n      0     4                    (object header)对象头                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)\n      4     4                    (object header)对象头                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)\n      8     4                    (object header)Class Pointer                           3c 23 00 f8 (00111100 00100011 00000000 11111000) (-134208708)\n     12     4                    (object header)对齐填充                           0a 00 00 00 (00001010 00000000 00000000 00000000) (10)\n     16    40   java.lang.Object Object;.&lt;elements&gt;数组长度(4 * 10)                        N/A\nInstance size: 56 bytes\nSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total</code></pre>\n<h3 id=\"三色标记法\"><a href=\"#三色标记法\" class=\"headerlink\" title=\"三色标记法\"></a>三色标记法</h3><p>实现并发标记的算法就是三色标记法，三色标记法最大的特点就是可以异步执行，从而可以以中断时间极少的代价或者完全没有中断来进行整个GC。</p>\n<ul>\n<li>白色：尚未被GC访问过的对象，如果全部标记已完成依旧为白色的，称为不可达对象，既垃圾对象。</li>\n<li>黑色：本对象已经被GC访问过，且本对象的子引用对象也已经被访问过了。</li>\n<li>灰色：本对象已访问过，但是本对象的子引用对象还没有被访问过，全部访问完会变成黑色，属于中间态。</li>\n</ul>\n<p><strong>标记过程</strong></p>\n<ol>\n<li>在GC并发标记刚开始时，所以对象均为白色集合。</li>\n<li>将所有GCRoots直接引用的对象标记为灰色集合。</li>\n<li>判断若灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将其所有的子引用对象放入灰色集合，当前对象放入黑色集合。</li>\n</ol>"},{"title":"Kafka如何保证消息100%投递（四）","description":"Kafka如何保证消息100%投递","date":"2020-12-02T09:35:09.000Z","_content":"## Kafka数据丢失原因\n\nKafka存在数据丢失问题，主要存在在Broker，Producer。\n\n### Broker刷盘机制\n\nBroker丢失消息是由于Kafka本身的原因造成的，kafka为了得到更高的性能和吞吐量，将数据异步批量的存储在磁盘中。消息的刷盘过程，为了提高性能，减少刷盘次数，kafka采用了批量刷盘的做法。即，按照一定的消息量，和时间间隔进行刷盘。这种机制也是由于linux操作系统决定的。将数据存储到linux操作系统种，会先存储到页缓存（Page cache）中，按照时间或者其他条件进行刷盘（从page cache到file），或者通过fsync命令强制刷盘。数据在page cache中时，如果系统挂掉，数据会丢失。\n\n![Broker在linux服务器上高速读写以及同步到Replica](kafka-messge-complete/1.png)\n\n如图所示，Broker在保存数据时，首先先将数据存到内存中的页缓存中，然后Linux的flusher程序会在特定情况下将页缓存中的数据刷到磁盘中落地。触发刷盘的条件有：<font color=red>主动调用sync或fsync函数</font>。<font color=red>可用内存低于阀值</font>。<font color=red>dirty data时间达到阀值</font>。 所以说从理论上来，要解决Broker不丢失数据是无法实现的，只能通过调整刷盘机制的参数缓解该情况。\n\n为了解决该问题，kafka通过producer和broker协同处理单个broker丢失参数的情况，一旦producer发现broker消息丢失，即可自动进行retry。那么producer是如何检测Broker丢失的呢？ 答案就是`ack`参数。\n\n- acks=0，producer不等待broker的响应，效率最高，但是消息很可能会丢。\n- acks=1，leader收到消息后，不等待其他follower的响应，即返回ack。这种情况只能保证数据被写到PageCache后producer就认为陈工了，没法保证是否数据刷到磁盘和followers收到数据。\n- ackas=all，leader收到消息后，挂起，等待所有ISR列表中的follower返回结果后。这种配置下，只有leader写入数据到pagecache是不会返回ack的，还需要所有的ISR返回“成功”才会触发ack，这个时候数据已经刷到磁盘了。\n\n### Producer批量发送\n\n为了提升效率减少IO，producer在发送数据时可以将多个请求进行合并后发送。被合并的请求咋发送一线缓存在本地buffer中。这也会产生断电后或者程序停止导致在buffer中的数据没法发送成功。\n\n![producer发送数据到Broker](kafka-messge-complete/2.png)\n\n## 保证方案\n\n从上面分析可知，Broker的刷盘机制和Producer批量发送导致了消息无法保证100%投递。如果要保证我们可以有如下方案：\n\n- 对于Brokder，设置ack=all。可以保证消息不会丢失，但是吞吐率不高。\n- 对于Producer，不直接将消息发送到buffer（内存），而是将消息写到本地的磁盘中（数据库或者文件），由另一个（或少量）生产线程进行消息发送。\n\n<font color=red>上面的方案虽然能保证消息能100%投递，但是对于性能下降严重，一般生产不采纳。</font>\n\n下面介绍一种方案，**采用消息提前持久化 + 定时任务兜底的方式来保证**。\n\n![](kafka-messge-complete/3.png)\n\n流程如上图所示：\n\n1. 订单服务生产者再投递消息之前，先把消息持久化到Redis或DB中，建议redis，高性能。\n2. 通过生产者回调机制判断是否发送成功，如果发送成功则将Redis中的数据删除。如果发送不成功的数据将还是存在Redis中。\n3. 通过一个定时器定时拉取Redis中时间间隔较常的数据，时间间隔较常没被删除证明是没发送成功，此时获取出来重新发送。\n\n不过这样的方案，就会有**可能发送多次相同的消息**，很有可能MQ已经收到了消息，就是ack消息回调时出现网络故障，没有让生产者收到。这要求我们必须能保证消费时支持幂等。","source":"_posts/kafka-messge-complete.md","raw":"---\ntitle: Kafka如何保证消息100%投递（四）\ntags:\n  - kafka\ncategories:  kafka\ndescription : Kafka如何保证消息100%投递\ndate: 2020-12-02 17:35:09\n---\n## Kafka数据丢失原因\n\nKafka存在数据丢失问题，主要存在在Broker，Producer。\n\n### Broker刷盘机制\n\nBroker丢失消息是由于Kafka本身的原因造成的，kafka为了得到更高的性能和吞吐量，将数据异步批量的存储在磁盘中。消息的刷盘过程，为了提高性能，减少刷盘次数，kafka采用了批量刷盘的做法。即，按照一定的消息量，和时间间隔进行刷盘。这种机制也是由于linux操作系统决定的。将数据存储到linux操作系统种，会先存储到页缓存（Page cache）中，按照时间或者其他条件进行刷盘（从page cache到file），或者通过fsync命令强制刷盘。数据在page cache中时，如果系统挂掉，数据会丢失。\n\n![Broker在linux服务器上高速读写以及同步到Replica](kafka-messge-complete/1.png)\n\n如图所示，Broker在保存数据时，首先先将数据存到内存中的页缓存中，然后Linux的flusher程序会在特定情况下将页缓存中的数据刷到磁盘中落地。触发刷盘的条件有：<font color=red>主动调用sync或fsync函数</font>。<font color=red>可用内存低于阀值</font>。<font color=red>dirty data时间达到阀值</font>。 所以说从理论上来，要解决Broker不丢失数据是无法实现的，只能通过调整刷盘机制的参数缓解该情况。\n\n为了解决该问题，kafka通过producer和broker协同处理单个broker丢失参数的情况，一旦producer发现broker消息丢失，即可自动进行retry。那么producer是如何检测Broker丢失的呢？ 答案就是`ack`参数。\n\n- acks=0，producer不等待broker的响应，效率最高，但是消息很可能会丢。\n- acks=1，leader收到消息后，不等待其他follower的响应，即返回ack。这种情况只能保证数据被写到PageCache后producer就认为陈工了，没法保证是否数据刷到磁盘和followers收到数据。\n- ackas=all，leader收到消息后，挂起，等待所有ISR列表中的follower返回结果后。这种配置下，只有leader写入数据到pagecache是不会返回ack的，还需要所有的ISR返回“成功”才会触发ack，这个时候数据已经刷到磁盘了。\n\n### Producer批量发送\n\n为了提升效率减少IO，producer在发送数据时可以将多个请求进行合并后发送。被合并的请求咋发送一线缓存在本地buffer中。这也会产生断电后或者程序停止导致在buffer中的数据没法发送成功。\n\n![producer发送数据到Broker](kafka-messge-complete/2.png)\n\n## 保证方案\n\n从上面分析可知，Broker的刷盘机制和Producer批量发送导致了消息无法保证100%投递。如果要保证我们可以有如下方案：\n\n- 对于Brokder，设置ack=all。可以保证消息不会丢失，但是吞吐率不高。\n- 对于Producer，不直接将消息发送到buffer（内存），而是将消息写到本地的磁盘中（数据库或者文件），由另一个（或少量）生产线程进行消息发送。\n\n<font color=red>上面的方案虽然能保证消息能100%投递，但是对于性能下降严重，一般生产不采纳。</font>\n\n下面介绍一种方案，**采用消息提前持久化 + 定时任务兜底的方式来保证**。\n\n![](kafka-messge-complete/3.png)\n\n流程如上图所示：\n\n1. 订单服务生产者再投递消息之前，先把消息持久化到Redis或DB中，建议redis，高性能。\n2. 通过生产者回调机制判断是否发送成功，如果发送成功则将Redis中的数据删除。如果发送不成功的数据将还是存在Redis中。\n3. 通过一个定时器定时拉取Redis中时间间隔较常的数据，时间间隔较常没被删除证明是没发送成功，此时获取出来重新发送。\n\n不过这样的方案，就会有**可能发送多次相同的消息**，很有可能MQ已经收到了消息，就是ack消息回调时出现网络故障，没有让生产者收到。这要求我们必须能保证消费时支持幂等。","slug":"kafka-messge-complete","published":1,"updated":"2021-04-08T00:47:06.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhv3000zqwv2940fawon","content":"<h2 id=\"Kafka数据丢失原因\"><a href=\"#Kafka数据丢失原因\" class=\"headerlink\" title=\"Kafka数据丢失原因\"></a>Kafka数据丢失原因</h2><p>Kafka存在数据丢失问题，主要存在在Broker，Producer。</p>\n<h3 id=\"Broker刷盘机制\"><a href=\"#Broker刷盘机制\" class=\"headerlink\" title=\"Broker刷盘机制\"></a>Broker刷盘机制</h3><p>Broker丢失消息是由于Kafka本身的原因造成的，kafka为了得到更高的性能和吞吐量，将数据异步批量的存储在磁盘中。消息的刷盘过程，为了提高性能，减少刷盘次数，kafka采用了批量刷盘的做法。即，按照一定的消息量，和时间间隔进行刷盘。这种机制也是由于linux操作系统决定的。将数据存储到linux操作系统种，会先存储到页缓存（Page cache）中，按照时间或者其他条件进行刷盘（从page cache到file），或者通过fsync命令强制刷盘。数据在page cache中时，如果系统挂掉，数据会丢失。</p>\n<p><img src=\"/2020/12/02/kafka-messge-complete/1.png\" alt=\"Broker在linux服务器上高速读写以及同步到Replica\"></p>\n<p>如图所示，Broker在保存数据时，首先先将数据存到内存中的页缓存中，然后Linux的flusher程序会在特定情况下将页缓存中的数据刷到磁盘中落地。触发刷盘的条件有：<font color=\"red\">主动调用sync或fsync函数</font>。<font color=\"red\">可用内存低于阀值</font>。<font color=\"red\">dirty data时间达到阀值</font>。 所以说从理论上来，要解决Broker不丢失数据是无法实现的，只能通过调整刷盘机制的参数缓解该情况。</p>\n<p>为了解决该问题，kafka通过producer和broker协同处理单个broker丢失参数的情况，一旦producer发现broker消息丢失，即可自动进行retry。那么producer是如何检测Broker丢失的呢？ 答案就是<code>ack</code>参数。</p>\n<ul>\n<li>acks=0，producer不等待broker的响应，效率最高，但是消息很可能会丢。</li>\n<li>acks=1，leader收到消息后，不等待其他follower的响应，即返回ack。这种情况只能保证数据被写到PageCache后producer就认为陈工了，没法保证是否数据刷到磁盘和followers收到数据。</li>\n<li>ackas=all，leader收到消息后，挂起，等待所有ISR列表中的follower返回结果后。这种配置下，只有leader写入数据到pagecache是不会返回ack的，还需要所有的ISR返回“成功”才会触发ack，这个时候数据已经刷到磁盘了。</li>\n</ul>\n<h3 id=\"Producer批量发送\"><a href=\"#Producer批量发送\" class=\"headerlink\" title=\"Producer批量发送\"></a>Producer批量发送</h3><p>为了提升效率减少IO，producer在发送数据时可以将多个请求进行合并后发送。被合并的请求咋发送一线缓存在本地buffer中。这也会产生断电后或者程序停止导致在buffer中的数据没法发送成功。</p>\n<p><img src=\"/2020/12/02/kafka-messge-complete/2.png\" alt=\"producer发送数据到Broker\"></p>\n<h2 id=\"保证方案\"><a href=\"#保证方案\" class=\"headerlink\" title=\"保证方案\"></a>保证方案</h2><p>从上面分析可知，Broker的刷盘机制和Producer批量发送导致了消息无法保证100%投递。如果要保证我们可以有如下方案：</p>\n<ul>\n<li>对于Brokder，设置ack=all。可以保证消息不会丢失，但是吞吐率不高。</li>\n<li>对于Producer，不直接将消息发送到buffer（内存），而是将消息写到本地的磁盘中（数据库或者文件），由另一个（或少量）生产线程进行消息发送。</li>\n</ul>\n<p><font color=\"red\">上面的方案虽然能保证消息能100%投递，但是对于性能下降严重，一般生产不采纳。</font></p>\n<p>下面介绍一种方案，<strong>采用消息提前持久化 + 定时任务兜底的方式来保证</strong>。</p>\n<p><img src=\"/2020/12/02/kafka-messge-complete/3.png\" alt></p>\n<p>流程如上图所示：</p>\n<ol>\n<li>订单服务生产者再投递消息之前，先把消息持久化到Redis或DB中，建议redis，高性能。</li>\n<li>通过生产者回调机制判断是否发送成功，如果发送成功则将Redis中的数据删除。如果发送不成功的数据将还是存在Redis中。</li>\n<li>通过一个定时器定时拉取Redis中时间间隔较常的数据，时间间隔较常没被删除证明是没发送成功，此时获取出来重新发送。</li>\n</ol>\n<p>不过这样的方案，就会有<strong>可能发送多次相同的消息</strong>，很有可能MQ已经收到了消息，就是ack消息回调时出现网络故障，没有让生产者收到。这要求我们必须能保证消费时支持幂等。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Kafka数据丢失原因\"><a href=\"#Kafka数据丢失原因\" class=\"headerlink\" title=\"Kafka数据丢失原因\"></a>Kafka数据丢失原因</h2><p>Kafka存在数据丢失问题，主要存在在Broker，Producer。</p>\n<h3 id=\"Broker刷盘机制\"><a href=\"#Broker刷盘机制\" class=\"headerlink\" title=\"Broker刷盘机制\"></a>Broker刷盘机制</h3><p>Broker丢失消息是由于Kafka本身的原因造成的，kafka为了得到更高的性能和吞吐量，将数据异步批量的存储在磁盘中。消息的刷盘过程，为了提高性能，减少刷盘次数，kafka采用了批量刷盘的做法。即，按照一定的消息量，和时间间隔进行刷盘。这种机制也是由于linux操作系统决定的。将数据存储到linux操作系统种，会先存储到页缓存（Page cache）中，按照时间或者其他条件进行刷盘（从page cache到file），或者通过fsync命令强制刷盘。数据在page cache中时，如果系统挂掉，数据会丢失。</p>\n<p><img src=\"/2020/12/02/kafka-messge-complete/1.png\" alt=\"Broker在linux服务器上高速读写以及同步到Replica\"></p>\n<p>如图所示，Broker在保存数据时，首先先将数据存到内存中的页缓存中，然后Linux的flusher程序会在特定情况下将页缓存中的数据刷到磁盘中落地。触发刷盘的条件有：<font color=\"red\">主动调用sync或fsync函数</font>。<font color=\"red\">可用内存低于阀值</font>。<font color=\"red\">dirty data时间达到阀值</font>。 所以说从理论上来，要解决Broker不丢失数据是无法实现的，只能通过调整刷盘机制的参数缓解该情况。</p>\n<p>为了解决该问题，kafka通过producer和broker协同处理单个broker丢失参数的情况，一旦producer发现broker消息丢失，即可自动进行retry。那么producer是如何检测Broker丢失的呢？ 答案就是<code>ack</code>参数。</p>\n<ul>\n<li>acks=0，producer不等待broker的响应，效率最高，但是消息很可能会丢。</li>\n<li>acks=1，leader收到消息后，不等待其他follower的响应，即返回ack。这种情况只能保证数据被写到PageCache后producer就认为陈工了，没法保证是否数据刷到磁盘和followers收到数据。</li>\n<li>ackas=all，leader收到消息后，挂起，等待所有ISR列表中的follower返回结果后。这种配置下，只有leader写入数据到pagecache是不会返回ack的，还需要所有的ISR返回“成功”才会触发ack，这个时候数据已经刷到磁盘了。</li>\n</ul>\n<h3 id=\"Producer批量发送\"><a href=\"#Producer批量发送\" class=\"headerlink\" title=\"Producer批量发送\"></a>Producer批量发送</h3><p>为了提升效率减少IO，producer在发送数据时可以将多个请求进行合并后发送。被合并的请求咋发送一线缓存在本地buffer中。这也会产生断电后或者程序停止导致在buffer中的数据没法发送成功。</p>\n<p><img src=\"/2020/12/02/kafka-messge-complete/2.png\" alt=\"producer发送数据到Broker\"></p>\n<h2 id=\"保证方案\"><a href=\"#保证方案\" class=\"headerlink\" title=\"保证方案\"></a>保证方案</h2><p>从上面分析可知，Broker的刷盘机制和Producer批量发送导致了消息无法保证100%投递。如果要保证我们可以有如下方案：</p>\n<ul>\n<li>对于Brokder，设置ack=all。可以保证消息不会丢失，但是吞吐率不高。</li>\n<li>对于Producer，不直接将消息发送到buffer（内存），而是将消息写到本地的磁盘中（数据库或者文件），由另一个（或少量）生产线程进行消息发送。</li>\n</ul>\n<p><font color=\"red\">上面的方案虽然能保证消息能100%投递，但是对于性能下降严重，一般生产不采纳。</font></p>\n<p>下面介绍一种方案，<strong>采用消息提前持久化 + 定时任务兜底的方式来保证</strong>。</p>\n<p><img src=\"/2020/12/02/kafka-messge-complete/3.png\" alt></p>\n<p>流程如上图所示：</p>\n<ol>\n<li>订单服务生产者再投递消息之前，先把消息持久化到Redis或DB中，建议redis，高性能。</li>\n<li>通过生产者回调机制判断是否发送成功，如果发送成功则将Redis中的数据删除。如果发送不成功的数据将还是存在Redis中。</li>\n<li>通过一个定时器定时拉取Redis中时间间隔较常的数据，时间间隔较常没被删除证明是没发送成功，此时获取出来重新发送。</li>\n</ol>\n<p>不过这样的方案，就会有<strong>可能发送多次相同的消息</strong>，很有可能MQ已经收到了消息，就是ack消息回调时出现网络故障，没有让生产者收到。这要求我们必须能保证消费时支持幂等。</p>\n"},{"title":"Kafka运维笔记（二）","description":"Kafka运维笔记","date":"2019-11-16T01:22:03.000Z","_content":"\n### 常用命令\n\n**创建主题**\n\n```shell\n#window\n.\\bin\\windows\\kafka-topics.bat --create  --zookeeper localhost:2181 --replication-factor 1 --partitions 6 --topic test001\n#shell\nsh kafka-topics.sh --create  --zookeeper localhost:2181 --replication-factor 1 --partitions 6 --topic test001\n```\n\n### 配置优化\n待续。。。\n","source":"_posts/kafka-operation.md","raw":"---\ntitle: Kafka运维笔记（二）\ntags:\n  - kafka\ncategories:  kafka\ndescription : Kafka运维笔记\ndate: 2019-11-16 09:22:03\n---\n\n### 常用命令\n\n**创建主题**\n\n```shell\n#window\n.\\bin\\windows\\kafka-topics.bat --create  --zookeeper localhost:2181 --replication-factor 1 --partitions 6 --topic test001\n#shell\nsh kafka-topics.sh --create  --zookeeper localhost:2181 --replication-factor 1 --partitions 6 --topic test001\n```\n\n### 配置优化\n待续。。。\n","slug":"kafka-operation","published":1,"updated":"2021-04-08T00:47:06.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhv50013qwv20sa97ixg","content":"<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p><strong>创建主题</strong></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#window\n.\\bin\\windows\\kafka-topics.bat --create  --zookeeper localhost:2181 --replication-factor 1 --partitions 6 --topic test001\n#shell\nsh kafka-topics.sh --create  --zookeeper localhost:2181 --replication-factor 1 --partitions 6 --topic test001</code></pre>\n<h3 id=\"配置优化\"><a href=\"#配置优化\" class=\"headerlink\" title=\"配置优化\"></a>配置优化</h3><p>待续。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><p><strong>创建主题</strong></p>\n<pre><code class=\"shell\">#window\n.\\bin\\windows\\kafka-topics.bat --create  --zookeeper localhost:2181 --replication-factor 1 --partitions 6 --topic test001\n#shell\nsh kafka-topics.sh --create  --zookeeper localhost:2181 --replication-factor 1 --partitions 6 --topic test001</code></pre>\n<h3 id=\"配置优化\"><a href=\"#配置优化\" class=\"headerlink\" title=\"配置优化\"></a>配置优化</h3><p>待续。。。</p>\n"},{"title":"Kafka多线程消费者设计（三）","description":"Kafka多线程消费者设计","date":"2019-11-15T09:35:09.000Z","_content":"待续。。。","source":"_posts/kafka-muticustomerthread.md","raw":"---\ntitle: Kafka多线程消费者设计（三）\ntags:\n  - kafka\ncategories:  kafka\ndescription : Kafka多线程消费者设计\ndate: 2019-11-15 17:35:09\n---\n待续。。。","slug":"kafka-muticustomerthread","published":1,"updated":"2021-04-08T00:47:06.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhv70016qwv27dy1djjx","content":"<p>待续。。。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>待续。。。</p>\n"},{"title":"MySQL之count(*)、count(1)、count(字段)","description":"详解MySQL之count(*)、count(1)、count(字段)","date":"2020-01-26T00:30:14.000Z","_content":"## 正文\ncount() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。\n<!--more-->\n### InnoDB下的count\n\ncount(*)、count(主键 id) 、 count(1) 都表示返回满足条件的结果集的总行数。而count(字段)则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。\n- **对于count(主键id)来说**，InnoDB引擎会遍历整张表，把每一行的id值取出来，返回给server层。server 层拿到 id 后，判断是不可能为空的，就按行累加。由于主键是不可能为NULL的，所以count(主键id)是忽略NULL的。\n\n  \n\n- **对于 count(1) 来说**，InnoDB 引擎遍历整张表，<font color=red>但不取值</font>。server层对于返回的每一行，放一个数字\"1\"进去，判断是不可能为空，按行累加。所以count(主键id)是忽略NULL的。\n\n  \n\n- **对于 count(字段) 来说**，所以count(字段)根据字段是否定义为not null来判断是否忽略NULL。\n  \n  - 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加\n  - 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加\n  \n  \n  \n- **但是 count(\\*) 是例外**，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。\n\n所以结论是：按照效率排序的话，<font size=5 color=red>count(字段) < count(主键 id) < count(1) ≈ count(\\*)</font>，所以我建议你，尽量使用  count(\\*)。\n\n### MyISAM下的count\n\nMyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。\n\n## 参考\n\n- 《MYSQL实战45讲》","source":"_posts/mysql-count.md","raw":"---\ntitle: MySQL之count(*)、count(1)、count(字段)\ntags:\n  - mysql\ncategories:  mysql\ndescription : 详解MySQL之count(*)、count(1)、count(字段)\ndate: 2020-01-26 08:30:14\n---\n## 正文\ncount() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。\n<!--more-->\n### InnoDB下的count\n\ncount(*)、count(主键 id) 、 count(1) 都表示返回满足条件的结果集的总行数。而count(字段)则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。\n- **对于count(主键id)来说**，InnoDB引擎会遍历整张表，把每一行的id值取出来，返回给server层。server 层拿到 id 后，判断是不可能为空的，就按行累加。由于主键是不可能为NULL的，所以count(主键id)是忽略NULL的。\n\n  \n\n- **对于 count(1) 来说**，InnoDB 引擎遍历整张表，<font color=red>但不取值</font>。server层对于返回的每一行，放一个数字\"1\"进去，判断是不可能为空，按行累加。所以count(主键id)是忽略NULL的。\n\n  \n\n- **对于 count(字段) 来说**，所以count(字段)根据字段是否定义为not null来判断是否忽略NULL。\n  \n  - 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加\n  - 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加\n  \n  \n  \n- **但是 count(\\*) 是例外**，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。\n\n所以结论是：按照效率排序的话，<font size=5 color=red>count(字段) < count(主键 id) < count(1) ≈ count(\\*)</font>，所以我建议你，尽量使用  count(\\*)。\n\n### MyISAM下的count\n\nMyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。\n\n## 参考\n\n- 《MYSQL实战45讲》","slug":"mysql-count","published":1,"updated":"2021-04-08T00:47:06.837Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhv8001bqwv2a2f8989q","content":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p>\n<a id=\"more\"></a>\n<h3 id=\"InnoDB下的count\"><a href=\"#InnoDB下的count\" class=\"headerlink\" title=\"InnoDB下的count\"></a>InnoDB下的count</h3><p>count(*)、count(主键 id) 、 count(1) 都表示返回满足条件的结果集的总行数。而count(字段)则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>\n<ul>\n<li><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值取出来，返回给server层。server 层拿到 id 后，判断是不可能为空的，就按行累加。由于主键是不可能为NULL的，所以count(主键id)是忽略NULL的。</li>\n</ul>\n<ul>\n<li><strong>对于 count(1) 来说</strong>，InnoDB 引擎遍历整张表，<font color=\"red\">但不取值</font>。server层对于返回的每一行，放一个数字”1”进去，判断是不可能为空，按行累加。所以count(主键id)是忽略NULL的。</li>\n</ul>\n<ul>\n<li><p><strong>对于 count(字段) 来说</strong>，所以count(字段)根据字段是否定义为not null来判断是否忽略NULL。</p>\n<ul>\n<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加</li>\n<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>但是 count(*) 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</li>\n</ul>\n<p>所以结论是：按照效率排序的话，<font size=\"5\" color=\"red\">count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</font>，所以我建议你，尽量使用  count(*)。</p>\n<h3 id=\"MyISAM下的count\"><a href=\"#MyISAM下的count\" class=\"headerlink\" title=\"MyISAM下的count\"></a>MyISAM下的count</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《MYSQL实战45讲》</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值。</p>","more":"<h3 id=\"InnoDB下的count\"><a href=\"#InnoDB下的count\" class=\"headerlink\" title=\"InnoDB下的count\"></a>InnoDB下的count</h3><p>count(*)、count(主键 id) 、 count(1) 都表示返回满足条件的结果集的总行数。而count(字段)则表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。</p>\n<ul>\n<li><strong>对于count(主键id)来说</strong>，InnoDB引擎会遍历整张表，把每一行的id值取出来，返回给server层。server 层拿到 id 后，判断是不可能为空的，就按行累加。由于主键是不可能为NULL的，所以count(主键id)是忽略NULL的。</li>\n</ul>\n<ul>\n<li><strong>对于 count(1) 来说</strong>，InnoDB 引擎遍历整张表，<font color=\"red\">但不取值</font>。server层对于返回的每一行，放一个数字”1”进去，判断是不可能为空，按行累加。所以count(主键id)是忽略NULL的。</li>\n</ul>\n<ul>\n<li><p><strong>对于 count(字段) 来说</strong>，所以count(字段)根据字段是否定义为not null来判断是否忽略NULL。</p>\n<ul>\n<li>如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加</li>\n<li>如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>但是 count(*) 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</li>\n</ul>\n<p>所以结论是：按照效率排序的话，<font size=\"5\" color=\"red\">count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</font>，所以我建议你，尽量使用  count(*)。</p>\n<h3 id=\"MyISAM下的count\"><a href=\"#MyISAM下的count\" class=\"headerlink\" title=\"MyISAM下的count\"></a>MyISAM下的count</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《MYSQL实战45讲》</li>\n</ul>"},{"title":"限流原理与guava单机限流","description":"介绍两种限流算法(漏桶算法/令牌桶算法)与guava单机限流使用","date":"2019-02-18T09:14:00.000Z","_content":"## 限流算法\n常见限流算法常用的限流算法有：令牌桶，漏桶、滑动窗口算法。\n<!--more-->\n### 漏桶算法\n#### 算法介绍\n漏桶算法的描述如下：\n\n- 一个固定容量的漏桶，按照常量固定速率流出水滴\n- 如果桶是空的，则不需流出水滴\n- 可以以任意速率流入水滴到漏桶\n- 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的\n\n![](limit-single/1.png)\n\n漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。\n我们将请求比喻成图上的流入水滴，水桶的容量表示最大能容纳的请求数，因为桶下面的流出率是固定的，当流入水滴(请求)过大时会造成水溢出，溢出的水滴(请求)则直接丢弃。\n可见这里有两个变量,一个是桶的大小,支持流量突发增多时可以存多少的水(burst),另一个是水桶漏洞的大小(rate)。\n\n#### 特点和局限性\n由于漏桶算法的流出速率是固定的，所以对于一些业务场景下要求能够突发传输，这时候漏桶算法就不适用了。\n### 令牌桶算法\n#### 算法介绍\n令牌桶算法是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。\n- 假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌；\n- 桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝；\n- 当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上；\n- 如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。\n![](limit-single/2.png)\n\n#### 特点和局限性\n令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量\n\n## Guava 限流\nGuava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。\n```\n//表示消费permits个令牌,如果桶中令牌足够则返回0.0,如果令牌不足则需要阻塞等待到令牌足够后才执行。\nlimiter.acquire(int permits)\n//表示一次性获取permits个令牌，判断如果在timeout秒内能获取得到令牌则阻塞直到获取到令牌，如果不行就直接返回false\nlimiter.tryAcquire(int permits,long timeout, TimeUnit unit)\n```\n\n### 平滑突发限流\n这种实现将突发请求速率平均为了固定请求速率\n```\n//表示桶容量初始为5，每秒5个的速率新增令牌，即每隔200毫秒新增一个令牌\nRateLimiter limiter = RateLimiter.create(5);\n```\n\n```\nRateLimiter limiter = RateLimiter.create(5);\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\n//输出\n0.0\n0.185957\n0.19372\n0.197661\n0.199752\n0.174605\n```\n首先初始化了一个速率为5r/s的令牌桶，接下去每次获取一个，按照200ms生成一个的话，每次获取需要阻塞0.19=200ms的时间\n\n\n```\nRateLimiter limiter = RateLimiter.create(5);\nSystem.out.println(limiter.acquire(200));\nlong start = System.currentTimeMillis();\nSystem.out.println(limiter.acquire(1));\nSystem.out.println((System.currentTimeMillis() - start) + \" ms\");\n//输出结果\n//0.0\n//39.973065\n//39980 ms\n```\n首先创建了一个容量初始为5，且每秒5个的速率新增令牌，即每隔200毫秒新增一个令牌。\n第一次调用acquire(200)从桶中获取200个令牌，由于令牌桶是支持突发的，所以第一次允许获取200个，当第二次调用acquire(1)从桶中获取1个令牌时，由于前面透支了，按照每秒5个的速率则需要在40秒后才能获得令牌，所以需要**阻塞等待**桶中补充令牌。\n\n**tryAcquire方法使用**\n\n```\n//RateLimiter.create(5) 表示桶容量为5且每秒新增5个令牌，即每隔200毫秒新增一个令牌；\nRateLimiter limiter = RateLimiter.create(5);\n//因为允许突发，第一次取100个，那么接下去20秒的请求都会被拒绝\nSystem.out.println(limiter.tryAcquire(100));\nlong start = System.currentTimeMillis();\nSystem.out.println(limiter.tryAcquire(5,60,TimeUnit.SECONDS));\nSystem.out.println((System.currentTimeMillis() - start) + \" ms\");\n//到这一步已经桶里面已经没有令牌了,所以接下去返回false\nSystem.out.println(limiter.tryAcquire(1));\nTimeUnit.SECONDS.sleep(1);\n//等待1秒后，桶里新生成了5个令牌，所以接下去获取返回true\nSystem.out.println(limiter.tryAcquire(5));\n输出结果\ntrue\ntrue\n19999 ms\nfalse\ntrue\n```\n\n\n平滑方式自己感觉会有一点点担心，例如是允许突发的，如果突发的数量太多一瞬间就压垮服务器了，所以Guava还提供了**平滑预热限流**\n### 平滑预热限流\n\n```\npermitsPerSecond表示每秒新增的令牌数，warmupPeriod表示在从冷启动速率过渡到平均速率的时间间隔\nRateLimiter limiter = RateLimiter.create(5, 1000, TimeUnit.MILLISECONDS);\n```\n\n```\nRateLimiter limiter = RateLimiter.create(5, 1000, TimeUnit.MILLISECONDS);\nfor(int i = 0; i < 5;i++) {\n    System.out.println(limiter.acquire());\n}\nThread.sleep(1000L);\nfor(int i = 0; i < 5;i++) {\n    System.out.println(limiter.acquire());\n}\n//输出结果:\n0.0\n0.5156\n0.353969\n0.219001\n0.200086\n0.0\n0.3806\n0.229003\n0.199237\n0.200266\n```\n速率是梯形上升速率的，也就是说冷启动时会以一个比较大的速率慢慢到平均速率；然后趋于平均速率（梯形下降到平均速率）。可以通过调节warmupPeriod参数实现一开始就是平滑固定速率。\n\n## 参考\n- https://blog.csdn.net/John8169/article/details/81125706\n- https://my.oschina.net/hanchao/blog/1833612?appinstall=0","source":"_posts/limit-single.md","raw":"---\ntitle: 限流原理与guava单机限流\ntags:\n  - 项目实践\ncategories:  java\ndescription : 介绍两种限流算法(漏桶算法/令牌桶算法)与guava单机限流使用\ndate: 2019-02-18 17:14:00\n---\n## 限流算法\n常见限流算法常用的限流算法有：令牌桶，漏桶、滑动窗口算法。\n<!--more-->\n### 漏桶算法\n#### 算法介绍\n漏桶算法的描述如下：\n\n- 一个固定容量的漏桶，按照常量固定速率流出水滴\n- 如果桶是空的，则不需流出水滴\n- 可以以任意速率流入水滴到漏桶\n- 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的\n\n![](limit-single/1.png)\n\n漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。\n我们将请求比喻成图上的流入水滴，水桶的容量表示最大能容纳的请求数，因为桶下面的流出率是固定的，当流入水滴(请求)过大时会造成水溢出，溢出的水滴(请求)则直接丢弃。\n可见这里有两个变量,一个是桶的大小,支持流量突发增多时可以存多少的水(burst),另一个是水桶漏洞的大小(rate)。\n\n#### 特点和局限性\n由于漏桶算法的流出速率是固定的，所以对于一些业务场景下要求能够突发传输，这时候漏桶算法就不适用了。\n### 令牌桶算法\n#### 算法介绍\n令牌桶算法是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。\n- 假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌；\n- 桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝；\n- 当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上；\n- 如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。\n![](limit-single/2.png)\n\n#### 特点和局限性\n令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量\n\n## Guava 限流\nGuava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。\n```\n//表示消费permits个令牌,如果桶中令牌足够则返回0.0,如果令牌不足则需要阻塞等待到令牌足够后才执行。\nlimiter.acquire(int permits)\n//表示一次性获取permits个令牌，判断如果在timeout秒内能获取得到令牌则阻塞直到获取到令牌，如果不行就直接返回false\nlimiter.tryAcquire(int permits,long timeout, TimeUnit unit)\n```\n\n### 平滑突发限流\n这种实现将突发请求速率平均为了固定请求速率\n```\n//表示桶容量初始为5，每秒5个的速率新增令牌，即每隔200毫秒新增一个令牌\nRateLimiter limiter = RateLimiter.create(5);\n```\n\n```\nRateLimiter limiter = RateLimiter.create(5);\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\n//输出\n0.0\n0.185957\n0.19372\n0.197661\n0.199752\n0.174605\n```\n首先初始化了一个速率为5r/s的令牌桶，接下去每次获取一个，按照200ms生成一个的话，每次获取需要阻塞0.19=200ms的时间\n\n\n```\nRateLimiter limiter = RateLimiter.create(5);\nSystem.out.println(limiter.acquire(200));\nlong start = System.currentTimeMillis();\nSystem.out.println(limiter.acquire(1));\nSystem.out.println((System.currentTimeMillis() - start) + \" ms\");\n//输出结果\n//0.0\n//39.973065\n//39980 ms\n```\n首先创建了一个容量初始为5，且每秒5个的速率新增令牌，即每隔200毫秒新增一个令牌。\n第一次调用acquire(200)从桶中获取200个令牌，由于令牌桶是支持突发的，所以第一次允许获取200个，当第二次调用acquire(1)从桶中获取1个令牌时，由于前面透支了，按照每秒5个的速率则需要在40秒后才能获得令牌，所以需要**阻塞等待**桶中补充令牌。\n\n**tryAcquire方法使用**\n\n```\n//RateLimiter.create(5) 表示桶容量为5且每秒新增5个令牌，即每隔200毫秒新增一个令牌；\nRateLimiter limiter = RateLimiter.create(5);\n//因为允许突发，第一次取100个，那么接下去20秒的请求都会被拒绝\nSystem.out.println(limiter.tryAcquire(100));\nlong start = System.currentTimeMillis();\nSystem.out.println(limiter.tryAcquire(5,60,TimeUnit.SECONDS));\nSystem.out.println((System.currentTimeMillis() - start) + \" ms\");\n//到这一步已经桶里面已经没有令牌了,所以接下去返回false\nSystem.out.println(limiter.tryAcquire(1));\nTimeUnit.SECONDS.sleep(1);\n//等待1秒后，桶里新生成了5个令牌，所以接下去获取返回true\nSystem.out.println(limiter.tryAcquire(5));\n输出结果\ntrue\ntrue\n19999 ms\nfalse\ntrue\n```\n\n\n平滑方式自己感觉会有一点点担心，例如是允许突发的，如果突发的数量太多一瞬间就压垮服务器了，所以Guava还提供了**平滑预热限流**\n### 平滑预热限流\n\n```\npermitsPerSecond表示每秒新增的令牌数，warmupPeriod表示在从冷启动速率过渡到平均速率的时间间隔\nRateLimiter limiter = RateLimiter.create(5, 1000, TimeUnit.MILLISECONDS);\n```\n\n```\nRateLimiter limiter = RateLimiter.create(5, 1000, TimeUnit.MILLISECONDS);\nfor(int i = 0; i < 5;i++) {\n    System.out.println(limiter.acquire());\n}\nThread.sleep(1000L);\nfor(int i = 0; i < 5;i++) {\n    System.out.println(limiter.acquire());\n}\n//输出结果:\n0.0\n0.5156\n0.353969\n0.219001\n0.200086\n0.0\n0.3806\n0.229003\n0.199237\n0.200266\n```\n速率是梯形上升速率的，也就是说冷启动时会以一个比较大的速率慢慢到平均速率；然后趋于平均速率（梯形下降到平均速率）。可以通过调节warmupPeriod参数实现一开始就是平滑固定速率。\n\n## 参考\n- https://blog.csdn.net/John8169/article/details/81125706\n- https://my.oschina.net/hanchao/blog/1833612?appinstall=0","slug":"limit-single","published":1,"updated":"2021-04-08T00:47:06.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhv9001eqwv28yb05t1b","content":"<h2 id=\"限流算法\"><a href=\"#限流算法\" class=\"headerlink\" title=\"限流算法\"></a>限流算法</h2><p>常见限流算法常用的限流算法有：令牌桶，漏桶、滑动窗口算法。</p>\n<a id=\"more\"></a>\n<h3 id=\"漏桶算法\"><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h3><h4 id=\"算法介绍\"><a href=\"#算法介绍\" class=\"headerlink\" title=\"算法介绍\"></a>算法介绍</h4><p>漏桶算法的描述如下：</p>\n<ul>\n<li>一个固定容量的漏桶，按照常量固定速率流出水滴</li>\n<li>如果桶是空的，则不需流出水滴</li>\n<li>可以以任意速率流入水滴到漏桶</li>\n<li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的</li>\n</ul>\n<p><img src=\"/2019/02/18/limit-single/1.png\" alt></p>\n<p>漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。<br>我们将请求比喻成图上的流入水滴，水桶的容量表示最大能容纳的请求数，因为桶下面的流出率是固定的，当流入水滴(请求)过大时会造成水溢出，溢出的水滴(请求)则直接丢弃。<br>可见这里有两个变量,一个是桶的大小,支持流量突发增多时可以存多少的水(burst),另一个是水桶漏洞的大小(rate)。</p>\n<h4 id=\"特点和局限性\"><a href=\"#特点和局限性\" class=\"headerlink\" title=\"特点和局限性\"></a>特点和局限性</h4><p>由于漏桶算法的流出速率是固定的，所以对于一些业务场景下要求能够突发传输，这时候漏桶算法就不适用了。</p>\n<h3 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h3><h4 id=\"算法介绍-1\"><a href=\"#算法介绍-1\" class=\"headerlink\" title=\"算法介绍\"></a>算法介绍</h4><p>令牌桶算法是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。</p>\n<ul>\n<li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌；</li>\n<li>桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝；</li>\n<li>当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上；</li>\n<li>如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。<br><img src=\"/2019/02/18/limit-single/2.png\" alt></li>\n</ul>\n<h4 id=\"特点和局限性-1\"><a href=\"#特点和局限性-1\" class=\"headerlink\" title=\"特点和局限性\"></a>特点和局限性</h4><p>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量</p>\n<h2 id=\"Guava-限流\"><a href=\"#Guava-限流\" class=\"headerlink\" title=\"Guava 限流\"></a>Guava 限流</h2><p>Guava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。</p>\n<pre><code>//表示消费permits个令牌,如果桶中令牌足够则返回0.0,如果令牌不足则需要阻塞等待到令牌足够后才执行。\nlimiter.acquire(int permits)\n//表示一次性获取permits个令牌，判断如果在timeout秒内能获取得到令牌则阻塞直到获取到令牌，如果不行就直接返回false\nlimiter.tryAcquire(int permits,long timeout, TimeUnit unit)</code></pre><h3 id=\"平滑突发限流\"><a href=\"#平滑突发限流\" class=\"headerlink\" title=\"平滑突发限流\"></a>平滑突发限流</h3><p>这种实现将突发请求速率平均为了固定请求速率</p>\n<pre><code>//表示桶容量初始为5，每秒5个的速率新增令牌，即每隔200毫秒新增一个令牌\nRateLimiter limiter = RateLimiter.create(5);</code></pre><pre><code>RateLimiter limiter = RateLimiter.create(5);\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\n//输出\n0.0\n0.185957\n0.19372\n0.197661\n0.199752\n0.174605</code></pre><p>首先初始化了一个速率为5r/s的令牌桶，接下去每次获取一个，按照200ms生成一个的话，每次获取需要阻塞0.19=200ms的时间</p>\n<pre><code>RateLimiter limiter = RateLimiter.create(5);\nSystem.out.println(limiter.acquire(200));\nlong start = System.currentTimeMillis();\nSystem.out.println(limiter.acquire(1));\nSystem.out.println((System.currentTimeMillis() - start) + &quot; ms&quot;);\n//输出结果\n//0.0\n//39.973065\n//39980 ms</code></pre><p>首先创建了一个容量初始为5，且每秒5个的速率新增令牌，即每隔200毫秒新增一个令牌。<br>第一次调用acquire(200)从桶中获取200个令牌，由于令牌桶是支持突发的，所以第一次允许获取200个，当第二次调用acquire(1)从桶中获取1个令牌时，由于前面透支了，按照每秒5个的速率则需要在40秒后才能获得令牌，所以需要<strong>阻塞等待</strong>桶中补充令牌。</p>\n<p><strong>tryAcquire方法使用</strong></p>\n<pre><code>//RateLimiter.create(5) 表示桶容量为5且每秒新增5个令牌，即每隔200毫秒新增一个令牌；\nRateLimiter limiter = RateLimiter.create(5);\n//因为允许突发，第一次取100个，那么接下去20秒的请求都会被拒绝\nSystem.out.println(limiter.tryAcquire(100));\nlong start = System.currentTimeMillis();\nSystem.out.println(limiter.tryAcquire(5,60,TimeUnit.SECONDS));\nSystem.out.println((System.currentTimeMillis() - start) + &quot; ms&quot;);\n//到这一步已经桶里面已经没有令牌了,所以接下去返回false\nSystem.out.println(limiter.tryAcquire(1));\nTimeUnit.SECONDS.sleep(1);\n//等待1秒后，桶里新生成了5个令牌，所以接下去获取返回true\nSystem.out.println(limiter.tryAcquire(5));\n输出结果\ntrue\ntrue\n19999 ms\nfalse\ntrue</code></pre><p>平滑方式自己感觉会有一点点担心，例如是允许突发的，如果突发的数量太多一瞬间就压垮服务器了，所以Guava还提供了<strong>平滑预热限流</strong></p>\n<h3 id=\"平滑预热限流\"><a href=\"#平滑预热限流\" class=\"headerlink\" title=\"平滑预热限流\"></a>平滑预热限流</h3><pre><code>permitsPerSecond表示每秒新增的令牌数，warmupPeriod表示在从冷启动速率过渡到平均速率的时间间隔\nRateLimiter limiter = RateLimiter.create(5, 1000, TimeUnit.MILLISECONDS);</code></pre><pre><code>RateLimiter limiter = RateLimiter.create(5, 1000, TimeUnit.MILLISECONDS);\nfor(int i = 0; i &lt; 5;i++) {\n    System.out.println(limiter.acquire());\n}\nThread.sleep(1000L);\nfor(int i = 0; i &lt; 5;i++) {\n    System.out.println(limiter.acquire());\n}\n//输出结果:\n0.0\n0.5156\n0.353969\n0.219001\n0.200086\n0.0\n0.3806\n0.229003\n0.199237\n0.200266</code></pre><p>速率是梯形上升速率的，也就是说冷启动时会以一个比较大的速率慢慢到平均速率；然后趋于平均速率（梯形下降到平均速率）。可以通过调节warmupPeriod参数实现一开始就是平滑固定速率。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/John8169/article/details/81125706\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/John8169/article/details/81125706</a></li>\n<li><a href=\"https://my.oschina.net/hanchao/blog/1833612?appinstall=0\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/hanchao/blog/1833612?appinstall=0</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"限流算法\"><a href=\"#限流算法\" class=\"headerlink\" title=\"限流算法\"></a>限流算法</h2><p>常见限流算法常用的限流算法有：令牌桶，漏桶、滑动窗口算法。</p>","more":"<h3 id=\"漏桶算法\"><a href=\"#漏桶算法\" class=\"headerlink\" title=\"漏桶算法\"></a>漏桶算法</h3><h4 id=\"算法介绍\"><a href=\"#算法介绍\" class=\"headerlink\" title=\"算法介绍\"></a>算法介绍</h4><p>漏桶算法的描述如下：</p>\n<ul>\n<li>一个固定容量的漏桶，按照常量固定速率流出水滴</li>\n<li>如果桶是空的，则不需流出水滴</li>\n<li>可以以任意速率流入水滴到漏桶</li>\n<li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的</li>\n</ul>\n<p><img src=\"/2019/02/18/limit-single/1.png\" alt></p>\n<p>漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会直接溢出，可以看出漏桶算法能强行限制数据的传输速率。<br>我们将请求比喻成图上的流入水滴，水桶的容量表示最大能容纳的请求数，因为桶下面的流出率是固定的，当流入水滴(请求)过大时会造成水溢出，溢出的水滴(请求)则直接丢弃。<br>可见这里有两个变量,一个是桶的大小,支持流量突发增多时可以存多少的水(burst),另一个是水桶漏洞的大小(rate)。</p>\n<h4 id=\"特点和局限性\"><a href=\"#特点和局限性\" class=\"headerlink\" title=\"特点和局限性\"></a>特点和局限性</h4><p>由于漏桶算法的流出速率是固定的，所以对于一些业务场景下要求能够突发传输，这时候漏桶算法就不适用了。</p>\n<h3 id=\"令牌桶算法\"><a href=\"#令牌桶算法\" class=\"headerlink\" title=\"令牌桶算法\"></a>令牌桶算法</h3><h4 id=\"算法介绍-1\"><a href=\"#算法介绍-1\" class=\"headerlink\" title=\"算法介绍\"></a>算法介绍</h4><p>令牌桶算法是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。</p>\n<ul>\n<li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌；</li>\n<li>桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝；</li>\n<li>当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上；</li>\n<li>如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。<br><img src=\"/2019/02/18/limit-single/2.png\" alt></li>\n</ul>\n<h4 id=\"特点和局限性-1\"><a href=\"#特点和局限性-1\" class=\"headerlink\" title=\"特点和局限性\"></a>特点和局限性</h4><p>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量</p>\n<h2 id=\"Guava-限流\"><a href=\"#Guava-限流\" class=\"headerlink\" title=\"Guava 限流\"></a>Guava 限流</h2><p>Guava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。</p>\n<pre><code>//表示消费permits个令牌,如果桶中令牌足够则返回0.0,如果令牌不足则需要阻塞等待到令牌足够后才执行。\nlimiter.acquire(int permits)\n//表示一次性获取permits个令牌，判断如果在timeout秒内能获取得到令牌则阻塞直到获取到令牌，如果不行就直接返回false\nlimiter.tryAcquire(int permits,long timeout, TimeUnit unit)</code></pre><h3 id=\"平滑突发限流\"><a href=\"#平滑突发限流\" class=\"headerlink\" title=\"平滑突发限流\"></a>平滑突发限流</h3><p>这种实现将突发请求速率平均为了固定请求速率</p>\n<pre><code>//表示桶容量初始为5，每秒5个的速率新增令牌，即每隔200毫秒新增一个令牌\nRateLimiter limiter = RateLimiter.create(5);</code></pre><pre><code>RateLimiter limiter = RateLimiter.create(5);\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\nSystem.out.println(limiter.acquire());\n//输出\n0.0\n0.185957\n0.19372\n0.197661\n0.199752\n0.174605</code></pre><p>首先初始化了一个速率为5r/s的令牌桶，接下去每次获取一个，按照200ms生成一个的话，每次获取需要阻塞0.19=200ms的时间</p>\n<pre><code>RateLimiter limiter = RateLimiter.create(5);\nSystem.out.println(limiter.acquire(200));\nlong start = System.currentTimeMillis();\nSystem.out.println(limiter.acquire(1));\nSystem.out.println((System.currentTimeMillis() - start) + &quot; ms&quot;);\n//输出结果\n//0.0\n//39.973065\n//39980 ms</code></pre><p>首先创建了一个容量初始为5，且每秒5个的速率新增令牌，即每隔200毫秒新增一个令牌。<br>第一次调用acquire(200)从桶中获取200个令牌，由于令牌桶是支持突发的，所以第一次允许获取200个，当第二次调用acquire(1)从桶中获取1个令牌时，由于前面透支了，按照每秒5个的速率则需要在40秒后才能获得令牌，所以需要<strong>阻塞等待</strong>桶中补充令牌。</p>\n<p><strong>tryAcquire方法使用</strong></p>\n<pre><code>//RateLimiter.create(5) 表示桶容量为5且每秒新增5个令牌，即每隔200毫秒新增一个令牌；\nRateLimiter limiter = RateLimiter.create(5);\n//因为允许突发，第一次取100个，那么接下去20秒的请求都会被拒绝\nSystem.out.println(limiter.tryAcquire(100));\nlong start = System.currentTimeMillis();\nSystem.out.println(limiter.tryAcquire(5,60,TimeUnit.SECONDS));\nSystem.out.println((System.currentTimeMillis() - start) + &quot; ms&quot;);\n//到这一步已经桶里面已经没有令牌了,所以接下去返回false\nSystem.out.println(limiter.tryAcquire(1));\nTimeUnit.SECONDS.sleep(1);\n//等待1秒后，桶里新生成了5个令牌，所以接下去获取返回true\nSystem.out.println(limiter.tryAcquire(5));\n输出结果\ntrue\ntrue\n19999 ms\nfalse\ntrue</code></pre><p>平滑方式自己感觉会有一点点担心，例如是允许突发的，如果突发的数量太多一瞬间就压垮服务器了，所以Guava还提供了<strong>平滑预热限流</strong></p>\n<h3 id=\"平滑预热限流\"><a href=\"#平滑预热限流\" class=\"headerlink\" title=\"平滑预热限流\"></a>平滑预热限流</h3><pre><code>permitsPerSecond表示每秒新增的令牌数，warmupPeriod表示在从冷启动速率过渡到平均速率的时间间隔\nRateLimiter limiter = RateLimiter.create(5, 1000, TimeUnit.MILLISECONDS);</code></pre><pre><code>RateLimiter limiter = RateLimiter.create(5, 1000, TimeUnit.MILLISECONDS);\nfor(int i = 0; i &lt; 5;i++) {\n    System.out.println(limiter.acquire());\n}\nThread.sleep(1000L);\nfor(int i = 0; i &lt; 5;i++) {\n    System.out.println(limiter.acquire());\n}\n//输出结果:\n0.0\n0.5156\n0.353969\n0.219001\n0.200086\n0.0\n0.3806\n0.229003\n0.199237\n0.200266</code></pre><p>速率是梯形上升速率的，也就是说冷启动时会以一个比较大的速率慢慢到平均速率；然后趋于平均速率（梯形下降到平均速率）。可以通过调节warmupPeriod参数实现一开始就是平滑固定速率。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://blog.csdn.net/John8169/article/details/81125706\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/John8169/article/details/81125706</a></li>\n<li><a href=\"https://my.oschina.net/hanchao/blog/1833612?appinstall=0\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/hanchao/blog/1833612?appinstall=0</a></li>\n</ul>"},{"title":"Linux命令之netstat与TCP详解","description":"Linux命令之netstat与TCP详解","_content":"## TCP\n\n传输控制协议（*TCP*，Transmission Control Protocol）是一种<font color=red>面向连接的</font>、<font color=red>可靠的</font>、<font color=red>基于字节流</font>的传输层通信协议。本人是这样理解面向连接和可靠性的。\n\n面向连接指的客户端/服务器在使用TCP进行数据传输时必须先建立一个TCP连接。连接的手段就是进行三次握手，关闭时需要四次挥手。\n\n可靠性指的是保证发送的数据<font color=red>无差错，无重复，按顺序，不丢失</font>。可靠性的保证主要通过如下手段实现：\n\n- 序列号，ACK信号：发送方按照顺序给要发送的数据包的每个字节都标上编号。接收方接收到发送方的数据包之后，回传一个ACK信号，标识下一个需求的数据包初始字节编号。（可以保证顺序）\n- 超时重发：在等待接收方回传的ACK信号超时后，发送方重发数据包。一旦开始重传，下一次等待的时间间隔指数增长，重发一定次数后还是收不到ACK信号，将强制终止连接。\n-  TCP的连接管理：建立连接的三次握手和断开连接的四次挥手。（保证安全）\n- 以段为单位发送数据包：在建立TCP连接的同时，两端协商发送数据包的单位，称为“最大消息长度”：MSS。\n-  滑动窗口：以段为单位发送数据包，每发送一个数据包需要等待一个ACK信号，当数据包往返时间越长效率越低。滑动窗口中窗口前端为已发送但为收到ACK的数据，后端为待发送数据。发送端一次发送多个数据，接收端回传收到的连续数据的ACK信号，缓存缺失数据之后的数据包(保持顺序)。发送端当收到ACK信号时，窗口向前依次移动，直到遇到有数据未确认时停止。一段时间后启动超时重传，接收端若收到缺失数据，则和缓存数据一起发送ACK信号，否则，抛弃缓存数据。\n- 流量控制：TCP首部有一个字段来通知窗口的大小，接收端通过设置来主动控制传输流量。\n- 拥塞控制：发送端通过拥塞窗口主动控制传输流量。慢启动：防止双方通信刚开始就传送大量数据包，发送端拥塞窗口初始设置为1MSS，每接受一个ACK信号，窗口扩大为两倍。发送数据时，取拥塞窗口和滑动窗口的较小值。同时设定一个慢启动阈值，当拥塞窗口大小超过阈值时，改为线性增长，直到网络拥塞。拥塞时将慢启动阈值设置为当前窗口的的一半，并将拥塞窗口的值设置为1，然后再次重复操作。\n\n## TCP三次握手和四次挥手\n\n一个正常的TCP连接，都会有三个阶段:\n\n- TCP三次握手。\n- 数据传送。\n- TCP四次挥手。\n\n![三次握手](linux-netstat/1.png)\n\n### 三次握手\n\n![三次握手与状态](linux-netstat/2.png)\n\n**三次握手说明：**\n\n1. 客户端发送TCP连接的请求报文，其中SYN=1表示建立TCP连接，seq表示序列号，x为随机序列号。客户端发送后将自己的状态设置成`SYN_SENT`状态。\n2. 服务单回复客户都按发送的TCP请求报文，seq=y表示序列号，y由服务端生成的随机数,SYN=1表示建立TCP连接（服务端也回复这个，表示我同意建立连接了），而且会产生ack字段，ack字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证，这里的ack加1可以理解为是确认和谁建立连接。\n3. 客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。\n\n上面的SYN，seq，ack我们可以缕一缕意思。\n\n- 其中SYN表示是要建立TCP连接，所以值都是为1。\n- seq表示发送的序列号，ack表示报文到达的确认。所以我们可以看到客户端假设发了seq=100，那么服务端确认后就发ack=100+1表示我确认了。然后服务端回复时也发了一个seq=200（这里200是图中的y），客户端确认后发送ack=200+1。\n- seq和ack的作用是保证传输可靠性，顺序性。\n\n### 四次挥手\n\n![四次挥手与状态](linux-netstat/3.png)\n\n1. 客户端发送TCP断开请求的报文，其中FIN=1表示要断开连接的请求，seq表示序列号，x是随机生成的。\n2. 服务端收到请求后回复客户端，ack表示回复确认，seq=y随机序列号。\n3. 第二步服务端回复完客户端后并不是一下子就断开，服务端需要保障所有传输到客户端的数据是否已经传输完毕，如果完毕了然后发送FIN=1表示我同意断开了，然后seq=y就是发送自己这边的随机序列号。\n4.客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。\n\n### TCP的11种状态\n\n![](linux-netstat/4.png)\n\n1. 一开始，建立连接之前服务器和客户端的状态都为CLOSED。\n2. 服务器创建socket后开始监听，变为LISTEN状态。\n3. 客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT。\n4. 服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD。\n5. 然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED。\n6. 服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立。\n\n![](linux-netstat/5.png)\n\n由于TCP连接是全双工的，断开连接会比建立连接麻烦一点点。 \n1. 客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1； \n2. 服务器收到FIN后向客户端发送ACK，服务器的状态变成CLOSE_WAIT； \n3. 客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送； \n4. 直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态； \n5. 客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态； \n6. 再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。 \n至此，还有一个状态没有出来：CLOSING状态。 \n\n**状态解释**\n\n| 状态         | 说明                                                         |\n| ------------ | ------------------------------------------------------------ |\n| LISTEN       | 等待从任何远端TCP 和端口的连接请求                           |\n| SYN_SENT     | 发送完一个连接请求后等待一个匹配的连接请求                   |\n| SYN_RECEIVED | 发送连接请求并且接收到匹配的连接请求以后等待连接请求确认     |\n| ESTABLISHED  | 连接完成，连接的数据传输阶段的正常状态                       |\n| FIN_WAIT_1   | 等待远端TCP的连接终止请求，或者等待之前发送的连接终止请求的确认 |\n| FIN_WAIT_2   | 等待远端TCP的连接终止请求                                    |\n| CLOSE_WAIT   | 等待本地用户的连接终止请求                                   |\n| CLOSING      | 等待远端TCP的连接终止请求确认                                |\n| LAST_ACK     | 等待先前发送给远端TCP的连接终止请求的确认                    |\n| TIME_WAIT    | 等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认 |\n\n### 常见问题\n\n参考：https://juejin.cn/post/6900439208641921038\n\n**为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次**\n\n首先要理解TCP是面向连接的，所以他需要通过握手来建立连接。TCP也是可靠性的，他通过什么来保证可靠性呢？序列号，通过序列号来保证消息的有序性， 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤，那为什么不是两次？\n\nhttps://blog.csdn.net/lengxiao1993/article/details/82771768\n\n**两次握手过程**\n\n1. A发送同步信号SYN + sequence\n2. B收到A的消息后，发送同步信号 SYN +  sequence + ACK（表示对A同步信号的确认）\n\n到此，如果只有两次，A能确定收到B的同步信号，但是B没法确定A是否收到自己发送的同步信号。这样可能造成的问题是，假如A发送了第一个连接请求后由于网络问题滞留，到了某个时间才到达B，此时这个报文是无效的，但是由于只有两次握手，B同意连接后发送ACK给A，A对于这个失效的报文不会理睬，导致B端一直等待浪费资源。\n\n**TCP报文结构**\n\n![](linux-netstat/6.png)\n\n其中，\n\n- 源端口和目的端口。\n- 位序号（seq）和确认号（ack）这个就是TCP通信时发送的，确认号而是和序列号配合使用的，应答某次请求时，则返回一个确认号，它的值等于对方请求序列号加1。\n- 6个标志位分别是，URG：这是条紧急信息，ACK:应答消息，PSH:缓冲区尚未填满，RST:重置连接，SYN:建立连接消息标志，FIN：连接关闭通知信息。\n- 滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。\n\n**TCP为什么说是可靠连接的**\n\nTCP的连接是基于三次握手，而断开则是四次挥手。为了保障数据不丢失及错误（可靠性），它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。\n\n**挥手时主动断开方状态在TIME_WAIT后为什么要等2MSL后才断开**\n\n1. TIME_WAIT的作用是为了保证最后一次挥手的ACK报文能送达给对方，如果ACK丢失，对方会超时重传FIN，主动关闭端会再次响应ACK过去；如果没有TIME_WAIT状态，直接关闭，对方重传的FIN报文则被响应一个RST报文，此RST会被动关闭端被解析成错误。\n2. MSL指的是\"报文最大生存时间\"，等待这个时间使本次连接所产生的报文段都从网络上消失，保证下一次的连接不会出现这种旧的连接请求的报文段。\n\n**TIME_WAIT和CLOSE_WAIT的区别**\n\nCLOSE_WAIT是被动关闭形成的，当对方发送FIN后，自己回应ACK后进入CLOSE_WAIT状态，随后检查是否存在未传输数据，如果没有则发起第三次挥手，发送FIN报文给对方，进入LAST_ACK状态并等待对方ACK报文到来。\n\nTIME_WAIT是主动关闭连接方式形成的；处于FIN_WAIT_2状态时，收到对方FIN报文后进入TIME_WAIT状态；之后再等待两个MSL(Maximum Segment Lifetime:报文最大生存时间)。\n\n**TCP和UDP的区别**\n\n1. udp是无连接的，tcp是面向连接的。\n2. udp是不可靠传输，tcp是可靠传输。\n3. udp是面向报文传输，tcp是面向字节流传输。\n4. udp不会发生粘包拆包，tcp会发生。\n\n**TCP的粘包拆包是怎么回事？如何解决？**\n\n网络通信采用的套接字(socket)技术，其实现实际是由系统内核提供一片连续缓存(流缓冲)来实现应用层程序与网卡接口之间的中转功能。多个数据包被连续存储于连续的缓存中，每个数据包的大小是不规定的。在对数据包进行读取时采用某一估测值大小（滑动窗口）来进行数据读出。例如缓冲里面目前有pag1=100字节，pag2=200字节，而我们采用估测值大小300字节的去读取的时候会将pag1,pag2都读取出来就发生了粘包。拆包同理，且拆包的话还有可能是大于MSS（最大报文长度），TCP在传输前将进行拆包了。\n\n解决方法:\n\n1. 在数据尾部增加特殊字符进行分割\n2. 将数据定为固定大小，少于固定大小的用填充数据填充\n3. 将数据分为两部分，一部分是头部，一部分是内容体。其中头部结构大小固定，且有一个字段声明内容体的大小\n\nhttps://zhuanlan.zhihu.com/p/90057929\n\n**Linux系统支持的最大TCP连接是多少**\n\nhttps://zhuanlan.zhihu.com/p/138263151\n\nhttps://blog.csdn.net/sqlquan/article/details/111561959\n\n**nagle算法有了解吗**\n\n## netstat\n\nnetstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。\n\n这个命令的参数太多，一般来说我们都是用它来查TCP连接的，然后看连接的状态对比对。\n\n```shell\n[root@Master1 ~]# netstat -ant #t表示只有展示TCP协议\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address               Foreign Address             State      \ntcp        0      0 0.0.0.0:63501               0.0.0.0:*                   LISTEN    \ntcp        1      0 127.0.0.1:44176             127.0.0.1:60047             CLOSE_WAIT  \ntcp        0      0 10.8.198.151:60884          10.8.2.30:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:55672          10.8.2.27:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:60882          10.8.2.30:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:63501          10.8.133.245:59893          ESTABLISHED \ntcp        0      0 10.8.198.151:60976          10.8.2.30:61235             TIME_WAIT    \ntcp        0      0 ::ffff:127.0.0.1:9600       :::*                        LISTEN      \ntcp        0      0 :::63501                    :::*                        LISTEN          \ntcp        0      0 ::ffff:10.8.198.151:60061   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        0      0 ::ffff:10.8.198.151:60050   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        1      0 ::1:60047                   ::1:43724                   CLOSE_WAIT  \ntcp        0      0 ::ffff:10.8.198.151:45024   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        0      0 ::ffff:10.8.198.151:43592   ::ffff:10.8.215.65:34710    TIME_WAIT  \n#Local Address - 源IP/端口\n#Foreign Address - 目标IP/端口\n#State 状态 - 对应上面说的TCP11个状态\n```\n\nnetstat命令有很多参数，这里就不一一说了。这个命令能帮助我们了解到具体的TCP的连接情况，例如我们可以通过如下命令知道当前服务器连接MySQL的状态。\n\n```\nnetstat -ant | grep 3306\n```\n\n## tcpdump\n\n用来抓包tcp协议的命令\n\n```shell\ntcpdump -n port 3306 #监控端口3306的TCP情况抓包 -n不把网络地址转换为名字\n# 发生了 3次握手\n11:38:15.679863 IP 172.18.0.5.38822 > 172.18.0.3.3306: Flags [S], seq 4065722321, win 29200, options [mss 1460,sackOK,TS val 2997352 ecr 0,nop,wscale 7], length 0\n11:38:15.679923 IP 172.18.0.3.3306 > 172.18.0.5.38822: Flags [S.], seq 780487619, ack 4065722322, win 28960, options [mss 1460,sackOK,TS val 2997352 ecr 2997352,nop,wscale 7], length 0\n11:38:15.679936 IP 172.18.0.5.38822 > 172.18.0.3.3306: Flags [.], ack 1, win 229, options [nop,nop,TS val 2997352 ecr 2997352], length 0\n```\n\n```shell\n# 监控端口3306的TCP情况并且截获所有10.8.152.162 的主机收到的和发出的所有的数据包\ntcpdump -n port 3306 and host 10.8.152.162 \n# 截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信\ntcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\) \n# 果想要获取主机210.27.48.1接收或发出的telnet包\ntcpdump tcp port 23 and host 210.27.48.1\n```\n\n## 参考\n\n- https://juejin.cn/post/6844903734300901390\n- [Linux tcpdump命令详解](https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html)\n- [wireshark抓包新手使用教程](https://www.cnblogs.com/mq0036/p/11187138.html)","source":"_posts/linux-netstat.md","raw":"---\ntitle: Linux命令之netstat与TCP详解\ntags:\n  - linux\n  - 网络\ncategories:  linux\ndescription: Linux命令之netstat与TCP详解\n---\n## TCP\n\n传输控制协议（*TCP*，Transmission Control Protocol）是一种<font color=red>面向连接的</font>、<font color=red>可靠的</font>、<font color=red>基于字节流</font>的传输层通信协议。本人是这样理解面向连接和可靠性的。\n\n面向连接指的客户端/服务器在使用TCP进行数据传输时必须先建立一个TCP连接。连接的手段就是进行三次握手，关闭时需要四次挥手。\n\n可靠性指的是保证发送的数据<font color=red>无差错，无重复，按顺序，不丢失</font>。可靠性的保证主要通过如下手段实现：\n\n- 序列号，ACK信号：发送方按照顺序给要发送的数据包的每个字节都标上编号。接收方接收到发送方的数据包之后，回传一个ACK信号，标识下一个需求的数据包初始字节编号。（可以保证顺序）\n- 超时重发：在等待接收方回传的ACK信号超时后，发送方重发数据包。一旦开始重传，下一次等待的时间间隔指数增长，重发一定次数后还是收不到ACK信号，将强制终止连接。\n-  TCP的连接管理：建立连接的三次握手和断开连接的四次挥手。（保证安全）\n- 以段为单位发送数据包：在建立TCP连接的同时，两端协商发送数据包的单位，称为“最大消息长度”：MSS。\n-  滑动窗口：以段为单位发送数据包，每发送一个数据包需要等待一个ACK信号，当数据包往返时间越长效率越低。滑动窗口中窗口前端为已发送但为收到ACK的数据，后端为待发送数据。发送端一次发送多个数据，接收端回传收到的连续数据的ACK信号，缓存缺失数据之后的数据包(保持顺序)。发送端当收到ACK信号时，窗口向前依次移动，直到遇到有数据未确认时停止。一段时间后启动超时重传，接收端若收到缺失数据，则和缓存数据一起发送ACK信号，否则，抛弃缓存数据。\n- 流量控制：TCP首部有一个字段来通知窗口的大小，接收端通过设置来主动控制传输流量。\n- 拥塞控制：发送端通过拥塞窗口主动控制传输流量。慢启动：防止双方通信刚开始就传送大量数据包，发送端拥塞窗口初始设置为1MSS，每接受一个ACK信号，窗口扩大为两倍。发送数据时，取拥塞窗口和滑动窗口的较小值。同时设定一个慢启动阈值，当拥塞窗口大小超过阈值时，改为线性增长，直到网络拥塞。拥塞时将慢启动阈值设置为当前窗口的的一半，并将拥塞窗口的值设置为1，然后再次重复操作。\n\n## TCP三次握手和四次挥手\n\n一个正常的TCP连接，都会有三个阶段:\n\n- TCP三次握手。\n- 数据传送。\n- TCP四次挥手。\n\n![三次握手](linux-netstat/1.png)\n\n### 三次握手\n\n![三次握手与状态](linux-netstat/2.png)\n\n**三次握手说明：**\n\n1. 客户端发送TCP连接的请求报文，其中SYN=1表示建立TCP连接，seq表示序列号，x为随机序列号。客户端发送后将自己的状态设置成`SYN_SENT`状态。\n2. 服务单回复客户都按发送的TCP请求报文，seq=y表示序列号，y由服务端生成的随机数,SYN=1表示建立TCP连接（服务端也回复这个，表示我同意建立连接了），而且会产生ack字段，ack字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证，这里的ack加1可以理解为是确认和谁建立连接。\n3. 客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。\n\n上面的SYN，seq，ack我们可以缕一缕意思。\n\n- 其中SYN表示是要建立TCP连接，所以值都是为1。\n- seq表示发送的序列号，ack表示报文到达的确认。所以我们可以看到客户端假设发了seq=100，那么服务端确认后就发ack=100+1表示我确认了。然后服务端回复时也发了一个seq=200（这里200是图中的y），客户端确认后发送ack=200+1。\n- seq和ack的作用是保证传输可靠性，顺序性。\n\n### 四次挥手\n\n![四次挥手与状态](linux-netstat/3.png)\n\n1. 客户端发送TCP断开请求的报文，其中FIN=1表示要断开连接的请求，seq表示序列号，x是随机生成的。\n2. 服务端收到请求后回复客户端，ack表示回复确认，seq=y随机序列号。\n3. 第二步服务端回复完客户端后并不是一下子就断开，服务端需要保障所有传输到客户端的数据是否已经传输完毕，如果完毕了然后发送FIN=1表示我同意断开了，然后seq=y就是发送自己这边的随机序列号。\n4.客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。\n\n### TCP的11种状态\n\n![](linux-netstat/4.png)\n\n1. 一开始，建立连接之前服务器和客户端的状态都为CLOSED。\n2. 服务器创建socket后开始监听，变为LISTEN状态。\n3. 客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT。\n4. 服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD。\n5. 然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED。\n6. 服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立。\n\n![](linux-netstat/5.png)\n\n由于TCP连接是全双工的，断开连接会比建立连接麻烦一点点。 \n1. 客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1； \n2. 服务器收到FIN后向客户端发送ACK，服务器的状态变成CLOSE_WAIT； \n3. 客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送； \n4. 直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态； \n5. 客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态； \n6. 再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。 \n至此，还有一个状态没有出来：CLOSING状态。 \n\n**状态解释**\n\n| 状态         | 说明                                                         |\n| ------------ | ------------------------------------------------------------ |\n| LISTEN       | 等待从任何远端TCP 和端口的连接请求                           |\n| SYN_SENT     | 发送完一个连接请求后等待一个匹配的连接请求                   |\n| SYN_RECEIVED | 发送连接请求并且接收到匹配的连接请求以后等待连接请求确认     |\n| ESTABLISHED  | 连接完成，连接的数据传输阶段的正常状态                       |\n| FIN_WAIT_1   | 等待远端TCP的连接终止请求，或者等待之前发送的连接终止请求的确认 |\n| FIN_WAIT_2   | 等待远端TCP的连接终止请求                                    |\n| CLOSE_WAIT   | 等待本地用户的连接终止请求                                   |\n| CLOSING      | 等待远端TCP的连接终止请求确认                                |\n| LAST_ACK     | 等待先前发送给远端TCP的连接终止请求的确认                    |\n| TIME_WAIT    | 等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认 |\n\n### 常见问题\n\n参考：https://juejin.cn/post/6900439208641921038\n\n**为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次**\n\n首先要理解TCP是面向连接的，所以他需要通过握手来建立连接。TCP也是可靠性的，他通过什么来保证可靠性呢？序列号，通过序列号来保证消息的有序性， 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤，那为什么不是两次？\n\nhttps://blog.csdn.net/lengxiao1993/article/details/82771768\n\n**两次握手过程**\n\n1. A发送同步信号SYN + sequence\n2. B收到A的消息后，发送同步信号 SYN +  sequence + ACK（表示对A同步信号的确认）\n\n到此，如果只有两次，A能确定收到B的同步信号，但是B没法确定A是否收到自己发送的同步信号。这样可能造成的问题是，假如A发送了第一个连接请求后由于网络问题滞留，到了某个时间才到达B，此时这个报文是无效的，但是由于只有两次握手，B同意连接后发送ACK给A，A对于这个失效的报文不会理睬，导致B端一直等待浪费资源。\n\n**TCP报文结构**\n\n![](linux-netstat/6.png)\n\n其中，\n\n- 源端口和目的端口。\n- 位序号（seq）和确认号（ack）这个就是TCP通信时发送的，确认号而是和序列号配合使用的，应答某次请求时，则返回一个确认号，它的值等于对方请求序列号加1。\n- 6个标志位分别是，URG：这是条紧急信息，ACK:应答消息，PSH:缓冲区尚未填满，RST:重置连接，SYN:建立连接消息标志，FIN：连接关闭通知信息。\n- 滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。\n\n**TCP为什么说是可靠连接的**\n\nTCP的连接是基于三次握手，而断开则是四次挥手。为了保障数据不丢失及错误（可靠性），它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。\n\n**挥手时主动断开方状态在TIME_WAIT后为什么要等2MSL后才断开**\n\n1. TIME_WAIT的作用是为了保证最后一次挥手的ACK报文能送达给对方，如果ACK丢失，对方会超时重传FIN，主动关闭端会再次响应ACK过去；如果没有TIME_WAIT状态，直接关闭，对方重传的FIN报文则被响应一个RST报文，此RST会被动关闭端被解析成错误。\n2. MSL指的是\"报文最大生存时间\"，等待这个时间使本次连接所产生的报文段都从网络上消失，保证下一次的连接不会出现这种旧的连接请求的报文段。\n\n**TIME_WAIT和CLOSE_WAIT的区别**\n\nCLOSE_WAIT是被动关闭形成的，当对方发送FIN后，自己回应ACK后进入CLOSE_WAIT状态，随后检查是否存在未传输数据，如果没有则发起第三次挥手，发送FIN报文给对方，进入LAST_ACK状态并等待对方ACK报文到来。\n\nTIME_WAIT是主动关闭连接方式形成的；处于FIN_WAIT_2状态时，收到对方FIN报文后进入TIME_WAIT状态；之后再等待两个MSL(Maximum Segment Lifetime:报文最大生存时间)。\n\n**TCP和UDP的区别**\n\n1. udp是无连接的，tcp是面向连接的。\n2. udp是不可靠传输，tcp是可靠传输。\n3. udp是面向报文传输，tcp是面向字节流传输。\n4. udp不会发生粘包拆包，tcp会发生。\n\n**TCP的粘包拆包是怎么回事？如何解决？**\n\n网络通信采用的套接字(socket)技术，其实现实际是由系统内核提供一片连续缓存(流缓冲)来实现应用层程序与网卡接口之间的中转功能。多个数据包被连续存储于连续的缓存中，每个数据包的大小是不规定的。在对数据包进行读取时采用某一估测值大小（滑动窗口）来进行数据读出。例如缓冲里面目前有pag1=100字节，pag2=200字节，而我们采用估测值大小300字节的去读取的时候会将pag1,pag2都读取出来就发生了粘包。拆包同理，且拆包的话还有可能是大于MSS（最大报文长度），TCP在传输前将进行拆包了。\n\n解决方法:\n\n1. 在数据尾部增加特殊字符进行分割\n2. 将数据定为固定大小，少于固定大小的用填充数据填充\n3. 将数据分为两部分，一部分是头部，一部分是内容体。其中头部结构大小固定，且有一个字段声明内容体的大小\n\nhttps://zhuanlan.zhihu.com/p/90057929\n\n**Linux系统支持的最大TCP连接是多少**\n\nhttps://zhuanlan.zhihu.com/p/138263151\n\nhttps://blog.csdn.net/sqlquan/article/details/111561959\n\n**nagle算法有了解吗**\n\n## netstat\n\nnetstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。\n\n这个命令的参数太多，一般来说我们都是用它来查TCP连接的，然后看连接的状态对比对。\n\n```shell\n[root@Master1 ~]# netstat -ant #t表示只有展示TCP协议\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address               Foreign Address             State      \ntcp        0      0 0.0.0.0:63501               0.0.0.0:*                   LISTEN    \ntcp        1      0 127.0.0.1:44176             127.0.0.1:60047             CLOSE_WAIT  \ntcp        0      0 10.8.198.151:60884          10.8.2.30:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:55672          10.8.2.27:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:60882          10.8.2.30:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:63501          10.8.133.245:59893          ESTABLISHED \ntcp        0      0 10.8.198.151:60976          10.8.2.30:61235             TIME_WAIT    \ntcp        0      0 ::ffff:127.0.0.1:9600       :::*                        LISTEN      \ntcp        0      0 :::63501                    :::*                        LISTEN          \ntcp        0      0 ::ffff:10.8.198.151:60061   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        0      0 ::ffff:10.8.198.151:60050   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        1      0 ::1:60047                   ::1:43724                   CLOSE_WAIT  \ntcp        0      0 ::ffff:10.8.198.151:45024   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        0      0 ::ffff:10.8.198.151:43592   ::ffff:10.8.215.65:34710    TIME_WAIT  \n#Local Address - 源IP/端口\n#Foreign Address - 目标IP/端口\n#State 状态 - 对应上面说的TCP11个状态\n```\n\nnetstat命令有很多参数，这里就不一一说了。这个命令能帮助我们了解到具体的TCP的连接情况，例如我们可以通过如下命令知道当前服务器连接MySQL的状态。\n\n```\nnetstat -ant | grep 3306\n```\n\n## tcpdump\n\n用来抓包tcp协议的命令\n\n```shell\ntcpdump -n port 3306 #监控端口3306的TCP情况抓包 -n不把网络地址转换为名字\n# 发生了 3次握手\n11:38:15.679863 IP 172.18.0.5.38822 > 172.18.0.3.3306: Flags [S], seq 4065722321, win 29200, options [mss 1460,sackOK,TS val 2997352 ecr 0,nop,wscale 7], length 0\n11:38:15.679923 IP 172.18.0.3.3306 > 172.18.0.5.38822: Flags [S.], seq 780487619, ack 4065722322, win 28960, options [mss 1460,sackOK,TS val 2997352 ecr 2997352,nop,wscale 7], length 0\n11:38:15.679936 IP 172.18.0.5.38822 > 172.18.0.3.3306: Flags [.], ack 1, win 229, options [nop,nop,TS val 2997352 ecr 2997352], length 0\n```\n\n```shell\n# 监控端口3306的TCP情况并且截获所有10.8.152.162 的主机收到的和发出的所有的数据包\ntcpdump -n port 3306 and host 10.8.152.162 \n# 截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信\ntcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\) \n# 果想要获取主机210.27.48.1接收或发出的telnet包\ntcpdump tcp port 23 and host 210.27.48.1\n```\n\n## 参考\n\n- https://juejin.cn/post/6844903734300901390\n- [Linux tcpdump命令详解](https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html)\n- [wireshark抓包新手使用教程](https://www.cnblogs.com/mq0036/p/11187138.html)","slug":"linux-netstat","published":1,"date":"2021-04-08T00:47:06.807Z","updated":"2021-04-08T00:47:06.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhv9001iqwv27jp34xc9","content":"<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p>传输控制协议（<em>TCP</em>，Transmission Control Protocol）是一种<font color=\"red\">面向连接的</font>、<font color=\"red\">可靠的</font>、<font color=\"red\">基于字节流</font>的传输层通信协议。本人是这样理解面向连接和可靠性的。</p>\n<p>面向连接指的客户端/服务器在使用TCP进行数据传输时必须先建立一个TCP连接。连接的手段就是进行三次握手，关闭时需要四次挥手。</p>\n<p>可靠性指的是保证发送的数据<font color=\"red\">无差错，无重复，按顺序，不丢失</font>。可靠性的保证主要通过如下手段实现：</p>\n<ul>\n<li>序列号，ACK信号：发送方按照顺序给要发送的数据包的每个字节都标上编号。接收方接收到发送方的数据包之后，回传一个ACK信号，标识下一个需求的数据包初始字节编号。（可以保证顺序）</li>\n<li>超时重发：在等待接收方回传的ACK信号超时后，发送方重发数据包。一旦开始重传，下一次等待的时间间隔指数增长，重发一定次数后还是收不到ACK信号，将强制终止连接。</li>\n<li>TCP的连接管理：建立连接的三次握手和断开连接的四次挥手。（保证安全）</li>\n<li>以段为单位发送数据包：在建立TCP连接的同时，两端协商发送数据包的单位，称为“最大消息长度”：MSS。</li>\n<li>滑动窗口：以段为单位发送数据包，每发送一个数据包需要等待一个ACK信号，当数据包往返时间越长效率越低。滑动窗口中窗口前端为已发送但为收到ACK的数据，后端为待发送数据。发送端一次发送多个数据，接收端回传收到的连续数据的ACK信号，缓存缺失数据之后的数据包(保持顺序)。发送端当收到ACK信号时，窗口向前依次移动，直到遇到有数据未确认时停止。一段时间后启动超时重传，接收端若收到缺失数据，则和缓存数据一起发送ACK信号，否则，抛弃缓存数据。</li>\n<li>流量控制：TCP首部有一个字段来通知窗口的大小，接收端通过设置来主动控制传输流量。</li>\n<li>拥塞控制：发送端通过拥塞窗口主动控制传输流量。慢启动：防止双方通信刚开始就传送大量数据包，发送端拥塞窗口初始设置为1MSS，每接受一个ACK信号，窗口扩大为两倍。发送数据时，取拥塞窗口和滑动窗口的较小值。同时设定一个慢启动阈值，当拥塞窗口大小超过阈值时，改为线性增长，直到网络拥塞。拥塞时将慢启动阈值设置为当前窗口的的一半，并将拥塞窗口的值设置为1，然后再次重复操作。</li>\n</ul>\n<h2 id=\"TCP三次握手和四次挥手\"><a href=\"#TCP三次握手和四次挥手\" class=\"headerlink\" title=\"TCP三次握手和四次挥手\"></a>TCP三次握手和四次挥手</h2><p>一个正常的TCP连接，都会有三个阶段:</p>\n<ul>\n<li>TCP三次握手。</li>\n<li>数据传送。</li>\n<li>TCP四次挥手。</li>\n</ul>\n<p><img src=\"/2021/04/08/linux-netstat/1.png\" alt=\"三次握手\"></p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p><img src=\"/2021/04/08/linux-netstat/2.png\" alt=\"三次握手与状态\"></p>\n<p><strong>三次握手说明：</strong></p>\n<ol>\n<li>客户端发送TCP连接的请求报文，其中SYN=1表示建立TCP连接，seq表示序列号，x为随机序列号。客户端发送后将自己的状态设置成<code>SYN_SENT</code>状态。</li>\n<li>服务单回复客户都按发送的TCP请求报文，seq=y表示序列号，y由服务端生成的随机数,SYN=1表示建立TCP连接（服务端也回复这个，表示我同意建立连接了），而且会产生ack字段，ack字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证，这里的ack加1可以理解为是确认和谁建立连接。</li>\n<li>客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。</li>\n</ol>\n<p>上面的SYN，seq，ack我们可以缕一缕意思。</p>\n<ul>\n<li>其中SYN表示是要建立TCP连接，所以值都是为1。</li>\n<li>seq表示发送的序列号，ack表示报文到达的确认。所以我们可以看到客户端假设发了seq=100，那么服务端确认后就发ack=100+1表示我确认了。然后服务端回复时也发了一个seq=200（这里200是图中的y），客户端确认后发送ack=200+1。</li>\n<li>seq和ack的作用是保证传输可靠性，顺序性。</li>\n</ul>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p><img src=\"/2021/04/08/linux-netstat/3.png\" alt=\"四次挥手与状态\"></p>\n<ol>\n<li>客户端发送TCP断开请求的报文，其中FIN=1表示要断开连接的请求，seq表示序列号，x是随机生成的。</li>\n<li>服务端收到请求后回复客户端，ack表示回复确认，seq=y随机序列号。</li>\n<li>第二步服务端回复完客户端后并不是一下子就断开，服务端需要保障所有传输到客户端的数据是否已经传输完毕，如果完毕了然后发送FIN=1表示我同意断开了，然后seq=y就是发送自己这边的随机序列号。</li>\n<li>客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。</li>\n</ol>\n<h3 id=\"TCP的11种状态\"><a href=\"#TCP的11种状态\" class=\"headerlink\" title=\"TCP的11种状态\"></a>TCP的11种状态</h3><p><img src=\"/2021/04/08/linux-netstat/4.png\" alt></p>\n<ol>\n<li>一开始，建立连接之前服务器和客户端的状态都为CLOSED。</li>\n<li>服务器创建socket后开始监听，变为LISTEN状态。</li>\n<li>客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT。</li>\n<li>服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD。</li>\n<li>然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED。</li>\n<li>服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立。</li>\n</ol>\n<p><img src=\"/2021/04/08/linux-netstat/5.png\" alt></p>\n<p>由于TCP连接是全双工的，断开连接会比建立连接麻烦一点点。 </p>\n<ol>\n<li>客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1； </li>\n<li>服务器收到FIN后向客户端发送ACK，服务器的状态变成CLOSE_WAIT； </li>\n<li>客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送； </li>\n<li>直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态； </li>\n<li>客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态； </li>\n<li>再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。<br>至此，还有一个状态没有出来：CLOSING状态。 </li>\n</ol>\n<p><strong>状态解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LISTEN</td>\n<td>等待从任何远端TCP 和端口的连接请求</td>\n</tr>\n<tr>\n<td>SYN_SENT</td>\n<td>发送完一个连接请求后等待一个匹配的连接请求</td>\n</tr>\n<tr>\n<td>SYN_RECEIVED</td>\n<td>发送连接请求并且接收到匹配的连接请求以后等待连接请求确认</td>\n</tr>\n<tr>\n<td>ESTABLISHED</td>\n<td>连接完成，连接的数据传输阶段的正常状态</td>\n</tr>\n<tr>\n<td>FIN_WAIT_1</td>\n<td>等待远端TCP的连接终止请求，或者等待之前发送的连接终止请求的确认</td>\n</tr>\n<tr>\n<td>FIN_WAIT_2</td>\n<td>等待远端TCP的连接终止请求</td>\n</tr>\n<tr>\n<td>CLOSE_WAIT</td>\n<td>等待本地用户的连接终止请求</td>\n</tr>\n<tr>\n<td>CLOSING</td>\n<td>等待远端TCP的连接终止请求确认</td>\n</tr>\n<tr>\n<td>LAST_ACK</td>\n<td>等待先前发送给远端TCP的连接终止请求的确认</td>\n</tr>\n<tr>\n<td>TIME_WAIT</td>\n<td>等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认</td>\n</tr>\n</tbody></table>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><p>参考：<a href=\"https://juejin.cn/post/6900439208641921038\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6900439208641921038</a></p>\n<p><strong>为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次</strong></p>\n<p>首先要理解TCP是面向连接的，所以他需要通过握手来建立连接。TCP也是可靠性的，他通过什么来保证可靠性呢？序列号，通过序列号来保证消息的有序性， 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤，那为什么不是两次？</p>\n<p><a href=\"https://blog.csdn.net/lengxiao1993/article/details/82771768\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></p>\n<p><strong>两次握手过程</strong></p>\n<ol>\n<li>A发送同步信号SYN + sequence</li>\n<li>B收到A的消息后，发送同步信号 SYN +  sequence + ACK（表示对A同步信号的确认）</li>\n</ol>\n<p>到此，如果只有两次，A能确定收到B的同步信号，但是B没法确定A是否收到自己发送的同步信号。这样可能造成的问题是，假如A发送了第一个连接请求后由于网络问题滞留，到了某个时间才到达B，此时这个报文是无效的，但是由于只有两次握手，B同意连接后发送ACK给A，A对于这个失效的报文不会理睬，导致B端一直等待浪费资源。</p>\n<p><strong>TCP报文结构</strong></p>\n<p><img src=\"/2021/04/08/linux-netstat/6.png\" alt></p>\n<p>其中，</p>\n<ul>\n<li>源端口和目的端口。</li>\n<li>位序号（seq）和确认号（ack）这个就是TCP通信时发送的，确认号而是和序列号配合使用的，应答某次请求时，则返回一个确认号，它的值等于对方请求序列号加1。</li>\n<li>6个标志位分别是，URG：这是条紧急信息，ACK:应答消息，PSH:缓冲区尚未填满，RST:重置连接，SYN:建立连接消息标志，FIN：连接关闭通知信息。</li>\n<li>滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</li>\n</ul>\n<p><strong>TCP为什么说是可靠连接的</strong></p>\n<p>TCP的连接是基于三次握手，而断开则是四次挥手。为了保障数据不丢失及错误（可靠性），它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。</p>\n<p><strong>挥手时主动断开方状态在TIME_WAIT后为什么要等2MSL后才断开</strong></p>\n<ol>\n<li>TIME_WAIT的作用是为了保证最后一次挥手的ACK报文能送达给对方，如果ACK丢失，对方会超时重传FIN，主动关闭端会再次响应ACK过去；如果没有TIME_WAIT状态，直接关闭，对方重传的FIN报文则被响应一个RST报文，此RST会被动关闭端被解析成错误。</li>\n<li>MSL指的是”报文最大生存时间”，等待这个时间使本次连接所产生的报文段都从网络上消失，保证下一次的连接不会出现这种旧的连接请求的报文段。</li>\n</ol>\n<p><strong>TIME_WAIT和CLOSE_WAIT的区别</strong></p>\n<p>CLOSE_WAIT是被动关闭形成的，当对方发送FIN后，自己回应ACK后进入CLOSE_WAIT状态，随后检查是否存在未传输数据，如果没有则发起第三次挥手，发送FIN报文给对方，进入LAST_ACK状态并等待对方ACK报文到来。</p>\n<p>TIME_WAIT是主动关闭连接方式形成的；处于FIN_WAIT_2状态时，收到对方FIN报文后进入TIME_WAIT状态；之后再等待两个MSL(Maximum Segment Lifetime:报文最大生存时间)。</p>\n<p><strong>TCP和UDP的区别</strong></p>\n<ol>\n<li>udp是无连接的，tcp是面向连接的。</li>\n<li>udp是不可靠传输，tcp是可靠传输。</li>\n<li>udp是面向报文传输，tcp是面向字节流传输。</li>\n<li>udp不会发生粘包拆包，tcp会发生。</li>\n</ol>\n<p><strong>TCP的粘包拆包是怎么回事？如何解决？</strong></p>\n<p>网络通信采用的套接字(socket)技术，其实现实际是由系统内核提供一片连续缓存(流缓冲)来实现应用层程序与网卡接口之间的中转功能。多个数据包被连续存储于连续的缓存中，每个数据包的大小是不规定的。在对数据包进行读取时采用某一估测值大小（滑动窗口）来进行数据读出。例如缓冲里面目前有pag1=100字节，pag2=200字节，而我们采用估测值大小300字节的去读取的时候会将pag1,pag2都读取出来就发生了粘包。拆包同理，且拆包的话还有可能是大于MSS（最大报文长度），TCP在传输前将进行拆包了。</p>\n<p>解决方法:</p>\n<ol>\n<li>在数据尾部增加特殊字符进行分割</li>\n<li>将数据定为固定大小，少于固定大小的用填充数据填充</li>\n<li>将数据分为两部分，一部分是头部，一部分是内容体。其中头部结构大小固定，且有一个字段声明内容体的大小</li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/90057929\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/90057929</a></p>\n<p><strong>Linux系统支持的最大TCP连接是多少</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/138263151\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/138263151</a></p>\n<p><a href=\"https://blog.csdn.net/sqlquan/article/details/111561959\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sqlquan/article/details/111561959</a></p>\n<p><strong>nagle算法有了解吗</strong></p>\n<h2 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h2><p>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>\n<p>这个命令的参数太多，一般来说我们都是用它来查TCP连接的，然后看连接的状态对比对。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[root@Master1 ~]# netstat -ant #t表示只有展示TCP协议\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address               Foreign Address             State      \ntcp        0      0 0.0.0.0:63501               0.0.0.0:*                   LISTEN    \ntcp        1      0 127.0.0.1:44176             127.0.0.1:60047             CLOSE_WAIT  \ntcp        0      0 10.8.198.151:60884          10.8.2.30:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:55672          10.8.2.27:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:60882          10.8.2.30:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:63501          10.8.133.245:59893          ESTABLISHED \ntcp        0      0 10.8.198.151:60976          10.8.2.30:61235             TIME_WAIT    \ntcp        0      0 ::ffff:127.0.0.1:9600       :::*                        LISTEN      \ntcp        0      0 :::63501                    :::*                        LISTEN          \ntcp        0      0 ::ffff:10.8.198.151:60061   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        0      0 ::ffff:10.8.198.151:60050   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        1      0 ::1:60047                   ::1:43724                   CLOSE_WAIT  \ntcp        0      0 ::ffff:10.8.198.151:45024   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        0      0 ::ffff:10.8.198.151:43592   ::ffff:10.8.215.65:34710    TIME_WAIT  \n#Local Address - 源IP/端口\n#Foreign Address - 目标IP/端口\n#State 状态 - 对应上面说的TCP11个状态</code></pre>\n<p>netstat命令有很多参数，这里就不一一说了。这个命令能帮助我们了解到具体的TCP的连接情况，例如我们可以通过如下命令知道当前服务器连接MySQL的状态。</p>\n<pre><code>netstat -ant | grep 3306</code></pre><h2 id=\"tcpdump\"><a href=\"#tcpdump\" class=\"headerlink\" title=\"tcpdump\"></a>tcpdump</h2><p>用来抓包tcp协议的命令</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">tcpdump -n port 3306 #监控端口3306的TCP情况抓包 -n不把网络地址转换为名字\n# 发生了 3次握手\n11:38:15.679863 IP 172.18.0.5.38822 > 172.18.0.3.3306: Flags [S], seq 4065722321, win 29200, options [mss 1460,sackOK,TS val 2997352 ecr 0,nop,wscale 7], length 0\n11:38:15.679923 IP 172.18.0.3.3306 > 172.18.0.5.38822: Flags [S.], seq 780487619, ack 4065722322, win 28960, options [mss 1460,sackOK,TS val 2997352 ecr 2997352,nop,wscale 7], length 0\n11:38:15.679936 IP 172.18.0.5.38822 > 172.18.0.3.3306: Flags [.], ack 1, win 229, options [nop,nop,TS val 2997352 ecr 2997352], length 0</code></pre>\n<pre class=\" language-shell\"><code class=\"language-shell\"># 监控端口3306的TCP情况并且截获所有10.8.152.162 的主机收到的和发出的所有的数据包\ntcpdump -n port 3306 and host 10.8.152.162 \n# 截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信\ntcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\) \n# 果想要获取主机210.27.48.1接收或发出的telnet包\ntcpdump tcp port 23 and host 210.27.48.1</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903734300901390\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903734300901390</a></li>\n<li><a href=\"https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html\" target=\"_blank\" rel=\"noopener\">Linux tcpdump命令详解</a></li>\n<li><a href=\"https://www.cnblogs.com/mq0036/p/11187138.html\" target=\"_blank\" rel=\"noopener\">wireshark抓包新手使用教程</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h2><p>传输控制协议（<em>TCP</em>，Transmission Control Protocol）是一种<font color=\"red\">面向连接的</font>、<font color=\"red\">可靠的</font>、<font color=\"red\">基于字节流</font>的传输层通信协议。本人是这样理解面向连接和可靠性的。</p>\n<p>面向连接指的客户端/服务器在使用TCP进行数据传输时必须先建立一个TCP连接。连接的手段就是进行三次握手，关闭时需要四次挥手。</p>\n<p>可靠性指的是保证发送的数据<font color=\"red\">无差错，无重复，按顺序，不丢失</font>。可靠性的保证主要通过如下手段实现：</p>\n<ul>\n<li>序列号，ACK信号：发送方按照顺序给要发送的数据包的每个字节都标上编号。接收方接收到发送方的数据包之后，回传一个ACK信号，标识下一个需求的数据包初始字节编号。（可以保证顺序）</li>\n<li>超时重发：在等待接收方回传的ACK信号超时后，发送方重发数据包。一旦开始重传，下一次等待的时间间隔指数增长，重发一定次数后还是收不到ACK信号，将强制终止连接。</li>\n<li>TCP的连接管理：建立连接的三次握手和断开连接的四次挥手。（保证安全）</li>\n<li>以段为单位发送数据包：在建立TCP连接的同时，两端协商发送数据包的单位，称为“最大消息长度”：MSS。</li>\n<li>滑动窗口：以段为单位发送数据包，每发送一个数据包需要等待一个ACK信号，当数据包往返时间越长效率越低。滑动窗口中窗口前端为已发送但为收到ACK的数据，后端为待发送数据。发送端一次发送多个数据，接收端回传收到的连续数据的ACK信号，缓存缺失数据之后的数据包(保持顺序)。发送端当收到ACK信号时，窗口向前依次移动，直到遇到有数据未确认时停止。一段时间后启动超时重传，接收端若收到缺失数据，则和缓存数据一起发送ACK信号，否则，抛弃缓存数据。</li>\n<li>流量控制：TCP首部有一个字段来通知窗口的大小，接收端通过设置来主动控制传输流量。</li>\n<li>拥塞控制：发送端通过拥塞窗口主动控制传输流量。慢启动：防止双方通信刚开始就传送大量数据包，发送端拥塞窗口初始设置为1MSS，每接受一个ACK信号，窗口扩大为两倍。发送数据时，取拥塞窗口和滑动窗口的较小值。同时设定一个慢启动阈值，当拥塞窗口大小超过阈值时，改为线性增长，直到网络拥塞。拥塞时将慢启动阈值设置为当前窗口的的一半，并将拥塞窗口的值设置为1，然后再次重复操作。</li>\n</ul>\n<h2 id=\"TCP三次握手和四次挥手\"><a href=\"#TCP三次握手和四次挥手\" class=\"headerlink\" title=\"TCP三次握手和四次挥手\"></a>TCP三次握手和四次挥手</h2><p>一个正常的TCP连接，都会有三个阶段:</p>\n<ul>\n<li>TCP三次握手。</li>\n<li>数据传送。</li>\n<li>TCP四次挥手。</li>\n</ul>\n<p><img src=\"/2021/04/08/linux-netstat/1.png\" alt=\"三次握手\"></p>\n<h3 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h3><p><img src=\"/2021/04/08/linux-netstat/2.png\" alt=\"三次握手与状态\"></p>\n<p><strong>三次握手说明：</strong></p>\n<ol>\n<li>客户端发送TCP连接的请求报文，其中SYN=1表示建立TCP连接，seq表示序列号，x为随机序列号。客户端发送后将自己的状态设置成<code>SYN_SENT</code>状态。</li>\n<li>服务单回复客户都按发送的TCP请求报文，seq=y表示序列号，y由服务端生成的随机数,SYN=1表示建立TCP连接（服务端也回复这个，表示我同意建立连接了），而且会产生ack字段，ack字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证，这里的ack加1可以理解为是确认和谁建立连接。</li>\n<li>客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。</li>\n</ol>\n<p>上面的SYN，seq，ack我们可以缕一缕意思。</p>\n<ul>\n<li>其中SYN表示是要建立TCP连接，所以值都是为1。</li>\n<li>seq表示发送的序列号，ack表示报文到达的确认。所以我们可以看到客户端假设发了seq=100，那么服务端确认后就发ack=100+1表示我确认了。然后服务端回复时也发了一个seq=200（这里200是图中的y），客户端确认后发送ack=200+1。</li>\n<li>seq和ack的作用是保证传输可靠性，顺序性。</li>\n</ul>\n<h3 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h3><p><img src=\"/2021/04/08/linux-netstat/3.png\" alt=\"四次挥手与状态\"></p>\n<ol>\n<li>客户端发送TCP断开请求的报文，其中FIN=1表示要断开连接的请求，seq表示序列号，x是随机生成的。</li>\n<li>服务端收到请求后回复客户端，ack表示回复确认，seq=y随机序列号。</li>\n<li>第二步服务端回复完客户端后并不是一下子就断开，服务端需要保障所有传输到客户端的数据是否已经传输完毕，如果完毕了然后发送FIN=1表示我同意断开了，然后seq=y就是发送自己这边的随机序列号。</li>\n<li>客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。</li>\n</ol>\n<h3 id=\"TCP的11种状态\"><a href=\"#TCP的11种状态\" class=\"headerlink\" title=\"TCP的11种状态\"></a>TCP的11种状态</h3><p><img src=\"/2021/04/08/linux-netstat/4.png\" alt></p>\n<ol>\n<li>一开始，建立连接之前服务器和客户端的状态都为CLOSED。</li>\n<li>服务器创建socket后开始监听，变为LISTEN状态。</li>\n<li>客户端请求建立连接，向服务器发送SYN报文，客户端的状态变味SYN_SENT。</li>\n<li>服务器收到客户端的报文后向客户端发送ACK和SYN报文，此时服务器的状态变为SYN_RCVD。</li>\n<li>然后，客户端收到ACK、SYN，就向服务器发送ACK，客户端状态变为ESTABLISHED。</li>\n<li>服务器端收到客户端的ACK后变为ESTABLISHED。此时3次握手完成，连接建立。</li>\n</ol>\n<p><img src=\"/2021/04/08/linux-netstat/5.png\" alt></p>\n<p>由于TCP连接是全双工的，断开连接会比建立连接麻烦一点点。 </p>\n<ol>\n<li>客户端先向服务器发送FIN报文，请求断开连接，其状态变为FIN_WAIT1； </li>\n<li>服务器收到FIN后向客户端发送ACK，服务器的状态变成CLOSE_WAIT； </li>\n<li>客户端收到ACK后就进入FIN_WAIT2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送； </li>\n<li>直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态； </li>\n<li>客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态； </li>\n<li>再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。<br>至此，还有一个状态没有出来：CLOSING状态。 </li>\n</ol>\n<p><strong>状态解释</strong></p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LISTEN</td>\n<td>等待从任何远端TCP 和端口的连接请求</td>\n</tr>\n<tr>\n<td>SYN_SENT</td>\n<td>发送完一个连接请求后等待一个匹配的连接请求</td>\n</tr>\n<tr>\n<td>SYN_RECEIVED</td>\n<td>发送连接请求并且接收到匹配的连接请求以后等待连接请求确认</td>\n</tr>\n<tr>\n<td>ESTABLISHED</td>\n<td>连接完成，连接的数据传输阶段的正常状态</td>\n</tr>\n<tr>\n<td>FIN_WAIT_1</td>\n<td>等待远端TCP的连接终止请求，或者等待之前发送的连接终止请求的确认</td>\n</tr>\n<tr>\n<td>FIN_WAIT_2</td>\n<td>等待远端TCP的连接终止请求</td>\n</tr>\n<tr>\n<td>CLOSE_WAIT</td>\n<td>等待本地用户的连接终止请求</td>\n</tr>\n<tr>\n<td>CLOSING</td>\n<td>等待远端TCP的连接终止请求确认</td>\n</tr>\n<tr>\n<td>LAST_ACK</td>\n<td>等待先前发送给远端TCP的连接终止请求的确认</td>\n</tr>\n<tr>\n<td>TIME_WAIT</td>\n<td>等待足够的时间过去以确保远端TCP 接收到它的连接终止请求的确认</td>\n</tr>\n</tbody></table>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><p>参考：<a href=\"https://juejin.cn/post/6900439208641921038\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6900439208641921038</a></p>\n<p><strong>为什么TCP协议要三次握手来确立连接，而不是两次，也不是4次</strong></p>\n<p>首先要理解TCP是面向连接的，所以他需要通过握手来建立连接。TCP也是可靠性的，他通过什么来保证可靠性呢？序列号，通过序列号来保证消息的有序性， 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤，那为什么不是两次？</p>\n<p><a href=\"https://blog.csdn.net/lengxiao1993/article/details/82771768\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></p>\n<p><strong>两次握手过程</strong></p>\n<ol>\n<li>A发送同步信号SYN + sequence</li>\n<li>B收到A的消息后，发送同步信号 SYN +  sequence + ACK（表示对A同步信号的确认）</li>\n</ol>\n<p>到此，如果只有两次，A能确定收到B的同步信号，但是B没法确定A是否收到自己发送的同步信号。这样可能造成的问题是，假如A发送了第一个连接请求后由于网络问题滞留，到了某个时间才到达B，此时这个报文是无效的，但是由于只有两次握手，B同意连接后发送ACK给A，A对于这个失效的报文不会理睬，导致B端一直等待浪费资源。</p>\n<p><strong>TCP报文结构</strong></p>\n<p><img src=\"/2021/04/08/linux-netstat/6.png\" alt></p>\n<p>其中，</p>\n<ul>\n<li>源端口和目的端口。</li>\n<li>位序号（seq）和确认号（ack）这个就是TCP通信时发送的，确认号而是和序列号配合使用的，应答某次请求时，则返回一个确认号，它的值等于对方请求序列号加1。</li>\n<li>6个标志位分别是，URG：这是条紧急信息，ACK:应答消息，PSH:缓冲区尚未填满，RST:重置连接，SYN:建立连接消息标志，FIN：连接关闭通知信息。</li>\n<li>滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。</li>\n</ul>\n<p><strong>TCP为什么说是可靠连接的</strong></p>\n<p>TCP的连接是基于三次握手，而断开则是四次挥手。为了保障数据不丢失及错误（可靠性），它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。</p>\n<p><strong>挥手时主动断开方状态在TIME_WAIT后为什么要等2MSL后才断开</strong></p>\n<ol>\n<li>TIME_WAIT的作用是为了保证最后一次挥手的ACK报文能送达给对方，如果ACK丢失，对方会超时重传FIN，主动关闭端会再次响应ACK过去；如果没有TIME_WAIT状态，直接关闭，对方重传的FIN报文则被响应一个RST报文，此RST会被动关闭端被解析成错误。</li>\n<li>MSL指的是”报文最大生存时间”，等待这个时间使本次连接所产生的报文段都从网络上消失，保证下一次的连接不会出现这种旧的连接请求的报文段。</li>\n</ol>\n<p><strong>TIME_WAIT和CLOSE_WAIT的区别</strong></p>\n<p>CLOSE_WAIT是被动关闭形成的，当对方发送FIN后，自己回应ACK后进入CLOSE_WAIT状态，随后检查是否存在未传输数据，如果没有则发起第三次挥手，发送FIN报文给对方，进入LAST_ACK状态并等待对方ACK报文到来。</p>\n<p>TIME_WAIT是主动关闭连接方式形成的；处于FIN_WAIT_2状态时，收到对方FIN报文后进入TIME_WAIT状态；之后再等待两个MSL(Maximum Segment Lifetime:报文最大生存时间)。</p>\n<p><strong>TCP和UDP的区别</strong></p>\n<ol>\n<li>udp是无连接的，tcp是面向连接的。</li>\n<li>udp是不可靠传输，tcp是可靠传输。</li>\n<li>udp是面向报文传输，tcp是面向字节流传输。</li>\n<li>udp不会发生粘包拆包，tcp会发生。</li>\n</ol>\n<p><strong>TCP的粘包拆包是怎么回事？如何解决？</strong></p>\n<p>网络通信采用的套接字(socket)技术，其实现实际是由系统内核提供一片连续缓存(流缓冲)来实现应用层程序与网卡接口之间的中转功能。多个数据包被连续存储于连续的缓存中，每个数据包的大小是不规定的。在对数据包进行读取时采用某一估测值大小（滑动窗口）来进行数据读出。例如缓冲里面目前有pag1=100字节，pag2=200字节，而我们采用估测值大小300字节的去读取的时候会将pag1,pag2都读取出来就发生了粘包。拆包同理，且拆包的话还有可能是大于MSS（最大报文长度），TCP在传输前将进行拆包了。</p>\n<p>解决方法:</p>\n<ol>\n<li>在数据尾部增加特殊字符进行分割</li>\n<li>将数据定为固定大小，少于固定大小的用填充数据填充</li>\n<li>将数据分为两部分，一部分是头部，一部分是内容体。其中头部结构大小固定，且有一个字段声明内容体的大小</li>\n</ol>\n<p><a href=\"https://zhuanlan.zhihu.com/p/90057929\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/90057929</a></p>\n<p><strong>Linux系统支持的最大TCP连接是多少</strong></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/138263151\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/138263151</a></p>\n<p><a href=\"https://blog.csdn.net/sqlquan/article/details/111561959\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sqlquan/article/details/111561959</a></p>\n<p><strong>nagle算法有了解吗</strong></p>\n<h2 id=\"netstat\"><a href=\"#netstat\" class=\"headerlink\" title=\"netstat\"></a>netstat</h2><p>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>\n<p>这个命令的参数太多，一般来说我们都是用它来查TCP连接的，然后看连接的状态对比对。</p>\n<pre><code class=\"shell\">[root@Master1 ~]# netstat -ant #t表示只有展示TCP协议\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address               Foreign Address             State      \ntcp        0      0 0.0.0.0:63501               0.0.0.0:*                   LISTEN    \ntcp        1      0 127.0.0.1:44176             127.0.0.1:60047             CLOSE_WAIT  \ntcp        0      0 10.8.198.151:60884          10.8.2.30:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:55672          10.8.2.27:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:60882          10.8.2.30:61235             TIME_WAIT   \ntcp        0      0 10.8.198.151:63501          10.8.133.245:59893          ESTABLISHED \ntcp        0      0 10.8.198.151:60976          10.8.2.30:61235             TIME_WAIT    \ntcp        0      0 ::ffff:127.0.0.1:9600       :::*                        LISTEN      \ntcp        0      0 :::63501                    :::*                        LISTEN          \ntcp        0      0 ::ffff:10.8.198.151:60061   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        0      0 ::ffff:10.8.198.151:60050   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        1      0 ::1:60047                   ::1:43724                   CLOSE_WAIT  \ntcp        0      0 ::ffff:10.8.198.151:45024   ::ffff:10.8.198.135:63751   ESTABLISHED \ntcp        0      0 ::ffff:10.8.198.151:43592   ::ffff:10.8.215.65:34710    TIME_WAIT  \n#Local Address - 源IP/端口\n#Foreign Address - 目标IP/端口\n#State 状态 - 对应上面说的TCP11个状态</code></pre>\n<p>netstat命令有很多参数，这里就不一一说了。这个命令能帮助我们了解到具体的TCP的连接情况，例如我们可以通过如下命令知道当前服务器连接MySQL的状态。</p>\n<pre><code>netstat -ant | grep 3306</code></pre><h2 id=\"tcpdump\"><a href=\"#tcpdump\" class=\"headerlink\" title=\"tcpdump\"></a>tcpdump</h2><p>用来抓包tcp协议的命令</p>\n<pre><code class=\"shell\">tcpdump -n port 3306 #监控端口3306的TCP情况抓包 -n不把网络地址转换为名字\n# 发生了 3次握手\n11:38:15.679863 IP 172.18.0.5.38822 &gt; 172.18.0.3.3306: Flags [S], seq 4065722321, win 29200, options [mss 1460,sackOK,TS val 2997352 ecr 0,nop,wscale 7], length 0\n11:38:15.679923 IP 172.18.0.3.3306 &gt; 172.18.0.5.38822: Flags [S.], seq 780487619, ack 4065722322, win 28960, options [mss 1460,sackOK,TS val 2997352 ecr 2997352,nop,wscale 7], length 0\n11:38:15.679936 IP 172.18.0.5.38822 &gt; 172.18.0.3.3306: Flags [.], ack 1, win 229, options [nop,nop,TS val 2997352 ecr 2997352], length 0</code></pre>\n<pre><code class=\"shell\"># 监控端口3306的TCP情况并且截获所有10.8.152.162 的主机收到的和发出的所有的数据包\ntcpdump -n port 3306 and host 10.8.152.162 \n# 截获主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信\ntcpdump host 210.27.48.1 and \\ (210.27.48.2 or 210.27.48.3 \\) \n# 果想要获取主机210.27.48.1接收或发出的telnet包\ntcpdump tcp port 23 and host 210.27.48.1</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844903734300901390\" target=\"_blank\" rel=\"noopener\">https://juejin.cn/post/6844903734300901390</a></li>\n<li><a href=\"https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html\" target=\"_blank\" rel=\"noopener\">Linux tcpdump命令详解</a></li>\n<li><a href=\"https://www.cnblogs.com/mq0036/p/11187138.html\" target=\"_blank\" rel=\"noopener\">wireshark抓包新手使用教程</a></li>\n</ul>\n"},{"title":"Linux故障排查命令使用(top、iostat、vmstat、netstat、free、df、iotop)","description":"Linux故障排查命令使用和JVM命令(jstat、jps、jmap、jstack)","_content":"## top命令详解\n### 各项指标详解\n![top命令展示](linux-top/1.png)\n\n#### 第一行：系统运行时间和平均负载\n```shell\ntop - 14:46:47 up 909 days,  3:15,  1 user,  load average: 1.80, 1.50, 1.37\n```\n- 14:46:47 表示当前系统时间\n- up 909 days 表示已经运行了909天期间没重启\n- 1 user 表示当前登录的用户数量\n- load average: 1.80, 1.50, 1.37 表示当前系统5分钟;10分钟;15分钟的负载\n<font color=red>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</font>\n<!--more-->\n#### 第二行：任务信息\n```shell\nTasks: 652 total,   1 running, 651 sleeping,   0 stopped,   0 zombie\n```\n- total : 当前系统的任务进程个数\n- runnning : 正在运行的任务进程个数\n- sleeping : 正在休眠的任务进程个数\n- stopped : 已经终止的任务进程个数\n- zombie : 僵尸进程个数\n\nrunning 表示在运行，占用cpu，sleeping则多半是在等待（比如等IO完成），所以大部分进程在sleeping是很正常的，否则都在running，cpu都不够用了.\n\n#### 第三行：CPU信息\n```shell\nCpu(s):  3.8%us,  0.4%sy,  0.0%ni, 95.7%id,  0.1%wa,  0.0%hi,  0.0%si,  0.0%st\n```\n- us — 用户空间占用CPU的百分比。\n- sy — 内核空间占用CPU的百分比。\n- ni — 改变过优先级的进程占用CPU的百分比\n- id — 空闲CPU百分比\n- wa — IO等待占用CPU的百分比\n- hi — 硬中断（Hardware IRQ）占用CPU的百分比\n- si — 软中断（Software Interrupts）占用CPU的百分比\n\n这里的内核态和用户态可以这样理解：\n- 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。\n- 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。\n\n#### 第四五行：内存信息\n```shell\nMem:  231349636k total, 72512612k used, 158837024k free,   299360k buffers\nSwap:  8388600k total,        0k used,  8388600k free,  3648000k cached\n```\n- Mem\n - total 物理内存重量\n - used 使用中的内存总量\n - free 空间内存总量\n - buffers 缓存的内存量\n- swap交换分区 具体值与上面的Mem一样,只是是对应交换分区的\n\n#### 各任务状态监控\n```\n   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n   10840 tomcat  20   0 68.0g  21g  14m S  0.3  9.8  71:32.92 jsvc     \n```\n- PID：进程ID，进程的唯一标识符\n- USER：进程所有者的实际用户名。\n- PR：进程的调度优先级。这个字段的一些值是'rt'。这意味这这些进程运行在实时态。\n- NI：进程的nice值（优先级）。越小的值意味着越高的优先级。负值表示高优先级，正值表示低优先级\n- VIRT：进程使用的虚拟内存。进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\n- RES：驻留内存大小。驻留内存是任务使用的非交换物理内存大小。进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\n- SHR：SHR是进程使用的共享内存。共享内存大小，单位kb\n- S：这个是进程的状态。它有以下不同的值:\n - D - 不可中断的睡眠态。\n - R – 运行态\n - S – 睡眠态\n - T – 被跟踪或已停止\n - Z – 僵尸态\n- %CPU：自从上一次更新时到现在任务所使用的CPU时间百分比。\n- %MEM：进程使用的可用物理内存百分比。\n- TIME+：任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。\n- COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）\n\n### top 常用参数命令\n- top -p PID 只监控某一个进程\n- top -c c表示展示完整命令行\n- top -Hp PID 查看指定进程的线程数的信息 <font>这个通常可以配合jstack来判断哪个线程占用CPU或者内存多</font>\n- top -u tomcat 查看进程用户是tomcat的任务\n\n### top 常用交互命令\n在top视图下，我们可以键入一些命令在帮助我们获得不同的视图\n\n![按键1展示各个CPU详细信息](linux-top/2.png)\n\n#### 常用键盘\n- P ：根据CPU使用百分比大小进行排序\n- M ：根据驻留内存大小进行排序\n- c ：切换显示命令名称和完整命令行\n- T ：根据时间/累计时间进行排序\n- q ：退出程序\n- 1 ：可以展示每个CPU的使用情况\n- u ：键入后会提示输出需要查看的用户名，然后就可以只查看对应用户名的任务\n\n## vmstat - 监控整体CPU,内存,IO使用情况\n### 所谓的IO\n\n所谓的I/O（Input/Output）操作实际上就是输入输出的数据传输行为。程序员最关注的主要是磁盘IO和网络IO，因为这两个IO操作和应用程序的关系最直接最紧密。\n\n- 磁盘IO：磁盘的输入输出，比如磁盘和内存之间的数据传输。\n\n- 网络IO：不同系统间跨网络的数据传输，比如两个系统间的远程接口调用。\n\n### 介绍\n\nvmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。\n相比top命令，这个命令可以看到<font color=red>整个CPU,内存,IO的使用情况</font>而不是单单看到各个进程的CPU使用率和内存使用率\n\nvmstat 3 2 表示 间隔3秒获取一次信息，一共获取2次\n\n```shell\n[ssh~]$ vmstat 3 2\nprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 163756688 272168 3186404    0    0     0    11    0    0  4  0 96  0  0\t\n 1  0      0 163758912 272168 3186424    0    0     0    72 8156 4923 14  0 85  0  0\t\n```\n### 输出参数介绍\n\n| 名称             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| r                | 表示多少个进程分配到CPU,如果值超过CPU个数表示到CPU瓶颈了     |\n| b                | 表示阻塞的进程                                               |\n| swpd (内存相关)  | 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了  |\n| free (内存相关)  | 空闲的物理内存的大小,目前我这个机器还有163758M空闲内存       |\n| buff (内存相关)  | 已用的buff大小，对块设备的读写进行缓冲                       |\n| cache (内存相关) | 已用的cache大小，文件系统的cache                             |\n| si (swap相关)    | 每秒从交换区写入内存的大小（单位：kb/s）                     |\n| so (swap相关)    | 每秒从内存写到交换区的大小                                   |\n| bi (IO相关)      | 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备 |\n| bo (IO相关)      | 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。 |\n| in               | 每秒CPU的中断次数，包括时间中断                              |\n| cs               | 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换. |\n| us (CPU相关)     | 用户进程执行消耗cpu时间                                      |\n| sy (CPU相关)     | 系统进程消耗cpu时间                                          |\n| id (CPU相关)     | 空闲时间(包括IO等待时间)                                     |\n| wa (CPU相关)     | 等待IO时间.                                                  |\n\n### 注意点\n\n- bi 和 bo 随机磁盘读写的时候，这两个值越大(如超出1024k)能看到CPU在IO等待的值也会越大。\n- cs上下文切换次数的值越小越好，太大了需要考虑调低线程或进程的数目。<font color=red>上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU没有充分被利用</font>\n- us的值比较高时，说明用户进程消耗的cpu时间多，如果长期超过50%使用，需要考虑优化程序\n- sy如果太高，表示系统调用时间长，例如是IO操作频繁\n\n## iostat -  监控系统设备的IO负载情况\n\n### 介绍\n\niostat工具对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。\n\n<font>可以认为iostat主要是通过监控磁盘来看IO负载</font>\n\n```shell\n-c 显示CPU使用情况\n-d 显示磁盘使用情况\n-k 以K为单位显示\n-m 以M为单位显示\n-N 显示磁盘阵列(LVM) 信息\n-n 显示NFS使用情况\n-p 可以报告出每块磁盘的每个分区的使用情况\n-t 显示终端和CPU的信息\n-x 显示详细信息\n```\n\niostat -d -k -x 20 # 表示间隔20秒输出一次信息\n\n![iostat监控磁盘](linux-top/3.png)\n\n### 参数说明\n\n- %user：CPU处在用户模式下的时间百分比。\n- %nice：CPU处在带NICE值的用户模式下的时间百分比。\n- %system：CPU处在系统模式下的时间百分比。\n- %iowait：CPU等待输入输出完成时间的百分比。\n- %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。\n- %idle：CPU空闲时间百分比。\n- Device ：设备名称\n- rrqm/s ：每秒合并到设备的读取请求数\n- wrqm/s ：每秒合并到设备的写请求数\n- r/s ：每秒向磁盘发起的读操作数\n- w/s ：每秒向磁盘发起的写操作数\n- rkB/s ：每秒读K字节数\n- wkB/s:每秒写K字节数\n- avgrq-sz ：平均每次设备I/O操作的数据大小\n- avgqu-sz ：平均I/O队列长度\n- await ：平均每次设备I/O操作的等待时间 (毫秒)，<font color=red>一般地，系统I/O响应时间应该低于5ms，如果大于 10ms就比较大了</font>\n- r_await ：每个读操作平均所需的时间；不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间\n- w_await ：每个写操作平均所需的时间；不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间\n- svctm ：平均每次设备I/O操作的服务时间 (毫秒)（这个数据不可信！）\n- %util ：一秒中有百分之多少的时间用于I/O操作，即被IO消耗的CPU百分比，<font color=red>一般地，如果该参数是100%表示设备已经接近满负荷运行了</font>\n\n如果%iowait的值过高，表示硬盘存在I/O瓶颈。\n如果%idle值高，表示CPU较空闲。\n如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量。\n如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。\n## free命令 -- 查看内存使用\n\n主要用来展示内存使用。其实也可以用top 和 vmstat 。 这里不过多介绍了\n\n```shell\n[watch@localhost ~]$ free -g  # -g 表示按照GB的方式展示\n             total       used       free     shared    buffers     cached\nMem:           220         64        156          0          0          3\n-/+ buffers/cache:         61        159\nSwap:            7          0          7\n```\n\n## df命令 -- 文件系统的磁盘空间使用情况\n\n```shell\n[watch@localhost ~]$ df -h #-h以易读的GB、MB、KB等格式显示\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/sda3       909G   57G  844G   7% /\ntmpfs           111G   16K  111G   1% /dev/shm\n/dev/sda1       485M  125M  335M  28% /boot\n/dev/sdb1       1.5T   16G  1.5T   2% /cache1\n```\n\n## iotop -- 精确到进程的IO监控\n\nLinux下的IO统计工具如iostat,top等大多数是只能统计到总体的读写情况, 如果你想知道每个进程是如何使用IO的就比较麻烦.\n\niotop 类似与top界面，可以查看各个进程使用IO的情况。\niotop -p PID 指定某个PID进行监控\n```shell\n[watch@localhost ~]$ iotop\nTotal DISK READ:       6.01 M/s | Total DISK WRITE:       3.85 K/s\n  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND                                                                                                          \n20074 be/4 hadoop      6.01 M/s    0.00 B/s  0.00 %  4.54 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n 6371 be/4 hadoop      0.00 B/s    3.25 M/s  0.00 %  0.00 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n 8497 be/4 hadoop      0.00 B/s    3.67 M/s  0.00 %  0.00 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init\n    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]\n```\n## netstat - 网络命令\n\n查看服务器的请求数可以用下面命令\n\n```shell\nnetstat -na |wc -l\nnetstat -anp | grep 3306 | wc -l # 统计3306端口的连接数\nnetstat -ant|awk '/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}'  #统计TCP各个状态数量\nnetstat -nat | awk '{print $6}' |sort|uniq -c|sort -rn  #统计TCP哪个状态连接数最多\nnetstat -nat | grep 'ESTABLISHED' |awk -F : '{print $1}' |sort|uniq -c|sort -rn # 统计状态为ESTABLISHED的IP是哪个\nnetstat -ant | awk '/tcp/ {print $6}'|sort |uniq -c |sort -nr #状态统计\nnetstat -ant | grep \"ESTABLISHED\"|awk '/tcp/ {print $5}'|cut -d \":\" -f1|sort |uniq -c |sort -nr |head -10 #前十位ESTABLISHED状态ip统计\n```\n\nNetstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具。\n\n```\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address(当前地址)      Foreign Address(远程地址)    State      \ntcp        0      0 127.0.0.1:2111              0.0.0.0:*                   LISTEN              \ntcp        0      0 127.0.0.1:20122             0.0.0.0:*                   LISTEN      \ntcp        0      0 0.0.0.0:2012                0.0.0.0:*                   LISTEN      \ntcp        0      0 127.0.0.1:50355             127.0.0.1:62016             TIME_WAIT      \ntcp        0      0 180.101.26.19:39669         180.101.26.26:63751         TIME_WAIT   \ntcp        0      0 180.101.26.19:39663         180.101.26.26:63751         TIME_WAIT   \ntcp        0      0 157.0.125.19:25119          218.98.49.27:65381          ESTABLISHED \n```\n\n\n\n## Arthas使用\n\nArthas是阿里巴巴出品的一款Java应用诊断利器。支持多种维度去诊断问题。具体使用可以直接看官网，写得很详细。\n\n官方文档 ： https://arthas.aliyun.com/zh-cn/\n\n### 线上服务平均响应时间太长，怎么排查？\n\n一般来说一个方法内部执行哪个方法耗时太长我们一般都是再代码上写\n\n```java\nlong start = System.currentTimeMillis();\ndoSome();\nSystem.out.println(\"doSome程序耗时 :\" + (System.currentTimeMillis() - start) );\n```\n\n然而Arthas提供了trace命令帮助我们定位。假设我要定位一个Controller类中一个方法的耗时\n\n```shell\ntrace --skipJDKMethod false com.xzy.springboot.springbootproject.controller.CommonController echo\n# com.xzy.springboot.springbootproject.controller.CommonController 类路径\n# echo 方法名\n```\n\n最终输出每个方法耗时\n\n```shell\n[arthas@16028]$ trace --skipJDKMethod false com.xzy.springboot.springbootproject.controller.CommonController echo\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 303 ms, listenerId: 1\n`---ts=2020-10-09 09:24:41;thread_name=http-nio-8080-exec-1;id=92;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@4e93dcb9\n    `---[1.736869ms] com.xzy.springboot.springbootproject.controller.CommonController:echo()\n        `---[1.110086ms] org.slf4j.Logger:info() #14 \n```\n\n## JVM调优命令 - jps\n\n可以列出本机所有java进程的pid.\n一般使用 jps -v 就行了。 -v 表示展示出详细的参数信息\n\n![jps命令](linux-top/4.png)\n\n## JVM调优命令 - jstat\n监控堆内存的用量和GC情况。\n使用格式如下 : jstat -gc PID 1000 20 # 表示使用-gc的方式打印PID的情况，间隔1000ms，打印20次\n\n![ jstat -gc命令](linux-top/5.png)\n\n-gc 对应输出结果详解\n\n- S0C:年轻代中第一个survivor（幸存区）的容量（字节）\n- S1C:年轻代中第二个survivor（幸存区）的容量(字节)\n- S0U:年轻代中第一个survivor（幸存区）目前已使用空间(字节)\n- S1U:年轻代中第二个survivor（幸存区）目前已使用空间(字节)\n- EC:年轻代中Eden（伊甸园）的容量(字节)\n- EU:年轻代中Eden（伊甸园）目前已使用空间(字节)\n- OC:Old代的容量(字节)\n- OU:Old代目前已使用空间(字节)\n- MC:metaspace(元空间)的容量(字节)\n- MU:metaspace(元空间)目前已使用空间(字节)\n- YGC:从应用程序启动到采样时年轻代中gc次数\n- YGCT:从应用程序启动到采样时年轻代中gc所用时间(s)\n- FGC:从应用程序启动到采样时old代(全gc)gc次数\n- FGCT:从应用程序启动到采样时old代(全gc)gc所用时间(s)\n- GCT:从应用程序启动到采样时gc用的总时间(s)\n\n另外除了-gc外，jstat还可以输出其他信息，具体如下\n\n- class:显示ClassLoad的相关信息；\n- compiler:显示JIT编译的相关信息；\n- gc:显示和gc相关的堆信息；\n- gccapacity:显示各个代的容量以及使用情况；\n- gcmetacapacity:显示metaspace的大小\n- gcnew:显示新生代信息；\n- gcnewcapacity:显示新生代大小和使用情况；\n- gcold:显示老年代和永久代的信息；\n- gcoldcapacity:显示老年代的大小；\n- gcutil　　:显示垃圾收集信息；\n- gccause:显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因\n\n那到底什么情况下，GC会对程序产生影响呢？ 一般来说需要判断<font color=red>FGC过于频繁、YGC耗时过长、FGC耗时过长、YGC过于频繁</font>\n\n命令详细可以参考：[jdk工具之jstat命令(Java Virtual Machine Statistics Monitoring Tool)](https://www.cnblogs.com/duanxz/archive/2012/11/03/2752166.html)\n\n## JVM调优命令 - jmap\njmap主要用来帮助我们查看堆内存情况，并支持导出成dump文件以便后续分析。\n<font color=red>导出dump文件会挂起JVM，所以一般再线上必须先切换机器后再执行</font>\n```shell\njmap -heap PID # 打印堆的使用情况\njmap -histo:live PID | head -50 #打印每个class的实例数目,内存占用,类全名信息. 如果live子参数加上后,只统计活的对象数量. 一般可以通过这个命令查看哪个对象占用的内存不合理\njmap -dump:live,format=b,file=/tmp/xxxx.hprof PID #导出存活对象的dump文件以便后面分析。live可以不加，加了表示存活对象\n```\n\n减少内存使用时一个重要目标，在堆分析上最简单的方法是利用堆直方图。通过堆直方图我们可以快速看到应用内的对象数目，同时不需要进行完整的堆转储（因为堆转储需要一段时间来分析，而且会消耗大量磁盘空间）。\n\n![存活对象的堆直方图](linux-top/6.png)\n\n## JVM调优命令 - jstack\n\njstack主要用来分析线程执行情况。可以生成某个时刻java进程中线程的快照帮助分析，比如，发现服务器的CPU的负载突然增高了、出现了死锁、死循环等。\n\n使用方法如下 :\n\n```properties\njstack PID\njstack PID > /temp/PID.txt #将线程堆栈信息保存到文件\n```\n\n**在Java中线程的状态一共被分成6种**\n\n- **初始状态**：New，线程对象创建出来后，没有调用start方法，线程处于初始状态\n- **运行状态**：包含了就绪状态和运行状态\n  - 就绪状态：Ready，调用了Start方法，等待CPU分配资源\n  - 运行状态：RUNNING，CPU分配资源给该线程，该线程处于运行状态\n- **阻塞状态** BLOCKED\n- **等待状态** WAITING：线程手动调用了wait()方法，或者join()方法\n- **超时等待状态** TIMED_WAITING：与等待状态相同，都是主动进入等待，也是需要其他线程唤醒，但是区别在与超时等待，如果超过了等待时间，则自动唤醒\n- **终止状态** DIED：线程结束之后的状态\n\n**案例1:排查线上tomcat占用CPU使用率高的原因**\n\nCPU使用率高，CPU飙升一般都是程序运行有问题，我们可以通过查看占用CPU最高的线程看看到底执行了什么\n\n1. 通过top命令查看当前使用CPU最高线程的是哪个进程，假设是tomcat，PID=10086\n2. 通过top -Hp 10086 定位到是哪个线程占用的CPU最高，假设是线程4519\n3. 算出4519的16进制，printf %x 4519 = 11a7\n4. `jstack 1893 |grep -A 200 11a7` 通过jstack查看具体信息，分析出可能出现问题的代码块\n\n**案例2:排查是否出现了死锁**\n\n```shell\njstack PID | grep 'deadlock' #判断PID是否出现了死锁\n```\n\n## 总结\n\n### 清楚从程序角度，有哪些原因导致FGC\n- 大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。\n- 内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.\n- 程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）\n- 程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM.\n- 代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。\n- JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。\n### 如何避免IO问题带来的系统故障\n- 对于磁盘文件访问的操作，可以采用线程池方式，并设置线程上线，从而避免整个JVM线程池污染，进而导致线程和CPU资源耗尽。\n- 对于网络请求，为了避免服务间调用带来的全链路故障，可以设置合理的超时时间，并且高并发场景设置限流，熔断机制。\n\n## 参考\n\n- https://www.cnblogs.com/Diyo/p/11411157.html\n- https://mp.weixin.qq.com/s/Vw63MUA0Zt80cU8_mvu7QQ","source":"_posts/linux-top.md","raw":"---\ntitle: Linux故障排查命令使用(top、iostat、vmstat、netstat、free、df、iotop)\ntags:\n  - linux\ncategories:  linux\ndescription: Linux故障排查命令使用和JVM命令(jstat、jps、jmap、jstack)\n---\n## top命令详解\n### 各项指标详解\n![top命令展示](linux-top/1.png)\n\n#### 第一行：系统运行时间和平均负载\n```shell\ntop - 14:46:47 up 909 days,  3:15,  1 user,  load average: 1.80, 1.50, 1.37\n```\n- 14:46:47 表示当前系统时间\n- up 909 days 表示已经运行了909天期间没重启\n- 1 user 表示当前登录的用户数量\n- load average: 1.80, 1.50, 1.37 表示当前系统5分钟;10分钟;15分钟的负载\n<font color=red>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</font>\n<!--more-->\n#### 第二行：任务信息\n```shell\nTasks: 652 total,   1 running, 651 sleeping,   0 stopped,   0 zombie\n```\n- total : 当前系统的任务进程个数\n- runnning : 正在运行的任务进程个数\n- sleeping : 正在休眠的任务进程个数\n- stopped : 已经终止的任务进程个数\n- zombie : 僵尸进程个数\n\nrunning 表示在运行，占用cpu，sleeping则多半是在等待（比如等IO完成），所以大部分进程在sleeping是很正常的，否则都在running，cpu都不够用了.\n\n#### 第三行：CPU信息\n```shell\nCpu(s):  3.8%us,  0.4%sy,  0.0%ni, 95.7%id,  0.1%wa,  0.0%hi,  0.0%si,  0.0%st\n```\n- us — 用户空间占用CPU的百分比。\n- sy — 内核空间占用CPU的百分比。\n- ni — 改变过优先级的进程占用CPU的百分比\n- id — 空闲CPU百分比\n- wa — IO等待占用CPU的百分比\n- hi — 硬中断（Hardware IRQ）占用CPU的百分比\n- si — 软中断（Software Interrupts）占用CPU的百分比\n\n这里的内核态和用户态可以这样理解：\n- 当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。\n- 当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。\n\n#### 第四五行：内存信息\n```shell\nMem:  231349636k total, 72512612k used, 158837024k free,   299360k buffers\nSwap:  8388600k total,        0k used,  8388600k free,  3648000k cached\n```\n- Mem\n - total 物理内存重量\n - used 使用中的内存总量\n - free 空间内存总量\n - buffers 缓存的内存量\n- swap交换分区 具体值与上面的Mem一样,只是是对应交换分区的\n\n#### 各任务状态监控\n```\n   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n   10840 tomcat  20   0 68.0g  21g  14m S  0.3  9.8  71:32.92 jsvc     \n```\n- PID：进程ID，进程的唯一标识符\n- USER：进程所有者的实际用户名。\n- PR：进程的调度优先级。这个字段的一些值是'rt'。这意味这这些进程运行在实时态。\n- NI：进程的nice值（优先级）。越小的值意味着越高的优先级。负值表示高优先级，正值表示低优先级\n- VIRT：进程使用的虚拟内存。进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES\n- RES：驻留内存大小。驻留内存是任务使用的非交换物理内存大小。进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA\n- SHR：SHR是进程使用的共享内存。共享内存大小，单位kb\n- S：这个是进程的状态。它有以下不同的值:\n - D - 不可中断的睡眠态。\n - R – 运行态\n - S – 睡眠态\n - T – 被跟踪或已停止\n - Z – 僵尸态\n- %CPU：自从上一次更新时到现在任务所使用的CPU时间百分比。\n- %MEM：进程使用的可用物理内存百分比。\n- TIME+：任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。\n- COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）\n\n### top 常用参数命令\n- top -p PID 只监控某一个进程\n- top -c c表示展示完整命令行\n- top -Hp PID 查看指定进程的线程数的信息 <font>这个通常可以配合jstack来判断哪个线程占用CPU或者内存多</font>\n- top -u tomcat 查看进程用户是tomcat的任务\n\n### top 常用交互命令\n在top视图下，我们可以键入一些命令在帮助我们获得不同的视图\n\n![按键1展示各个CPU详细信息](linux-top/2.png)\n\n#### 常用键盘\n- P ：根据CPU使用百分比大小进行排序\n- M ：根据驻留内存大小进行排序\n- c ：切换显示命令名称和完整命令行\n- T ：根据时间/累计时间进行排序\n- q ：退出程序\n- 1 ：可以展示每个CPU的使用情况\n- u ：键入后会提示输出需要查看的用户名，然后就可以只查看对应用户名的任务\n\n## vmstat - 监控整体CPU,内存,IO使用情况\n### 所谓的IO\n\n所谓的I/O（Input/Output）操作实际上就是输入输出的数据传输行为。程序员最关注的主要是磁盘IO和网络IO，因为这两个IO操作和应用程序的关系最直接最紧密。\n\n- 磁盘IO：磁盘的输入输出，比如磁盘和内存之间的数据传输。\n\n- 网络IO：不同系统间跨网络的数据传输，比如两个系统间的远程接口调用。\n\n### 介绍\n\nvmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。\n相比top命令，这个命令可以看到<font color=red>整个CPU,内存,IO的使用情况</font>而不是单单看到各个进程的CPU使用率和内存使用率\n\nvmstat 3 2 表示 间隔3秒获取一次信息，一共获取2次\n\n```shell\n[ssh~]$ vmstat 3 2\nprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 163756688 272168 3186404    0    0     0    11    0    0  4  0 96  0  0\t\n 1  0      0 163758912 272168 3186424    0    0     0    72 8156 4923 14  0 85  0  0\t\n```\n### 输出参数介绍\n\n| 名称             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| r                | 表示多少个进程分配到CPU,如果值超过CPU个数表示到CPU瓶颈了     |\n| b                | 表示阻塞的进程                                               |\n| swpd (内存相关)  | 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了  |\n| free (内存相关)  | 空闲的物理内存的大小,目前我这个机器还有163758M空闲内存       |\n| buff (内存相关)  | 已用的buff大小，对块设备的读写进行缓冲                       |\n| cache (内存相关) | 已用的cache大小，文件系统的cache                             |\n| si (swap相关)    | 每秒从交换区写入内存的大小（单位：kb/s）                     |\n| so (swap相关)    | 每秒从内存写到交换区的大小                                   |\n| bi (IO相关)      | 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备 |\n| bo (IO相关)      | 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。 |\n| in               | 每秒CPU的中断次数，包括时间中断                              |\n| cs               | 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换. |\n| us (CPU相关)     | 用户进程执行消耗cpu时间                                      |\n| sy (CPU相关)     | 系统进程消耗cpu时间                                          |\n| id (CPU相关)     | 空闲时间(包括IO等待时间)                                     |\n| wa (CPU相关)     | 等待IO时间.                                                  |\n\n### 注意点\n\n- bi 和 bo 随机磁盘读写的时候，这两个值越大(如超出1024k)能看到CPU在IO等待的值也会越大。\n- cs上下文切换次数的值越小越好，太大了需要考虑调低线程或进程的数目。<font color=red>上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU没有充分被利用</font>\n- us的值比较高时，说明用户进程消耗的cpu时间多，如果长期超过50%使用，需要考虑优化程序\n- sy如果太高，表示系统调用时间长，例如是IO操作频繁\n\n## iostat -  监控系统设备的IO负载情况\n\n### 介绍\n\niostat工具对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。\n\n<font>可以认为iostat主要是通过监控磁盘来看IO负载</font>\n\n```shell\n-c 显示CPU使用情况\n-d 显示磁盘使用情况\n-k 以K为单位显示\n-m 以M为单位显示\n-N 显示磁盘阵列(LVM) 信息\n-n 显示NFS使用情况\n-p 可以报告出每块磁盘的每个分区的使用情况\n-t 显示终端和CPU的信息\n-x 显示详细信息\n```\n\niostat -d -k -x 20 # 表示间隔20秒输出一次信息\n\n![iostat监控磁盘](linux-top/3.png)\n\n### 参数说明\n\n- %user：CPU处在用户模式下的时间百分比。\n- %nice：CPU处在带NICE值的用户模式下的时间百分比。\n- %system：CPU处在系统模式下的时间百分比。\n- %iowait：CPU等待输入输出完成时间的百分比。\n- %steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。\n- %idle：CPU空闲时间百分比。\n- Device ：设备名称\n- rrqm/s ：每秒合并到设备的读取请求数\n- wrqm/s ：每秒合并到设备的写请求数\n- r/s ：每秒向磁盘发起的读操作数\n- w/s ：每秒向磁盘发起的写操作数\n- rkB/s ：每秒读K字节数\n- wkB/s:每秒写K字节数\n- avgrq-sz ：平均每次设备I/O操作的数据大小\n- avgqu-sz ：平均I/O队列长度\n- await ：平均每次设备I/O操作的等待时间 (毫秒)，<font color=red>一般地，系统I/O响应时间应该低于5ms，如果大于 10ms就比较大了</font>\n- r_await ：每个读操作平均所需的时间；不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间\n- w_await ：每个写操作平均所需的时间；不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间\n- svctm ：平均每次设备I/O操作的服务时间 (毫秒)（这个数据不可信！）\n- %util ：一秒中有百分之多少的时间用于I/O操作，即被IO消耗的CPU百分比，<font color=red>一般地，如果该参数是100%表示设备已经接近满负荷运行了</font>\n\n如果%iowait的值过高，表示硬盘存在I/O瓶颈。\n如果%idle值高，表示CPU较空闲。\n如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量。\n如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。\n## free命令 -- 查看内存使用\n\n主要用来展示内存使用。其实也可以用top 和 vmstat 。 这里不过多介绍了\n\n```shell\n[watch@localhost ~]$ free -g  # -g 表示按照GB的方式展示\n             total       used       free     shared    buffers     cached\nMem:           220         64        156          0          0          3\n-/+ buffers/cache:         61        159\nSwap:            7          0          7\n```\n\n## df命令 -- 文件系统的磁盘空间使用情况\n\n```shell\n[watch@localhost ~]$ df -h #-h以易读的GB、MB、KB等格式显示\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/sda3       909G   57G  844G   7% /\ntmpfs           111G   16K  111G   1% /dev/shm\n/dev/sda1       485M  125M  335M  28% /boot\n/dev/sdb1       1.5T   16G  1.5T   2% /cache1\n```\n\n## iotop -- 精确到进程的IO监控\n\nLinux下的IO统计工具如iostat,top等大多数是只能统计到总体的读写情况, 如果你想知道每个进程是如何使用IO的就比较麻烦.\n\niotop 类似与top界面，可以查看各个进程使用IO的情况。\niotop -p PID 指定某个PID进行监控\n```shell\n[watch@localhost ~]$ iotop\nTotal DISK READ:       6.01 M/s | Total DISK WRITE:       3.85 K/s\n  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND                                                                                                          \n20074 be/4 hadoop      6.01 M/s    0.00 B/s  0.00 %  4.54 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n 6371 be/4 hadoop      0.00 B/s    3.25 M/s  0.00 %  0.00 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n 8497 be/4 hadoop      0.00 B/s    3.67 M/s  0.00 %  0.00 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init\n    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]\n```\n## netstat - 网络命令\n\n查看服务器的请求数可以用下面命令\n\n```shell\nnetstat -na |wc -l\nnetstat -anp | grep 3306 | wc -l # 统计3306端口的连接数\nnetstat -ant|awk '/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}'  #统计TCP各个状态数量\nnetstat -nat | awk '{print $6}' |sort|uniq -c|sort -rn  #统计TCP哪个状态连接数最多\nnetstat -nat | grep 'ESTABLISHED' |awk -F : '{print $1}' |sort|uniq -c|sort -rn # 统计状态为ESTABLISHED的IP是哪个\nnetstat -ant | awk '/tcp/ {print $6}'|sort |uniq -c |sort -nr #状态统计\nnetstat -ant | grep \"ESTABLISHED\"|awk '/tcp/ {print $5}'|cut -d \":\" -f1|sort |uniq -c |sort -nr |head -10 #前十位ESTABLISHED状态ip统计\n```\n\nNetstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具。\n\n```\nActive Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address(当前地址)      Foreign Address(远程地址)    State      \ntcp        0      0 127.0.0.1:2111              0.0.0.0:*                   LISTEN              \ntcp        0      0 127.0.0.1:20122             0.0.0.0:*                   LISTEN      \ntcp        0      0 0.0.0.0:2012                0.0.0.0:*                   LISTEN      \ntcp        0      0 127.0.0.1:50355             127.0.0.1:62016             TIME_WAIT      \ntcp        0      0 180.101.26.19:39669         180.101.26.26:63751         TIME_WAIT   \ntcp        0      0 180.101.26.19:39663         180.101.26.26:63751         TIME_WAIT   \ntcp        0      0 157.0.125.19:25119          218.98.49.27:65381          ESTABLISHED \n```\n\n\n\n## Arthas使用\n\nArthas是阿里巴巴出品的一款Java应用诊断利器。支持多种维度去诊断问题。具体使用可以直接看官网，写得很详细。\n\n官方文档 ： https://arthas.aliyun.com/zh-cn/\n\n### 线上服务平均响应时间太长，怎么排查？\n\n一般来说一个方法内部执行哪个方法耗时太长我们一般都是再代码上写\n\n```java\nlong start = System.currentTimeMillis();\ndoSome();\nSystem.out.println(\"doSome程序耗时 :\" + (System.currentTimeMillis() - start) );\n```\n\n然而Arthas提供了trace命令帮助我们定位。假设我要定位一个Controller类中一个方法的耗时\n\n```shell\ntrace --skipJDKMethod false com.xzy.springboot.springbootproject.controller.CommonController echo\n# com.xzy.springboot.springbootproject.controller.CommonController 类路径\n# echo 方法名\n```\n\n最终输出每个方法耗时\n\n```shell\n[arthas@16028]$ trace --skipJDKMethod false com.xzy.springboot.springbootproject.controller.CommonController echo\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 303 ms, listenerId: 1\n`---ts=2020-10-09 09:24:41;thread_name=http-nio-8080-exec-1;id=92;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@4e93dcb9\n    `---[1.736869ms] com.xzy.springboot.springbootproject.controller.CommonController:echo()\n        `---[1.110086ms] org.slf4j.Logger:info() #14 \n```\n\n## JVM调优命令 - jps\n\n可以列出本机所有java进程的pid.\n一般使用 jps -v 就行了。 -v 表示展示出详细的参数信息\n\n![jps命令](linux-top/4.png)\n\n## JVM调优命令 - jstat\n监控堆内存的用量和GC情况。\n使用格式如下 : jstat -gc PID 1000 20 # 表示使用-gc的方式打印PID的情况，间隔1000ms，打印20次\n\n![ jstat -gc命令](linux-top/5.png)\n\n-gc 对应输出结果详解\n\n- S0C:年轻代中第一个survivor（幸存区）的容量（字节）\n- S1C:年轻代中第二个survivor（幸存区）的容量(字节)\n- S0U:年轻代中第一个survivor（幸存区）目前已使用空间(字节)\n- S1U:年轻代中第二个survivor（幸存区）目前已使用空间(字节)\n- EC:年轻代中Eden（伊甸园）的容量(字节)\n- EU:年轻代中Eden（伊甸园）目前已使用空间(字节)\n- OC:Old代的容量(字节)\n- OU:Old代目前已使用空间(字节)\n- MC:metaspace(元空间)的容量(字节)\n- MU:metaspace(元空间)目前已使用空间(字节)\n- YGC:从应用程序启动到采样时年轻代中gc次数\n- YGCT:从应用程序启动到采样时年轻代中gc所用时间(s)\n- FGC:从应用程序启动到采样时old代(全gc)gc次数\n- FGCT:从应用程序启动到采样时old代(全gc)gc所用时间(s)\n- GCT:从应用程序启动到采样时gc用的总时间(s)\n\n另外除了-gc外，jstat还可以输出其他信息，具体如下\n\n- class:显示ClassLoad的相关信息；\n- compiler:显示JIT编译的相关信息；\n- gc:显示和gc相关的堆信息；\n- gccapacity:显示各个代的容量以及使用情况；\n- gcmetacapacity:显示metaspace的大小\n- gcnew:显示新生代信息；\n- gcnewcapacity:显示新生代大小和使用情况；\n- gcold:显示老年代和永久代的信息；\n- gcoldcapacity:显示老年代的大小；\n- gcutil　　:显示垃圾收集信息；\n- gccause:显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因\n\n那到底什么情况下，GC会对程序产生影响呢？ 一般来说需要判断<font color=red>FGC过于频繁、YGC耗时过长、FGC耗时过长、YGC过于频繁</font>\n\n命令详细可以参考：[jdk工具之jstat命令(Java Virtual Machine Statistics Monitoring Tool)](https://www.cnblogs.com/duanxz/archive/2012/11/03/2752166.html)\n\n## JVM调优命令 - jmap\njmap主要用来帮助我们查看堆内存情况，并支持导出成dump文件以便后续分析。\n<font color=red>导出dump文件会挂起JVM，所以一般再线上必须先切换机器后再执行</font>\n```shell\njmap -heap PID # 打印堆的使用情况\njmap -histo:live PID | head -50 #打印每个class的实例数目,内存占用,类全名信息. 如果live子参数加上后,只统计活的对象数量. 一般可以通过这个命令查看哪个对象占用的内存不合理\njmap -dump:live,format=b,file=/tmp/xxxx.hprof PID #导出存活对象的dump文件以便后面分析。live可以不加，加了表示存活对象\n```\n\n减少内存使用时一个重要目标，在堆分析上最简单的方法是利用堆直方图。通过堆直方图我们可以快速看到应用内的对象数目，同时不需要进行完整的堆转储（因为堆转储需要一段时间来分析，而且会消耗大量磁盘空间）。\n\n![存活对象的堆直方图](linux-top/6.png)\n\n## JVM调优命令 - jstack\n\njstack主要用来分析线程执行情况。可以生成某个时刻java进程中线程的快照帮助分析，比如，发现服务器的CPU的负载突然增高了、出现了死锁、死循环等。\n\n使用方法如下 :\n\n```properties\njstack PID\njstack PID > /temp/PID.txt #将线程堆栈信息保存到文件\n```\n\n**在Java中线程的状态一共被分成6种**\n\n- **初始状态**：New，线程对象创建出来后，没有调用start方法，线程处于初始状态\n- **运行状态**：包含了就绪状态和运行状态\n  - 就绪状态：Ready，调用了Start方法，等待CPU分配资源\n  - 运行状态：RUNNING，CPU分配资源给该线程，该线程处于运行状态\n- **阻塞状态** BLOCKED\n- **等待状态** WAITING：线程手动调用了wait()方法，或者join()方法\n- **超时等待状态** TIMED_WAITING：与等待状态相同，都是主动进入等待，也是需要其他线程唤醒，但是区别在与超时等待，如果超过了等待时间，则自动唤醒\n- **终止状态** DIED：线程结束之后的状态\n\n**案例1:排查线上tomcat占用CPU使用率高的原因**\n\nCPU使用率高，CPU飙升一般都是程序运行有问题，我们可以通过查看占用CPU最高的线程看看到底执行了什么\n\n1. 通过top命令查看当前使用CPU最高线程的是哪个进程，假设是tomcat，PID=10086\n2. 通过top -Hp 10086 定位到是哪个线程占用的CPU最高，假设是线程4519\n3. 算出4519的16进制，printf %x 4519 = 11a7\n4. `jstack 1893 |grep -A 200 11a7` 通过jstack查看具体信息，分析出可能出现问题的代码块\n\n**案例2:排查是否出现了死锁**\n\n```shell\njstack PID | grep 'deadlock' #判断PID是否出现了死锁\n```\n\n## 总结\n\n### 清楚从程序角度，有哪些原因导致FGC\n- 大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。\n- 内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.\n- 程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）\n- 程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM.\n- 代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。\n- JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。\n### 如何避免IO问题带来的系统故障\n- 对于磁盘文件访问的操作，可以采用线程池方式，并设置线程上线，从而避免整个JVM线程池污染，进而导致线程和CPU资源耗尽。\n- 对于网络请求，为了避免服务间调用带来的全链路故障，可以设置合理的超时时间，并且高并发场景设置限流，熔断机制。\n\n## 参考\n\n- https://www.cnblogs.com/Diyo/p/11411157.html\n- https://mp.weixin.qq.com/s/Vw63MUA0Zt80cU8_mvu7QQ","slug":"linux-top","published":1,"date":"2021-04-08T00:47:06.827Z","updated":"2021-04-30T00:58:39.974Z","_id":"ckn9yvhva001mqwv2hanmfrzj","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"top命令详解\"><a href=\"#top命令详解\" class=\"headerlink\" title=\"top命令详解\"></a>top命令详解</h2><h3 id=\"各项指标详解\"><a href=\"#各项指标详解\" class=\"headerlink\" title=\"各项指标详解\"></a>各项指标详解</h3><p><img src=\"/2021/04/08/linux-top/1.png\" alt=\"top命令展示\"></p>\n<h4 id=\"第一行：系统运行时间和平均负载\"><a href=\"#第一行：系统运行时间和平均负载\" class=\"headerlink\" title=\"第一行：系统运行时间和平均负载\"></a>第一行：系统运行时间和平均负载</h4><pre class=\" language-shell\"><code class=\"language-shell\">top - 14:46:47 up 909 days,  3:15,  1 user,  load average: 1.80, 1.50, 1.37</code></pre>\n<ul>\n<li>14:46:47 表示当前系统时间</li>\n<li>up 909 days 表示已经运行了909天期间没重启</li>\n<li>1 user 表示当前登录的用户数量</li>\n<li>load average: 1.80, 1.50, 1.37 表示当前系统5分钟;10分钟;15分钟的负载<br><font color=\"red\">load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</font><a id=\"more\"></a>\n<h4 id=\"第二行：任务信息\"><a href=\"#第二行：任务信息\" class=\"headerlink\" title=\"第二行：任务信息\"></a>第二行：任务信息</h4><pre class=\" language-shell\"><code class=\"language-shell\">Tasks: 652 total,   1 running, 651 sleeping,   0 stopped,   0 zombie</code></pre>\n</li>\n<li>total : 当前系统的任务进程个数</li>\n<li>runnning : 正在运行的任务进程个数</li>\n<li>sleeping : 正在休眠的任务进程个数</li>\n<li>stopped : 已经终止的任务进程个数</li>\n<li>zombie : 僵尸进程个数</li>\n</ul>\n<p>running 表示在运行，占用cpu，sleeping则多半是在等待（比如等IO完成），所以大部分进程在sleeping是很正常的，否则都在running，cpu都不够用了.</p>\n<h4 id=\"第三行：CPU信息\"><a href=\"#第三行：CPU信息\" class=\"headerlink\" title=\"第三行：CPU信息\"></a>第三行：CPU信息</h4><pre class=\" language-shell\"><code class=\"language-shell\">Cpu(s):  3.8%us,  0.4%sy,  0.0%ni, 95.7%id,  0.1%wa,  0.0%hi,  0.0%si,  0.0%st</code></pre>\n<ul>\n<li>us — 用户空间占用CPU的百分比。</li>\n<li>sy — 内核空间占用CPU的百分比。</li>\n<li>ni — 改变过优先级的进程占用CPU的百分比</li>\n<li>id — 空闲CPU百分比</li>\n<li>wa — IO等待占用CPU的百分比</li>\n<li>hi — 硬中断（Hardware IRQ）占用CPU的百分比</li>\n<li>si — 软中断（Software Interrupts）占用CPU的百分比</li>\n</ul>\n<p>这里的内核态和用户态可以这样理解：</p>\n<ul>\n<li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。</li>\n<li>当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。</li>\n</ul>\n<h4 id=\"第四五行：内存信息\"><a href=\"#第四五行：内存信息\" class=\"headerlink\" title=\"第四五行：内存信息\"></a>第四五行：内存信息</h4><pre class=\" language-shell\"><code class=\"language-shell\">Mem:  231349636k total, 72512612k used, 158837024k free,   299360k buffers\nSwap:  8388600k total,        0k used,  8388600k free,  3648000k cached</code></pre>\n<ul>\n<li>Mem<ul>\n<li>total 物理内存重量</li>\n<li>used 使用中的内存总量</li>\n<li>free 空间内存总量</li>\n<li>buffers 缓存的内存量</li>\n</ul>\n</li>\n<li>swap交换分区 具体值与上面的Mem一样,只是是对应交换分区的</li>\n</ul>\n<h4 id=\"各任务状态监控\"><a href=\"#各任务状态监控\" class=\"headerlink\" title=\"各任务状态监控\"></a>各任务状态监控</h4><pre><code>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n   10840 tomcat  20   0 68.0g  21g  14m S  0.3  9.8  71:32.92 jsvc     </code></pre><ul>\n<li>PID：进程ID，进程的唯一标识符</li>\n<li>USER：进程所有者的实际用户名。</li>\n<li>PR：进程的调度优先级。这个字段的一些值是’rt’。这意味这这些进程运行在实时态。</li>\n<li>NI：进程的nice值（优先级）。越小的值意味着越高的优先级。负值表示高优先级，正值表示低优先级</li>\n<li>VIRT：进程使用的虚拟内存。进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li>\n<li>RES：驻留内存大小。驻留内存是任务使用的非交换物理内存大小。进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li>\n<li>SHR：SHR是进程使用的共享内存。共享内存大小，单位kb</li>\n<li>S：这个是进程的状态。它有以下不同的值:<ul>\n<li>D - 不可中断的睡眠态。</li>\n<li>R – 运行态</li>\n<li>S – 睡眠态</li>\n<li>T – 被跟踪或已停止</li>\n<li>Z – 僵尸态</li>\n</ul>\n</li>\n<li>%CPU：自从上一次更新时到现在任务所使用的CPU时间百分比。</li>\n<li>%MEM：进程使用的可用物理内存百分比。</li>\n<li>TIME+：任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。</li>\n<li>COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）</li>\n</ul>\n<h3 id=\"top-常用参数命令\"><a href=\"#top-常用参数命令\" class=\"headerlink\" title=\"top 常用参数命令\"></a>top 常用参数命令</h3><ul>\n<li>top -p PID 只监控某一个进程</li>\n<li>top -c c表示展示完整命令行</li>\n<li>top -Hp PID 查看指定进程的线程数的信息 <font>这个通常可以配合jstack来判断哪个线程占用CPU或者内存多</font></li>\n<li>top -u tomcat 查看进程用户是tomcat的任务</li>\n</ul>\n<h3 id=\"top-常用交互命令\"><a href=\"#top-常用交互命令\" class=\"headerlink\" title=\"top 常用交互命令\"></a>top 常用交互命令</h3><p>在top视图下，我们可以键入一些命令在帮助我们获得不同的视图</p>\n<p><img src=\"/2021/04/08/linux-top/2.png\" alt=\"按键1展示各个CPU详细信息\"></p>\n<h4 id=\"常用键盘\"><a href=\"#常用键盘\" class=\"headerlink\" title=\"常用键盘\"></a>常用键盘</h4><ul>\n<li>P ：根据CPU使用百分比大小进行排序</li>\n<li>M ：根据驻留内存大小进行排序</li>\n<li>c ：切换显示命令名称和完整命令行</li>\n<li>T ：根据时间/累计时间进行排序</li>\n<li>q ：退出程序</li>\n<li>1 ：可以展示每个CPU的使用情况</li>\n<li>u ：键入后会提示输出需要查看的用户名，然后就可以只查看对应用户名的任务</li>\n</ul>\n<h2 id=\"vmstat-监控整体CPU-内存-IO使用情况\"><a href=\"#vmstat-监控整体CPU-内存-IO使用情况\" class=\"headerlink\" title=\"vmstat - 监控整体CPU,内存,IO使用情况\"></a>vmstat - 监控整体CPU,内存,IO使用情况</h2><h3 id=\"所谓的IO\"><a href=\"#所谓的IO\" class=\"headerlink\" title=\"所谓的IO\"></a>所谓的IO</h3><p>所谓的I/O（Input/Output）操作实际上就是输入输出的数据传输行为。程序员最关注的主要是磁盘IO和网络IO，因为这两个IO操作和应用程序的关系最直接最紧密。</p>\n<ul>\n<li><p>磁盘IO：磁盘的输入输出，比如磁盘和内存之间的数据传输。</p>\n</li>\n<li><p>网络IO：不同系统间跨网络的数据传输，比如两个系统间的远程接口调用。</p>\n</li>\n</ul>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。<br>相比top命令，这个命令可以看到<font color=\"red\">整个CPU,内存,IO的使用情况</font>而不是单单看到各个进程的CPU使用率和内存使用率</p>\n<p>vmstat 3 2 表示 间隔3秒获取一次信息，一共获取2次</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[ssh~]$ vmstat 3 2\nprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 163756688 272168 3186404    0    0     0    11    0    0  4  0 96  0  0    \n 1  0      0 163758912 272168 3186424    0    0     0    72 8156 4923 14  0 85  0  0    </code></pre>\n<h3 id=\"输出参数介绍\"><a href=\"#输出参数介绍\" class=\"headerlink\" title=\"输出参数介绍\"></a>输出参数介绍</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r</td>\n<td>表示多少个进程分配到CPU,如果值超过CPU个数表示到CPU瓶颈了</td>\n</tr>\n<tr>\n<td>b</td>\n<td>表示阻塞的进程</td>\n</tr>\n<tr>\n<td>swpd (内存相关)</td>\n<td>虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了</td>\n</tr>\n<tr>\n<td>free (内存相关)</td>\n<td>空闲的物理内存的大小,目前我这个机器还有163758M空闲内存</td>\n</tr>\n<tr>\n<td>buff (内存相关)</td>\n<td>已用的buff大小，对块设备的读写进行缓冲</td>\n</tr>\n<tr>\n<td>cache (内存相关)</td>\n<td>已用的cache大小，文件系统的cache</td>\n</tr>\n<tr>\n<td>si (swap相关)</td>\n<td>每秒从交换区写入内存的大小（单位：kb/s）</td>\n</tr>\n<tr>\n<td>so (swap相关)</td>\n<td>每秒从内存写到交换区的大小</td>\n</tr>\n<tr>\n<td>bi (IO相关)</td>\n<td>块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备</td>\n</tr>\n<tr>\n<td>bo (IO相关)</td>\n<td>块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。</td>\n</tr>\n<tr>\n<td>in</td>\n<td>每秒CPU的中断次数，包括时间中断</td>\n</tr>\n<tr>\n<td>cs</td>\n<td>每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换.</td>\n</tr>\n<tr>\n<td>us (CPU相关)</td>\n<td>用户进程执行消耗cpu时间</td>\n</tr>\n<tr>\n<td>sy (CPU相关)</td>\n<td>系统进程消耗cpu时间</td>\n</tr>\n<tr>\n<td>id (CPU相关)</td>\n<td>空闲时间(包括IO等待时间)</td>\n</tr>\n<tr>\n<td>wa (CPU相关)</td>\n<td>等待IO时间.</td>\n</tr>\n</tbody></table>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ul>\n<li>bi 和 bo 随机磁盘读写的时候，这两个值越大(如超出1024k)能看到CPU在IO等待的值也会越大。</li>\n<li>cs上下文切换次数的值越小越好，太大了需要考虑调低线程或进程的数目。<font color=\"red\">上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU没有充分被利用</font></li>\n<li>us的值比较高时，说明用户进程消耗的cpu时间多，如果长期超过50%使用，需要考虑优化程序</li>\n<li>sy如果太高，表示系统调用时间长，例如是IO操作频繁</li>\n</ul>\n<h2 id=\"iostat-监控系统设备的IO负载情况\"><a href=\"#iostat-监控系统设备的IO负载情况\" class=\"headerlink\" title=\"iostat -  监控系统设备的IO负载情况\"></a>iostat -  监控系统设备的IO负载情况</h2><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>iostat工具对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。</p>\n<p><font>可以认为iostat主要是通过监控磁盘来看IO负载</font></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">-c 显示CPU使用情况\n-d 显示磁盘使用情况\n-k 以K为单位显示\n-m 以M为单位显示\n-N 显示磁盘阵列(LVM) 信息\n-n 显示NFS使用情况\n-p 可以报告出每块磁盘的每个分区的使用情况\n-t 显示终端和CPU的信息\n-x 显示详细信息</code></pre>\n<p>iostat -d -k -x 20 # 表示间隔20秒输出一次信息</p>\n<p><img src=\"/2021/04/08/linux-top/3.png\" alt=\"iostat监控磁盘\"></p>\n<h3 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><ul>\n<li>%user：CPU处在用户模式下的时间百分比。</li>\n<li>%nice：CPU处在带NICE值的用户模式下的时间百分比。</li>\n<li>%system：CPU处在系统模式下的时间百分比。</li>\n<li>%iowait：CPU等待输入输出完成时间的百分比。</li>\n<li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li>\n<li>%idle：CPU空闲时间百分比。</li>\n<li>Device ：设备名称</li>\n<li>rrqm/s ：每秒合并到设备的读取请求数</li>\n<li>wrqm/s ：每秒合并到设备的写请求数</li>\n<li>r/s ：每秒向磁盘发起的读操作数</li>\n<li>w/s ：每秒向磁盘发起的写操作数</li>\n<li>rkB/s ：每秒读K字节数</li>\n<li>wkB/s:每秒写K字节数</li>\n<li>avgrq-sz ：平均每次设备I/O操作的数据大小</li>\n<li>avgqu-sz ：平均I/O队列长度</li>\n<li>await ：平均每次设备I/O操作的等待时间 (毫秒)，<font color=\"red\">一般地，系统I/O响应时间应该低于5ms，如果大于 10ms就比较大了</font></li>\n<li>r_await ：每个读操作平均所需的时间；不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间</li>\n<li>w_await ：每个写操作平均所需的时间；不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间</li>\n<li>svctm ：平均每次设备I/O操作的服务时间 (毫秒)（这个数据不可信！）</li>\n<li>%util ：一秒中有百分之多少的时间用于I/O操作，即被IO消耗的CPU百分比，<font color=\"red\">一般地，如果该参数是100%表示设备已经接近满负荷运行了</font></li>\n</ul>\n<p>如果%iowait的值过高，表示硬盘存在I/O瓶颈。<br>如果%idle值高，表示CPU较空闲。<br>如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量。<br>如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。</p>\n<h2 id=\"free命令-–-查看内存使用\"><a href=\"#free命令-–-查看内存使用\" class=\"headerlink\" title=\"free命令 – 查看内存使用\"></a>free命令 – 查看内存使用</h2><p>主要用来展示内存使用。其实也可以用top 和 vmstat 。 这里不过多介绍了</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[watch@localhost ~]$ free -g  # -g 表示按照GB的方式展示\n             total       used       free     shared    buffers     cached\nMem:           220         64        156          0          0          3\n-/+ buffers/cache:         61        159\nSwap:            7          0          7</code></pre>\n<h2 id=\"df命令-–-文件系统的磁盘空间使用情况\"><a href=\"#df命令-–-文件系统的磁盘空间使用情况\" class=\"headerlink\" title=\"df命令 – 文件系统的磁盘空间使用情况\"></a>df命令 – 文件系统的磁盘空间使用情况</h2><pre class=\" language-shell\"><code class=\"language-shell\">[watch@localhost ~]$ df -h #-h以易读的GB、MB、KB等格式显示\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/sda3       909G   57G  844G   7% /\ntmpfs           111G   16K  111G   1% /dev/shm\n/dev/sda1       485M  125M  335M  28% /boot\n/dev/sdb1       1.5T   16G  1.5T   2% /cache1</code></pre>\n<h2 id=\"iotop-–-精确到进程的IO监控\"><a href=\"#iotop-–-精确到进程的IO监控\" class=\"headerlink\" title=\"iotop – 精确到进程的IO监控\"></a>iotop – 精确到进程的IO监控</h2><p>Linux下的IO统计工具如iostat,top等大多数是只能统计到总体的读写情况, 如果你想知道每个进程是如何使用IO的就比较麻烦.</p>\n<p>iotop 类似与top界面，可以查看各个进程使用IO的情况。<br>iotop -p PID 指定某个PID进行监控</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[watch@localhost ~]$ iotop\nTotal DISK READ:       6.01 M/s | Total DISK WRITE:       3.85 K/s\n  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO>    COMMAND                                                                                                          \n20074 be/4 hadoop      6.01 M/s    0.00 B/s  0.00 %  4.54 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n 6371 be/4 hadoop      0.00 B/s    3.25 M/s  0.00 %  0.00 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n 8497 be/4 hadoop      0.00 B/s    3.67 M/s  0.00 %  0.00 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init\n    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</code></pre>\n<h2 id=\"netstat-网络命令\"><a href=\"#netstat-网络命令\" class=\"headerlink\" title=\"netstat - 网络命令\"></a>netstat - 网络命令</h2><p>查看服务器的请求数可以用下面命令</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">netstat -na |wc -l\nnetstat -anp | grep 3306 | wc -l # 统计3306端口的连接数\nnetstat -ant|awk '/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}'  #统计TCP各个状态数量\nnetstat -nat | awk '{print $6}' |sort|uniq -c|sort -rn  #统计TCP哪个状态连接数最多\nnetstat -nat | grep 'ESTABLISHED' |awk -F : '{print $1}' |sort|uniq -c|sort -rn # 统计状态为ESTABLISHED的IP是哪个\nnetstat -ant | awk '/tcp/ {print $6}'|sort |uniq -c |sort -nr #状态统计\nnetstat -ant | grep \"ESTABLISHED\"|awk '/tcp/ {print $5}'|cut -d \":\" -f1|sort |uniq -c |sort -nr |head -10 #前十位ESTABLISHED状态ip统计</code></pre>\n<p>Netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具。</p>\n<pre><code>Active Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address(当前地址)      Foreign Address(远程地址)    State      \ntcp        0      0 127.0.0.1:2111              0.0.0.0:*                   LISTEN              \ntcp        0      0 127.0.0.1:20122             0.0.0.0:*                   LISTEN      \ntcp        0      0 0.0.0.0:2012                0.0.0.0:*                   LISTEN      \ntcp        0      0 127.0.0.1:50355             127.0.0.1:62016             TIME_WAIT      \ntcp        0      0 180.101.26.19:39669         180.101.26.26:63751         TIME_WAIT   \ntcp        0      0 180.101.26.19:39663         180.101.26.26:63751         TIME_WAIT   \ntcp        0      0 157.0.125.19:25119          218.98.49.27:65381          ESTABLISHED </code></pre><h2 id=\"Arthas使用\"><a href=\"#Arthas使用\" class=\"headerlink\" title=\"Arthas使用\"></a>Arthas使用</h2><p>Arthas是阿里巴巴出品的一款Java应用诊断利器。支持多种维度去诊断问题。具体使用可以直接看官网，写得很详细。</p>\n<p>官方文档 ： <a href=\"https://arthas.aliyun.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">https://arthas.aliyun.com/zh-cn/</a></p>\n<h3 id=\"线上服务平均响应时间太长，怎么排查？\"><a href=\"#线上服务平均响应时间太长，怎么排查？\" class=\"headerlink\" title=\"线上服务平均响应时间太长，怎么排查？\"></a>线上服务平均响应时间太长，怎么排查？</h3><p>一般来说一个方法内部执行哪个方法耗时太长我们一般都是再代码上写</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">long</span> start <span class=\"token operator\">=</span> System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">doSome</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"doSome程序耗时 :\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>然而Arthas提供了trace命令帮助我们定位。假设我要定位一个Controller类中一个方法的耗时</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">trace --skipJDKMethod false com.xzy.springboot.springbootproject.controller.CommonController echo\n# com.xzy.springboot.springbootproject.controller.CommonController 类路径\n# echo 方法名</code></pre>\n<p>最终输出每个方法耗时</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[arthas@16028]$ trace --skipJDKMethod false com.xzy.springboot.springbootproject.controller.CommonController echo\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 303 ms, listenerId: 1\n`---ts=2020-10-09 09:24:41;thread_name=http-nio-8080-exec-1;id=92;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@4e93dcb9\n    `---[1.736869ms] com.xzy.springboot.springbootproject.controller.CommonController:echo()\n        `---[1.110086ms] org.slf4j.Logger:info() #14 </code></pre>\n<h2 id=\"JVM调优命令-jps\"><a href=\"#JVM调优命令-jps\" class=\"headerlink\" title=\"JVM调优命令 - jps\"></a>JVM调优命令 - jps</h2><p>可以列出本机所有java进程的pid.<br>一般使用 jps -v 就行了。 -v 表示展示出详细的参数信息</p>\n<p><img src=\"/2021/04/08/linux-top/4.png\" alt=\"jps命令\"></p>\n<h2 id=\"JVM调优命令-jstat\"><a href=\"#JVM调优命令-jstat\" class=\"headerlink\" title=\"JVM调优命令 - jstat\"></a>JVM调优命令 - jstat</h2><p>监控堆内存的用量和GC情况。<br>使用格式如下 : jstat -gc PID 1000 20 # 表示使用-gc的方式打印PID的情况，间隔1000ms，打印20次</p>\n<p><img src=\"/2021/04/08/linux-top/5.png\" alt=\" jstat -gc命令\"></p>\n<p>-gc 对应输出结果详解</p>\n<ul>\n<li>S0C:年轻代中第一个survivor（幸存区）的容量（字节）</li>\n<li>S1C:年轻代中第二个survivor（幸存区）的容量(字节)</li>\n<li>S0U:年轻代中第一个survivor（幸存区）目前已使用空间(字节)</li>\n<li>S1U:年轻代中第二个survivor（幸存区）目前已使用空间(字节)</li>\n<li>EC:年轻代中Eden（伊甸园）的容量(字节)</li>\n<li>EU:年轻代中Eden（伊甸园）目前已使用空间(字节)</li>\n<li>OC:Old代的容量(字节)</li>\n<li>OU:Old代目前已使用空间(字节)</li>\n<li>MC:metaspace(元空间)的容量(字节)</li>\n<li>MU:metaspace(元空间)目前已使用空间(字节)</li>\n<li>YGC:从应用程序启动到采样时年轻代中gc次数</li>\n<li>YGCT:从应用程序启动到采样时年轻代中gc所用时间(s)</li>\n<li>FGC:从应用程序启动到采样时old代(全gc)gc次数</li>\n<li>FGCT:从应用程序启动到采样时old代(全gc)gc所用时间(s)</li>\n<li>GCT:从应用程序启动到采样时gc用的总时间(s)</li>\n</ul>\n<p>另外除了-gc外，jstat还可以输出其他信息，具体如下</p>\n<ul>\n<li>class:显示ClassLoad的相关信息；</li>\n<li>compiler:显示JIT编译的相关信息；</li>\n<li>gc:显示和gc相关的堆信息；</li>\n<li>gccapacity:显示各个代的容量以及使用情况；</li>\n<li>gcmetacapacity:显示metaspace的大小</li>\n<li>gcnew:显示新生代信息；</li>\n<li>gcnewcapacity:显示新生代大小和使用情况；</li>\n<li>gcold:显示老年代和永久代的信息；</li>\n<li>gcoldcapacity:显示老年代的大小；</li>\n<li>gcutil　　:显示垃圾收集信息；</li>\n<li>gccause:显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因</li>\n</ul>\n<p>那到底什么情况下，GC会对程序产生影响呢？ 一般来说需要判断<font color=\"red\">FGC过于频繁、YGC耗时过长、FGC耗时过长、YGC过于频繁</font></p>\n<p>命令详细可以参考：<a href=\"https://www.cnblogs.com/duanxz/archive/2012/11/03/2752166.html\" target=\"_blank\" rel=\"noopener\">jdk工具之jstat命令(Java Virtual Machine Statistics Monitoring Tool)</a></p>\n<h2 id=\"JVM调优命令-jmap\"><a href=\"#JVM调优命令-jmap\" class=\"headerlink\" title=\"JVM调优命令 - jmap\"></a>JVM调优命令 - jmap</h2><p>jmap主要用来帮助我们查看堆内存情况，并支持导出成dump文件以便后续分析。<br><font color=\"red\">导出dump文件会挂起JVM，所以一般再线上必须先切换机器后再执行</font></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">jmap -heap PID # 打印堆的使用情况\njmap -histo:live PID | head -50 #打印每个class的实例数目,内存占用,类全名信息. 如果live子参数加上后,只统计活的对象数量. 一般可以通过这个命令查看哪个对象占用的内存不合理\njmap -dump:live,format=b,file=/tmp/xxxx.hprof PID #导出存活对象的dump文件以便后面分析。live可以不加，加了表示存活对象</code></pre>\n<p>减少内存使用时一个重要目标，在堆分析上最简单的方法是利用堆直方图。通过堆直方图我们可以快速看到应用内的对象数目，同时不需要进行完整的堆转储（因为堆转储需要一段时间来分析，而且会消耗大量磁盘空间）。</p>\n<p><img src=\"/2021/04/08/linux-top/6.png\" alt=\"存活对象的堆直方图\"></p>\n<h2 id=\"JVM调优命令-jstack\"><a href=\"#JVM调优命令-jstack\" class=\"headerlink\" title=\"JVM调优命令 - jstack\"></a>JVM调优命令 - jstack</h2><p>jstack主要用来分析线程执行情况。可以生成某个时刻java进程中线程的快照帮助分析，比如，发现服务器的CPU的负载突然增高了、出现了死锁、死循环等。</p>\n<p>使用方法如下 :</p>\n<pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token attr-name\">jstack</span> <span class=\"token attr-value\">PID</span>\n<span class=\"token attr-name\">jstack</span> <span class=\"token attr-value\">PID > /temp/PID.txt #将线程堆栈信息保存到文件</span></code></pre>\n<p><strong>在Java中线程的状态一共被分成6种</strong></p>\n<ul>\n<li><strong>初始状态</strong>：New，线程对象创建出来后，没有调用start方法，线程处于初始状态</li>\n<li><strong>运行状态</strong>：包含了就绪状态和运行状态<ul>\n<li>就绪状态：Ready，调用了Start方法，等待CPU分配资源</li>\n<li>运行状态：RUNNING，CPU分配资源给该线程，该线程处于运行状态</li>\n</ul>\n</li>\n<li><strong>阻塞状态</strong> BLOCKED</li>\n<li><strong>等待状态</strong> WAITING：线程手动调用了wait()方法，或者join()方法</li>\n<li><strong>超时等待状态</strong> TIMED_WAITING：与等待状态相同，都是主动进入等待，也是需要其他线程唤醒，但是区别在与超时等待，如果超过了等待时间，则自动唤醒</li>\n<li><strong>终止状态</strong> DIED：线程结束之后的状态</li>\n</ul>\n<p><strong>案例1:排查线上tomcat占用CPU使用率高的原因</strong></p>\n<p>CPU使用率高，CPU飙升一般都是程序运行有问题，我们可以通过查看占用CPU最高的线程看看到底执行了什么</p>\n<ol>\n<li>通过top命令查看当前使用CPU最高线程的是哪个进程，假设是tomcat，PID=10086</li>\n<li>通过top -Hp 10086 定位到是哪个线程占用的CPU最高，假设是线程4519</li>\n<li>算出4519的16进制，printf %x 4519 = 11a7</li>\n<li><code>jstack 1893 |grep -A 200 11a7</code> 通过jstack查看具体信息，分析出可能出现问题的代码块</li>\n</ol>\n<p><strong>案例2:排查是否出现了死锁</strong></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">jstack PID | grep 'deadlock' #判断PID是否出现了死锁</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"清楚从程序角度，有哪些原因导致FGC\"><a href=\"#清楚从程序角度，有哪些原因导致FGC\" class=\"headerlink\" title=\"清楚从程序角度，有哪些原因导致FGC\"></a>清楚从程序角度，有哪些原因导致FGC</h3><ul>\n<li>大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。</li>\n<li>内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.</li>\n<li>程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）</li>\n<li>程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM.</li>\n<li>代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。</li>\n<li>JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。<h3 id=\"如何避免IO问题带来的系统故障\"><a href=\"#如何避免IO问题带来的系统故障\" class=\"headerlink\" title=\"如何避免IO问题带来的系统故障\"></a>如何避免IO问题带来的系统故障</h3></li>\n<li>对于磁盘文件访问的操作，可以采用线程池方式，并设置线程上线，从而避免整个JVM线程池污染，进而导致线程和CPU资源耗尽。</li>\n<li>对于网络请求，为了避免服务间调用带来的全链路故障，可以设置合理的超时时间，并且高并发场景设置限流，熔断机制。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cnblogs.com/Diyo/p/11411157.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Diyo/p/11411157.html</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Vw63MUA0Zt80cU8_mvu7QQ\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/Vw63MUA0Zt80cU8_mvu7QQ</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"top命令详解\"><a href=\"#top命令详解\" class=\"headerlink\" title=\"top命令详解\"></a>top命令详解</h2><h3 id=\"各项指标详解\"><a href=\"#各项指标详解\" class=\"headerlink\" title=\"各项指标详解\"></a>各项指标详解</h3><p><img src=\"/2021/04/08/linux-top/1.png\" alt=\"top命令展示\"></p>\n<h4 id=\"第一行：系统运行时间和平均负载\"><a href=\"#第一行：系统运行时间和平均负载\" class=\"headerlink\" title=\"第一行：系统运行时间和平均负载\"></a>第一行：系统运行时间和平均负载</h4><pre><code class=\"shell\">top - 14:46:47 up 909 days,  3:15,  1 user,  load average: 1.80, 1.50, 1.37</code></pre>\n<ul>\n<li>14:46:47 表示当前系统时间</li>\n<li>up 909 days 表示已经运行了909天期间没重启</li>\n<li>1 user 表示当前登录的用户数量</li>\n<li>load average: 1.80, 1.50, 1.37 表示当前系统5分钟;10分钟;15分钟的负载<br><font color=\"red\">load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</font></li></ul>","more":"<h4 id=\"第二行：任务信息\"><a href=\"#第二行：任务信息\" class=\"headerlink\" title=\"第二行：任务信息\"></a>第二行：任务信息</h4><pre><code class=\"shell\">Tasks: 652 total,   1 running, 651 sleeping,   0 stopped,   0 zombie</code></pre>\n\n<li>total : 当前系统的任务进程个数</li>\n<li>runnning : 正在运行的任务进程个数</li>\n<li>sleeping : 正在休眠的任务进程个数</li>\n<li>stopped : 已经终止的任务进程个数</li>\n<li>zombie : 僵尸进程个数</li>\n\n<p>running 表示在运行，占用cpu，sleeping则多半是在等待（比如等IO完成），所以大部分进程在sleeping是很正常的，否则都在running，cpu都不够用了.</p>\n<h4 id=\"第三行：CPU信息\"><a href=\"#第三行：CPU信息\" class=\"headerlink\" title=\"第三行：CPU信息\"></a>第三行：CPU信息</h4><pre><code class=\"shell\">Cpu(s):  3.8%us,  0.4%sy,  0.0%ni, 95.7%id,  0.1%wa,  0.0%hi,  0.0%si,  0.0%st</code></pre>\n<ul>\n<li>us — 用户空间占用CPU的百分比。</li>\n<li>sy — 内核空间占用CPU的百分比。</li>\n<li>ni — 改变过优先级的进程占用CPU的百分比</li>\n<li>id — 空闲CPU百分比</li>\n<li>wa — IO等待占用CPU的百分比</li>\n<li>hi — 硬中断（Hardware IRQ）占用CPU的百分比</li>\n<li>si — 软中断（Software Interrupts）占用CPU的百分比</li>\n</ul>\n<p>这里的内核态和用户态可以这样理解：</p>\n<ul>\n<li>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）。</li>\n<li>当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。</li>\n</ul>\n<h4 id=\"第四五行：内存信息\"><a href=\"#第四五行：内存信息\" class=\"headerlink\" title=\"第四五行：内存信息\"></a>第四五行：内存信息</h4><pre><code class=\"shell\">Mem:  231349636k total, 72512612k used, 158837024k free,   299360k buffers\nSwap:  8388600k total,        0k used,  8388600k free,  3648000k cached</code></pre>\n<ul>\n<li>Mem<ul>\n<li>total 物理内存重量</li>\n<li>used 使用中的内存总量</li>\n<li>free 空间内存总量</li>\n<li>buffers 缓存的内存量</li>\n</ul>\n</li>\n<li>swap交换分区 具体值与上面的Mem一样,只是是对应交换分区的</li>\n</ul>\n<h4 id=\"各任务状态监控\"><a href=\"#各任务状态监控\" class=\"headerlink\" title=\"各任务状态监控\"></a>各任务状态监控</h4><pre><code>   PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n   10840 tomcat  20   0 68.0g  21g  14m S  0.3  9.8  71:32.92 jsvc     </code></pre><ul>\n<li>PID：进程ID，进程的唯一标识符</li>\n<li>USER：进程所有者的实际用户名。</li>\n<li>PR：进程的调度优先级。这个字段的一些值是’rt’。这意味这这些进程运行在实时态。</li>\n<li>NI：进程的nice值（优先级）。越小的值意味着越高的优先级。负值表示高优先级，正值表示低优先级</li>\n<li>VIRT：进程使用的虚拟内存。进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li>\n<li>RES：驻留内存大小。驻留内存是任务使用的非交换物理内存大小。进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li>\n<li>SHR：SHR是进程使用的共享内存。共享内存大小，单位kb</li>\n<li>S：这个是进程的状态。它有以下不同的值:<ul>\n<li>D - 不可中断的睡眠态。</li>\n<li>R – 运行态</li>\n<li>S – 睡眠态</li>\n<li>T – 被跟踪或已停止</li>\n<li>Z – 僵尸态</li>\n</ul>\n</li>\n<li>%CPU：自从上一次更新时到现在任务所使用的CPU时间百分比。</li>\n<li>%MEM：进程使用的可用物理内存百分比。</li>\n<li>TIME+：任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。</li>\n<li>COMMAND：运行进程所使用的命令。进程名称（命令名/命令行）</li>\n</ul>\n<h3 id=\"top-常用参数命令\"><a href=\"#top-常用参数命令\" class=\"headerlink\" title=\"top 常用参数命令\"></a>top 常用参数命令</h3><ul>\n<li>top -p PID 只监控某一个进程</li>\n<li>top -c c表示展示完整命令行</li>\n<li>top -Hp PID 查看指定进程的线程数的信息 <font>这个通常可以配合jstack来判断哪个线程占用CPU或者内存多</font></li>\n<li>top -u tomcat 查看进程用户是tomcat的任务</li>\n</ul>\n<h3 id=\"top-常用交互命令\"><a href=\"#top-常用交互命令\" class=\"headerlink\" title=\"top 常用交互命令\"></a>top 常用交互命令</h3><p>在top视图下，我们可以键入一些命令在帮助我们获得不同的视图</p>\n<p><img src=\"/2021/04/08/linux-top/2.png\" alt=\"按键1展示各个CPU详细信息\"></p>\n<h4 id=\"常用键盘\"><a href=\"#常用键盘\" class=\"headerlink\" title=\"常用键盘\"></a>常用键盘</h4><ul>\n<li>P ：根据CPU使用百分比大小进行排序</li>\n<li>M ：根据驻留内存大小进行排序</li>\n<li>c ：切换显示命令名称和完整命令行</li>\n<li>T ：根据时间/累计时间进行排序</li>\n<li>q ：退出程序</li>\n<li>1 ：可以展示每个CPU的使用情况</li>\n<li>u ：键入后会提示输出需要查看的用户名，然后就可以只查看对应用户名的任务</li>\n</ul>\n<h2 id=\"vmstat-监控整体CPU-内存-IO使用情况\"><a href=\"#vmstat-监控整体CPU-内存-IO使用情况\" class=\"headerlink\" title=\"vmstat - 监控整体CPU,内存,IO使用情况\"></a>vmstat - 监控整体CPU,内存,IO使用情况</h2><h3 id=\"所谓的IO\"><a href=\"#所谓的IO\" class=\"headerlink\" title=\"所谓的IO\"></a>所谓的IO</h3><p>所谓的I/O（Input/Output）操作实际上就是输入输出的数据传输行为。程序员最关注的主要是磁盘IO和网络IO，因为这两个IO操作和应用程序的关系最直接最紧密。</p>\n<ul>\n<li><p>磁盘IO：磁盘的输入输出，比如磁盘和内存之间的数据传输。</p>\n</li>\n<li><p>网络IO：不同系统间跨网络的数据传输，比如两个系统间的远程接口调用。</p>\n</li>\n</ul>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。<br>相比top命令，这个命令可以看到<font color=\"red\">整个CPU,内存,IO的使用情况</font>而不是单单看到各个进程的CPU使用率和内存使用率</p>\n<p>vmstat 3 2 表示 间隔3秒获取一次信息，一共获取2次</p>\n<pre><code class=\"shell\">[ssh~]$ vmstat 3 2\nprocs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 1  0      0 163756688 272168 3186404    0    0     0    11    0    0  4  0 96  0  0    \n 1  0      0 163758912 272168 3186424    0    0     0    72 8156 4923 14  0 85  0  0    </code></pre>\n<h3 id=\"输出参数介绍\"><a href=\"#输出参数介绍\" class=\"headerlink\" title=\"输出参数介绍\"></a>输出参数介绍</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>r</td>\n<td>表示多少个进程分配到CPU,如果值超过CPU个数表示到CPU瓶颈了</td>\n</tr>\n<tr>\n<td>b</td>\n<td>表示阻塞的进程</td>\n</tr>\n<tr>\n<td>swpd (内存相关)</td>\n<td>虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了</td>\n</tr>\n<tr>\n<td>free (内存相关)</td>\n<td>空闲的物理内存的大小,目前我这个机器还有163758M空闲内存</td>\n</tr>\n<tr>\n<td>buff (内存相关)</td>\n<td>已用的buff大小，对块设备的读写进行缓冲</td>\n</tr>\n<tr>\n<td>cache (内存相关)</td>\n<td>已用的cache大小，文件系统的cache</td>\n</tr>\n<tr>\n<td>si (swap相关)</td>\n<td>每秒从交换区写入内存的大小（单位：kb/s）</td>\n</tr>\n<tr>\n<td>so (swap相关)</td>\n<td>每秒从内存写到交换区的大小</td>\n</tr>\n<tr>\n<td>bi (IO相关)</td>\n<td>块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备</td>\n</tr>\n<tr>\n<td>bo (IO相关)</td>\n<td>块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。</td>\n</tr>\n<tr>\n<td>in</td>\n<td>每秒CPU的中断次数，包括时间中断</td>\n</tr>\n<tr>\n<td>cs</td>\n<td>每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换.</td>\n</tr>\n<tr>\n<td>us (CPU相关)</td>\n<td>用户进程执行消耗cpu时间</td>\n</tr>\n<tr>\n<td>sy (CPU相关)</td>\n<td>系统进程消耗cpu时间</td>\n</tr>\n<tr>\n<td>id (CPU相关)</td>\n<td>空闲时间(包括IO等待时间)</td>\n</tr>\n<tr>\n<td>wa (CPU相关)</td>\n<td>等待IO时间.</td>\n</tr>\n</tbody></table>\n<h3 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h3><ul>\n<li>bi 和 bo 随机磁盘读写的时候，这两个值越大(如超出1024k)能看到CPU在IO等待的值也会越大。</li>\n<li>cs上下文切换次数的值越小越好，太大了需要考虑调低线程或进程的数目。<font color=\"red\">上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU没有充分被利用</font></li>\n<li>us的值比较高时，说明用户进程消耗的cpu时间多，如果长期超过50%使用，需要考虑优化程序</li>\n<li>sy如果太高，表示系统调用时间长，例如是IO操作频繁</li>\n</ul>\n<h2 id=\"iostat-监控系统设备的IO负载情况\"><a href=\"#iostat-监控系统设备的IO负载情况\" class=\"headerlink\" title=\"iostat -  监控系统设备的IO负载情况\"></a>iostat -  监控系统设备的IO负载情况</h2><h3 id=\"介绍-1\"><a href=\"#介绍-1\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>iostat工具对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。</p>\n<p><font>可以认为iostat主要是通过监控磁盘来看IO负载</font></p>\n<pre><code class=\"shell\">-c 显示CPU使用情况\n-d 显示磁盘使用情况\n-k 以K为单位显示\n-m 以M为单位显示\n-N 显示磁盘阵列(LVM) 信息\n-n 显示NFS使用情况\n-p 可以报告出每块磁盘的每个分区的使用情况\n-t 显示终端和CPU的信息\n-x 显示详细信息</code></pre>\n<p>iostat -d -k -x 20 # 表示间隔20秒输出一次信息</p>\n<p><img src=\"/2021/04/08/linux-top/3.png\" alt=\"iostat监控磁盘\"></p>\n<h3 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h3><ul>\n<li>%user：CPU处在用户模式下的时间百分比。</li>\n<li>%nice：CPU处在带NICE值的用户模式下的时间百分比。</li>\n<li>%system：CPU处在系统模式下的时间百分比。</li>\n<li>%iowait：CPU等待输入输出完成时间的百分比。</li>\n<li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li>\n<li>%idle：CPU空闲时间百分比。</li>\n<li>Device ：设备名称</li>\n<li>rrqm/s ：每秒合并到设备的读取请求数</li>\n<li>wrqm/s ：每秒合并到设备的写请求数</li>\n<li>r/s ：每秒向磁盘发起的读操作数</li>\n<li>w/s ：每秒向磁盘发起的写操作数</li>\n<li>rkB/s ：每秒读K字节数</li>\n<li>wkB/s:每秒写K字节数</li>\n<li>avgrq-sz ：平均每次设备I/O操作的数据大小</li>\n<li>avgqu-sz ：平均I/O队列长度</li>\n<li>await ：平均每次设备I/O操作的等待时间 (毫秒)，<font color=\"red\">一般地，系统I/O响应时间应该低于5ms，如果大于 10ms就比较大了</font></li>\n<li>r_await ：每个读操作平均所需的时间；不仅包括硬盘设备读操作的时间，还包括了在kernel队列中等待的时间</li>\n<li>w_await ：每个写操作平均所需的时间；不仅包括硬盘设备写操作的时间，还包括了在kernel队列中等待的时间</li>\n<li>svctm ：平均每次设备I/O操作的服务时间 (毫秒)（这个数据不可信！）</li>\n<li>%util ：一秒中有百分之多少的时间用于I/O操作，即被IO消耗的CPU百分比，<font color=\"red\">一般地，如果该参数是100%表示设备已经接近满负荷运行了</font></li>\n</ul>\n<p>如果%iowait的值过高，表示硬盘存在I/O瓶颈。<br>如果%idle值高，表示CPU较空闲。<br>如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量。<br>如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。</p>\n<h2 id=\"free命令-–-查看内存使用\"><a href=\"#free命令-–-查看内存使用\" class=\"headerlink\" title=\"free命令 – 查看内存使用\"></a>free命令 – 查看内存使用</h2><p>主要用来展示内存使用。其实也可以用top 和 vmstat 。 这里不过多介绍了</p>\n<pre><code class=\"shell\">[watch@localhost ~]$ free -g  # -g 表示按照GB的方式展示\n             total       used       free     shared    buffers     cached\nMem:           220         64        156          0          0          3\n-/+ buffers/cache:         61        159\nSwap:            7          0          7</code></pre>\n<h2 id=\"df命令-–-文件系统的磁盘空间使用情况\"><a href=\"#df命令-–-文件系统的磁盘空间使用情况\" class=\"headerlink\" title=\"df命令 – 文件系统的磁盘空间使用情况\"></a>df命令 – 文件系统的磁盘空间使用情况</h2><pre><code class=\"shell\">[watch@localhost ~]$ df -h #-h以易读的GB、MB、KB等格式显示\nFilesystem      Size  Used Avail Use% Mounted on\n/dev/sda3       909G   57G  844G   7% /\ntmpfs           111G   16K  111G   1% /dev/shm\n/dev/sda1       485M  125M  335M  28% /boot\n/dev/sdb1       1.5T   16G  1.5T   2% /cache1</code></pre>\n<h2 id=\"iotop-–-精确到进程的IO监控\"><a href=\"#iotop-–-精确到进程的IO监控\" class=\"headerlink\" title=\"iotop – 精确到进程的IO监控\"></a>iotop – 精确到进程的IO监控</h2><p>Linux下的IO统计工具如iostat,top等大多数是只能统计到总体的读写情况, 如果你想知道每个进程是如何使用IO的就比较麻烦.</p>\n<p>iotop 类似与top界面，可以查看各个进程使用IO的情况。<br>iotop -p PID 指定某个PID进行监控</p>\n<pre><code class=\"shell\">[watch@localhost ~]$ iotop\nTotal DISK READ:       6.01 M/s | Total DISK WRITE:       3.85 K/s\n  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND                                                                                                          \n20074 be/4 hadoop      6.01 M/s    0.00 B/s  0.00 %  4.54 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n 6371 be/4 hadoop      0.00 B/s    3.25 M/s  0.00 %  0.00 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n 8497 be/4 hadoop      0.00 B/s    3.67 M/s  0.00 %  0.00 % java -Dproc_datanode -Xmx8192m -server  org.apache.hadoop.hdfs.server.datanode.DataNode\n    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % init\n    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</code></pre>\n<h2 id=\"netstat-网络命令\"><a href=\"#netstat-网络命令\" class=\"headerlink\" title=\"netstat - 网络命令\"></a>netstat - 网络命令</h2><p>查看服务器的请求数可以用下面命令</p>\n<pre><code class=\"shell\">netstat -na |wc -l\nnetstat -anp | grep 3306 | wc -l # 统计3306端口的连接数\nnetstat -ant|awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}&#39;  #统计TCP各个状态数量\nnetstat -nat | awk &#39;{print $6}&#39; |sort|uniq -c|sort -rn  #统计TCP哪个状态连接数最多\nnetstat -nat | grep &#39;ESTABLISHED&#39; |awk -F : &#39;{print $1}&#39; |sort|uniq -c|sort -rn # 统计状态为ESTABLISHED的IP是哪个\nnetstat -ant | awk &#39;/tcp/ {print $6}&#39;|sort |uniq -c |sort -nr #状态统计\nnetstat -ant | grep &quot;ESTABLISHED&quot;|awk &#39;/tcp/ {print $5}&#39;|cut -d &quot;:&quot; -f1|sort |uniq -c |sort -nr |head -10 #前十位ESTABLISHED状态ip统计</code></pre>\n<p>Netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具。</p>\n<pre><code>Active Internet connections (servers and established)\nProto Recv-Q Send-Q Local Address(当前地址)      Foreign Address(远程地址)    State      \ntcp        0      0 127.0.0.1:2111              0.0.0.0:*                   LISTEN              \ntcp        0      0 127.0.0.1:20122             0.0.0.0:*                   LISTEN      \ntcp        0      0 0.0.0.0:2012                0.0.0.0:*                   LISTEN      \ntcp        0      0 127.0.0.1:50355             127.0.0.1:62016             TIME_WAIT      \ntcp        0      0 180.101.26.19:39669         180.101.26.26:63751         TIME_WAIT   \ntcp        0      0 180.101.26.19:39663         180.101.26.26:63751         TIME_WAIT   \ntcp        0      0 157.0.125.19:25119          218.98.49.27:65381          ESTABLISHED </code></pre><h2 id=\"Arthas使用\"><a href=\"#Arthas使用\" class=\"headerlink\" title=\"Arthas使用\"></a>Arthas使用</h2><p>Arthas是阿里巴巴出品的一款Java应用诊断利器。支持多种维度去诊断问题。具体使用可以直接看官网，写得很详细。</p>\n<p>官方文档 ： <a href=\"https://arthas.aliyun.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">https://arthas.aliyun.com/zh-cn/</a></p>\n<h3 id=\"线上服务平均响应时间太长，怎么排查？\"><a href=\"#线上服务平均响应时间太长，怎么排查？\" class=\"headerlink\" title=\"线上服务平均响应时间太长，怎么排查？\"></a>线上服务平均响应时间太长，怎么排查？</h3><p>一般来说一个方法内部执行哪个方法耗时太长我们一般都是再代码上写</p>\n<pre><code class=\"java\">long start = System.currentTimeMillis();\ndoSome();\nSystem.out.println(&quot;doSome程序耗时 :&quot; + (System.currentTimeMillis() - start) );</code></pre>\n<p>然而Arthas提供了trace命令帮助我们定位。假设我要定位一个Controller类中一个方法的耗时</p>\n<pre><code class=\"shell\">trace --skipJDKMethod false com.xzy.springboot.springbootproject.controller.CommonController echo\n# com.xzy.springboot.springbootproject.controller.CommonController 类路径\n# echo 方法名</code></pre>\n<p>最终输出每个方法耗时</p>\n<pre><code class=\"shell\">[arthas@16028]$ trace --skipJDKMethod false com.xzy.springboot.springbootproject.controller.CommonController echo\nPress Q or Ctrl+C to abort.\nAffect(class count: 1 , method count: 1) cost in 303 ms, listenerId: 1\n`---ts=2020-10-09 09:24:41;thread_name=http-nio-8080-exec-1;id=92;is_daemon=true;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@4e93dcb9\n    `---[1.736869ms] com.xzy.springboot.springbootproject.controller.CommonController:echo()\n        `---[1.110086ms] org.slf4j.Logger:info() #14 </code></pre>\n<h2 id=\"JVM调优命令-jps\"><a href=\"#JVM调优命令-jps\" class=\"headerlink\" title=\"JVM调优命令 - jps\"></a>JVM调优命令 - jps</h2><p>可以列出本机所有java进程的pid.<br>一般使用 jps -v 就行了。 -v 表示展示出详细的参数信息</p>\n<p><img src=\"/2021/04/08/linux-top/4.png\" alt=\"jps命令\"></p>\n<h2 id=\"JVM调优命令-jstat\"><a href=\"#JVM调优命令-jstat\" class=\"headerlink\" title=\"JVM调优命令 - jstat\"></a>JVM调优命令 - jstat</h2><p>监控堆内存的用量和GC情况。<br>使用格式如下 : jstat -gc PID 1000 20 # 表示使用-gc的方式打印PID的情况，间隔1000ms，打印20次</p>\n<p><img src=\"/2021/04/08/linux-top/5.png\" alt=\" jstat -gc命令\"></p>\n<p>-gc 对应输出结果详解</p>\n<ul>\n<li>S0C:年轻代中第一个survivor（幸存区）的容量（字节）</li>\n<li>S1C:年轻代中第二个survivor（幸存区）的容量(字节)</li>\n<li>S0U:年轻代中第一个survivor（幸存区）目前已使用空间(字节)</li>\n<li>S1U:年轻代中第二个survivor（幸存区）目前已使用空间(字节)</li>\n<li>EC:年轻代中Eden（伊甸园）的容量(字节)</li>\n<li>EU:年轻代中Eden（伊甸园）目前已使用空间(字节)</li>\n<li>OC:Old代的容量(字节)</li>\n<li>OU:Old代目前已使用空间(字节)</li>\n<li>MC:metaspace(元空间)的容量(字节)</li>\n<li>MU:metaspace(元空间)目前已使用空间(字节)</li>\n<li>YGC:从应用程序启动到采样时年轻代中gc次数</li>\n<li>YGCT:从应用程序启动到采样时年轻代中gc所用时间(s)</li>\n<li>FGC:从应用程序启动到采样时old代(全gc)gc次数</li>\n<li>FGCT:从应用程序启动到采样时old代(全gc)gc所用时间(s)</li>\n<li>GCT:从应用程序启动到采样时gc用的总时间(s)</li>\n</ul>\n<p>另外除了-gc外，jstat还可以输出其他信息，具体如下</p>\n<ul>\n<li>class:显示ClassLoad的相关信息；</li>\n<li>compiler:显示JIT编译的相关信息；</li>\n<li>gc:显示和gc相关的堆信息；</li>\n<li>gccapacity:显示各个代的容量以及使用情况；</li>\n<li>gcmetacapacity:显示metaspace的大小</li>\n<li>gcnew:显示新生代信息；</li>\n<li>gcnewcapacity:显示新生代大小和使用情况；</li>\n<li>gcold:显示老年代和永久代的信息；</li>\n<li>gcoldcapacity:显示老年代的大小；</li>\n<li>gcutil　　:显示垃圾收集信息；</li>\n<li>gccause:显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因</li>\n</ul>\n<p>那到底什么情况下，GC会对程序产生影响呢？ 一般来说需要判断<font color=\"red\">FGC过于频繁、YGC耗时过长、FGC耗时过长、YGC过于频繁</font></p>\n<p>命令详细可以参考：<a href=\"https://www.cnblogs.com/duanxz/archive/2012/11/03/2752166.html\" target=\"_blank\" rel=\"noopener\">jdk工具之jstat命令(Java Virtual Machine Statistics Monitoring Tool)</a></p>\n<h2 id=\"JVM调优命令-jmap\"><a href=\"#JVM调优命令-jmap\" class=\"headerlink\" title=\"JVM调优命令 - jmap\"></a>JVM调优命令 - jmap</h2><p>jmap主要用来帮助我们查看堆内存情况，并支持导出成dump文件以便后续分析。<br><font color=\"red\">导出dump文件会挂起JVM，所以一般再线上必须先切换机器后再执行</font></p>\n<pre><code class=\"shell\">jmap -heap PID # 打印堆的使用情况\njmap -histo:live PID | head -50 #打印每个class的实例数目,内存占用,类全名信息. 如果live子参数加上后,只统计活的对象数量. 一般可以通过这个命令查看哪个对象占用的内存不合理\njmap -dump:live,format=b,file=/tmp/xxxx.hprof PID #导出存活对象的dump文件以便后面分析。live可以不加，加了表示存活对象</code></pre>\n<p>减少内存使用时一个重要目标，在堆分析上最简单的方法是利用堆直方图。通过堆直方图我们可以快速看到应用内的对象数目，同时不需要进行完整的堆转储（因为堆转储需要一段时间来分析，而且会消耗大量磁盘空间）。</p>\n<p><img src=\"/2021/04/08/linux-top/6.png\" alt=\"存活对象的堆直方图\"></p>\n<h2 id=\"JVM调优命令-jstack\"><a href=\"#JVM调优命令-jstack\" class=\"headerlink\" title=\"JVM调优命令 - jstack\"></a>JVM调优命令 - jstack</h2><p>jstack主要用来分析线程执行情况。可以生成某个时刻java进程中线程的快照帮助分析，比如，发现服务器的CPU的负载突然增高了、出现了死锁、死循环等。</p>\n<p>使用方法如下 :</p>\n<pre><code class=\"properties\">jstack PID\njstack PID &gt; /temp/PID.txt #将线程堆栈信息保存到文件</code></pre>\n<p><strong>在Java中线程的状态一共被分成6种</strong></p>\n<ul>\n<li><strong>初始状态</strong>：New，线程对象创建出来后，没有调用start方法，线程处于初始状态</li>\n<li><strong>运行状态</strong>：包含了就绪状态和运行状态<ul>\n<li>就绪状态：Ready，调用了Start方法，等待CPU分配资源</li>\n<li>运行状态：RUNNING，CPU分配资源给该线程，该线程处于运行状态</li>\n</ul>\n</li>\n<li><strong>阻塞状态</strong> BLOCKED</li>\n<li><strong>等待状态</strong> WAITING：线程手动调用了wait()方法，或者join()方法</li>\n<li><strong>超时等待状态</strong> TIMED_WAITING：与等待状态相同，都是主动进入等待，也是需要其他线程唤醒，但是区别在与超时等待，如果超过了等待时间，则自动唤醒</li>\n<li><strong>终止状态</strong> DIED：线程结束之后的状态</li>\n</ul>\n<p><strong>案例1:排查线上tomcat占用CPU使用率高的原因</strong></p>\n<p>CPU使用率高，CPU飙升一般都是程序运行有问题，我们可以通过查看占用CPU最高的线程看看到底执行了什么</p>\n<ol>\n<li>通过top命令查看当前使用CPU最高线程的是哪个进程，假设是tomcat，PID=10086</li>\n<li>通过top -Hp 10086 定位到是哪个线程占用的CPU最高，假设是线程4519</li>\n<li>算出4519的16进制，printf %x 4519 = 11a7</li>\n<li><code>jstack 1893 |grep -A 200 11a7</code> 通过jstack查看具体信息，分析出可能出现问题的代码块</li>\n</ol>\n<p><strong>案例2:排查是否出现了死锁</strong></p>\n<pre><code class=\"shell\">jstack PID | grep &#39;deadlock&#39; #判断PID是否出现了死锁</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"清楚从程序角度，有哪些原因导致FGC\"><a href=\"#清楚从程序角度，有哪些原因导致FGC\" class=\"headerlink\" title=\"清楚从程序角度，有哪些原因导致FGC\"></a>清楚从程序角度，有哪些原因导致FGC</h3><ul>\n<li>大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。</li>\n<li>内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.</li>\n<li>程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. （即本文中的案例）</li>\n<li>程序BUG导致动态生成了很多新类，使得 Metaspace 不断被占用，先引发FGC，最后导致OOM.</li>\n<li>代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。</li>\n<li>JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。<h3 id=\"如何避免IO问题带来的系统故障\"><a href=\"#如何避免IO问题带来的系统故障\" class=\"headerlink\" title=\"如何避免IO问题带来的系统故障\"></a>如何避免IO问题带来的系统故障</h3></li>\n<li>对于磁盘文件访问的操作，可以采用线程池方式，并设置线程上线，从而避免整个JVM线程池污染，进而导致线程和CPU资源耗尽。</li>\n<li>对于网络请求，为了避免服务间调用带来的全链路故障，可以设置合理的超时时间，并且高并发场景设置限流，熔断机制。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cnblogs.com/Diyo/p/11411157.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Diyo/p/11411157.html</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/Vw63MUA0Zt80cU8_mvu7QQ\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/Vw63MUA0Zt80cU8_mvu7QQ</a></li>\n</ul>"},{"title":"Mysql-InnoDB索引之索引使用和优化原则(二)","description":"Mysql-InnoDB索引之索引使用和优化原则(二)","date":"2019-07-18T02:00:00.000Z","_content":"\n## 提出问题\n1. 什么是回表？\n2. 索引是不是可以无限建？\n3. 什么是索引的最左匹配原则？\n4. 什么是覆盖索引？\n5. 如何建立高效的索引？\n<!--more-->\n## 索引的代价\n通过上文《Mysql-InnoDB索引之索引结构详解(一)》我们了解到了B+树索引的原理。<font color=#FF0000 >InnoDB</font>存储引擎会自动为主键（如果没有它会自动帮我们添加）建立<font color=#FF0000 >聚簇索引</font>，聚簇索引的叶子节点包含完整的用户记录。而且每次建立一次索引都需要为其建立一颗B+树。\n\n### 空间上的代价\n\n每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据也组成，那可是很大的存储空间。\n\n### 时间上的代价\n\n每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。我们清楚B+树每层节点都是按照索引列的值从小到大顺序排序的，如果做了增删改则会对排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页分裂、页回收啥的操作来维护好节点和记录的排序，所以在时间上需要对索引进行维护。\n\n所以，<font color=#FF0000 >一个表上索引建的越多，就会占⽤越多的存储空间，在增删改记录的时候性能就越差。</font>\n\n## 索引的使用\n\n我们先建立一个表\n\n```sql\nCREATE TABLE person_info (\n\t    id INT NOT NULL auto_increment,\n\t    NAME VARCHAR (100) NOT NULL,\n\t    birthday DATE NOT NULL,\n\t    phone_number CHAR (11) NOT NULL,\n\t    country VARCHAR (100) NOT NULL,\n\t    PRIMARY KEY (id),\n\t    KEY idx_name_birthday_phone_number (NAME, birthday, phone_number)\n);\n```\n\n根据上面的SQL，我们知道表person_info的索引情况\n\n- 主键是id列，InnoDB存储引擎为主键设置了一个<font color=#FF0000 >聚簇索引</font>，因为是聚簇索引索引对应的B+树的叶子节点存储的用户记录<font color=#FF0000 >包含所有列</font>\n- 定义了一个联合索引idx_name_birthday_phone_number,由列name，birthday，phone_number组成，这个联合索引的B+树的叶子节点存储的用户记录包含name，birthday，phone_numbe和主键id，<font color=#FF0000 >但不包含country</font>。\n\n![](mysql-index-use/1.png)\n\n这里需要注意的是联合索引B+树的建立是按照先name,再birthday,最后phone_number的顺序，索引B+树的顺序是按照\n\n- 先通过<font color=red>name</font>进行排序。\n- 如果<font color=red>name</font>相同，再按照<font color=red>birthday</font>排序。\n- 如果<font color=red>birthday</font>也相同，则按照<font color=red>phone_number</font>排序。\n\n### 通过主键ID查找数据\n\n```SQL\nSELECT\n\t*\nFROM\n\tperson_info\nWHERE\n\tID = 10;\n```\n\n这种方式下，由于ID是主键，索引通过聚簇索引所在的B+树根据二分法查找到对应的数据。\n\n### 全值匹配\n\n```sql\nSELECT\n\t*\nFROM\n\tperson_info\nWHERE\n\tNAME = 'Ashburn'\nAND birthday = '1990-09-27'\nAND phone_number = '15123983239';\n```\n\n上面SQL，由于查询条件包含在了idx_name_birthday_phone_number索引内，所以查询过程如下\n\n1. 因为B+树的数据页和记录先是按照name列的值进行排序的，所以先可以很快定位name列的值是Ashburn的记录位置\n2. 在name列相同的记录是按照birthday列的值进行排序的，所以在name列的值是Ashburn的记录可以快速定位birthday列的值是'1990-09-27'的记录\n3. 如果很不幸，name和birthday列的值都是相同的，那记录是按照phone_number列的值排序的，所以联合索引中的三个列都可能被用到\n\n这种情况下我们通过三个列的全值匹配查找到的对应的记录，记录上包含了id,name,birthday,phone_number。但是我们查询的是*,在idx_name_birthday_phone_number索引B+树上并没有存储country的数据，那这时候如何查找country？\n\n### 回表\n\n由于country只记录在聚簇索引B+树上，而我们通过联合索引已经查到数据对应的ID，所以这时候通过ID继续去聚簇索引上查找一遍，最终获取到了最后的数据。\n\n这种需要把从上⼀步中获取到的每⼀条记录的id字段都到聚簇索引对应的B+树中找到完整的⽤户记录，也就是我们通常所说的<font color=red>回表</font>\n\n#### 回表的代价\n\n<font color=red>需要回表的记录越多，使用二级索引的性能就越低</font>，甚至让某些查询宁愿使用全表扫描也不使用二级索引。假设有一种情况，name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239' 的数据占了所有数据的90%以上，那此时通过联合索引先查一遍获取到对应的主键ID再去聚簇索引查一遍的方式（二级索引+回表）就比全表扫描效率差。\n\n所以在使用上我们应该尽量避免回表产生的问题\n\n- 建议点1 ：例如可以判断业务上是否需要获取所有列的数据，如果业务上只需要id,name,birthday,phone_number列的值而不需要country的值，这时候可以不使用select * ,这样可以防止回表 \n- 建议点2 ：尽量避免回表的次数，这种可以从索引的选取方面考虑，例如对于重复值大的列不建议设置为索引。\n\n### 覆盖索引\n\n为了彻底告别回表操作带来的性能损耗，我们建议：<font color=red>最好在查询列表⾥只包含索引列</font>\n\n```sql\nSELECT\n\tID,NAME,birthday,phone_number\nFROM\n\tperson_info\nWHERE\n\tNAME = 'Ashburn'\nAND birthday = '1990-09-27'\nAND phone_number = '15123983239';\n```\n\n我们把这种只需要用到索引的查询方式称为索引覆盖。排序操作也优先使用<font color=red>覆盖索引</font>\n\n### 最左匹配原则\n\n下面两个SQL语句，查询条件相同，只是顺序不同，是否性能相同？\n\n```sql\n-- SQL 1\nSELECT\n\t*\nFROM\n\tperson_info\nWHERE\n\tNAME = 'Ashburn'\nAND birthday = '1990-09-27'\nAND phone_number = '15123983239';\n-- SQL 2\nSELECT\n\t*\nFROM\n\tperson_info\nWHERE\n\tbirthday = '1990-09-27'\nAND NAME = 'Ashburn'\nAND phone_number = '15123983239';\n```\n\n答案是不相同，通过索引的分析，我们知道idx_name_birthday_phone_number的排序方式是name -> birthday - > phone_number。但是SQL2是先birthday->NAME->phone_number。这样则没办法先通过name去查找索引，所以SQL2使用不到索引将会采用全表扫描。\n\n所以，<font color=red>如果我们想使⽤联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</font>\n\n### 用于排序\n\n我们在写查询语句的时候经常需要对查询出来的记录通过ORDER BY语句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。\n\n但如果排序的列是按照索引排列的，例如\n\n```sql\nSELECT\n\tID,NAME,birthday,phone_number\nFROM\n\tperson_info\nORDER BY\n\tNAME,\n\tbirthday,\n\tphone_number;\n```\n\n则可以直接按照索引的存储顺序进行排序。\n\n#### 不能使用索引排序的情况\n1. ASC,DESC混用，对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是ASC规则排序，要么都是DESC规则排序。\n2. WHERE子句中出现非排序使用到的索引列。\n3. 排序列包含非同一个索引的列。如果不是同一个索引，排序的方式是不一样的\n4. 排序列使用了复杂的表达式\n\n## 如何挑选索引\n### 只为用于搜索、排序或分组的列创建索引\n只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。\n### 需要考虑列的基数\n列的基数指的是某一列中不重复数据的个数。在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。\n例如上面说的回表和全表扫描情况，一个列的重复个数越多那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。\n所以，<font color=red>最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</font>\n\n### 索引列的类型尽量小\n\n- 数据类型越小，在查询时进行的比较操作越快\n- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓 存在内存中，从而加快读写效率\n\n### 索引字符串值的前缀\n\n- B+树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大\n- 如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间\n\n所以可以只对<font color=red>一个列的前几个字符进行索引</font>。\n\n```sql\nCREATE TABLE person_info (\n\t    NAME VARCHAR (100) NOT NULL,\n\t    birthday DATE NOT NULL,\n\t    phone_number CHAR (11) NOT NULL,\n\t    country VARCHAR (100) NOT NULL,\n\t    KEY idx_name_birthday_phone_number (NAME (10),birthday,phone_number)\n);\n```\n\nname(10)就表示在建立的B+树索引中只保留记录的前10个字符的编码，这种只索引字符串值的前缀的策略是我们经常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。\n\n### 让索引列在比较表达式中单独出现\n\n如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。\n\n```sql\nWHERE my_col * 2 < 4 -- 不能使用索引\nWHERE my_col < 4 / 2 -- 可以使用索引\n```\n\n### 避免冗余和重复索引\n\n```sql\nCREATE TABLE person_info (\n\t    id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n\t    NAME VARCHAR (100) NOT NULL,\n\t    birthday DATE NOT NULL,\n\t    phone_number CHAR (11) NOT NULL,\n\t    country VARCHAR (100) NOT NULL,\n\t    PRIMARY KEY (id),\n\t    KEY idx_name_birthday_phone_number (NAME (10),birthday,phone_number),\n\t    KEY idx_name (NAME(10))\n);\n```\n\n例如上面NAME已经包含在联合索引中了，又自己新建了一个索引，这种重复的索引是毫无必要的。\n\n## 总结\n\n- B+树索引在空间和时间上都有代价，所以没事⼉别瞎建索引\n- B+树索引适⽤于下边这些情况\n  - 全值匹配\n  - 匹配左边的列\n  - 匹配范围值\n  - 精确匹配某一列并范围匹配另外一列\n  - 用于排序\n  - 用于分组\n- 在使⽤索引时需要注意下边这些事项\n  - 只为⽤于搜索、排序或分组的列创建索引\n  - 为列的基数⼤的列创建索引 \n  - 索引列的类型尽量⼩\n  - 可以只对字符串值的前缀建⽴索引 \n  - 只有索引列在⽐较表达式中单独出现才可以适⽤索引\n  - 为了尽可能少的让聚簇索引发⽣⻚⾯分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性\n  - 定位并删除表中的重复和冗余索引\n  - 尽量使⽤覆盖索引进⾏查询，避免回表带来的性能损耗\n\n## 参考\n\n- 本文参考《MYSQL高性能》，《MySQL 是怎样运行的：从根儿上理解 MySQL》","source":"_posts/mysql-index-use.md","raw":"---\ntitle: Mysql-InnoDB索引之索引使用和优化原则(二)\ntags:\n  - mysql\ncategories:  mysql\ndescription : Mysql-InnoDB索引之索引使用和优化原则(二)\ndate: 2019-07-18 10:00:00\n---\n\n## 提出问题\n1. 什么是回表？\n2. 索引是不是可以无限建？\n3. 什么是索引的最左匹配原则？\n4. 什么是覆盖索引？\n5. 如何建立高效的索引？\n<!--more-->\n## 索引的代价\n通过上文《Mysql-InnoDB索引之索引结构详解(一)》我们了解到了B+树索引的原理。<font color=#FF0000 >InnoDB</font>存储引擎会自动为主键（如果没有它会自动帮我们添加）建立<font color=#FF0000 >聚簇索引</font>，聚簇索引的叶子节点包含完整的用户记录。而且每次建立一次索引都需要为其建立一颗B+树。\n\n### 空间上的代价\n\n每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据也组成，那可是很大的存储空间。\n\n### 时间上的代价\n\n每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。我们清楚B+树每层节点都是按照索引列的值从小到大顺序排序的，如果做了增删改则会对排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页分裂、页回收啥的操作来维护好节点和记录的排序，所以在时间上需要对索引进行维护。\n\n所以，<font color=#FF0000 >一个表上索引建的越多，就会占⽤越多的存储空间，在增删改记录的时候性能就越差。</font>\n\n## 索引的使用\n\n我们先建立一个表\n\n```sql\nCREATE TABLE person_info (\n\t    id INT NOT NULL auto_increment,\n\t    NAME VARCHAR (100) NOT NULL,\n\t    birthday DATE NOT NULL,\n\t    phone_number CHAR (11) NOT NULL,\n\t    country VARCHAR (100) NOT NULL,\n\t    PRIMARY KEY (id),\n\t    KEY idx_name_birthday_phone_number (NAME, birthday, phone_number)\n);\n```\n\n根据上面的SQL，我们知道表person_info的索引情况\n\n- 主键是id列，InnoDB存储引擎为主键设置了一个<font color=#FF0000 >聚簇索引</font>，因为是聚簇索引索引对应的B+树的叶子节点存储的用户记录<font color=#FF0000 >包含所有列</font>\n- 定义了一个联合索引idx_name_birthday_phone_number,由列name，birthday，phone_number组成，这个联合索引的B+树的叶子节点存储的用户记录包含name，birthday，phone_numbe和主键id，<font color=#FF0000 >但不包含country</font>。\n\n![](mysql-index-use/1.png)\n\n这里需要注意的是联合索引B+树的建立是按照先name,再birthday,最后phone_number的顺序，索引B+树的顺序是按照\n\n- 先通过<font color=red>name</font>进行排序。\n- 如果<font color=red>name</font>相同，再按照<font color=red>birthday</font>排序。\n- 如果<font color=red>birthday</font>也相同，则按照<font color=red>phone_number</font>排序。\n\n### 通过主键ID查找数据\n\n```SQL\nSELECT\n\t*\nFROM\n\tperson_info\nWHERE\n\tID = 10;\n```\n\n这种方式下，由于ID是主键，索引通过聚簇索引所在的B+树根据二分法查找到对应的数据。\n\n### 全值匹配\n\n```sql\nSELECT\n\t*\nFROM\n\tperson_info\nWHERE\n\tNAME = 'Ashburn'\nAND birthday = '1990-09-27'\nAND phone_number = '15123983239';\n```\n\n上面SQL，由于查询条件包含在了idx_name_birthday_phone_number索引内，所以查询过程如下\n\n1. 因为B+树的数据页和记录先是按照name列的值进行排序的，所以先可以很快定位name列的值是Ashburn的记录位置\n2. 在name列相同的记录是按照birthday列的值进行排序的，所以在name列的值是Ashburn的记录可以快速定位birthday列的值是'1990-09-27'的记录\n3. 如果很不幸，name和birthday列的值都是相同的，那记录是按照phone_number列的值排序的，所以联合索引中的三个列都可能被用到\n\n这种情况下我们通过三个列的全值匹配查找到的对应的记录，记录上包含了id,name,birthday,phone_number。但是我们查询的是*,在idx_name_birthday_phone_number索引B+树上并没有存储country的数据，那这时候如何查找country？\n\n### 回表\n\n由于country只记录在聚簇索引B+树上，而我们通过联合索引已经查到数据对应的ID，所以这时候通过ID继续去聚簇索引上查找一遍，最终获取到了最后的数据。\n\n这种需要把从上⼀步中获取到的每⼀条记录的id字段都到聚簇索引对应的B+树中找到完整的⽤户记录，也就是我们通常所说的<font color=red>回表</font>\n\n#### 回表的代价\n\n<font color=red>需要回表的记录越多，使用二级索引的性能就越低</font>，甚至让某些查询宁愿使用全表扫描也不使用二级索引。假设有一种情况，name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239' 的数据占了所有数据的90%以上，那此时通过联合索引先查一遍获取到对应的主键ID再去聚簇索引查一遍的方式（二级索引+回表）就比全表扫描效率差。\n\n所以在使用上我们应该尽量避免回表产生的问题\n\n- 建议点1 ：例如可以判断业务上是否需要获取所有列的数据，如果业务上只需要id,name,birthday,phone_number列的值而不需要country的值，这时候可以不使用select * ,这样可以防止回表 \n- 建议点2 ：尽量避免回表的次数，这种可以从索引的选取方面考虑，例如对于重复值大的列不建议设置为索引。\n\n### 覆盖索引\n\n为了彻底告别回表操作带来的性能损耗，我们建议：<font color=red>最好在查询列表⾥只包含索引列</font>\n\n```sql\nSELECT\n\tID,NAME,birthday,phone_number\nFROM\n\tperson_info\nWHERE\n\tNAME = 'Ashburn'\nAND birthday = '1990-09-27'\nAND phone_number = '15123983239';\n```\n\n我们把这种只需要用到索引的查询方式称为索引覆盖。排序操作也优先使用<font color=red>覆盖索引</font>\n\n### 最左匹配原则\n\n下面两个SQL语句，查询条件相同，只是顺序不同，是否性能相同？\n\n```sql\n-- SQL 1\nSELECT\n\t*\nFROM\n\tperson_info\nWHERE\n\tNAME = 'Ashburn'\nAND birthday = '1990-09-27'\nAND phone_number = '15123983239';\n-- SQL 2\nSELECT\n\t*\nFROM\n\tperson_info\nWHERE\n\tbirthday = '1990-09-27'\nAND NAME = 'Ashburn'\nAND phone_number = '15123983239';\n```\n\n答案是不相同，通过索引的分析，我们知道idx_name_birthday_phone_number的排序方式是name -> birthday - > phone_number。但是SQL2是先birthday->NAME->phone_number。这样则没办法先通过name去查找索引，所以SQL2使用不到索引将会采用全表扫描。\n\n所以，<font color=red>如果我们想使⽤联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</font>\n\n### 用于排序\n\n我们在写查询语句的时候经常需要对查询出来的记录通过ORDER BY语句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。\n\n但如果排序的列是按照索引排列的，例如\n\n```sql\nSELECT\n\tID,NAME,birthday,phone_number\nFROM\n\tperson_info\nORDER BY\n\tNAME,\n\tbirthday,\n\tphone_number;\n```\n\n则可以直接按照索引的存储顺序进行排序。\n\n#### 不能使用索引排序的情况\n1. ASC,DESC混用，对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是ASC规则排序，要么都是DESC规则排序。\n2. WHERE子句中出现非排序使用到的索引列。\n3. 排序列包含非同一个索引的列。如果不是同一个索引，排序的方式是不一样的\n4. 排序列使用了复杂的表达式\n\n## 如何挑选索引\n### 只为用于搜索、排序或分组的列创建索引\n只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。\n### 需要考虑列的基数\n列的基数指的是某一列中不重复数据的个数。在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。\n例如上面说的回表和全表扫描情况，一个列的重复个数越多那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。\n所以，<font color=red>最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</font>\n\n### 索引列的类型尽量小\n\n- 数据类型越小，在查询时进行的比较操作越快\n- 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓 存在内存中，从而加快读写效率\n\n### 索引字符串值的前缀\n\n- B+树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大\n- 如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间\n\n所以可以只对<font color=red>一个列的前几个字符进行索引</font>。\n\n```sql\nCREATE TABLE person_info (\n\t    NAME VARCHAR (100) NOT NULL,\n\t    birthday DATE NOT NULL,\n\t    phone_number CHAR (11) NOT NULL,\n\t    country VARCHAR (100) NOT NULL,\n\t    KEY idx_name_birthday_phone_number (NAME (10),birthday,phone_number)\n);\n```\n\nname(10)就表示在建立的B+树索引中只保留记录的前10个字符的编码，这种只索引字符串值的前缀的策略是我们经常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。\n\n### 让索引列在比较表达式中单独出现\n\n如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。\n\n```sql\nWHERE my_col * 2 < 4 -- 不能使用索引\nWHERE my_col < 4 / 2 -- 可以使用索引\n```\n\n### 避免冗余和重复索引\n\n```sql\nCREATE TABLE person_info (\n\t    id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n\t    NAME VARCHAR (100) NOT NULL,\n\t    birthday DATE NOT NULL,\n\t    phone_number CHAR (11) NOT NULL,\n\t    country VARCHAR (100) NOT NULL,\n\t    PRIMARY KEY (id),\n\t    KEY idx_name_birthday_phone_number (NAME (10),birthday,phone_number),\n\t    KEY idx_name (NAME(10))\n);\n```\n\n例如上面NAME已经包含在联合索引中了，又自己新建了一个索引，这种重复的索引是毫无必要的。\n\n## 总结\n\n- B+树索引在空间和时间上都有代价，所以没事⼉别瞎建索引\n- B+树索引适⽤于下边这些情况\n  - 全值匹配\n  - 匹配左边的列\n  - 匹配范围值\n  - 精确匹配某一列并范围匹配另外一列\n  - 用于排序\n  - 用于分组\n- 在使⽤索引时需要注意下边这些事项\n  - 只为⽤于搜索、排序或分组的列创建索引\n  - 为列的基数⼤的列创建索引 \n  - 索引列的类型尽量⼩\n  - 可以只对字符串值的前缀建⽴索引 \n  - 只有索引列在⽐较表达式中单独出现才可以适⽤索引\n  - 为了尽可能少的让聚簇索引发⽣⻚⾯分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性\n  - 定位并删除表中的重复和冗余索引\n  - 尽量使⽤覆盖索引进⾏查询，避免回表带来的性能损耗\n\n## 参考\n\n- 本文参考《MYSQL高性能》，《MySQL 是怎样运行的：从根儿上理解 MySQL》","slug":"mysql-index-use","published":1,"updated":"2021-04-08T00:47:06.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvb001oqwv22g36hv60","content":"<h2 id=\"提出问题\"><a href=\"#提出问题\" class=\"headerlink\" title=\"提出问题\"></a>提出问题</h2><ol>\n<li>什么是回表？</li>\n<li>索引是不是可以无限建？</li>\n<li>什么是索引的最左匹配原则？</li>\n<li>什么是覆盖索引？</li>\n<li>如何建立高效的索引？<a id=\"more\"></a>\n<h2 id=\"索引的代价\"><a href=\"#索引的代价\" class=\"headerlink\" title=\"索引的代价\"></a>索引的代价</h2>通过上文《Mysql-InnoDB索引之索引结构详解(一)》我们了解到了B+树索引的原理。<font color=\"#FF0000\">InnoDB</font>存储引擎会自动为主键（如果没有它会自动帮我们添加）建立<font color=\"#FF0000\">聚簇索引</font>，聚簇索引的叶子节点包含完整的用户记录。而且每次建立一次索引都需要为其建立一颗B+树。</li>\n</ol>\n<h3 id=\"空间上的代价\"><a href=\"#空间上的代价\" class=\"headerlink\" title=\"空间上的代价\"></a>空间上的代价</h3><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据也组成，那可是很大的存储空间。</p>\n<h3 id=\"时间上的代价\"><a href=\"#时间上的代价\" class=\"headerlink\" title=\"时间上的代价\"></a>时间上的代价</h3><p>每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。我们清楚B+树每层节点都是按照索引列的值从小到大顺序排序的，如果做了增删改则会对排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页分裂、页回收啥的操作来维护好节点和记录的排序，所以在时间上需要对索引进行维护。</p>\n<p>所以，<font color=\"#FF0000\">一个表上索引建的越多，就会占⽤越多的存储空间，在增删改记录的时候性能就越差。</font></p>\n<h2 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h2><p>我们先建立一个表</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> person_info <span class=\"token punctuation\">(</span>\n        id <span class=\"token keyword\">INT</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">auto_increment</span><span class=\"token punctuation\">,</span>\n        NAME <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        birthday <span class=\"token keyword\">DATE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        phone_number CHAR <span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        country <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">KEY</span> idx_name_birthday_phone_number <span class=\"token punctuation\">(</span>NAME<span class=\"token punctuation\">,</span> birthday<span class=\"token punctuation\">,</span> phone_number<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>根据上面的SQL，我们知道表person_info的索引情况</p>\n<ul>\n<li>主键是id列，InnoDB存储引擎为主键设置了一个<font color=\"#FF0000\">聚簇索引</font>，因为是聚簇索引索引对应的B+树的叶子节点存储的用户记录<font color=\"#FF0000\">包含所有列</font></li>\n<li>定义了一个联合索引idx_name_birthday_phone_number,由列name，birthday，phone_number组成，这个联合索引的B+树的叶子节点存储的用户记录包含name，birthday，phone_numbe和主键id，<font color=\"#FF0000\">但不包含country</font>。</li>\n</ul>\n<p><img src=\"/2019/07/18/mysql-index-use/1.png\" alt></p>\n<p>这里需要注意的是联合索引B+树的建立是按照先name,再birthday,最后phone_number的顺序，索引B+树的顺序是按照</p>\n<ul>\n<li>先通过<font color=\"red\">name</font>进行排序。</li>\n<li>如果<font color=\"red\">name</font>相同，再按照<font color=\"red\">birthday</font>排序。</li>\n<li>如果<font color=\"red\">birthday</font>也相同，则按照<font color=\"red\">phone_number</font>排序。</li>\n</ul>\n<h3 id=\"通过主键ID查找数据\"><a href=\"#通过主键ID查找数据\" class=\"headerlink\" title=\"通过主键ID查找数据\"></a>通过主键ID查找数据</h3><pre class=\" language-SQL\"><code class=\"language-SQL\">SELECT\n    *\nFROM\n    person_info\nWHERE\n    ID = 10;</code></pre>\n<p>这种方式下，由于ID是主键，索引通过聚簇索引所在的B+树根据二分法查找到对应的数据。</p>\n<h3 id=\"全值匹配\"><a href=\"#全值匹配\" class=\"headerlink\" title=\"全值匹配\"></a>全值匹配</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span>\n    person_info\n<span class=\"token keyword\">WHERE</span>\n    NAME <span class=\"token operator\">=</span> <span class=\"token string\">'Ashburn'</span>\n<span class=\"token operator\">AND</span> birthday <span class=\"token operator\">=</span> <span class=\"token string\">'1990-09-27'</span>\n<span class=\"token operator\">AND</span> phone_number <span class=\"token operator\">=</span> <span class=\"token string\">'15123983239'</span><span class=\"token punctuation\">;</span></code></pre>\n<p>上面SQL，由于查询条件包含在了idx_name_birthday_phone_number索引内，所以查询过程如下</p>\n<ol>\n<li>因为B+树的数据页和记录先是按照name列的值进行排序的，所以先可以很快定位name列的值是Ashburn的记录位置</li>\n<li>在name列相同的记录是按照birthday列的值进行排序的，所以在name列的值是Ashburn的记录可以快速定位birthday列的值是’1990-09-27’的记录</li>\n<li>如果很不幸，name和birthday列的值都是相同的，那记录是按照phone_number列的值排序的，所以联合索引中的三个列都可能被用到</li>\n</ol>\n<p>这种情况下我们通过三个列的全值匹配查找到的对应的记录，记录上包含了id,name,birthday,phone_number。但是我们查询的是*,在idx_name_birthday_phone_number索引B+树上并没有存储country的数据，那这时候如何查找country？</p>\n<h3 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h3><p>由于country只记录在聚簇索引B+树上，而我们通过联合索引已经查到数据对应的ID，所以这时候通过ID继续去聚簇索引上查找一遍，最终获取到了最后的数据。</p>\n<p>这种需要把从上⼀步中获取到的每⼀条记录的id字段都到聚簇索引对应的B+树中找到完整的⽤户记录，也就是我们通常所说的<font color=\"red\">回表</font></p>\n<h4 id=\"回表的代价\"><a href=\"#回表的代价\" class=\"headerlink\" title=\"回表的代价\"></a>回表的代价</h4><p><font color=\"red\">需要回表的记录越多，使用二级索引的性能就越低</font>，甚至让某些查询宁愿使用全表扫描也不使用二级索引。假设有一种情况，name = ‘Ashburn’ AND birthday = ‘1990-09-27’ AND phone_number = ‘15123983239’ 的数据占了所有数据的90%以上，那此时通过联合索引先查一遍获取到对应的主键ID再去聚簇索引查一遍的方式（二级索引+回表）就比全表扫描效率差。</p>\n<p>所以在使用上我们应该尽量避免回表产生的问题</p>\n<ul>\n<li>建议点1 ：例如可以判断业务上是否需要获取所有列的数据，如果业务上只需要id,name,birthday,phone_number列的值而不需要country的值，这时候可以不使用select * ,这样可以防止回表 </li>\n<li>建议点2 ：尽量避免回表的次数，这种可以从索引的选取方面考虑，例如对于重复值大的列不建议设置为索引。</li>\n</ul>\n<h3 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h3><p>为了彻底告别回表操作带来的性能损耗，我们建议：<font color=\"red\">最好在查询列表⾥只包含索引列</font></p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    ID<span class=\"token punctuation\">,</span>NAME<span class=\"token punctuation\">,</span>birthday<span class=\"token punctuation\">,</span>phone_number\n<span class=\"token keyword\">FROM</span>\n    person_info\n<span class=\"token keyword\">WHERE</span>\n    NAME <span class=\"token operator\">=</span> <span class=\"token string\">'Ashburn'</span>\n<span class=\"token operator\">AND</span> birthday <span class=\"token operator\">=</span> <span class=\"token string\">'1990-09-27'</span>\n<span class=\"token operator\">AND</span> phone_number <span class=\"token operator\">=</span> <span class=\"token string\">'15123983239'</span><span class=\"token punctuation\">;</span></code></pre>\n<p>我们把这种只需要用到索引的查询方式称为索引覆盖。排序操作也优先使用<font color=\"red\">覆盖索引</font></p>\n<h3 id=\"最左匹配原则\"><a href=\"#最左匹配原则\" class=\"headerlink\" title=\"最左匹配原则\"></a>最左匹配原则</h3><p>下面两个SQL语句，查询条件相同，只是顺序不同，是否性能相同？</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">-- SQL 1</span>\n<span class=\"token keyword\">SELECT</span>\n    <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span>\n    person_info\n<span class=\"token keyword\">WHERE</span>\n    NAME <span class=\"token operator\">=</span> <span class=\"token string\">'Ashburn'</span>\n<span class=\"token operator\">AND</span> birthday <span class=\"token operator\">=</span> <span class=\"token string\">'1990-09-27'</span>\n<span class=\"token operator\">AND</span> phone_number <span class=\"token operator\">=</span> <span class=\"token string\">'15123983239'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">-- SQL 2</span>\n<span class=\"token keyword\">SELECT</span>\n    <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span>\n    person_info\n<span class=\"token keyword\">WHERE</span>\n    birthday <span class=\"token operator\">=</span> <span class=\"token string\">'1990-09-27'</span>\n<span class=\"token operator\">AND</span> NAME <span class=\"token operator\">=</span> <span class=\"token string\">'Ashburn'</span>\n<span class=\"token operator\">AND</span> phone_number <span class=\"token operator\">=</span> <span class=\"token string\">'15123983239'</span><span class=\"token punctuation\">;</span></code></pre>\n<p>答案是不相同，通过索引的分析，我们知道idx_name_birthday_phone_number的排序方式是name -&gt; birthday - &gt; phone_number。但是SQL2是先birthday-&gt;NAME-&gt;phone_number。这样则没办法先通过name去查找索引，所以SQL2使用不到索引将会采用全表扫描。</p>\n<p>所以，<font color=\"red\">如果我们想使⽤联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</font></p>\n<h3 id=\"用于排序\"><a href=\"#用于排序\" class=\"headerlink\" title=\"用于排序\"></a>用于排序</h3><p>我们在写查询语句的时候经常需要对查询出来的记录通过ORDER BY语句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。</p>\n<p>但如果排序的列是按照索引排列的，例如</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    ID<span class=\"token punctuation\">,</span>NAME<span class=\"token punctuation\">,</span>birthday<span class=\"token punctuation\">,</span>phone_number\n<span class=\"token keyword\">FROM</span>\n    person_info\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span>\n    NAME<span class=\"token punctuation\">,</span>\n    birthday<span class=\"token punctuation\">,</span>\n    phone_number<span class=\"token punctuation\">;</span></code></pre>\n<p>则可以直接按照索引的存储顺序进行排序。</p>\n<h4 id=\"不能使用索引排序的情况\"><a href=\"#不能使用索引排序的情况\" class=\"headerlink\" title=\"不能使用索引排序的情况\"></a>不能使用索引排序的情况</h4><ol>\n<li>ASC,DESC混用，对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是ASC规则排序，要么都是DESC规则排序。</li>\n<li>WHERE子句中出现非排序使用到的索引列。</li>\n<li>排序列包含非同一个索引的列。如果不是同一个索引，排序的方式是不一样的</li>\n<li>排序列使用了复杂的表达式</li>\n</ol>\n<h2 id=\"如何挑选索引\"><a href=\"#如何挑选索引\" class=\"headerlink\" title=\"如何挑选索引\"></a>如何挑选索引</h2><h3 id=\"只为用于搜索、排序或分组的列创建索引\"><a href=\"#只为用于搜索、排序或分组的列创建索引\" class=\"headerlink\" title=\"只为用于搜索、排序或分组的列创建索引\"></a>只为用于搜索、排序或分组的列创建索引</h3><p>只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。</p>\n<h3 id=\"需要考虑列的基数\"><a href=\"#需要考虑列的基数\" class=\"headerlink\" title=\"需要考虑列的基数\"></a>需要考虑列的基数</h3><p>列的基数指的是某一列中不重复数据的个数。在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。<br>例如上面说的回表和全表扫描情况，一个列的重复个数越多那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。<br>所以，<font color=\"red\">最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</font></p>\n<h3 id=\"索引列的类型尽量小\"><a href=\"#索引列的类型尽量小\" class=\"headerlink\" title=\"索引列的类型尽量小\"></a>索引列的类型尽量小</h3><ul>\n<li>数据类型越小，在查询时进行的比较操作越快</li>\n<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓 存在内存中，从而加快读写效率</li>\n</ul>\n<h3 id=\"索引字符串值的前缀\"><a href=\"#索引字符串值的前缀\" class=\"headerlink\" title=\"索引字符串值的前缀\"></a>索引字符串值的前缀</h3><ul>\n<li>B+树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大</li>\n<li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间</li>\n</ul>\n<p>所以可以只对<font color=\"red\">一个列的前几个字符进行索引</font>。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> person_info <span class=\"token punctuation\">(</span>\n        NAME <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        birthday <span class=\"token keyword\">DATE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        phone_number CHAR <span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        country <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">KEY</span> idx_name_birthday_phone_number <span class=\"token punctuation\">(</span>NAME <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>birthday<span class=\"token punctuation\">,</span>phone_number<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>name(10)就表示在建立的B+树索引中只保留记录的前10个字符的编码，这种只索引字符串值的前缀的策略是我们经常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。</p>\n<h3 id=\"让索引列在比较表达式中单独出现\"><a href=\"#让索引列在比较表达式中单独出现\" class=\"headerlink\" title=\"让索引列在比较表达式中单独出现\"></a>让索引列在比较表达式中单独出现</h3><p>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">WHERE</span> my_col <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span> <span class=\"token comment\" spellcheck=\"true\">-- 不能使用索引</span>\n<span class=\"token keyword\">WHERE</span> my_col <span class=\"token operator\">&lt;</span> <span class=\"token number\">4</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span> <span class=\"token comment\" spellcheck=\"true\">-- 可以使用索引</span></code></pre>\n<h3 id=\"避免冗余和重复索引\"><a href=\"#避免冗余和重复索引\" class=\"headerlink\" title=\"避免冗余和重复索引\"></a>避免冗余和重复索引</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> person_info <span class=\"token punctuation\">(</span>\n        id <span class=\"token keyword\">INT</span> UNSIGNED <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n        NAME <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        birthday <span class=\"token keyword\">DATE</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        phone_number CHAR <span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        country <span class=\"token keyword\">VARCHAR</span> <span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">KEY</span> idx_name_birthday_phone_number <span class=\"token punctuation\">(</span>NAME <span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>birthday<span class=\"token punctuation\">,</span>phone_number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">KEY</span> idx_name <span class=\"token punctuation\">(</span>NAME<span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>例如上面NAME已经包含在联合索引中了，又自己新建了一个索引，这种重复的索引是毫无必要的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>B+树索引在空间和时间上都有代价，所以没事⼉别瞎建索引</li>\n<li>B+树索引适⽤于下边这些情况<ul>\n<li>全值匹配</li>\n<li>匹配左边的列</li>\n<li>匹配范围值</li>\n<li>精确匹配某一列并范围匹配另外一列</li>\n<li>用于排序</li>\n<li>用于分组</li>\n</ul>\n</li>\n<li>在使⽤索引时需要注意下边这些事项<ul>\n<li>只为⽤于搜索、排序或分组的列创建索引</li>\n<li>为列的基数⼤的列创建索引 </li>\n<li>索引列的类型尽量⼩</li>\n<li>可以只对字符串值的前缀建⽴索引 </li>\n<li>只有索引列在⽐较表达式中单独出现才可以适⽤索引</li>\n<li>为了尽可能少的让聚簇索引发⽣⻚⾯分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性</li>\n<li>定位并删除表中的重复和冗余索引</li>\n<li>尽量使⽤覆盖索引进⾏查询，避免回表带来的性能损耗</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>本文参考《MYSQL高性能》，《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"提出问题\"><a href=\"#提出问题\" class=\"headerlink\" title=\"提出问题\"></a>提出问题</h2><ol>\n<li>什么是回表？</li>\n<li>索引是不是可以无限建？</li>\n<li>什么是索引的最左匹配原则？</li>\n<li>什么是覆盖索引？</li>\n<li>如何建立高效的索引？</li></ol>","more":"<h2 id=\"索引的代价\"><a href=\"#索引的代价\" class=\"headerlink\" title=\"索引的代价\"></a>索引的代价</h2>通过上文《Mysql-InnoDB索引之索引结构详解(一)》我们了解到了B+树索引的原理。<font color=\"#FF0000\">InnoDB</font>存储引擎会自动为主键（如果没有它会自动帮我们添加）建立<font color=\"#FF0000\">聚簇索引</font>，聚簇索引的叶子节点包含完整的用户记录。而且每次建立一次索引都需要为其建立一颗B+树。\n\n<h3 id=\"空间上的代价\"><a href=\"#空间上的代价\" class=\"headerlink\" title=\"空间上的代价\"></a>空间上的代价</h3><p>每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会占用16KB的存储空间，一棵很大的B+树由许多数据也组成，那可是很大的存储空间。</p>\n<h3 id=\"时间上的代价\"><a href=\"#时间上的代价\" class=\"headerlink\" title=\"时间上的代价\"></a>时间上的代价</h3><p>每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。我们清楚B+树每层节点都是按照索引列的值从小到大顺序排序的，如果做了增删改则会对排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页分裂、页回收啥的操作来维护好节点和记录的排序，所以在时间上需要对索引进行维护。</p>\n<p>所以，<font color=\"#FF0000\">一个表上索引建的越多，就会占⽤越多的存储空间，在增删改记录的时候性能就越差。</font></p>\n<h2 id=\"索引的使用\"><a href=\"#索引的使用\" class=\"headerlink\" title=\"索引的使用\"></a>索引的使用</h2><p>我们先建立一个表</p>\n<pre><code class=\"sql\">CREATE TABLE person_info (\n        id INT NOT NULL auto_increment,\n        NAME VARCHAR (100) NOT NULL,\n        birthday DATE NOT NULL,\n        phone_number CHAR (11) NOT NULL,\n        country VARCHAR (100) NOT NULL,\n        PRIMARY KEY (id),\n        KEY idx_name_birthday_phone_number (NAME, birthday, phone_number)\n);</code></pre>\n<p>根据上面的SQL，我们知道表person_info的索引情况</p>\n<ul>\n<li>主键是id列，InnoDB存储引擎为主键设置了一个<font color=\"#FF0000\">聚簇索引</font>，因为是聚簇索引索引对应的B+树的叶子节点存储的用户记录<font color=\"#FF0000\">包含所有列</font></li>\n<li>定义了一个联合索引idx_name_birthday_phone_number,由列name，birthday，phone_number组成，这个联合索引的B+树的叶子节点存储的用户记录包含name，birthday，phone_numbe和主键id，<font color=\"#FF0000\">但不包含country</font>。</li>\n</ul>\n<p><img src=\"/2019/07/18/mysql-index-use/1.png\" alt></p>\n<p>这里需要注意的是联合索引B+树的建立是按照先name,再birthday,最后phone_number的顺序，索引B+树的顺序是按照</p>\n<ul>\n<li>先通过<font color=\"red\">name</font>进行排序。</li>\n<li>如果<font color=\"red\">name</font>相同，再按照<font color=\"red\">birthday</font>排序。</li>\n<li>如果<font color=\"red\">birthday</font>也相同，则按照<font color=\"red\">phone_number</font>排序。</li>\n</ul>\n<h3 id=\"通过主键ID查找数据\"><a href=\"#通过主键ID查找数据\" class=\"headerlink\" title=\"通过主键ID查找数据\"></a>通过主键ID查找数据</h3><pre><code class=\"SQL\">SELECT\n    *\nFROM\n    person_info\nWHERE\n    ID = 10;</code></pre>\n<p>这种方式下，由于ID是主键，索引通过聚簇索引所在的B+树根据二分法查找到对应的数据。</p>\n<h3 id=\"全值匹配\"><a href=\"#全值匹配\" class=\"headerlink\" title=\"全值匹配\"></a>全值匹配</h3><pre><code class=\"sql\">SELECT\n    *\nFROM\n    person_info\nWHERE\n    NAME = &#39;Ashburn&#39;\nAND birthday = &#39;1990-09-27&#39;\nAND phone_number = &#39;15123983239&#39;;</code></pre>\n<p>上面SQL，由于查询条件包含在了idx_name_birthday_phone_number索引内，所以查询过程如下</p>\n<ol>\n<li>因为B+树的数据页和记录先是按照name列的值进行排序的，所以先可以很快定位name列的值是Ashburn的记录位置</li>\n<li>在name列相同的记录是按照birthday列的值进行排序的，所以在name列的值是Ashburn的记录可以快速定位birthday列的值是’1990-09-27’的记录</li>\n<li>如果很不幸，name和birthday列的值都是相同的，那记录是按照phone_number列的值排序的，所以联合索引中的三个列都可能被用到</li>\n</ol>\n<p>这种情况下我们通过三个列的全值匹配查找到的对应的记录，记录上包含了id,name,birthday,phone_number。但是我们查询的是*,在idx_name_birthday_phone_number索引B+树上并没有存储country的数据，那这时候如何查找country？</p>\n<h3 id=\"回表\"><a href=\"#回表\" class=\"headerlink\" title=\"回表\"></a>回表</h3><p>由于country只记录在聚簇索引B+树上，而我们通过联合索引已经查到数据对应的ID，所以这时候通过ID继续去聚簇索引上查找一遍，最终获取到了最后的数据。</p>\n<p>这种需要把从上⼀步中获取到的每⼀条记录的id字段都到聚簇索引对应的B+树中找到完整的⽤户记录，也就是我们通常所说的<font color=\"red\">回表</font></p>\n<h4 id=\"回表的代价\"><a href=\"#回表的代价\" class=\"headerlink\" title=\"回表的代价\"></a>回表的代价</h4><p><font color=\"red\">需要回表的记录越多，使用二级索引的性能就越低</font>，甚至让某些查询宁愿使用全表扫描也不使用二级索引。假设有一种情况，name = ‘Ashburn’ AND birthday = ‘1990-09-27’ AND phone_number = ‘15123983239’ 的数据占了所有数据的90%以上，那此时通过联合索引先查一遍获取到对应的主键ID再去聚簇索引查一遍的方式（二级索引+回表）就比全表扫描效率差。</p>\n<p>所以在使用上我们应该尽量避免回表产生的问题</p>\n<ul>\n<li>建议点1 ：例如可以判断业务上是否需要获取所有列的数据，如果业务上只需要id,name,birthday,phone_number列的值而不需要country的值，这时候可以不使用select * ,这样可以防止回表 </li>\n<li>建议点2 ：尽量避免回表的次数，这种可以从索引的选取方面考虑，例如对于重复值大的列不建议设置为索引。</li>\n</ul>\n<h3 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h3><p>为了彻底告别回表操作带来的性能损耗，我们建议：<font color=\"red\">最好在查询列表⾥只包含索引列</font></p>\n<pre><code class=\"sql\">SELECT\n    ID,NAME,birthday,phone_number\nFROM\n    person_info\nWHERE\n    NAME = &#39;Ashburn&#39;\nAND birthday = &#39;1990-09-27&#39;\nAND phone_number = &#39;15123983239&#39;;</code></pre>\n<p>我们把这种只需要用到索引的查询方式称为索引覆盖。排序操作也优先使用<font color=\"red\">覆盖索引</font></p>\n<h3 id=\"最左匹配原则\"><a href=\"#最左匹配原则\" class=\"headerlink\" title=\"最左匹配原则\"></a>最左匹配原则</h3><p>下面两个SQL语句，查询条件相同，只是顺序不同，是否性能相同？</p>\n<pre><code class=\"sql\">-- SQL 1\nSELECT\n    *\nFROM\n    person_info\nWHERE\n    NAME = &#39;Ashburn&#39;\nAND birthday = &#39;1990-09-27&#39;\nAND phone_number = &#39;15123983239&#39;;\n-- SQL 2\nSELECT\n    *\nFROM\n    person_info\nWHERE\n    birthday = &#39;1990-09-27&#39;\nAND NAME = &#39;Ashburn&#39;\nAND phone_number = &#39;15123983239&#39;;</code></pre>\n<p>答案是不相同，通过索引的分析，我们知道idx_name_birthday_phone_number的排序方式是name -&gt; birthday - &gt; phone_number。但是SQL2是先birthday-&gt;NAME-&gt;phone_number。这样则没办法先通过name去查找索引，所以SQL2使用不到索引将会采用全表扫描。</p>\n<p>所以，<font color=\"red\">如果我们想使⽤联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</font></p>\n<h3 id=\"用于排序\"><a href=\"#用于排序\" class=\"headerlink\" title=\"用于排序\"></a>用于排序</h3><p>我们在写查询语句的时候经常需要对查询出来的记录通过ORDER BY语句按照某种规则进行排序。一般情况下，我们只能把记录都加载到内存中，再用一些排序算法，比如快速排序、归并排序等等在内存中对这些记录进行排序，有的时候可能查询的结果集太大以不能在内存中进行排序的话，还可能暂时借助磁盘的空间来存放中间结果，排序操作完成后再把排好序的结果集返回到客户端。</p>\n<p>但如果排序的列是按照索引排列的，例如</p>\n<pre><code class=\"sql\">SELECT\n    ID,NAME,birthday,phone_number\nFROM\n    person_info\nORDER BY\n    NAME,\n    birthday,\n    phone_number;</code></pre>\n<p>则可以直接按照索引的存储顺序进行排序。</p>\n<h4 id=\"不能使用索引排序的情况\"><a href=\"#不能使用索引排序的情况\" class=\"headerlink\" title=\"不能使用索引排序的情况\"></a>不能使用索引排序的情况</h4><ol>\n<li>ASC,DESC混用，对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是ASC规则排序，要么都是DESC规则排序。</li>\n<li>WHERE子句中出现非排序使用到的索引列。</li>\n<li>排序列包含非同一个索引的列。如果不是同一个索引，排序的方式是不一样的</li>\n<li>排序列使用了复杂的表达式</li>\n</ol>\n<h2 id=\"如何挑选索引\"><a href=\"#如何挑选索引\" class=\"headerlink\" title=\"如何挑选索引\"></a>如何挑选索引</h2><h3 id=\"只为用于搜索、排序或分组的列创建索引\"><a href=\"#只为用于搜索、排序或分组的列创建索引\" class=\"headerlink\" title=\"只为用于搜索、排序或分组的列创建索引\"></a>只为用于搜索、排序或分组的列创建索引</h3><p>只为出现在WHERE子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。</p>\n<h3 id=\"需要考虑列的基数\"><a href=\"#需要考虑列的基数\" class=\"headerlink\" title=\"需要考虑列的基数\"></a>需要考虑列的基数</h3><p>列的基数指的是某一列中不重复数据的个数。在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中。<br>例如上面说的回表和全表扫描情况，一个列的重复个数越多那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。<br>所以，<font color=\"red\">最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。</font></p>\n<h3 id=\"索引列的类型尽量小\"><a href=\"#索引列的类型尽量小\" class=\"headerlink\" title=\"索引列的类型尽量小\"></a>索引列的类型尽量小</h3><ul>\n<li>数据类型越小，在查询时进行的比较操作越快</li>\n<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓 存在内存中，从而加快读写效率</li>\n</ul>\n<h3 id=\"索引字符串值的前缀\"><a href=\"#索引字符串值的前缀\" class=\"headerlink\" title=\"索引字符串值的前缀\"></a>索引字符串值的前缀</h3><ul>\n<li>B+树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大</li>\n<li>如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间</li>\n</ul>\n<p>所以可以只对<font color=\"red\">一个列的前几个字符进行索引</font>。</p>\n<pre><code class=\"sql\">CREATE TABLE person_info (\n        NAME VARCHAR (100) NOT NULL,\n        birthday DATE NOT NULL,\n        phone_number CHAR (11) NOT NULL,\n        country VARCHAR (100) NOT NULL,\n        KEY idx_name_birthday_phone_number (NAME (10),birthday,phone_number)\n);</code></pre>\n<p>name(10)就表示在建立的B+树索引中只保留记录的前10个字符的编码，这种只索引字符串值的前缀的策略是我们经常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。</p>\n<h3 id=\"让索引列在比较表达式中单独出现\"><a href=\"#让索引列在比较表达式中单独出现\" class=\"headerlink\" title=\"让索引列在比较表达式中单独出现\"></a>让索引列在比较表达式中单独出现</h3><p>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的。</p>\n<pre><code class=\"sql\">WHERE my_col * 2 &lt; 4 -- 不能使用索引\nWHERE my_col &lt; 4 / 2 -- 可以使用索引</code></pre>\n<h3 id=\"避免冗余和重复索引\"><a href=\"#避免冗余和重复索引\" class=\"headerlink\" title=\"避免冗余和重复索引\"></a>避免冗余和重复索引</h3><pre><code class=\"sql\">CREATE TABLE person_info (\n        id INT UNSIGNED NOT NULL AUTO_INCREMENT,\n        NAME VARCHAR (100) NOT NULL,\n        birthday DATE NOT NULL,\n        phone_number CHAR (11) NOT NULL,\n        country VARCHAR (100) NOT NULL,\n        PRIMARY KEY (id),\n        KEY idx_name_birthday_phone_number (NAME (10),birthday,phone_number),\n        KEY idx_name (NAME(10))\n);</code></pre>\n<p>例如上面NAME已经包含在联合索引中了，又自己新建了一个索引，这种重复的索引是毫无必要的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>B+树索引在空间和时间上都有代价，所以没事⼉别瞎建索引</li>\n<li>B+树索引适⽤于下边这些情况<ul>\n<li>全值匹配</li>\n<li>匹配左边的列</li>\n<li>匹配范围值</li>\n<li>精确匹配某一列并范围匹配另外一列</li>\n<li>用于排序</li>\n<li>用于分组</li>\n</ul>\n</li>\n<li>在使⽤索引时需要注意下边这些事项<ul>\n<li>只为⽤于搜索、排序或分组的列创建索引</li>\n<li>为列的基数⼤的列创建索引 </li>\n<li>索引列的类型尽量⼩</li>\n<li>可以只对字符串值的前缀建⽴索引 </li>\n<li>只有索引列在⽐较表达式中单独出现才可以适⽤索引</li>\n<li>为了尽可能少的让聚簇索引发⽣⻚⾯分裂和记录移位的情况，建议让主键拥有AUTO_INCREMENT属性</li>\n<li>定位并删除表中的重复和冗余索引</li>\n<li>尽量使⽤覆盖索引进⾏查询，避免回表带来的性能损耗</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>本文参考《MYSQL高性能》，《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>\n</ul>"},{"title":"MySQL索引优化EXPLAIN详解","description":"MySQL索引优化EXPLAIN","date":"2020-07-31T09:34:03.000Z","_content":"## 正文\n\n### EXPLAIN字段说明\n\n![示例1](mysql-explain/1.png)\n\n| **`列名`**    | **`用途`**                                             |\n| ------------- | ------------------------------------------------------ |\n| id            | 每一个SELECT关键字查询语句都对应一个唯一id             |\n| select_type   | SELECT关键字对应的查询类型                             |\n| table         | 表名                                                   |\n| partitions    | 匹配的分区信息                                         |\n| type          | 单表的访问方法                                         |\n| possible_keys | 可能用到的索引                                         |\n| key           | 实际使用到的索引                                       |\n| key_len       | 实际使用到的索引长度                                   |\n| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 |\n| rows          | 预估需要读取的记录条数                                 |\n| filtered      | 某个表经过条件过滤后剩余的记录条数百分比               |\n| Extra         | 额外的一些信息                                         |\n\n为了事情的发展，我们新建几张表方便后面讲解...\n<!--more-->\n```sql\nCREATE TABLE `s1` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `key1` varchar(100) DEFAULT NULL,\n  `key2` int(11) DEFAULT NULL,\n  `key3` varchar(100) DEFAULT NULL,\n  `key_part1` varchar(100) DEFAULT NULL,\n  `key_part2` varchar(100) DEFAULT NULL,\n  `key_part3` varchar(100) DEFAULT NULL,\n  `common_field` varchar(100) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `idx_key2` (`key2`),\n  KEY `idx_key1` (`key1`),\n  KEY `idx_key3` (`key3`),\n  KEY `idx_key_part` (`key_part1`,`key_part2`,`key_part3`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4;\n-- s2结构相同\n```\n### id列\n\n`id` 列编号是 `SELECT` 的序列号，并且 id 的顺序是按 `SELECT` 出现的顺序增长的。id列越大执行优先级越高，id 相同则从上往下执行，id 为 NULL 最后执行。\n\n<font color=red>ID越大，执行的优先级越高；ID相等，从上往下优先顺序执行。</font>\n\n例如下面，id = 2 的子查询先查询，然后再查 id = 1 的情况。\n\n![](mysql-explain/2.png)\n\n这个查询执行时有个临时表别名为 derived，外部 SELECT 查询引用了这个临时表。\n\n![derived2为物化表](mysql-explain/3.png)\n\n根据相同ID的话，从上往下顺序执行，我们可以知道此SQL选择s1作为驱动表。\n\n![ID相同的情况](mysql-explain/4.png)\n\n### select_type 列\n查询的SQL对应的类型。一般有下面几种值。\n\n| 名称               | 描述                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| SIMPLE             | 简单查询。查询不包含子查询 和 `UNION`。                      |\n| PRIMARY            | 对于包含UNION、UNION ALL或者⼦查询的⼤查询来说，它是由⼏个⼩查询组成的，其中最左边的那个查询的select_type值就是PRIMARY |\n| UNION              | 对于包含UNION或者UNION ALL的⼤查询来说，它是由⼏个⼩查询组成的，其中除了最左边的那个⼩查询以外，其余的⼩查询的select_type值就是UNION |\n| UNION RESULT       | MySQL选择使⽤临时表来完成UNION查询的去重⼯作，针对该临时表的查询的select_type就是UNION RESULT |\n| SUBQUERY           | 如果包含⼦查询的查询语句不能够转为对应的semi-join的形式，并且该⼦查询是不相关⼦查询，并且查询优化器决定采⽤将该⼦查询物化的⽅案来执⾏该⼦查询时,该⼦查询的第⼀个SELECT关键字代表的那个查询的select_type就是SUBQUERY |\n| DEPENDENT SUBQUERY | 如果包含⼦查询的查询语句不能够转为对应的semi-join的形式，并且该⼦查询是相关⼦查询，则该⼦查询的第⼀个SELECT关键字代表的那个查询的 select_type就是DEPENDENT SUBQUERY |\n| DEPENDENT UNION    | 在包含UNION或者UNION ALL的⼤查询中，如果各个⼩查询都依赖于外层查询的话，那除了最左边的那个⼩查询之外，其余的⼩查询的select_type的值就是DEPENDENT UNION |\n| DERIVED            | 对于采⽤物化的⽅式执⾏的包含派⽣表的查询，该派⽣表对应的⼦查询的select_type就是DERIVED |\n\n\n\n### table列\n\ntable 列表示 EXPLAIN 的单独行的唯一标识符。这个值可能是表名、表的别名或者一个未查询产生临时表的标识符，如派生表、子查询或集合。\n\n当 `FROM` 子句中有子查询时，如果优化器采用的物化方式，table 列是\\<derivenN>格式，表示当前查询依赖 `id=N` 的查询，于是先执行 `id=N` 的查询。\n\n### partitions 列\n\n分区的意思，这一般没怎么用到。。\n\n### type 列\n\n这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。\n依次从最优到最差分别是 : <font color=red> system > const > eq_ref > ref > range > index > ALL</font>。\n\n<font size=4 color=red>一般来说，必须保证查询在range级别及其以上是最好的</font>。\n\n#### system\n当表中只有⼀条记录并且该表使⽤的存储引擎的统计数据是精确的，⽐如MyISAM、Memory，那么对该表的访问⽅法就是system。\n\n#### const\n根据主键或者唯⼀⼆级索引列与常数进⾏等值匹配时，对单表的访问⽅法就是const。\n\n```sql\nEXPLAIN select * from s1 WHERE key2 = 256;\n```\n\n![唯一索引执行计划](mysql-explain/5.png)\n\n#### eq_ref\n在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的，则对该被驱动表的访问方法就是 eq_ref。\n\n```sql\nEXPLAIN SELECT * FROM s1 JOIN s2 on s1.id = s2.id;\n```\n![eq_ref执行计划](mysql-explain/6.png)\n\n从执⾏计划的结果中可以看出，MySQL打算将s1作为驱动表，s2作为被驱动表，重点关注s2的访问⽅法是eq_ref，表明在访问s2表的时候可以通过主键的 等值匹配来进⾏访问。\n\n#### ref\n当通过普通的⼆级索引列与常量进⾏等值匹配时来查询某个表，那么对该表的访问⽅法就可能是ref。\n```sql\nEXPLAIN select * from s1 WHERE key1 = 'rkm';\n```\n\n![ref执行计划](mysql-explain/7.png)\n\n可以看出，key1是普通二级索引，通过等值查询的结果可能有多个。所以是req。\n它与req_eq的区别在于 ： 相比 eq_ref，ref不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n\n#### ref_or_null\n对普通二级索引(<font color=red>包括普通索引和唯一索引,普通索引和唯一索引都允许有NULL值且不限制NULL的个数</font>)进行等值查询，该索引列也可以为NULL值时。\n\n```sql\nEXPLAIN select * from s1 WHERE key1 = 'rkm' or key1 is null;\n```\n\n![ref_or_null执行计划](mysql-explain/8.png)\n\n#### index_merge\nMySQL使用索引合并的方式执行的。\n所谓的索引合并值的是 ：我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。可以参考下另一篇文章《Mysql-InnoDB索引之单表使用索引详解(三)》\n\n```sql\nEXPLAIN select * from s1 WHERE key2 = 2354 or key1 = 'rkm'\n```\n\n![index_merge执行计划](mysql-explain/9.png)\n\n#### range\n使用索引获取范围区间的记录，通常出现在 in, between ,> ,<, >= 等操作中。\n```sql\nEXPLAIN SELECT * FROM s1 where key2 BETWEEN 100 and 200;\n```\n\n![range执行计划](mysql-explain/10.png)\n\n#### index\n扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而 ALL 是从硬盘中读取）。\n这种比ALL快一点，他指的是直接从B+索引树查询所有的数据。总结一句话就是扫描覆盖索引。\n```sql\nEXPLAIN\tSELECT\tkey_part2\tFROM\ts1\tWHERE\tkey_part3\t=\t'a';\n```\n\n![](mysql-explain/11.png)\n\n例如此SQL,由于key_part2和key_part3是在同一个索引树上，且获取key_part2时不需要回表。\n但是为什么会是扫描全表索引呢？ 因为key_part3不是最左匹配。\n\n#### ALL\n不说了，性能最差。\n### possible_keys 列\npossible_keys 列表示查询<font color=red>可能</font>使用哪些索引来查找。\n\n如果possible_keys 为NULL表示没有相关的索引，此时需要验证下语句情况。\n\n另外需要注意的是 ： <font color=red>不是这一列的值越多越好，使用索引过多，查询优化器计算时查询成本高，所以如果可能的话，尽量删除那些不用的索引。</font>\n\n### key 列\nkey 列表示实际采用哪个索引来优化对该表的访问。\n\n### key_len 列\nkey_len 列表示当查询优化器决定使用某一个索引查询时，该索引记录的最大长度。\n\n### ref 列\n当使⽤索引列等值匹配的条件去执⾏查询时，也就是在访问⽅法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery其中之⼀时， ref列展示的就是与索引列作等值匹配的东东是个啥，⽐如只是⼀个常数或者是某个列。\n```sql\nEXPLAIN\tSELECT\t*\tFROM\ts1\tWHERE\tkey1\t=\t'a';\n```\n\n![](mysql-explain/12.png)\n\n可以看到ref列的值是const，表明在使⽤idx_key1索引执⾏查询时，与key1列作等值匹配的对象是⼀个常数。\n### rows 列\nrows 列是查询优化器估计要读取并检测的行数，注意这个不是结果集里的行数。\n通常也可以通过这个来看查询的量，如果量大则表示SQL性能差\n\n### filtered 列\n对于单表来说意义不大，主要用于连接查询中。\n前文中也已提到 filtered 列，是一个百分比的值，对于连接查询来说，主要看驱动表的 filtered列的值 ，通过 rows * filtered/100 计算可以估算出被驱动表还需要执行的查询次数。\n\n### Extra 列\nExtra列是⽤来说明⼀些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL到底将如何执⾏给定的查询语句。\n下面说下几种比较重要的。\n####  Using index\n查询的列被索引覆盖，并且 WHERE 筛选条件是索引的前导列，使用了索引性能高。一般是使用了覆盖索引(查询列都是索引列字段)。\n可以具体观察如下两条语句的区别\n```sql\nEXPLAIN\tSELECT\tkey1\tFROM\ts1\tWHERE\tkey1\t=\t'a';\nEXPLAIN\tSELECT\t*\tFROM\ts1\tWHERE\tkey1\t=\t'a';\n```\n#### Using index condition\n指的是有些搜索条件中虽然出现了索引列，但却不能使⽤到索引。例如下面这个SQL\n```sql\nEXPLAIN\tSELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';\n```\n\n![](mysql-explain/13.png)\n\n由于这个语句只能用到第一个条件，对于第二个条件在以前是需要在回表的时候去过滤的。但是现在做了优化，对于第一个条件查出来的二级索引记录先不着急回表，⽽是先检测⼀下该记录是否满⾜key1 LIKE '%a'这个条件，如果这个条件不满⾜，则该⼆级索引记录压根⼉ 就没必要回表。这种情况称之为<font color=red>索引条件下推</font>。\n#### Using temporary\nMySQL 中需要创建一张内部临时表来处理查询，一般出现这种情况就需要考虑进行优化了，首先是想到用索引来优化。\n#### Using filesort\n使用一个外部索引排序。一般来说我们根据索引的顺序排序是最优的，而这种情况指的是没办法根据索引的顺序直接排序，所以数据被放到了内存或磁盘中排序，这种在内存中或者磁盘上进⾏排序的⽅式统称为⽂件排序。\n<font color=red>一般出现这个需要看下是否可以根据索引来排序优化。</font>\n#### Using join buffer(Block Nested Loop)\n在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。出现该值，应该注意，根据查询的具体情况可能需要添加索引来改进性能。\n\n**到底能不能使用join，使用join是否有性能问题，要使用join需要注意几个要点。?**\n\n**如果使用join，需要让小表(数据量小)的表作为驱动表，大表作为被驱动表，且前提是on条件中可以使用到大表的索引。**\n\n如果是小表作为驱动表，假设小表有100条记录，大表1000条记录。\n\n```sql\nSELECT * from 小表 left join 大表 on 小表.a = 大表.b;\n```\n\n假设大表上a字段有索引。处理逻辑如下：\n\n1. 全表扫描小表100行记录到内存join_buffer\n2. 从小表中一条一条记录的去查大表，由于大表a上有索引，每次只会扫描到1条到内存。\n3. 内存进行合并，总扫描次数为 100 + 100 = 200\n\n如果大表a字段没索引，处理逻辑如下:\n\n1. 全表扫描小表100行记录到内存join_buffer\n2. 全表扫描大表1000行记录到内存join_buffer\n3. 在内存join做合并，取小表一条记录，然后跟内存中大表记录做1000次判断，所以在内存中的判断次数是 100 * 1000 = 100000次。\n\n如果没索引的情况下，两个表都做一次全表扫描，所以总的扫描行数是 M+N。内存中判断次数为M * N。如果内存join_buffer空间不够的话只能**分段**处理。所以就会出现Block Nested Loop。所以如果出现Block Nested Loop，则说明扫描行数就会过多。尤其是在大表上的 join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。\n\n\n\n## SQL优化常用规则\n1. 对于联合索引，在写SQL查询条件时要遵守最左前缀法则。从索引的最左前列开始并且不跳过索引中的列。\n\n2. 索引上尽量避免做函数计算等操作，会导致索引失效而转向全表扫描。\n\n3. 尽量使用覆盖索引。简单理解就是只访问建了索引的列，减少使用 `SELECT *` 语句查询。\n\n4. IS NOT NULL 无法使用索引。索引列建议时候NOT NULL做约束，防止使用到IS NOT NULL查询导致没有用到索引\n\n5. 模糊条件查询以通配符开头索引失效\n\n   ```sql\n   like '%xx' -- 无法用到索引\n   like '%xx%' -- 无法用到索引\n   like 'xx%' -- 可以用到索引\n   ```\n\n6. OR使用多数情况下索引会失效。例如OR前后有两个条件，第一个条件用到了索引，第二个没有用到索引。那不会走索引。\n\n   ```sql\n   SELECT * FROM TABLE KEY1 = 'XXX' OR KEY2 = 'XXX'; \n   --如果key1是索引，key2不是索引，那这个SQL不走索引。因为是OR，后面的条件是需要满足的，所以没必要在走一次聚簇索引。可以使用UNION 进行优化，这样能保证KEY1走索引。\n   ```\n\n7. 负向查询条件不能使用索引。负向查询条件包括：`!=、<>、NOT IN、NOT EXISTS、NOT LIKE` 等\n\n8. ORDER BY排序也需要遵循最左前缀列的原则，不然容易用到文件排序\n\n9. IN与EXIST的用法\n\n   1. SELECT * FROM a WHERE id IN (SELECT id from b) -  IN适用于`b表比较小，a表比较大`的情况。b表只会执行一次，A表有10000条记录,B表有100条记录,那么最多有可能遍历10000*100次,遍历次数大大减少,效率大大提升。\n   2. SELECT a.* FROM A a  WHERE EXISTS(SELECT 1 FROM B b WHERE a.id=b.id) - EXISTE适用于`b表比较大，a表比较小`的情况。\n\n## 优化器追踪\n\n```sql\n-- 查询优化器状态\nshow variables like 'optimizer_trace';\n-- 设置回话级别临时开启\nset session optimizer_trace=\"enabled=on\",end_markers_in_json=on;\n-- 设置优化器追踪内存大小\nset OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;\n-- 执行自己的SQL\n-- 查看优化器\nSELECT trace FROM information_schema.OPTIMIZER_TRACE;\n```\n\n\n\n## 图示\n\n![](mysql-explain/1.jpg)\n\n## 参考\n\n- [一本彻底搞懂MySQL索引优化EXPLAIN百科全书](https://mp.weixin.qq.com/s/rem7Ds_QSnyhlrtNPByQcg)\n\n","source":"_posts/mysql-explain.md","raw":"---\n\ntitle: MySQL索引优化EXPLAIN详解\ntags:\n  - mysql\ncategories:  mysql\ndescription : MySQL索引优化EXPLAIN\ndate: 2020-07-31 17:34:03\n---\n## 正文\n\n### EXPLAIN字段说明\n\n![示例1](mysql-explain/1.png)\n\n| **`列名`**    | **`用途`**                                             |\n| ------------- | ------------------------------------------------------ |\n| id            | 每一个SELECT关键字查询语句都对应一个唯一id             |\n| select_type   | SELECT关键字对应的查询类型                             |\n| table         | 表名                                                   |\n| partitions    | 匹配的分区信息                                         |\n| type          | 单表的访问方法                                         |\n| possible_keys | 可能用到的索引                                         |\n| key           | 实际使用到的索引                                       |\n| key_len       | 实际使用到的索引长度                                   |\n| ref           | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 |\n| rows          | 预估需要读取的记录条数                                 |\n| filtered      | 某个表经过条件过滤后剩余的记录条数百分比               |\n| Extra         | 额外的一些信息                                         |\n\n为了事情的发展，我们新建几张表方便后面讲解...\n<!--more-->\n```sql\nCREATE TABLE `s1` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `key1` varchar(100) DEFAULT NULL,\n  `key2` int(11) DEFAULT NULL,\n  `key3` varchar(100) DEFAULT NULL,\n  `key_part1` varchar(100) DEFAULT NULL,\n  `key_part2` varchar(100) DEFAULT NULL,\n  `key_part3` varchar(100) DEFAULT NULL,\n  `common_field` varchar(100) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `idx_key2` (`key2`),\n  KEY `idx_key1` (`key1`),\n  KEY `idx_key3` (`key3`),\n  KEY `idx_key_part` (`key_part1`,`key_part2`,`key_part3`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4;\n-- s2结构相同\n```\n### id列\n\n`id` 列编号是 `SELECT` 的序列号，并且 id 的顺序是按 `SELECT` 出现的顺序增长的。id列越大执行优先级越高，id 相同则从上往下执行，id 为 NULL 最后执行。\n\n<font color=red>ID越大，执行的优先级越高；ID相等，从上往下优先顺序执行。</font>\n\n例如下面，id = 2 的子查询先查询，然后再查 id = 1 的情况。\n\n![](mysql-explain/2.png)\n\n这个查询执行时有个临时表别名为 derived，外部 SELECT 查询引用了这个临时表。\n\n![derived2为物化表](mysql-explain/3.png)\n\n根据相同ID的话，从上往下顺序执行，我们可以知道此SQL选择s1作为驱动表。\n\n![ID相同的情况](mysql-explain/4.png)\n\n### select_type 列\n查询的SQL对应的类型。一般有下面几种值。\n\n| 名称               | 描述                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| SIMPLE             | 简单查询。查询不包含子查询 和 `UNION`。                      |\n| PRIMARY            | 对于包含UNION、UNION ALL或者⼦查询的⼤查询来说，它是由⼏个⼩查询组成的，其中最左边的那个查询的select_type值就是PRIMARY |\n| UNION              | 对于包含UNION或者UNION ALL的⼤查询来说，它是由⼏个⼩查询组成的，其中除了最左边的那个⼩查询以外，其余的⼩查询的select_type值就是UNION |\n| UNION RESULT       | MySQL选择使⽤临时表来完成UNION查询的去重⼯作，针对该临时表的查询的select_type就是UNION RESULT |\n| SUBQUERY           | 如果包含⼦查询的查询语句不能够转为对应的semi-join的形式，并且该⼦查询是不相关⼦查询，并且查询优化器决定采⽤将该⼦查询物化的⽅案来执⾏该⼦查询时,该⼦查询的第⼀个SELECT关键字代表的那个查询的select_type就是SUBQUERY |\n| DEPENDENT SUBQUERY | 如果包含⼦查询的查询语句不能够转为对应的semi-join的形式，并且该⼦查询是相关⼦查询，则该⼦查询的第⼀个SELECT关键字代表的那个查询的 select_type就是DEPENDENT SUBQUERY |\n| DEPENDENT UNION    | 在包含UNION或者UNION ALL的⼤查询中，如果各个⼩查询都依赖于外层查询的话，那除了最左边的那个⼩查询之外，其余的⼩查询的select_type的值就是DEPENDENT UNION |\n| DERIVED            | 对于采⽤物化的⽅式执⾏的包含派⽣表的查询，该派⽣表对应的⼦查询的select_type就是DERIVED |\n\n\n\n### table列\n\ntable 列表示 EXPLAIN 的单独行的唯一标识符。这个值可能是表名、表的别名或者一个未查询产生临时表的标识符，如派生表、子查询或集合。\n\n当 `FROM` 子句中有子查询时，如果优化器采用的物化方式，table 列是\\<derivenN>格式，表示当前查询依赖 `id=N` 的查询，于是先执行 `id=N` 的查询。\n\n### partitions 列\n\n分区的意思，这一般没怎么用到。。\n\n### type 列\n\n这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。\n依次从最优到最差分别是 : <font color=red> system > const > eq_ref > ref > range > index > ALL</font>。\n\n<font size=4 color=red>一般来说，必须保证查询在range级别及其以上是最好的</font>。\n\n#### system\n当表中只有⼀条记录并且该表使⽤的存储引擎的统计数据是精确的，⽐如MyISAM、Memory，那么对该表的访问⽅法就是system。\n\n#### const\n根据主键或者唯⼀⼆级索引列与常数进⾏等值匹配时，对单表的访问⽅法就是const。\n\n```sql\nEXPLAIN select * from s1 WHERE key2 = 256;\n```\n\n![唯一索引执行计划](mysql-explain/5.png)\n\n#### eq_ref\n在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的，则对该被驱动表的访问方法就是 eq_ref。\n\n```sql\nEXPLAIN SELECT * FROM s1 JOIN s2 on s1.id = s2.id;\n```\n![eq_ref执行计划](mysql-explain/6.png)\n\n从执⾏计划的结果中可以看出，MySQL打算将s1作为驱动表，s2作为被驱动表，重点关注s2的访问⽅法是eq_ref，表明在访问s2表的时候可以通过主键的 等值匹配来进⾏访问。\n\n#### ref\n当通过普通的⼆级索引列与常量进⾏等值匹配时来查询某个表，那么对该表的访问⽅法就可能是ref。\n```sql\nEXPLAIN select * from s1 WHERE key1 = 'rkm';\n```\n\n![ref执行计划](mysql-explain/7.png)\n\n可以看出，key1是普通二级索引，通过等值查询的结果可能有多个。所以是req。\n它与req_eq的区别在于 ： 相比 eq_ref，ref不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n\n#### ref_or_null\n对普通二级索引(<font color=red>包括普通索引和唯一索引,普通索引和唯一索引都允许有NULL值且不限制NULL的个数</font>)进行等值查询，该索引列也可以为NULL值时。\n\n```sql\nEXPLAIN select * from s1 WHERE key1 = 'rkm' or key1 is null;\n```\n\n![ref_or_null执行计划](mysql-explain/8.png)\n\n#### index_merge\nMySQL使用索引合并的方式执行的。\n所谓的索引合并值的是 ：我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。可以参考下另一篇文章《Mysql-InnoDB索引之单表使用索引详解(三)》\n\n```sql\nEXPLAIN select * from s1 WHERE key2 = 2354 or key1 = 'rkm'\n```\n\n![index_merge执行计划](mysql-explain/9.png)\n\n#### range\n使用索引获取范围区间的记录，通常出现在 in, between ,> ,<, >= 等操作中。\n```sql\nEXPLAIN SELECT * FROM s1 where key2 BETWEEN 100 and 200;\n```\n\n![range执行计划](mysql-explain/10.png)\n\n#### index\n扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而 ALL 是从硬盘中读取）。\n这种比ALL快一点，他指的是直接从B+索引树查询所有的数据。总结一句话就是扫描覆盖索引。\n```sql\nEXPLAIN\tSELECT\tkey_part2\tFROM\ts1\tWHERE\tkey_part3\t=\t'a';\n```\n\n![](mysql-explain/11.png)\n\n例如此SQL,由于key_part2和key_part3是在同一个索引树上，且获取key_part2时不需要回表。\n但是为什么会是扫描全表索引呢？ 因为key_part3不是最左匹配。\n\n#### ALL\n不说了，性能最差。\n### possible_keys 列\npossible_keys 列表示查询<font color=red>可能</font>使用哪些索引来查找。\n\n如果possible_keys 为NULL表示没有相关的索引，此时需要验证下语句情况。\n\n另外需要注意的是 ： <font color=red>不是这一列的值越多越好，使用索引过多，查询优化器计算时查询成本高，所以如果可能的话，尽量删除那些不用的索引。</font>\n\n### key 列\nkey 列表示实际采用哪个索引来优化对该表的访问。\n\n### key_len 列\nkey_len 列表示当查询优化器决定使用某一个索引查询时，该索引记录的最大长度。\n\n### ref 列\n当使⽤索引列等值匹配的条件去执⾏查询时，也就是在访问⽅法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery其中之⼀时， ref列展示的就是与索引列作等值匹配的东东是个啥，⽐如只是⼀个常数或者是某个列。\n```sql\nEXPLAIN\tSELECT\t*\tFROM\ts1\tWHERE\tkey1\t=\t'a';\n```\n\n![](mysql-explain/12.png)\n\n可以看到ref列的值是const，表明在使⽤idx_key1索引执⾏查询时，与key1列作等值匹配的对象是⼀个常数。\n### rows 列\nrows 列是查询优化器估计要读取并检测的行数，注意这个不是结果集里的行数。\n通常也可以通过这个来看查询的量，如果量大则表示SQL性能差\n\n### filtered 列\n对于单表来说意义不大，主要用于连接查询中。\n前文中也已提到 filtered 列，是一个百分比的值，对于连接查询来说，主要看驱动表的 filtered列的值 ，通过 rows * filtered/100 计算可以估算出被驱动表还需要执行的查询次数。\n\n### Extra 列\nExtra列是⽤来说明⼀些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL到底将如何执⾏给定的查询语句。\n下面说下几种比较重要的。\n####  Using index\n查询的列被索引覆盖，并且 WHERE 筛选条件是索引的前导列，使用了索引性能高。一般是使用了覆盖索引(查询列都是索引列字段)。\n可以具体观察如下两条语句的区别\n```sql\nEXPLAIN\tSELECT\tkey1\tFROM\ts1\tWHERE\tkey1\t=\t'a';\nEXPLAIN\tSELECT\t*\tFROM\ts1\tWHERE\tkey1\t=\t'a';\n```\n#### Using index condition\n指的是有些搜索条件中虽然出现了索引列，但却不能使⽤到索引。例如下面这个SQL\n```sql\nEXPLAIN\tSELECT * FROM s1 WHERE key1 > 'z' AND key1 LIKE '%a';\n```\n\n![](mysql-explain/13.png)\n\n由于这个语句只能用到第一个条件，对于第二个条件在以前是需要在回表的时候去过滤的。但是现在做了优化，对于第一个条件查出来的二级索引记录先不着急回表，⽽是先检测⼀下该记录是否满⾜key1 LIKE '%a'这个条件，如果这个条件不满⾜，则该⼆级索引记录压根⼉ 就没必要回表。这种情况称之为<font color=red>索引条件下推</font>。\n#### Using temporary\nMySQL 中需要创建一张内部临时表来处理查询，一般出现这种情况就需要考虑进行优化了，首先是想到用索引来优化。\n#### Using filesort\n使用一个外部索引排序。一般来说我们根据索引的顺序排序是最优的，而这种情况指的是没办法根据索引的顺序直接排序，所以数据被放到了内存或磁盘中排序，这种在内存中或者磁盘上进⾏排序的⽅式统称为⽂件排序。\n<font color=red>一般出现这个需要看下是否可以根据索引来排序优化。</font>\n#### Using join buffer(Block Nested Loop)\n在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。出现该值，应该注意，根据查询的具体情况可能需要添加索引来改进性能。\n\n**到底能不能使用join，使用join是否有性能问题，要使用join需要注意几个要点。?**\n\n**如果使用join，需要让小表(数据量小)的表作为驱动表，大表作为被驱动表，且前提是on条件中可以使用到大表的索引。**\n\n如果是小表作为驱动表，假设小表有100条记录，大表1000条记录。\n\n```sql\nSELECT * from 小表 left join 大表 on 小表.a = 大表.b;\n```\n\n假设大表上a字段有索引。处理逻辑如下：\n\n1. 全表扫描小表100行记录到内存join_buffer\n2. 从小表中一条一条记录的去查大表，由于大表a上有索引，每次只会扫描到1条到内存。\n3. 内存进行合并，总扫描次数为 100 + 100 = 200\n\n如果大表a字段没索引，处理逻辑如下:\n\n1. 全表扫描小表100行记录到内存join_buffer\n2. 全表扫描大表1000行记录到内存join_buffer\n3. 在内存join做合并，取小表一条记录，然后跟内存中大表记录做1000次判断，所以在内存中的判断次数是 100 * 1000 = 100000次。\n\n如果没索引的情况下，两个表都做一次全表扫描，所以总的扫描行数是 M+N。内存中判断次数为M * N。如果内存join_buffer空间不够的话只能**分段**处理。所以就会出现Block Nested Loop。所以如果出现Block Nested Loop，则说明扫描行数就会过多。尤其是在大表上的 join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。\n\n\n\n## SQL优化常用规则\n1. 对于联合索引，在写SQL查询条件时要遵守最左前缀法则。从索引的最左前列开始并且不跳过索引中的列。\n\n2. 索引上尽量避免做函数计算等操作，会导致索引失效而转向全表扫描。\n\n3. 尽量使用覆盖索引。简单理解就是只访问建了索引的列，减少使用 `SELECT *` 语句查询。\n\n4. IS NOT NULL 无法使用索引。索引列建议时候NOT NULL做约束，防止使用到IS NOT NULL查询导致没有用到索引\n\n5. 模糊条件查询以通配符开头索引失效\n\n   ```sql\n   like '%xx' -- 无法用到索引\n   like '%xx%' -- 无法用到索引\n   like 'xx%' -- 可以用到索引\n   ```\n\n6. OR使用多数情况下索引会失效。例如OR前后有两个条件，第一个条件用到了索引，第二个没有用到索引。那不会走索引。\n\n   ```sql\n   SELECT * FROM TABLE KEY1 = 'XXX' OR KEY2 = 'XXX'; \n   --如果key1是索引，key2不是索引，那这个SQL不走索引。因为是OR，后面的条件是需要满足的，所以没必要在走一次聚簇索引。可以使用UNION 进行优化，这样能保证KEY1走索引。\n   ```\n\n7. 负向查询条件不能使用索引。负向查询条件包括：`!=、<>、NOT IN、NOT EXISTS、NOT LIKE` 等\n\n8. ORDER BY排序也需要遵循最左前缀列的原则，不然容易用到文件排序\n\n9. IN与EXIST的用法\n\n   1. SELECT * FROM a WHERE id IN (SELECT id from b) -  IN适用于`b表比较小，a表比较大`的情况。b表只会执行一次，A表有10000条记录,B表有100条记录,那么最多有可能遍历10000*100次,遍历次数大大减少,效率大大提升。\n   2. SELECT a.* FROM A a  WHERE EXISTS(SELECT 1 FROM B b WHERE a.id=b.id) - EXISTE适用于`b表比较大，a表比较小`的情况。\n\n## 优化器追踪\n\n```sql\n-- 查询优化器状态\nshow variables like 'optimizer_trace';\n-- 设置回话级别临时开启\nset session optimizer_trace=\"enabled=on\",end_markers_in_json=on;\n-- 设置优化器追踪内存大小\nset OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;\n-- 执行自己的SQL\n-- 查看优化器\nSELECT trace FROM information_schema.OPTIMIZER_TRACE;\n```\n\n\n\n## 图示\n\n![](mysql-explain/1.jpg)\n\n## 参考\n\n- [一本彻底搞懂MySQL索引优化EXPLAIN百科全书](https://mp.weixin.qq.com/s/rem7Ds_QSnyhlrtNPByQcg)\n\n","slug":"mysql-explain","published":1,"updated":"2021-08-24T00:55:50.559Z","_id":"ckn9yvhvb001sqwv2fa488nq5","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"EXPLAIN字段说明\"><a href=\"#EXPLAIN字段说明\" class=\"headerlink\" title=\"EXPLAIN字段说明\"></a>EXPLAIN字段说明</h3><p><img src=\"/2020/07/31/mysql-explain/1.png\" alt=\"示例1\"></p>\n<table>\n<thead>\n<tr>\n<th><strong><code>列名</code></strong></th>\n<th><strong><code>用途</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>每一个SELECT关键字查询语句都对应一个唯一id</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>SELECT关键字对应的查询类型</td>\n</tr>\n<tr>\n<td>table</td>\n<td>表名</td>\n</tr>\n<tr>\n<td>partitions</td>\n<td>匹配的分区信息</td>\n</tr>\n<tr>\n<td>type</td>\n<td>单表的访问方法</td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td>可能用到的索引</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际使用到的索引</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>实际使用到的索引长度</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>预估需要读取的记录条数</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>某个表经过条件过滤后剩余的记录条数百分比</td>\n</tr>\n<tr>\n<td>Extra</td>\n<td>额外的一些信息</td>\n</tr>\n</tbody></table>\n<p>为了事情的发展，我们新建几张表方便后面讲解…</p>\n<a id=\"more\"></a>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>s1<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key1<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key2<span class=\"token punctuation\">`</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key3<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key_part1<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key_part2<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key_part3<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>common_field<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>idx_key2<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>key2<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>idx_key1<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>key1<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>idx_key3<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>key3<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>idx_key_part<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>key_part1<span class=\"token punctuation\">`</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">`</span>key_part2<span class=\"token punctuation\">`</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">`</span>key_part3<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token operator\">=</span><span class=\"token number\">10</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8mb4<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">-- s2结构相同</span></code></pre>\n<h3 id=\"id列\"><a href=\"#id列\" class=\"headerlink\" title=\"id列\"></a>id列</h3><p><code>id</code> 列编号是 <code>SELECT</code> 的序列号，并且 id 的顺序是按 <code>SELECT</code> 出现的顺序增长的。id列越大执行优先级越高，id 相同则从上往下执行，id 为 NULL 最后执行。</p>\n<p><font color=\"red\">ID越大，执行的优先级越高；ID相等，从上往下优先顺序执行。</font></p>\n<p>例如下面，id = 2 的子查询先查询，然后再查 id = 1 的情况。</p>\n<p><img src=\"/2020/07/31/mysql-explain/2.png\" alt></p>\n<p>这个查询执行时有个临时表别名为 derived，外部 SELECT 查询引用了这个临时表。</p>\n<p><img src=\"/2020/07/31/mysql-explain/3.png\" alt=\"derived2为物化表\"></p>\n<p>根据相同ID的话，从上往下顺序执行，我们可以知道此SQL选择s1作为驱动表。</p>\n<p><img src=\"/2020/07/31/mysql-explain/4.png\" alt=\"ID相同的情况\"></p>\n<h3 id=\"select-type-列\"><a href=\"#select-type-列\" class=\"headerlink\" title=\"select_type 列\"></a>select_type 列</h3><p>查询的SQL对应的类型。一般有下面几种值。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIMPLE</td>\n<td>简单查询。查询不包含子查询 和 <code>UNION</code>。</td>\n</tr>\n<tr>\n<td>PRIMARY</td>\n<td>对于包含UNION、UNION ALL或者⼦查询的⼤查询来说，它是由⼏个⼩查询组成的，其中最左边的那个查询的select_type值就是PRIMARY</td>\n</tr>\n<tr>\n<td>UNION</td>\n<td>对于包含UNION或者UNION ALL的⼤查询来说，它是由⼏个⼩查询组成的，其中除了最左边的那个⼩查询以外，其余的⼩查询的select_type值就是UNION</td>\n</tr>\n<tr>\n<td>UNION RESULT</td>\n<td>MySQL选择使⽤临时表来完成UNION查询的去重⼯作，针对该临时表的查询的select_type就是UNION RESULT</td>\n</tr>\n<tr>\n<td>SUBQUERY</td>\n<td>如果包含⼦查询的查询语句不能够转为对应的semi-join的形式，并且该⼦查询是不相关⼦查询，并且查询优化器决定采⽤将该⼦查询物化的⽅案来执⾏该⼦查询时,该⼦查询的第⼀个SELECT关键字代表的那个查询的select_type就是SUBQUERY</td>\n</tr>\n<tr>\n<td>DEPENDENT SUBQUERY</td>\n<td>如果包含⼦查询的查询语句不能够转为对应的semi-join的形式，并且该⼦查询是相关⼦查询，则该⼦查询的第⼀个SELECT关键字代表的那个查询的 select_type就是DEPENDENT SUBQUERY</td>\n</tr>\n<tr>\n<td>DEPENDENT UNION</td>\n<td>在包含UNION或者UNION ALL的⼤查询中，如果各个⼩查询都依赖于外层查询的话，那除了最左边的那个⼩查询之外，其余的⼩查询的select_type的值就是DEPENDENT UNION</td>\n</tr>\n<tr>\n<td>DERIVED</td>\n<td>对于采⽤物化的⽅式执⾏的包含派⽣表的查询，该派⽣表对应的⼦查询的select_type就是DERIVED</td>\n</tr>\n</tbody></table>\n<h3 id=\"table列\"><a href=\"#table列\" class=\"headerlink\" title=\"table列\"></a>table列</h3><p>table 列表示 EXPLAIN 的单独行的唯一标识符。这个值可能是表名、表的别名或者一个未查询产生临时表的标识符，如派生表、子查询或集合。</p>\n<p>当 <code>FROM</code> 子句中有子查询时，如果优化器采用的物化方式，table 列是&lt;derivenN&gt;格式，表示当前查询依赖 <code>id=N</code> 的查询，于是先执行 <code>id=N</code> 的查询。</p>\n<h3 id=\"partitions-列\"><a href=\"#partitions-列\" class=\"headerlink\" title=\"partitions 列\"></a>partitions 列</h3><p>分区的意思，这一般没怎么用到。。</p>\n<h3 id=\"type-列\"><a href=\"#type-列\" class=\"headerlink\" title=\"type 列\"></a>type 列</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别是 : <font color=\"red\"> system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</font>。</p>\n<p><font size=\"4\" color=\"red\">一般来说，必须保证查询在range级别及其以上是最好的</font>。</p>\n<h4 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system\"></a>system</h4><p>当表中只有⼀条记录并且该表使⽤的存储引擎的统计数据是精确的，⽐如MyISAM、Memory，那么对该表的访问⽅法就是system。</p>\n<h4 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h4><p>根据主键或者唯⼀⼆级索引列与常数进⾏等值匹配时，对单表的访问⽅法就是const。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> s1 <span class=\"token keyword\">WHERE</span> key2 <span class=\"token operator\">=</span> <span class=\"token number\">256</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/5.png\" alt=\"唯一索引执行计划\"></p>\n<h4 id=\"eq-ref\"><a href=\"#eq-ref\" class=\"headerlink\" title=\"eq_ref\"></a>eq_ref</h4><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的，则对该被驱动表的访问方法就是 eq_ref。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> s1 <span class=\"token keyword\">JOIN</span> s2 <span class=\"token keyword\">on</span> s1<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> s2<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/6.png\" alt=\"eq_ref执行计划\"></p>\n<p>从执⾏计划的结果中可以看出，MySQL打算将s1作为驱动表，s2作为被驱动表，重点关注s2的访问⽅法是eq_ref，表明在访问s2表的时候可以通过主键的 等值匹配来进⾏访问。</p>\n<h4 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h4><p>当通过普通的⼆级索引列与常量进⾏等值匹配时来查询某个表，那么对该表的访问⽅法就可能是ref。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> s1 <span class=\"token keyword\">WHERE</span> key1 <span class=\"token operator\">=</span> <span class=\"token string\">'rkm'</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/7.png\" alt=\"ref执行计划\"></p>\n<p>可以看出，key1是普通二级索引，通过等值查询的结果可能有多个。所以是req。<br>它与req_eq的区别在于 ： 相比 eq_ref，ref不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>\n<h4 id=\"ref-or-null\"><a href=\"#ref-or-null\" class=\"headerlink\" title=\"ref_or_null\"></a>ref_or_null</h4><p>对普通二级索引(<font color=\"red\">包括普通索引和唯一索引,普通索引和唯一索引都允许有NULL值且不限制NULL的个数</font>)进行等值查询，该索引列也可以为NULL值时。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> s1 <span class=\"token keyword\">WHERE</span> key1 <span class=\"token operator\">=</span> <span class=\"token string\">'rkm'</span> <span class=\"token operator\">or</span> key1 <span class=\"token operator\">is</span> <span class=\"token boolean\">null</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/8.png\" alt=\"ref_or_null执行计划\"></p>\n<h4 id=\"index-merge\"><a href=\"#index-merge\" class=\"headerlink\" title=\"index_merge\"></a>index_merge</h4><p>MySQL使用索引合并的方式执行的。<br>所谓的索引合并值的是 ：我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。可以参考下另一篇文章《Mysql-InnoDB索引之单表使用索引详解(三)》</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">select</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> s1 <span class=\"token keyword\">WHERE</span> key2 <span class=\"token operator\">=</span> <span class=\"token number\">2354</span> <span class=\"token operator\">or</span> key1 <span class=\"token operator\">=</span> <span class=\"token string\">'rkm'</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/9.png\" alt=\"index_merge执行计划\"></p>\n<h4 id=\"range\"><a href=\"#range\" class=\"headerlink\" title=\"range\"></a>range</h4><p>使用索引获取范围区间的记录，通常出现在 in, between ,&gt; ,&lt;, &gt;= 等操作中。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> s1 <span class=\"token keyword\">where</span> key2 <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">100</span> <span class=\"token operator\">and</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/10.png\" alt=\"range执行计划\"></p>\n<h4 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h4><p>扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而 ALL 是从硬盘中读取）。<br>这种比ALL快一点，他指的是直接从B+索引树查询所有的数据。总结一句话就是扫描覆盖索引。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>    <span class=\"token keyword\">SELECT</span>    key_part2    <span class=\"token keyword\">FROM</span>    s1    <span class=\"token keyword\">WHERE</span>    key_part3    <span class=\"token operator\">=</span>    <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/11.png\" alt></p>\n<p>例如此SQL,由于key_part2和key_part3是在同一个索引树上，且获取key_part2时不需要回表。<br>但是为什么会是扫描全表索引呢？ 因为key_part3不是最左匹配。</p>\n<h4 id=\"ALL\"><a href=\"#ALL\" class=\"headerlink\" title=\"ALL\"></a>ALL</h4><p>不说了，性能最差。</p>\n<h3 id=\"possible-keys-列\"><a href=\"#possible-keys-列\" class=\"headerlink\" title=\"possible_keys 列\"></a>possible_keys 列</h3><p>possible_keys 列表示查询<font color=\"red\">可能</font>使用哪些索引来查找。</p>\n<p>如果possible_keys 为NULL表示没有相关的索引，此时需要验证下语句情况。</p>\n<p>另外需要注意的是 ： <font color=\"red\">不是这一列的值越多越好，使用索引过多，查询优化器计算时查询成本高，所以如果可能的话，尽量删除那些不用的索引。</font></p>\n<h3 id=\"key-列\"><a href=\"#key-列\" class=\"headerlink\" title=\"key 列\"></a>key 列</h3><p>key 列表示实际采用哪个索引来优化对该表的访问。</p>\n<h3 id=\"key-len-列\"><a href=\"#key-len-列\" class=\"headerlink\" title=\"key_len 列\"></a>key_len 列</h3><p>key_len 列表示当查询优化器决定使用某一个索引查询时，该索引记录的最大长度。</p>\n<h3 id=\"ref-列\"><a href=\"#ref-列\" class=\"headerlink\" title=\"ref 列\"></a>ref 列</h3><p>当使⽤索引列等值匹配的条件去执⾏查询时，也就是在访问⽅法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery其中之⼀时， ref列展示的就是与索引列作等值匹配的东东是个啥，⽐如只是⼀个常数或者是某个列。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>    <span class=\"token keyword\">SELECT</span>    <span class=\"token operator\">*</span>    <span class=\"token keyword\">FROM</span>    s1    <span class=\"token keyword\">WHERE</span>    key1    <span class=\"token operator\">=</span>    <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/12.png\" alt></p>\n<p>可以看到ref列的值是const，表明在使⽤idx_key1索引执⾏查询时，与key1列作等值匹配的对象是⼀个常数。</p>\n<h3 id=\"rows-列\"><a href=\"#rows-列\" class=\"headerlink\" title=\"rows 列\"></a>rows 列</h3><p>rows 列是查询优化器估计要读取并检测的行数，注意这个不是结果集里的行数。<br>通常也可以通过这个来看查询的量，如果量大则表示SQL性能差</p>\n<h3 id=\"filtered-列\"><a href=\"#filtered-列\" class=\"headerlink\" title=\"filtered 列\"></a>filtered 列</h3><p>对于单表来说意义不大，主要用于连接查询中。<br>前文中也已提到 filtered 列，是一个百分比的值，对于连接查询来说，主要看驱动表的 filtered列的值 ，通过 rows * filtered/100 计算可以估算出被驱动表还需要执行的查询次数。</p>\n<h3 id=\"Extra-列\"><a href=\"#Extra-列\" class=\"headerlink\" title=\"Extra 列\"></a>Extra 列</h3><p>Extra列是⽤来说明⼀些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL到底将如何执⾏给定的查询语句。<br>下面说下几种比较重要的。</p>\n<h4 id=\"Using-index\"><a href=\"#Using-index\" class=\"headerlink\" title=\"Using index\"></a>Using index</h4><p>查询的列被索引覆盖，并且 WHERE 筛选条件是索引的前导列，使用了索引性能高。一般是使用了覆盖索引(查询列都是索引列字段)。<br>可以具体观察如下两条语句的区别</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>    <span class=\"token keyword\">SELECT</span>    key1    <span class=\"token keyword\">FROM</span>    s1    <span class=\"token keyword\">WHERE</span>    key1    <span class=\"token operator\">=</span>    <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">EXPLAIN</span>    <span class=\"token keyword\">SELECT</span>    <span class=\"token operator\">*</span>    <span class=\"token keyword\">FROM</span>    s1    <span class=\"token keyword\">WHERE</span>    key1    <span class=\"token operator\">=</span>    <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"Using-index-condition\"><a href=\"#Using-index-condition\" class=\"headerlink\" title=\"Using index condition\"></a>Using index condition</h4><p>指的是有些搜索条件中虽然出现了索引列，但却不能使⽤到索引。例如下面这个SQL</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span>    <span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> s1 <span class=\"token keyword\">WHERE</span> key1 <span class=\"token operator\">></span> <span class=\"token string\">'z'</span> <span class=\"token operator\">AND</span> key1 <span class=\"token operator\">LIKE</span> <span class=\"token string\">'%a'</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/13.png\" alt></p>\n<p>由于这个语句只能用到第一个条件，对于第二个条件在以前是需要在回表的时候去过滤的。但是现在做了优化，对于第一个条件查出来的二级索引记录先不着急回表，⽽是先检测⼀下该记录是否满⾜key1 LIKE ‘%a’这个条件，如果这个条件不满⾜，则该⼆级索引记录压根⼉ 就没必要回表。这种情况称之为<font color=\"red\">索引条件下推</font>。</p>\n<h4 id=\"Using-temporary\"><a href=\"#Using-temporary\" class=\"headerlink\" title=\"Using temporary\"></a>Using temporary</h4><p>MySQL 中需要创建一张内部临时表来处理查询，一般出现这种情况就需要考虑进行优化了，首先是想到用索引来优化。</p>\n<h4 id=\"Using-filesort\"><a href=\"#Using-filesort\" class=\"headerlink\" title=\"Using filesort\"></a>Using filesort</h4><p>使用一个外部索引排序。一般来说我们根据索引的顺序排序是最优的，而这种情况指的是没办法根据索引的顺序直接排序，所以数据被放到了内存或磁盘中排序，这种在内存中或者磁盘上进⾏排序的⽅式统称为⽂件排序。<br><font color=\"red\">一般出现这个需要看下是否可以根据索引来排序优化。</font></p>\n<h4 id=\"Using-join-buffer-Block-Nested-Loop\"><a href=\"#Using-join-buffer-Block-Nested-Loop\" class=\"headerlink\" title=\"Using join buffer(Block Nested Loop)\"></a>Using join buffer(Block Nested Loop)</h4><p>在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。出现该值，应该注意，根据查询的具体情况可能需要添加索引来改进性能。</p>\n<p><strong>到底能不能使用join，使用join是否有性能问题，要使用join需要注意几个要点。?</strong></p>\n<p><strong>如果使用join，需要让小表(数据量小)的表作为驱动表，大表作为被驱动表，且前提是on条件中可以使用到大表的索引。</strong></p>\n<p>如果是小表作为驱动表，假设小表有100条记录，大表1000条记录。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">from</span> 小表 <span class=\"token keyword\">left</span> <span class=\"token keyword\">join</span> 大表 <span class=\"token keyword\">on</span> 小表<span class=\"token punctuation\">.</span><span class=\"token number\">a</span> <span class=\"token operator\">=</span> 大表<span class=\"token punctuation\">.</span><span class=\"token number\">b</span><span class=\"token punctuation\">;</span></code></pre>\n<p>假设大表上a字段有索引。处理逻辑如下：</p>\n<ol>\n<li>全表扫描小表100行记录到内存join_buffer</li>\n<li>从小表中一条一条记录的去查大表，由于大表a上有索引，每次只会扫描到1条到内存。</li>\n<li>内存进行合并，总扫描次数为 100 + 100 = 200</li>\n</ol>\n<p>如果大表a字段没索引，处理逻辑如下:</p>\n<ol>\n<li>全表扫描小表100行记录到内存join_buffer</li>\n<li>全表扫描大表1000行记录到内存join_buffer</li>\n<li>在内存join做合并，取小表一条记录，然后跟内存中大表记录做1000次判断，所以在内存中的判断次数是 100 * 1000 = 100000次。</li>\n</ol>\n<p>如果没索引的情况下，两个表都做一次全表扫描，所以总的扫描行数是 M+N。内存中判断次数为M * N。如果内存join_buffer空间不够的话只能<strong>分段</strong>处理。所以就会出现Block Nested Loop。所以如果出现Block Nested Loop，则说明扫描行数就会过多。尤其是在大表上的 join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</p>\n<h2 id=\"SQL优化常用规则\"><a href=\"#SQL优化常用规则\" class=\"headerlink\" title=\"SQL优化常用规则\"></a>SQL优化常用规则</h2><ol>\n<li><p>对于联合索引，在写SQL查询条件时要遵守最左前缀法则。从索引的最左前列开始并且不跳过索引中的列。</p>\n</li>\n<li><p>索引上尽量避免做函数计算等操作，会导致索引失效而转向全表扫描。</p>\n</li>\n<li><p>尽量使用覆盖索引。简单理解就是只访问建了索引的列，减少使用 <code>SELECT *</code> 语句查询。</p>\n</li>\n<li><p>IS NOT NULL 无法使用索引。索引列建议时候NOT NULL做约束，防止使用到IS NOT NULL查询导致没有用到索引</p>\n</li>\n<li><p>模糊条件查询以通配符开头索引失效</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token operator\">like</span> <span class=\"token string\">'%xx'</span> <span class=\"token comment\" spellcheck=\"true\">-- 无法用到索引</span>\n<span class=\"token operator\">like</span> <span class=\"token string\">'%xx%'</span> <span class=\"token comment\" spellcheck=\"true\">-- 无法用到索引</span>\n<span class=\"token operator\">like</span> <span class=\"token string\">'xx%'</span> <span class=\"token comment\" spellcheck=\"true\">-- 可以用到索引</span></code></pre>\n</li>\n<li><p>OR使用多数情况下索引会失效。例如OR前后有两个条件，第一个条件用到了索引，第二个没有用到索引。那不会走索引。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">TABLE</span> KEY1 <span class=\"token operator\">=</span> <span class=\"token string\">'XXX'</span> <span class=\"token operator\">OR</span> KEY2 <span class=\"token operator\">=</span> <span class=\"token string\">'XXX'</span><span class=\"token punctuation\">;</span> \n<span class=\"token comment\" spellcheck=\"true\">--如果key1是索引，key2不是索引，那这个SQL不走索引。因为是OR，后面的条件是需要满足的，所以没必要在走一次聚簇索引。可以使用UNION 进行优化，这样能保证KEY1走索引。</span></code></pre>\n</li>\n<li><p>负向查询条件不能使用索引。负向查询条件包括：<code>!=、&lt;&gt;、NOT IN、NOT EXISTS、NOT LIKE</code> 等</p>\n</li>\n<li><p>ORDER BY排序也需要遵循最左前缀列的原则，不然容易用到文件排序</p>\n</li>\n<li><p>IN与EXIST的用法</p>\n<ol>\n<li>SELECT * FROM a WHERE id IN (SELECT id from b) -  IN适用于<code>b表比较小，a表比较大</code>的情况。b表只会执行一次，A表有10000条记录,B表有100条记录,那么最多有可能遍历10000*100次,遍历次数大大减少,效率大大提升。</li>\n<li>SELECT a.* FROM A a  WHERE EXISTS(SELECT 1 FROM B b WHERE a.id=b.id) - EXISTE适用于<code>b表比较大，a表比较小</code>的情况。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"优化器追踪\"><a href=\"#优化器追踪\" class=\"headerlink\" title=\"优化器追踪\"></a>优化器追踪</h2><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">-- 查询优化器状态</span>\n<span class=\"token keyword\">show</span> variables <span class=\"token operator\">like</span> <span class=\"token string\">'optimizer_trace'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">-- 设置回话级别临时开启</span>\n<span class=\"token keyword\">set</span> <span class=\"token keyword\">session</span> optimizer_trace<span class=\"token operator\">=</span><span class=\"token string\">\"enabled=on\"</span><span class=\"token punctuation\">,</span>end_markers_in_json<span class=\"token operator\">=</span><span class=\"token keyword\">on</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">-- 设置优化器追踪内存大小</span>\n<span class=\"token keyword\">set</span> OPTIMIZER_TRACE_MAX_MEM_SIZE<span class=\"token operator\">=</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">-- 执行自己的SQL</span>\n<span class=\"token comment\" spellcheck=\"true\">-- 查看优化器</span>\n<span class=\"token keyword\">SELECT</span> trace <span class=\"token keyword\">FROM</span> information_schema<span class=\"token punctuation\">.</span>OPTIMIZER_TRACE<span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h2><p><img src=\"/2020/07/31/mysql-explain/1.jpg\" alt></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/rem7Ds_QSnyhlrtNPByQcg\" target=\"_blank\" rel=\"noopener\">一本彻底搞懂MySQL索引优化EXPLAIN百科全书</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"EXPLAIN字段说明\"><a href=\"#EXPLAIN字段说明\" class=\"headerlink\" title=\"EXPLAIN字段说明\"></a>EXPLAIN字段说明</h3><p><img src=\"/2020/07/31/mysql-explain/1.png\" alt=\"示例1\"></p>\n<table>\n<thead>\n<tr>\n<th><strong><code>列名</code></strong></th>\n<th><strong><code>用途</code></strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>每一个SELECT关键字查询语句都对应一个唯一id</td>\n</tr>\n<tr>\n<td>select_type</td>\n<td>SELECT关键字对应的查询类型</td>\n</tr>\n<tr>\n<td>table</td>\n<td>表名</td>\n</tr>\n<tr>\n<td>partitions</td>\n<td>匹配的分区信息</td>\n</tr>\n<tr>\n<td>type</td>\n<td>单表的访问方法</td>\n</tr>\n<tr>\n<td>possible_keys</td>\n<td>可能用到的索引</td>\n</tr>\n<tr>\n<td>key</td>\n<td>实际使用到的索引</td>\n</tr>\n<tr>\n<td>key_len</td>\n<td>实际使用到的索引长度</td>\n</tr>\n<tr>\n<td>ref</td>\n<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>\n</tr>\n<tr>\n<td>rows</td>\n<td>预估需要读取的记录条数</td>\n</tr>\n<tr>\n<td>filtered</td>\n<td>某个表经过条件过滤后剩余的记录条数百分比</td>\n</tr>\n<tr>\n<td>Extra</td>\n<td>额外的一些信息</td>\n</tr>\n</tbody></table>\n<p>为了事情的发展，我们新建几张表方便后面讲解…</p>","more":"<pre><code class=\"sql\">CREATE TABLE `s1` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `key1` varchar(100) DEFAULT NULL,\n  `key2` int(11) DEFAULT NULL,\n  `key3` varchar(100) DEFAULT NULL,\n  `key_part1` varchar(100) DEFAULT NULL,\n  `key_part2` varchar(100) DEFAULT NULL,\n  `key_part3` varchar(100) DEFAULT NULL,\n  `common_field` varchar(100) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `idx_key2` (`key2`),\n  KEY `idx_key1` (`key1`),\n  KEY `idx_key3` (`key3`),\n  KEY `idx_key_part` (`key_part1`,`key_part2`,`key_part3`)\n) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8mb4;\n-- s2结构相同</code></pre>\n<h3 id=\"id列\"><a href=\"#id列\" class=\"headerlink\" title=\"id列\"></a>id列</h3><p><code>id</code> 列编号是 <code>SELECT</code> 的序列号，并且 id 的顺序是按 <code>SELECT</code> 出现的顺序增长的。id列越大执行优先级越高，id 相同则从上往下执行，id 为 NULL 最后执行。</p>\n<p><font color=\"red\">ID越大，执行的优先级越高；ID相等，从上往下优先顺序执行。</font></p>\n<p>例如下面，id = 2 的子查询先查询，然后再查 id = 1 的情况。</p>\n<p><img src=\"/2020/07/31/mysql-explain/2.png\" alt></p>\n<p>这个查询执行时有个临时表别名为 derived，外部 SELECT 查询引用了这个临时表。</p>\n<p><img src=\"/2020/07/31/mysql-explain/3.png\" alt=\"derived2为物化表\"></p>\n<p>根据相同ID的话，从上往下顺序执行，我们可以知道此SQL选择s1作为驱动表。</p>\n<p><img src=\"/2020/07/31/mysql-explain/4.png\" alt=\"ID相同的情况\"></p>\n<h3 id=\"select-type-列\"><a href=\"#select-type-列\" class=\"headerlink\" title=\"select_type 列\"></a>select_type 列</h3><p>查询的SQL对应的类型。一般有下面几种值。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIMPLE</td>\n<td>简单查询。查询不包含子查询 和 <code>UNION</code>。</td>\n</tr>\n<tr>\n<td>PRIMARY</td>\n<td>对于包含UNION、UNION ALL或者⼦查询的⼤查询来说，它是由⼏个⼩查询组成的，其中最左边的那个查询的select_type值就是PRIMARY</td>\n</tr>\n<tr>\n<td>UNION</td>\n<td>对于包含UNION或者UNION ALL的⼤查询来说，它是由⼏个⼩查询组成的，其中除了最左边的那个⼩查询以外，其余的⼩查询的select_type值就是UNION</td>\n</tr>\n<tr>\n<td>UNION RESULT</td>\n<td>MySQL选择使⽤临时表来完成UNION查询的去重⼯作，针对该临时表的查询的select_type就是UNION RESULT</td>\n</tr>\n<tr>\n<td>SUBQUERY</td>\n<td>如果包含⼦查询的查询语句不能够转为对应的semi-join的形式，并且该⼦查询是不相关⼦查询，并且查询优化器决定采⽤将该⼦查询物化的⽅案来执⾏该⼦查询时,该⼦查询的第⼀个SELECT关键字代表的那个查询的select_type就是SUBQUERY</td>\n</tr>\n<tr>\n<td>DEPENDENT SUBQUERY</td>\n<td>如果包含⼦查询的查询语句不能够转为对应的semi-join的形式，并且该⼦查询是相关⼦查询，则该⼦查询的第⼀个SELECT关键字代表的那个查询的 select_type就是DEPENDENT SUBQUERY</td>\n</tr>\n<tr>\n<td>DEPENDENT UNION</td>\n<td>在包含UNION或者UNION ALL的⼤查询中，如果各个⼩查询都依赖于外层查询的话，那除了最左边的那个⼩查询之外，其余的⼩查询的select_type的值就是DEPENDENT UNION</td>\n</tr>\n<tr>\n<td>DERIVED</td>\n<td>对于采⽤物化的⽅式执⾏的包含派⽣表的查询，该派⽣表对应的⼦查询的select_type就是DERIVED</td>\n</tr>\n</tbody></table>\n<h3 id=\"table列\"><a href=\"#table列\" class=\"headerlink\" title=\"table列\"></a>table列</h3><p>table 列表示 EXPLAIN 的单独行的唯一标识符。这个值可能是表名、表的别名或者一个未查询产生临时表的标识符，如派生表、子查询或集合。</p>\n<p>当 <code>FROM</code> 子句中有子查询时，如果优化器采用的物化方式，table 列是&lt;derivenN&gt;格式，表示当前查询依赖 <code>id=N</code> 的查询，于是先执行 <code>id=N</code> 的查询。</p>\n<h3 id=\"partitions-列\"><a href=\"#partitions-列\" class=\"headerlink\" title=\"partitions 列\"></a>partitions 列</h3><p>分区的意思，这一般没怎么用到。。</p>\n<h3 id=\"type-列\"><a href=\"#type-列\" class=\"headerlink\" title=\"type 列\"></a>type 列</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。<br>依次从最优到最差分别是 : <font color=\"red\"> system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</font>。</p>\n<p><font size=\"4\" color=\"red\">一般来说，必须保证查询在range级别及其以上是最好的</font>。</p>\n<h4 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system\"></a>system</h4><p>当表中只有⼀条记录并且该表使⽤的存储引擎的统计数据是精确的，⽐如MyISAM、Memory，那么对该表的访问⽅法就是system。</p>\n<h4 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h4><p>根据主键或者唯⼀⼆级索引列与常数进⾏等值匹配时，对单表的访问⽅法就是const。</p>\n<pre><code class=\"sql\">EXPLAIN select * from s1 WHERE key2 = 256;</code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/5.png\" alt=\"唯一索引执行计划\"></p>\n<h4 id=\"eq-ref\"><a href=\"#eq-ref\" class=\"headerlink\" title=\"eq_ref\"></a>eq_ref</h4><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的，则对该被驱动表的访问方法就是 eq_ref。</p>\n<pre><code class=\"sql\">EXPLAIN SELECT * FROM s1 JOIN s2 on s1.id = s2.id;</code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/6.png\" alt=\"eq_ref执行计划\"></p>\n<p>从执⾏计划的结果中可以看出，MySQL打算将s1作为驱动表，s2作为被驱动表，重点关注s2的访问⽅法是eq_ref，表明在访问s2表的时候可以通过主键的 等值匹配来进⾏访问。</p>\n<h4 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h4><p>当通过普通的⼆级索引列与常量进⾏等值匹配时来查询某个表，那么对该表的访问⽅法就可能是ref。</p>\n<pre><code class=\"sql\">EXPLAIN select * from s1 WHERE key1 = &#39;rkm&#39;;</code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/7.png\" alt=\"ref执行计划\"></p>\n<p>可以看出，key1是普通二级索引，通过等值查询的结果可能有多个。所以是req。<br>它与req_eq的区别在于 ： 相比 eq_ref，ref不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>\n<h4 id=\"ref-or-null\"><a href=\"#ref-or-null\" class=\"headerlink\" title=\"ref_or_null\"></a>ref_or_null</h4><p>对普通二级索引(<font color=\"red\">包括普通索引和唯一索引,普通索引和唯一索引都允许有NULL值且不限制NULL的个数</font>)进行等值查询，该索引列也可以为NULL值时。</p>\n<pre><code class=\"sql\">EXPLAIN select * from s1 WHERE key1 = &#39;rkm&#39; or key1 is null;</code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/8.png\" alt=\"ref_or_null执行计划\"></p>\n<h4 id=\"index-merge\"><a href=\"#index-merge\" class=\"headerlink\" title=\"index_merge\"></a>index_merge</h4><p>MySQL使用索引合并的方式执行的。<br>所谓的索引合并值的是 ：我们的 where 中可能有多个条件(或者join)涉及到多个字段，它们之间进行 AND 或者 OR，那么此时就有可能会使用到 index merge 技术。index merge 技术如果简单的说，其实就是：对多个索引分别进行条件扫描，然后将它们各自的结果进行合并(intersect/union)。可以参考下另一篇文章《Mysql-InnoDB索引之单表使用索引详解(三)》</p>\n<pre><code class=\"sql\">EXPLAIN select * from s1 WHERE key2 = 2354 or key1 = &#39;rkm&#39;</code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/9.png\" alt=\"index_merge执行计划\"></p>\n<h4 id=\"range\"><a href=\"#range\" class=\"headerlink\" title=\"range\"></a>range</h4><p>使用索引获取范围区间的记录，通常出现在 in, between ,&gt; ,&lt;, &gt;= 等操作中。</p>\n<pre><code class=\"sql\">EXPLAIN SELECT * FROM s1 where key2 BETWEEN 100 and 200;</code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/10.png\" alt=\"range执行计划\"></p>\n<h4 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h4><p>扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而 ALL 是从硬盘中读取）。<br>这种比ALL快一点，他指的是直接从B+索引树查询所有的数据。总结一句话就是扫描覆盖索引。</p>\n<pre><code class=\"sql\">EXPLAIN    SELECT    key_part2    FROM    s1    WHERE    key_part3    =    &#39;a&#39;;</code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/11.png\" alt></p>\n<p>例如此SQL,由于key_part2和key_part3是在同一个索引树上，且获取key_part2时不需要回表。<br>但是为什么会是扫描全表索引呢？ 因为key_part3不是最左匹配。</p>\n<h4 id=\"ALL\"><a href=\"#ALL\" class=\"headerlink\" title=\"ALL\"></a>ALL</h4><p>不说了，性能最差。</p>\n<h3 id=\"possible-keys-列\"><a href=\"#possible-keys-列\" class=\"headerlink\" title=\"possible_keys 列\"></a>possible_keys 列</h3><p>possible_keys 列表示查询<font color=\"red\">可能</font>使用哪些索引来查找。</p>\n<p>如果possible_keys 为NULL表示没有相关的索引，此时需要验证下语句情况。</p>\n<p>另外需要注意的是 ： <font color=\"red\">不是这一列的值越多越好，使用索引过多，查询优化器计算时查询成本高，所以如果可能的话，尽量删除那些不用的索引。</font></p>\n<h3 id=\"key-列\"><a href=\"#key-列\" class=\"headerlink\" title=\"key 列\"></a>key 列</h3><p>key 列表示实际采用哪个索引来优化对该表的访问。</p>\n<h3 id=\"key-len-列\"><a href=\"#key-len-列\" class=\"headerlink\" title=\"key_len 列\"></a>key_len 列</h3><p>key_len 列表示当查询优化器决定使用某一个索引查询时，该索引记录的最大长度。</p>\n<h3 id=\"ref-列\"><a href=\"#ref-列\" class=\"headerlink\" title=\"ref 列\"></a>ref 列</h3><p>当使⽤索引列等值匹配的条件去执⾏查询时，也就是在访问⽅法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery其中之⼀时， ref列展示的就是与索引列作等值匹配的东东是个啥，⽐如只是⼀个常数或者是某个列。</p>\n<pre><code class=\"sql\">EXPLAIN    SELECT    *    FROM    s1    WHERE    key1    =    &#39;a&#39;;</code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/12.png\" alt></p>\n<p>可以看到ref列的值是const，表明在使⽤idx_key1索引执⾏查询时，与key1列作等值匹配的对象是⼀个常数。</p>\n<h3 id=\"rows-列\"><a href=\"#rows-列\" class=\"headerlink\" title=\"rows 列\"></a>rows 列</h3><p>rows 列是查询优化器估计要读取并检测的行数，注意这个不是结果集里的行数。<br>通常也可以通过这个来看查询的量，如果量大则表示SQL性能差</p>\n<h3 id=\"filtered-列\"><a href=\"#filtered-列\" class=\"headerlink\" title=\"filtered 列\"></a>filtered 列</h3><p>对于单表来说意义不大，主要用于连接查询中。<br>前文中也已提到 filtered 列，是一个百分比的值，对于连接查询来说，主要看驱动表的 filtered列的值 ，通过 rows * filtered/100 计算可以估算出被驱动表还需要执行的查询次数。</p>\n<h3 id=\"Extra-列\"><a href=\"#Extra-列\" class=\"headerlink\" title=\"Extra 列\"></a>Extra 列</h3><p>Extra列是⽤来说明⼀些额外信息的，我们可以通过这些额外信息来更准确的理解MySQL到底将如何执⾏给定的查询语句。<br>下面说下几种比较重要的。</p>\n<h4 id=\"Using-index\"><a href=\"#Using-index\" class=\"headerlink\" title=\"Using index\"></a>Using index</h4><p>查询的列被索引覆盖，并且 WHERE 筛选条件是索引的前导列，使用了索引性能高。一般是使用了覆盖索引(查询列都是索引列字段)。<br>可以具体观察如下两条语句的区别</p>\n<pre><code class=\"sql\">EXPLAIN    SELECT    key1    FROM    s1    WHERE    key1    =    &#39;a&#39;;\nEXPLAIN    SELECT    *    FROM    s1    WHERE    key1    =    &#39;a&#39;;</code></pre>\n<h4 id=\"Using-index-condition\"><a href=\"#Using-index-condition\" class=\"headerlink\" title=\"Using index condition\"></a>Using index condition</h4><p>指的是有些搜索条件中虽然出现了索引列，但却不能使⽤到索引。例如下面这个SQL</p>\n<pre><code class=\"sql\">EXPLAIN    SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key1 LIKE &#39;%a&#39;;</code></pre>\n<p><img src=\"/2020/07/31/mysql-explain/13.png\" alt></p>\n<p>由于这个语句只能用到第一个条件，对于第二个条件在以前是需要在回表的时候去过滤的。但是现在做了优化，对于第一个条件查出来的二级索引记录先不着急回表，⽽是先检测⼀下该记录是否满⾜key1 LIKE ‘%a’这个条件，如果这个条件不满⾜，则该⼆级索引记录压根⼉ 就没必要回表。这种情况称之为<font color=\"red\">索引条件下推</font>。</p>\n<h4 id=\"Using-temporary\"><a href=\"#Using-temporary\" class=\"headerlink\" title=\"Using temporary\"></a>Using temporary</h4><p>MySQL 中需要创建一张内部临时表来处理查询，一般出现这种情况就需要考虑进行优化了，首先是想到用索引来优化。</p>\n<h4 id=\"Using-filesort\"><a href=\"#Using-filesort\" class=\"headerlink\" title=\"Using filesort\"></a>Using filesort</h4><p>使用一个外部索引排序。一般来说我们根据索引的顺序排序是最优的，而这种情况指的是没办法根据索引的顺序直接排序，所以数据被放到了内存或磁盘中排序，这种在内存中或者磁盘上进⾏排序的⽅式统称为⽂件排序。<br><font color=\"red\">一般出现这个需要看下是否可以根据索引来排序优化。</font></p>\n<h4 id=\"Using-join-buffer-Block-Nested-Loop\"><a href=\"#Using-join-buffer-Block-Nested-Loop\" class=\"headerlink\" title=\"Using join buffer(Block Nested Loop)\"></a>Using join buffer(Block Nested Loop)</h4><p>在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。出现该值，应该注意，根据查询的具体情况可能需要添加索引来改进性能。</p>\n<p><strong>到底能不能使用join，使用join是否有性能问题，要使用join需要注意几个要点。?</strong></p>\n<p><strong>如果使用join，需要让小表(数据量小)的表作为驱动表，大表作为被驱动表，且前提是on条件中可以使用到大表的索引。</strong></p>\n<p>如果是小表作为驱动表，假设小表有100条记录，大表1000条记录。</p>\n<pre><code class=\"sql\">SELECT * from 小表 left join 大表 on 小表.a = 大表.b;</code></pre>\n<p>假设大表上a字段有索引。处理逻辑如下：</p>\n<ol>\n<li>全表扫描小表100行记录到内存join_buffer</li>\n<li>从小表中一条一条记录的去查大表，由于大表a上有索引，每次只会扫描到1条到内存。</li>\n<li>内存进行合并，总扫描次数为 100 + 100 = 200</li>\n</ol>\n<p>如果大表a字段没索引，处理逻辑如下:</p>\n<ol>\n<li>全表扫描小表100行记录到内存join_buffer</li>\n<li>全表扫描大表1000行记录到内存join_buffer</li>\n<li>在内存join做合并，取小表一条记录，然后跟内存中大表记录做1000次判断，所以在内存中的判断次数是 100 * 1000 = 100000次。</li>\n</ol>\n<p>如果没索引的情况下，两个表都做一次全表扫描，所以总的扫描行数是 M+N。内存中判断次数为M * N。如果内存join_buffer空间不够的话只能<strong>分段</strong>处理。所以就会出现Block Nested Loop。所以如果出现Block Nested Loop，则说明扫描行数就会过多。尤其是在大表上的 join操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。</p>\n<h2 id=\"SQL优化常用规则\"><a href=\"#SQL优化常用规则\" class=\"headerlink\" title=\"SQL优化常用规则\"></a>SQL优化常用规则</h2><ol>\n<li><p>对于联合索引，在写SQL查询条件时要遵守最左前缀法则。从索引的最左前列开始并且不跳过索引中的列。</p>\n</li>\n<li><p>索引上尽量避免做函数计算等操作，会导致索引失效而转向全表扫描。</p>\n</li>\n<li><p>尽量使用覆盖索引。简单理解就是只访问建了索引的列，减少使用 <code>SELECT *</code> 语句查询。</p>\n</li>\n<li><p>IS NOT NULL 无法使用索引。索引列建议时候NOT NULL做约束，防止使用到IS NOT NULL查询导致没有用到索引</p>\n</li>\n<li><p>模糊条件查询以通配符开头索引失效</p>\n<pre><code class=\"sql\">like &#39;%xx&#39; -- 无法用到索引\nlike &#39;%xx%&#39; -- 无法用到索引\nlike &#39;xx%&#39; -- 可以用到索引</code></pre>\n</li>\n<li><p>OR使用多数情况下索引会失效。例如OR前后有两个条件，第一个条件用到了索引，第二个没有用到索引。那不会走索引。</p>\n<pre><code class=\"sql\">SELECT * FROM TABLE KEY1 = &#39;XXX&#39; OR KEY2 = &#39;XXX&#39;; \n--如果key1是索引，key2不是索引，那这个SQL不走索引。因为是OR，后面的条件是需要满足的，所以没必要在走一次聚簇索引。可以使用UNION 进行优化，这样能保证KEY1走索引。</code></pre>\n</li>\n<li><p>负向查询条件不能使用索引。负向查询条件包括：<code>!=、&lt;&gt;、NOT IN、NOT EXISTS、NOT LIKE</code> 等</p>\n</li>\n<li><p>ORDER BY排序也需要遵循最左前缀列的原则，不然容易用到文件排序</p>\n</li>\n<li><p>IN与EXIST的用法</p>\n<ol>\n<li>SELECT * FROM a WHERE id IN (SELECT id from b) -  IN适用于<code>b表比较小，a表比较大</code>的情况。b表只会执行一次，A表有10000条记录,B表有100条记录,那么最多有可能遍历10000*100次,遍历次数大大减少,效率大大提升。</li>\n<li>SELECT a.* FROM A a  WHERE EXISTS(SELECT 1 FROM B b WHERE a.id=b.id) - EXISTE适用于<code>b表比较大，a表比较小</code>的情况。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"优化器追踪\"><a href=\"#优化器追踪\" class=\"headerlink\" title=\"优化器追踪\"></a>优化器追踪</h2><pre><code class=\"sql\">-- 查询优化器状态\nshow variables like &#39;optimizer_trace&#39;;\n-- 设置回话级别临时开启\nset session optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;\n-- 设置优化器追踪内存大小\nset OPTIMIZER_TRACE_MAX_MEM_SIZE=1000000;\n-- 执行自己的SQL\n-- 查看优化器\nSELECT trace FROM information_schema.OPTIMIZER_TRACE;</code></pre>\n<h2 id=\"图示\"><a href=\"#图示\" class=\"headerlink\" title=\"图示\"></a>图示</h2><p><img src=\"/2020/07/31/mysql-explain/1.jpg\" alt></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/rem7Ds_QSnyhlrtNPByQcg\" target=\"_blank\" rel=\"noopener\">一本彻底搞懂MySQL索引优化EXPLAIN百科全书</a></li>\n</ul>"},{"title":"MySQL中InnoDB锁，死锁详解","description":"MySQL中InnoDB锁，死锁详解","date":"2020-11-11T09:56:53.000Z","_content":"\n### 为什么有锁\n\nMysql锁主要是为了解决多事务并发带来的问题。多事务并发分成以下三种情况：\n\n- 读读，两个事务都只有读操作，不加锁。\n- 写写，多个未提交事务在对同一个记录做修改操作时，需要让操作排队，这就是用锁实现的。\n- 读写，Innodb中读操作利用多版本控制并发（MVCC），写操作使用锁来控制。\n\nInnoDB锁官方文档地址 ：[InnoDB Locking Doc](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-shared-exclusive-locks)。锁作为MySQL一个很重要的知识点，虽然有隐式加锁解锁的存在开发人员很少涉及到，但了解锁对开发尤为重要，不然遇到死锁问题都不知道哪里出现问题了。\n### 锁类型与上锁方式\n\n在MySQL中，锁按照类型划分可以分成 ：表锁，行锁（本文重点），页锁。\n\n在MySQL中，锁按照种类可以划分成：共享锁（S）和排他锁（X）。\n\n![](mysql-lock/2.png)\n\n<!--more-->\n\n这里说一下上面的意向共享锁和意向排他锁。其实这两个应该算是表级锁。为啥会有这两个东西呢？为了<font color=red>**为了允许行锁和表锁共存，实现多粒度锁机制**</font>。引用MySQL官方文档对意向锁的解释\"Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table.\"。翻译过来大概是：意向锁是表级锁，指示事务稍后需要为表中的行使用哪种类型的锁（共享或独占）。举个列子，假设一张表的某些行已经被人加了X锁，现在另一个事务需要对这张表加X锁，此时需要判断这个表上的记录是否有一些被人加过X锁了，如果加过了就不允许加表X锁了，如果没有意向锁的话需要逐行遍历判断是否加过行X锁。所以，\n\n- 在事务可以获取表中某一行的共享锁之前，它必须首先获取表上的IS锁。\n- 在事务可以获得表中一行的排他锁之前，它必须首先获得表上的IX锁。\n\n**意向锁是MySQL自动帮我们加的，我们不需要操心，只需要了解下就行。**\n\n### 行锁\n\n下面介绍行锁的几个种类：Record Locks（记录锁），Gap Locks（间隙锁），Next-Key Locks（记录锁+间隙锁组合），Insert Intention Locks（插入意向锁）。\n\n先创建一个表，用来下面分析\n\n```sql\nCREATE TABLE HERO(\nid INT, \nname VARCAHR(100),\nPRIMARY KEY(id),\nKEY `INDEX_NAME` (`name`) USING BIREE\n) Engine=InnoDB CHARSET=utf8;\n```\n\n\n\n#### Record Locks（记录锁）\n\n单条索引记录上加锁，有S锁和X锁之分。**record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁**，但原理上和表锁应该是完全不同的。\n\n- 当⼀个事务获取了⼀条记录的S记录锁后，其他事务也可以继续获取该记录的S记录锁，但不可以继续获取X记录锁。\n\n- 当⼀个事务获取了⼀条记录的X记录锁后，其他事务既不可以继续获取该记录的S记录锁 ，也不可以继续获取X型正经记录锁 。\n\n![Record Locks加锁](mysql-lock/3.png)\n\n#### Gap Locks（间隙锁）\n\n这种锁作用在索引记录之间。他是为<font color=red>防止其他事务插入间隙（包括防止insert方式插入新数据到间隙，以及update方式将其他行变更到此间隙）</font>。Gap锁可以有效的防止”幻读“（因为这些间隙都被上了锁，其他事务不可能再插入数据到这些间隙中，于是当前事务在连续进行”当前读“时，每次读到的都是相同的记录）。Gap锁<font color=red>只作用在隔离级别为RR（不可重复读）的数据库</font>上，但是不意味着隔离等级为RC（已提交读）级别的不会使用，<font color=red>在RC级别，在进行外键约束检测和唯一键约束检测的时候，会使用到Gap锁</font>。\n\n![Gap Locks](mysql-lock/4.png)\n\n**什么情况下会加Gap锁？**\n\n- RR隔离级别下，Gap锁会用在非唯一索引或者不走索引的当前读中，也就是说除了唯一索引的唯一搜索外，都会获取gap锁或next-key锁。[初步理解MySQL的gap锁](https://www.cnblogs.com/crazylqy/p/7821481.html?spm=a2c6h.12873639.0.0.47a21bf4qroWrl)\n- RC隔离级别，在进行外键约束检测和唯一键约束检测的时候，会使用到Gap锁。[RC隔离级别下的间隙锁案例](https://cloud.tencent.com/developer/article/1678599)\n\n举例说明，例如还是上面那个图，ID是主键索引，name是普通索引。\n\n```SQL\n-- 精确查询主键索引，只加X锁，不加Gap锁\nUPDATE `HERO` SET name = 'xxx' WHERE ID = '3';\n-- 会在5，7，,9上加X锁。在(3,5),(5,7),(7,9),(9,+∞)上加Gap锁\nUPDATE `HERO` SET name = 'xxx' WHERE ID > '3';\n-- 没命中，在(1,3)加Gap锁。\nUPDATE `HERO` SET name = 'xxx' WHERE ID = '2';\n```\n\n#### NextKey Locks\n\n本质上就是Gap锁和Record锁的结合，锁住索引外还要锁住索引的间隙。再具体一些就是，一个record锁，加上，位于此索引记录前的第一个间隙处的间隙锁。举个简单的例子就是，如果现在有一个索引包含三个值1，3，5，则next-key lock锁，可能锁住的范围就有(-∞,1],(1,3],(3,5],(5,+∞]。<font color=red>同样在next-key lock一般作用在RR隔离等级的数据库，但是当出现在insert时候，检测到唯一键冲突的时候，会在冲突所在唯一索引出和之前的间隙处加Next-key lock</font>。\n\n#### Insert Intention Locks\n\n这个锁是在数据插入之前会加此锁。它是一种轻量的Gap锁，同时也是意向排他锁的一种。它的存在使得多个事务在写入不同数据到统一索引间隙的时候，不会发生锁等待（<font color=red>例如一个间隙已经加了Gap锁了，事务B，C同时往这个间隙加Insert Intention Lock是不会互相阻塞的，但是Gap跟Insert Intention Locks会阻塞，必须等到Gap释放后才能加Insert Intention Locks</font>）。另外由于它是一种意向插入锁，所以当排他锁已经处于间隙上的时候，根据锁的兼容矩阵，可以知道，***意向插入锁必须等待此间隙上的排它锁释放，才能获取。***\n\n### 死锁案例分析\n\n#### 背景分析\n\n我们数据库中发生死锁的表是具有”**<font color=red>多列组合构建的主键索引</font>**“，且数据库的隔离级别多RC。由于业务原因，经常会出现对同一行数据进行字段的反复修改的场景。为了简化代码我们使用了insert on duplicate key update语句来解决，这个语句的意思是首先先执行插入，如果检测到唯一键冲突时，仅更新特定（非索引）字段。为了优化入库的效率，我们将原来执行insert on duplicate key update语句进行切分采用多事务的方式，结果发生了”Deadlock found when trying to get lock“死锁问题。\n\n```sql\n--- 表结构----\nCREATE TABLE `flow_data` (\n  `time` varchar(8) NOT NULL DEFAULT '',\n  `domain` varchar(256) NOT NULL DEFAULT '',\n  `v1` bigint(20) DEFAULT '0',\n  `v2` bigint(20) DEFAULT '0',\n  `v3` bigint(20) DEFAULT '0',\n  `v4` bigint(20) DEFAULT '0',\n  PRIMARY KEY (`time`,`domain`),\n  KEY `index_domain` (`domain`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n--- 对应死锁的语句----\nINSERT INTO flow_data (time, domain, v1, v2, v3, v4) VALUES\n  ('20201111','a.com',26420278,27235006,26189728,29158467),\n  ('20201111','b.com',26420278,27235006,26189728,29158467),\n  ('20201111','c.com',26420278,27235006,26189728,29158467) \nON DUPLICATE KEY UPDATE \n  v1=VALUES(v1),v2 =VALUES(v2),v3=VALUES(v3),v4 =VALUES(v4);\n```\n\n![](mysql-lock/6.png)\n\n#### 问题现象\n\n![](mysql-lock/7.png)\n\n我们分析下死锁信息，\n\n事务1正在等待别的事务的锁释放，这个锁是”lock_mode X locks gap before rec insert intention waiting“，直接翻译过来就是<font color=red>插入意向锁在等待排他gap锁的释放</font>。\n\n事务2目前持有一个X锁，并且也在等别的事务的锁的释放，”lock_mode X locks gap before rec insert intention waiting\"。\n\n#### 问题分析\n\n上面的死锁问题刚开始很疑惑，主要有几点\n\n- 为什么在RC隔离级别下会用了Gap锁？\n- insert on duplicate key update语句是否在内部有导致了什么检查才会加锁？\n\n带着疑问，重新好好的复习了一下MySQL的锁知识和官方文档，也全网找了相关的问题。得出一下几个要点。\n\n- insert on duplicate key update 语句在内部会<font color=red>检测是否发生唯一键的冲突</font>，这个不难理解，例如原来有个domian=a.com，如果原来表里面没有a.com，那就INSERT；如果已经有了这个domain（为啥能知道有了这个domain，因为唯一键冲突），就UPDATE。\n- 在RC级别，在<font color=red>进行外键约束检测和唯一键约束检测</font>的时候，会使用到Gap锁。\n- 同样在next-key lock一般作用在RR隔离等级的数据库，但是当出现在insert时候，<font color=red>检测到唯一键冲突</font>的时候，会在冲突所在唯一索引出和之前的间隙处加Next-key lock。\n- <font color=red>意向插入锁必须等待此间隙上的排它锁释放，才能获取</font>。\n\n所以得出死锁结论：<font color=red>本质上就是两个事务同时获取到了不同间隙的X Next-key锁，而这个两个事务又同时想要向对方已经获取了next-key锁的间隙内插入新的数据，于是乎死锁出现了</font>。\n\n![](mysql-lock/8.png)\n\n#### 解决方法\n\n查找了网上的几种解决方法，包括如下：\n\n- 不用insert on duplicate key update语句，但是业务需要，这个不能换，最终这个没有采纳。\n- 笔者用的Mysql5.7,网上说Mysql5.6不会有这个问题，但是降级数据库是大隐患，也不采纳。\n- insert on duplicate key update语句每次的批次少点，减少发生死锁的概率。这个确实可以，但是治标不治本。\n- 死锁后重试。\n\n最终笔者采用的是对domain先进行排序后再分批次 + 死锁后重试，用了这个方法后就没再出现过死锁。\n\n这里为啥排序后可以解决，因为导致这个问题的原因是每个事务的doamin都是乱序的，那么多事务执行就容易出现上面的问题。InnoDB的索引是按照规则进行排序的，那么将所有domian排序后再分批次，那么就不会出现。且为了保险也做了死锁重试来兜底。","source":"_posts/mysql-lock.md","raw":"---\ntitle: MySQL中InnoDB锁，死锁详解\ntags:\n  - mysql\ncategories:  mysql\ndescription : MySQL中InnoDB锁，死锁详解\ndate: 2020-11-11 17:56:53\n---\n\n### 为什么有锁\n\nMysql锁主要是为了解决多事务并发带来的问题。多事务并发分成以下三种情况：\n\n- 读读，两个事务都只有读操作，不加锁。\n- 写写，多个未提交事务在对同一个记录做修改操作时，需要让操作排队，这就是用锁实现的。\n- 读写，Innodb中读操作利用多版本控制并发（MVCC），写操作使用锁来控制。\n\nInnoDB锁官方文档地址 ：[InnoDB Locking Doc](https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-shared-exclusive-locks)。锁作为MySQL一个很重要的知识点，虽然有隐式加锁解锁的存在开发人员很少涉及到，但了解锁对开发尤为重要，不然遇到死锁问题都不知道哪里出现问题了。\n### 锁类型与上锁方式\n\n在MySQL中，锁按照类型划分可以分成 ：表锁，行锁（本文重点），页锁。\n\n在MySQL中，锁按照种类可以划分成：共享锁（S）和排他锁（X）。\n\n![](mysql-lock/2.png)\n\n<!--more-->\n\n这里说一下上面的意向共享锁和意向排他锁。其实这两个应该算是表级锁。为啥会有这两个东西呢？为了<font color=red>**为了允许行锁和表锁共存，实现多粒度锁机制**</font>。引用MySQL官方文档对意向锁的解释\"Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table.\"。翻译过来大概是：意向锁是表级锁，指示事务稍后需要为表中的行使用哪种类型的锁（共享或独占）。举个列子，假设一张表的某些行已经被人加了X锁，现在另一个事务需要对这张表加X锁，此时需要判断这个表上的记录是否有一些被人加过X锁了，如果加过了就不允许加表X锁了，如果没有意向锁的话需要逐行遍历判断是否加过行X锁。所以，\n\n- 在事务可以获取表中某一行的共享锁之前，它必须首先获取表上的IS锁。\n- 在事务可以获得表中一行的排他锁之前，它必须首先获得表上的IX锁。\n\n**意向锁是MySQL自动帮我们加的，我们不需要操心，只需要了解下就行。**\n\n### 行锁\n\n下面介绍行锁的几个种类：Record Locks（记录锁），Gap Locks（间隙锁），Next-Key Locks（记录锁+间隙锁组合），Insert Intention Locks（插入意向锁）。\n\n先创建一个表，用来下面分析\n\n```sql\nCREATE TABLE HERO(\nid INT, \nname VARCAHR(100),\nPRIMARY KEY(id),\nKEY `INDEX_NAME` (`name`) USING BIREE\n) Engine=InnoDB CHARSET=utf8;\n```\n\n\n\n#### Record Locks（记录锁）\n\n单条索引记录上加锁，有S锁和X锁之分。**record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁**，但原理上和表锁应该是完全不同的。\n\n- 当⼀个事务获取了⼀条记录的S记录锁后，其他事务也可以继续获取该记录的S记录锁，但不可以继续获取X记录锁。\n\n- 当⼀个事务获取了⼀条记录的X记录锁后，其他事务既不可以继续获取该记录的S记录锁 ，也不可以继续获取X型正经记录锁 。\n\n![Record Locks加锁](mysql-lock/3.png)\n\n#### Gap Locks（间隙锁）\n\n这种锁作用在索引记录之间。他是为<font color=red>防止其他事务插入间隙（包括防止insert方式插入新数据到间隙，以及update方式将其他行变更到此间隙）</font>。Gap锁可以有效的防止”幻读“（因为这些间隙都被上了锁，其他事务不可能再插入数据到这些间隙中，于是当前事务在连续进行”当前读“时，每次读到的都是相同的记录）。Gap锁<font color=red>只作用在隔离级别为RR（不可重复读）的数据库</font>上，但是不意味着隔离等级为RC（已提交读）级别的不会使用，<font color=red>在RC级别，在进行外键约束检测和唯一键约束检测的时候，会使用到Gap锁</font>。\n\n![Gap Locks](mysql-lock/4.png)\n\n**什么情况下会加Gap锁？**\n\n- RR隔离级别下，Gap锁会用在非唯一索引或者不走索引的当前读中，也就是说除了唯一索引的唯一搜索外，都会获取gap锁或next-key锁。[初步理解MySQL的gap锁](https://www.cnblogs.com/crazylqy/p/7821481.html?spm=a2c6h.12873639.0.0.47a21bf4qroWrl)\n- RC隔离级别，在进行外键约束检测和唯一键约束检测的时候，会使用到Gap锁。[RC隔离级别下的间隙锁案例](https://cloud.tencent.com/developer/article/1678599)\n\n举例说明，例如还是上面那个图，ID是主键索引，name是普通索引。\n\n```SQL\n-- 精确查询主键索引，只加X锁，不加Gap锁\nUPDATE `HERO` SET name = 'xxx' WHERE ID = '3';\n-- 会在5，7，,9上加X锁。在(3,5),(5,7),(7,9),(9,+∞)上加Gap锁\nUPDATE `HERO` SET name = 'xxx' WHERE ID > '3';\n-- 没命中，在(1,3)加Gap锁。\nUPDATE `HERO` SET name = 'xxx' WHERE ID = '2';\n```\n\n#### NextKey Locks\n\n本质上就是Gap锁和Record锁的结合，锁住索引外还要锁住索引的间隙。再具体一些就是，一个record锁，加上，位于此索引记录前的第一个间隙处的间隙锁。举个简单的例子就是，如果现在有一个索引包含三个值1，3，5，则next-key lock锁，可能锁住的范围就有(-∞,1],(1,3],(3,5],(5,+∞]。<font color=red>同样在next-key lock一般作用在RR隔离等级的数据库，但是当出现在insert时候，检测到唯一键冲突的时候，会在冲突所在唯一索引出和之前的间隙处加Next-key lock</font>。\n\n#### Insert Intention Locks\n\n这个锁是在数据插入之前会加此锁。它是一种轻量的Gap锁，同时也是意向排他锁的一种。它的存在使得多个事务在写入不同数据到统一索引间隙的时候，不会发生锁等待（<font color=red>例如一个间隙已经加了Gap锁了，事务B，C同时往这个间隙加Insert Intention Lock是不会互相阻塞的，但是Gap跟Insert Intention Locks会阻塞，必须等到Gap释放后才能加Insert Intention Locks</font>）。另外由于它是一种意向插入锁，所以当排他锁已经处于间隙上的时候，根据锁的兼容矩阵，可以知道，***意向插入锁必须等待此间隙上的排它锁释放，才能获取。***\n\n### 死锁案例分析\n\n#### 背景分析\n\n我们数据库中发生死锁的表是具有”**<font color=red>多列组合构建的主键索引</font>**“，且数据库的隔离级别多RC。由于业务原因，经常会出现对同一行数据进行字段的反复修改的场景。为了简化代码我们使用了insert on duplicate key update语句来解决，这个语句的意思是首先先执行插入，如果检测到唯一键冲突时，仅更新特定（非索引）字段。为了优化入库的效率，我们将原来执行insert on duplicate key update语句进行切分采用多事务的方式，结果发生了”Deadlock found when trying to get lock“死锁问题。\n\n```sql\n--- 表结构----\nCREATE TABLE `flow_data` (\n  `time` varchar(8) NOT NULL DEFAULT '',\n  `domain` varchar(256) NOT NULL DEFAULT '',\n  `v1` bigint(20) DEFAULT '0',\n  `v2` bigint(20) DEFAULT '0',\n  `v3` bigint(20) DEFAULT '0',\n  `v4` bigint(20) DEFAULT '0',\n  PRIMARY KEY (`time`,`domain`),\n  KEY `index_domain` (`domain`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n--- 对应死锁的语句----\nINSERT INTO flow_data (time, domain, v1, v2, v3, v4) VALUES\n  ('20201111','a.com',26420278,27235006,26189728,29158467),\n  ('20201111','b.com',26420278,27235006,26189728,29158467),\n  ('20201111','c.com',26420278,27235006,26189728,29158467) \nON DUPLICATE KEY UPDATE \n  v1=VALUES(v1),v2 =VALUES(v2),v3=VALUES(v3),v4 =VALUES(v4);\n```\n\n![](mysql-lock/6.png)\n\n#### 问题现象\n\n![](mysql-lock/7.png)\n\n我们分析下死锁信息，\n\n事务1正在等待别的事务的锁释放，这个锁是”lock_mode X locks gap before rec insert intention waiting“，直接翻译过来就是<font color=red>插入意向锁在等待排他gap锁的释放</font>。\n\n事务2目前持有一个X锁，并且也在等别的事务的锁的释放，”lock_mode X locks gap before rec insert intention waiting\"。\n\n#### 问题分析\n\n上面的死锁问题刚开始很疑惑，主要有几点\n\n- 为什么在RC隔离级别下会用了Gap锁？\n- insert on duplicate key update语句是否在内部有导致了什么检查才会加锁？\n\n带着疑问，重新好好的复习了一下MySQL的锁知识和官方文档，也全网找了相关的问题。得出一下几个要点。\n\n- insert on duplicate key update 语句在内部会<font color=red>检测是否发生唯一键的冲突</font>，这个不难理解，例如原来有个domian=a.com，如果原来表里面没有a.com，那就INSERT；如果已经有了这个domain（为啥能知道有了这个domain，因为唯一键冲突），就UPDATE。\n- 在RC级别，在<font color=red>进行外键约束检测和唯一键约束检测</font>的时候，会使用到Gap锁。\n- 同样在next-key lock一般作用在RR隔离等级的数据库，但是当出现在insert时候，<font color=red>检测到唯一键冲突</font>的时候，会在冲突所在唯一索引出和之前的间隙处加Next-key lock。\n- <font color=red>意向插入锁必须等待此间隙上的排它锁释放，才能获取</font>。\n\n所以得出死锁结论：<font color=red>本质上就是两个事务同时获取到了不同间隙的X Next-key锁，而这个两个事务又同时想要向对方已经获取了next-key锁的间隙内插入新的数据，于是乎死锁出现了</font>。\n\n![](mysql-lock/8.png)\n\n#### 解决方法\n\n查找了网上的几种解决方法，包括如下：\n\n- 不用insert on duplicate key update语句，但是业务需要，这个不能换，最终这个没有采纳。\n- 笔者用的Mysql5.7,网上说Mysql5.6不会有这个问题，但是降级数据库是大隐患，也不采纳。\n- insert on duplicate key update语句每次的批次少点，减少发生死锁的概率。这个确实可以，但是治标不治本。\n- 死锁后重试。\n\n最终笔者采用的是对domain先进行排序后再分批次 + 死锁后重试，用了这个方法后就没再出现过死锁。\n\n这里为啥排序后可以解决，因为导致这个问题的原因是每个事务的doamin都是乱序的，那么多事务执行就容易出现上面的问题。InnoDB的索引是按照规则进行排序的，那么将所有domian排序后再分批次，那么就不会出现。且为了保险也做了死锁重试来兜底。","slug":"mysql-lock","published":1,"updated":"2021-04-08T00:47:06.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvc001vqwv2huefgvah","content":"<h3 id=\"为什么有锁\"><a href=\"#为什么有锁\" class=\"headerlink\" title=\"为什么有锁\"></a>为什么有锁</h3><p>Mysql锁主要是为了解决多事务并发带来的问题。多事务并发分成以下三种情况：</p>\n<ul>\n<li>读读，两个事务都只有读操作，不加锁。</li>\n<li>写写，多个未提交事务在对同一个记录做修改操作时，需要让操作排队，这就是用锁实现的。</li>\n<li>读写，Innodb中读操作利用多版本控制并发（MVCC），写操作使用锁来控制。</li>\n</ul>\n<p>InnoDB锁官方文档地址 ：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-shared-exclusive-locks\" target=\"_blank\" rel=\"noopener\">InnoDB Locking Doc</a>。锁作为MySQL一个很重要的知识点，虽然有隐式加锁解锁的存在开发人员很少涉及到，但了解锁对开发尤为重要，不然遇到死锁问题都不知道哪里出现问题了。</p>\n<h3 id=\"锁类型与上锁方式\"><a href=\"#锁类型与上锁方式\" class=\"headerlink\" title=\"锁类型与上锁方式\"></a>锁类型与上锁方式</h3><p>在MySQL中，锁按照类型划分可以分成 ：表锁，行锁（本文重点），页锁。</p>\n<p>在MySQL中，锁按照种类可以划分成：共享锁（S）和排他锁（X）。</p>\n<p><img src=\"/2020/11/11/mysql-lock/2.png\" alt></p>\n<a id=\"more\"></a>\n\n<p>这里说一下上面的意向共享锁和意向排他锁。其实这两个应该算是表级锁。为啥会有这两个东西呢？为了<font color=\"red\"><strong>为了允许行锁和表锁共存，实现多粒度锁机制</strong></font>。引用MySQL官方文档对意向锁的解释”Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table.”。翻译过来大概是：意向锁是表级锁，指示事务稍后需要为表中的行使用哪种类型的锁（共享或独占）。举个列子，假设一张表的某些行已经被人加了X锁，现在另一个事务需要对这张表加X锁，此时需要判断这个表上的记录是否有一些被人加过X锁了，如果加过了就不允许加表X锁了，如果没有意向锁的话需要逐行遍历判断是否加过行X锁。所以，</p>\n<ul>\n<li>在事务可以获取表中某一行的共享锁之前，它必须首先获取表上的IS锁。</li>\n<li>在事务可以获得表中一行的排他锁之前，它必须首先获得表上的IX锁。</li>\n</ul>\n<p><strong>意向锁是MySQL自动帮我们加的，我们不需要操心，只需要了解下就行。</strong></p>\n<h3 id=\"行锁\"><a href=\"#行锁\" class=\"headerlink\" title=\"行锁\"></a>行锁</h3><p>下面介绍行锁的几个种类：Record Locks（记录锁），Gap Locks（间隙锁），Next-Key Locks（记录锁+间隙锁组合），Insert Intention Locks（插入意向锁）。</p>\n<p>先创建一个表，用来下面分析</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> HERO<span class=\"token punctuation\">(</span>\nid <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span> \nname VARCAHR<span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>INDEX_NAME<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>name<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">USING</span> BIREE\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">Engine</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"Record-Locks（记录锁）\"><a href=\"#Record-Locks（记录锁）\" class=\"headerlink\" title=\"Record Locks（记录锁）\"></a>Record Locks（记录锁）</h4><p>单条索引记录上加锁，有S锁和X锁之分。<strong>record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁</strong>，但原理上和表锁应该是完全不同的。</p>\n<ul>\n<li><p>当⼀个事务获取了⼀条记录的S记录锁后，其他事务也可以继续获取该记录的S记录锁，但不可以继续获取X记录锁。</p>\n</li>\n<li><p>当⼀个事务获取了⼀条记录的X记录锁后，其他事务既不可以继续获取该记录的S记录锁 ，也不可以继续获取X型正经记录锁 。</p>\n</li>\n</ul>\n<p><img src=\"/2020/11/11/mysql-lock/3.png\" alt=\"Record Locks加锁\"></p>\n<h4 id=\"Gap-Locks（间隙锁）\"><a href=\"#Gap-Locks（间隙锁）\" class=\"headerlink\" title=\"Gap Locks（间隙锁）\"></a>Gap Locks（间隙锁）</h4><p>这种锁作用在索引记录之间。他是为<font color=\"red\">防止其他事务插入间隙（包括防止insert方式插入新数据到间隙，以及update方式将其他行变更到此间隙）</font>。Gap锁可以有效的防止”幻读“（因为这些间隙都被上了锁，其他事务不可能再插入数据到这些间隙中，于是当前事务在连续进行”当前读“时，每次读到的都是相同的记录）。Gap锁<font color=\"red\">只作用在隔离级别为RR（不可重复读）的数据库</font>上，但是不意味着隔离等级为RC（已提交读）级别的不会使用，<font color=\"red\">在RC级别，在进行外键约束检测和唯一键约束检测的时候，会使用到Gap锁</font>。</p>\n<p><img src=\"/2020/11/11/mysql-lock/4.png\" alt=\"Gap Locks\"></p>\n<p><strong>什么情况下会加Gap锁？</strong></p>\n<ul>\n<li>RR隔离级别下，Gap锁会用在非唯一索引或者不走索引的当前读中，也就是说除了唯一索引的唯一搜索外，都会获取gap锁或next-key锁。<a href=\"https://www.cnblogs.com/crazylqy/p/7821481.html?spm=a2c6h.12873639.0.0.47a21bf4qroWrl\" target=\"_blank\" rel=\"noopener\">初步理解MySQL的gap锁</a></li>\n<li>RC隔离级别，在进行外键约束检测和唯一键约束检测的时候，会使用到Gap锁。<a href=\"https://cloud.tencent.com/developer/article/1678599\" target=\"_blank\" rel=\"noopener\">RC隔离级别下的间隙锁案例</a></li>\n</ul>\n<p>举例说明，例如还是上面那个图，ID是主键索引，name是普通索引。</p>\n<pre class=\" language-SQL\"><code class=\"language-SQL\">-- 精确查询主键索引，只加X锁，不加Gap锁\nUPDATE `HERO` SET name = 'xxx' WHERE ID = '3';\n-- 会在5，7，,9上加X锁。在(3,5),(5,7),(7,9),(9,+∞)上加Gap锁\nUPDATE `HERO` SET name = 'xxx' WHERE ID > '3';\n-- 没命中，在(1,3)加Gap锁。\nUPDATE `HERO` SET name = 'xxx' WHERE ID = '2';</code></pre>\n<h4 id=\"NextKey-Locks\"><a href=\"#NextKey-Locks\" class=\"headerlink\" title=\"NextKey Locks\"></a>NextKey Locks</h4><p>本质上就是Gap锁和Record锁的结合，锁住索引外还要锁住索引的间隙。再具体一些就是，一个record锁，加上，位于此索引记录前的第一个间隙处的间隙锁。举个简单的例子就是，如果现在有一个索引包含三个值1，3，5，则next-key lock锁，可能锁住的范围就有(-∞,1],(1,3],(3,5],(5,+∞]。<font color=\"red\">同样在next-key lock一般作用在RR隔离等级的数据库，但是当出现在insert时候，检测到唯一键冲突的时候，会在冲突所在唯一索引出和之前的间隙处加Next-key lock</font>。</p>\n<h4 id=\"Insert-Intention-Locks\"><a href=\"#Insert-Intention-Locks\" class=\"headerlink\" title=\"Insert Intention Locks\"></a>Insert Intention Locks</h4><p>这个锁是在数据插入之前会加此锁。它是一种轻量的Gap锁，同时也是意向排他锁的一种。它的存在使得多个事务在写入不同数据到统一索引间隙的时候，不会发生锁等待（<font color=\"red\">例如一个间隙已经加了Gap锁了，事务B，C同时往这个间隙加Insert Intention Lock是不会互相阻塞的，但是Gap跟Insert Intention Locks会阻塞，必须等到Gap释放后才能加Insert Intention Locks</font>）。另外由于它是一种意向插入锁，所以当排他锁已经处于间隙上的时候，根据锁的兼容矩阵，可以知道，<strong><em>意向插入锁必须等待此间隙上的排它锁释放，才能获取。</em></strong></p>\n<h3 id=\"死锁案例分析\"><a href=\"#死锁案例分析\" class=\"headerlink\" title=\"死锁案例分析\"></a>死锁案例分析</h3><h4 id=\"背景分析\"><a href=\"#背景分析\" class=\"headerlink\" title=\"背景分析\"></a>背景分析</h4><p>我们数据库中发生死锁的表是具有”<strong><font color=\"red\">多列组合构建的主键索引</font></strong>“，且数据库的隔离级别多RC。由于业务原因，经常会出现对同一行数据进行字段的反复修改的场景。为了简化代码我们使用了insert on duplicate key update语句来解决，这个语句的意思是首先先执行插入，如果检测到唯一键冲突时，仅更新特定（非索引）字段。为了优化入库的效率，我们将原来执行insert on duplicate key update语句进行切分采用多事务的方式，结果发生了”Deadlock found when trying to get lock“死锁问题。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">--- 表结构----</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>flow_data<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">`</span>time<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>domain<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">''</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>v1<span class=\"token punctuation\">`</span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>v2<span class=\"token punctuation\">`</span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>v3<span class=\"token punctuation\">`</span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>v4<span class=\"token punctuation\">`</span> <span class=\"token keyword\">bigint</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token string\">'0'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>time<span class=\"token punctuation\">`</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">`</span>domain<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>index_domain<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>domain<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">USING</span> <span class=\"token keyword\">BTREE</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">--- 对应死锁的语句----</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> flow_data <span class=\"token punctuation\">(</span>time<span class=\"token punctuation\">,</span> domain<span class=\"token punctuation\">,</span> v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">,</span> v3<span class=\"token punctuation\">,</span> v4<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span>\n  <span class=\"token punctuation\">(</span><span class=\"token string\">'20201111'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'a.com'</span><span class=\"token punctuation\">,</span><span class=\"token number\">26420278</span><span class=\"token punctuation\">,</span><span class=\"token number\">27235006</span><span class=\"token punctuation\">,</span><span class=\"token number\">26189728</span><span class=\"token punctuation\">,</span><span class=\"token number\">29158467</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token string\">'20201111'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'b.com'</span><span class=\"token punctuation\">,</span><span class=\"token number\">26420278</span><span class=\"token punctuation\">,</span><span class=\"token number\">27235006</span><span class=\"token punctuation\">,</span><span class=\"token number\">26189728</span><span class=\"token punctuation\">,</span><span class=\"token number\">29158467</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">(</span><span class=\"token string\">'20201111'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'c.com'</span><span class=\"token punctuation\">,</span><span class=\"token number\">26420278</span><span class=\"token punctuation\">,</span><span class=\"token number\">27235006</span><span class=\"token punctuation\">,</span><span class=\"token number\">26189728</span><span class=\"token punctuation\">,</span><span class=\"token number\">29158467</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">ON</span> <span class=\"token keyword\">DUPLICATE KEY</span> <span class=\"token keyword\">UPDATE</span> \n  v1<span class=\"token operator\">=</span><span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>v2 <span class=\"token operator\">=</span><span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>v3<span class=\"token operator\">=</span><span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>v3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>v4 <span class=\"token operator\">=</span><span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span>v4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/11/11/mysql-lock/6.png\" alt></p>\n<h4 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h4><p><img src=\"/2020/11/11/mysql-lock/7.png\" alt></p>\n<p>我们分析下死锁信息，</p>\n<p>事务1正在等待别的事务的锁释放，这个锁是”lock_mode X locks gap before rec insert intention waiting“，直接翻译过来就是<font color=\"red\">插入意向锁在等待排他gap锁的释放</font>。</p>\n<p>事务2目前持有一个X锁，并且也在等别的事务的锁的释放，”lock_mode X locks gap before rec insert intention waiting”。</p>\n<h4 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>上面的死锁问题刚开始很疑惑，主要有几点</p>\n<ul>\n<li>为什么在RC隔离级别下会用了Gap锁？</li>\n<li>insert on duplicate key update语句是否在内部有导致了什么检查才会加锁？</li>\n</ul>\n<p>带着疑问，重新好好的复习了一下MySQL的锁知识和官方文档，也全网找了相关的问题。得出一下几个要点。</p>\n<ul>\n<li>insert on duplicate key update 语句在内部会<font color=\"red\">检测是否发生唯一键的冲突</font>，这个不难理解，例如原来有个domian=a.com，如果原来表里面没有a.com，那就INSERT；如果已经有了这个domain（为啥能知道有了这个domain，因为唯一键冲突），就UPDATE。</li>\n<li>在RC级别，在<font color=\"red\">进行外键约束检测和唯一键约束检测</font>的时候，会使用到Gap锁。</li>\n<li>同样在next-key lock一般作用在RR隔离等级的数据库，但是当出现在insert时候，<font color=\"red\">检测到唯一键冲突</font>的时候，会在冲突所在唯一索引出和之前的间隙处加Next-key lock。</li>\n<li><font color=\"red\">意向插入锁必须等待此间隙上的排它锁释放，才能获取</font>。</li>\n</ul>\n<p>所以得出死锁结论：<font color=\"red\">本质上就是两个事务同时获取到了不同间隙的X Next-key锁，而这个两个事务又同时想要向对方已经获取了next-key锁的间隙内插入新的数据，于是乎死锁出现了</font>。</p>\n<p><img src=\"/2020/11/11/mysql-lock/8.png\" alt></p>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>查找了网上的几种解决方法，包括如下：</p>\n<ul>\n<li>不用insert on duplicate key update语句，但是业务需要，这个不能换，最终这个没有采纳。</li>\n<li>笔者用的Mysql5.7,网上说Mysql5.6不会有这个问题，但是降级数据库是大隐患，也不采纳。</li>\n<li>insert on duplicate key update语句每次的批次少点，减少发生死锁的概率。这个确实可以，但是治标不治本。</li>\n<li>死锁后重试。</li>\n</ul>\n<p>最终笔者采用的是对domain先进行排序后再分批次 + 死锁后重试，用了这个方法后就没再出现过死锁。</p>\n<p>这里为啥排序后可以解决，因为导致这个问题的原因是每个事务的doamin都是乱序的，那么多事务执行就容易出现上面的问题。InnoDB的索引是按照规则进行排序的，那么将所有domian排序后再分批次，那么就不会出现。且为了保险也做了死锁重试来兜底。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"为什么有锁\"><a href=\"#为什么有锁\" class=\"headerlink\" title=\"为什么有锁\"></a>为什么有锁</h3><p>Mysql锁主要是为了解决多事务并发带来的问题。多事务并发分成以下三种情况：</p>\n<ul>\n<li>读读，两个事务都只有读操作，不加锁。</li>\n<li>写写，多个未提交事务在对同一个记录做修改操作时，需要让操作排队，这就是用锁实现的。</li>\n<li>读写，Innodb中读操作利用多版本控制并发（MVCC），写操作使用锁来控制。</li>\n</ul>\n<p>InnoDB锁官方文档地址 ：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-shared-exclusive-locks\" target=\"_blank\" rel=\"noopener\">InnoDB Locking Doc</a>。锁作为MySQL一个很重要的知识点，虽然有隐式加锁解锁的存在开发人员很少涉及到，但了解锁对开发尤为重要，不然遇到死锁问题都不知道哪里出现问题了。</p>\n<h3 id=\"锁类型与上锁方式\"><a href=\"#锁类型与上锁方式\" class=\"headerlink\" title=\"锁类型与上锁方式\"></a>锁类型与上锁方式</h3><p>在MySQL中，锁按照类型划分可以分成 ：表锁，行锁（本文重点），页锁。</p>\n<p>在MySQL中，锁按照种类可以划分成：共享锁（S）和排他锁（X）。</p>\n<p><img src=\"/2020/11/11/mysql-lock/2.png\" alt></p>","more":"<p>这里说一下上面的意向共享锁和意向排他锁。其实这两个应该算是表级锁。为啥会有这两个东西呢？为了<font color=\"red\"><strong>为了允许行锁和表锁共存，实现多粒度锁机制</strong></font>。引用MySQL官方文档对意向锁的解释”Intention locks are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table.”。翻译过来大概是：意向锁是表级锁，指示事务稍后需要为表中的行使用哪种类型的锁（共享或独占）。举个列子，假设一张表的某些行已经被人加了X锁，现在另一个事务需要对这张表加X锁，此时需要判断这个表上的记录是否有一些被人加过X锁了，如果加过了就不允许加表X锁了，如果没有意向锁的话需要逐行遍历判断是否加过行X锁。所以，</p>\n<ul>\n<li>在事务可以获取表中某一行的共享锁之前，它必须首先获取表上的IS锁。</li>\n<li>在事务可以获得表中一行的排他锁之前，它必须首先获得表上的IX锁。</li>\n</ul>\n<p><strong>意向锁是MySQL自动帮我们加的，我们不需要操心，只需要了解下就行。</strong></p>\n<h3 id=\"行锁\"><a href=\"#行锁\" class=\"headerlink\" title=\"行锁\"></a>行锁</h3><p>下面介绍行锁的几个种类：Record Locks（记录锁），Gap Locks（间隙锁），Next-Key Locks（记录锁+间隙锁组合），Insert Intention Locks（插入意向锁）。</p>\n<p>先创建一个表，用来下面分析</p>\n<pre><code class=\"sql\">CREATE TABLE HERO(\nid INT, \nname VARCAHR(100),\nPRIMARY KEY(id),\nKEY `INDEX_NAME` (`name`) USING BIREE\n) Engine=InnoDB CHARSET=utf8;</code></pre>\n<h4 id=\"Record-Locks（记录锁）\"><a href=\"#Record-Locks（记录锁）\" class=\"headerlink\" title=\"Record Locks（记录锁）\"></a>Record Locks（记录锁）</h4><p>单条索引记录上加锁，有S锁和X锁之分。<strong>record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁</strong>，但原理上和表锁应该是完全不同的。</p>\n<ul>\n<li><p>当⼀个事务获取了⼀条记录的S记录锁后，其他事务也可以继续获取该记录的S记录锁，但不可以继续获取X记录锁。</p>\n</li>\n<li><p>当⼀个事务获取了⼀条记录的X记录锁后，其他事务既不可以继续获取该记录的S记录锁 ，也不可以继续获取X型正经记录锁 。</p>\n</li>\n</ul>\n<p><img src=\"/2020/11/11/mysql-lock/3.png\" alt=\"Record Locks加锁\"></p>\n<h4 id=\"Gap-Locks（间隙锁）\"><a href=\"#Gap-Locks（间隙锁）\" class=\"headerlink\" title=\"Gap Locks（间隙锁）\"></a>Gap Locks（间隙锁）</h4><p>这种锁作用在索引记录之间。他是为<font color=\"red\">防止其他事务插入间隙（包括防止insert方式插入新数据到间隙，以及update方式将其他行变更到此间隙）</font>。Gap锁可以有效的防止”幻读“（因为这些间隙都被上了锁，其他事务不可能再插入数据到这些间隙中，于是当前事务在连续进行”当前读“时，每次读到的都是相同的记录）。Gap锁<font color=\"red\">只作用在隔离级别为RR（不可重复读）的数据库</font>上，但是不意味着隔离等级为RC（已提交读）级别的不会使用，<font color=\"red\">在RC级别，在进行外键约束检测和唯一键约束检测的时候，会使用到Gap锁</font>。</p>\n<p><img src=\"/2020/11/11/mysql-lock/4.png\" alt=\"Gap Locks\"></p>\n<p><strong>什么情况下会加Gap锁？</strong></p>\n<ul>\n<li>RR隔离级别下，Gap锁会用在非唯一索引或者不走索引的当前读中，也就是说除了唯一索引的唯一搜索外，都会获取gap锁或next-key锁。<a href=\"https://www.cnblogs.com/crazylqy/p/7821481.html?spm=a2c6h.12873639.0.0.47a21bf4qroWrl\" target=\"_blank\" rel=\"noopener\">初步理解MySQL的gap锁</a></li>\n<li>RC隔离级别，在进行外键约束检测和唯一键约束检测的时候，会使用到Gap锁。<a href=\"https://cloud.tencent.com/developer/article/1678599\" target=\"_blank\" rel=\"noopener\">RC隔离级别下的间隙锁案例</a></li>\n</ul>\n<p>举例说明，例如还是上面那个图，ID是主键索引，name是普通索引。</p>\n<pre><code class=\"SQL\">-- 精确查询主键索引，只加X锁，不加Gap锁\nUPDATE `HERO` SET name = &#39;xxx&#39; WHERE ID = &#39;3&#39;;\n-- 会在5，7，,9上加X锁。在(3,5),(5,7),(7,9),(9,+∞)上加Gap锁\nUPDATE `HERO` SET name = &#39;xxx&#39; WHERE ID &gt; &#39;3&#39;;\n-- 没命中，在(1,3)加Gap锁。\nUPDATE `HERO` SET name = &#39;xxx&#39; WHERE ID = &#39;2&#39;;</code></pre>\n<h4 id=\"NextKey-Locks\"><a href=\"#NextKey-Locks\" class=\"headerlink\" title=\"NextKey Locks\"></a>NextKey Locks</h4><p>本质上就是Gap锁和Record锁的结合，锁住索引外还要锁住索引的间隙。再具体一些就是，一个record锁，加上，位于此索引记录前的第一个间隙处的间隙锁。举个简单的例子就是，如果现在有一个索引包含三个值1，3，5，则next-key lock锁，可能锁住的范围就有(-∞,1],(1,3],(3,5],(5,+∞]。<font color=\"red\">同样在next-key lock一般作用在RR隔离等级的数据库，但是当出现在insert时候，检测到唯一键冲突的时候，会在冲突所在唯一索引出和之前的间隙处加Next-key lock</font>。</p>\n<h4 id=\"Insert-Intention-Locks\"><a href=\"#Insert-Intention-Locks\" class=\"headerlink\" title=\"Insert Intention Locks\"></a>Insert Intention Locks</h4><p>这个锁是在数据插入之前会加此锁。它是一种轻量的Gap锁，同时也是意向排他锁的一种。它的存在使得多个事务在写入不同数据到统一索引间隙的时候，不会发生锁等待（<font color=\"red\">例如一个间隙已经加了Gap锁了，事务B，C同时往这个间隙加Insert Intention Lock是不会互相阻塞的，但是Gap跟Insert Intention Locks会阻塞，必须等到Gap释放后才能加Insert Intention Locks</font>）。另外由于它是一种意向插入锁，所以当排他锁已经处于间隙上的时候，根据锁的兼容矩阵，可以知道，<strong><em>意向插入锁必须等待此间隙上的排它锁释放，才能获取。</em></strong></p>\n<h3 id=\"死锁案例分析\"><a href=\"#死锁案例分析\" class=\"headerlink\" title=\"死锁案例分析\"></a>死锁案例分析</h3><h4 id=\"背景分析\"><a href=\"#背景分析\" class=\"headerlink\" title=\"背景分析\"></a>背景分析</h4><p>我们数据库中发生死锁的表是具有”<strong><font color=\"red\">多列组合构建的主键索引</font></strong>“，且数据库的隔离级别多RC。由于业务原因，经常会出现对同一行数据进行字段的反复修改的场景。为了简化代码我们使用了insert on duplicate key update语句来解决，这个语句的意思是首先先执行插入，如果检测到唯一键冲突时，仅更新特定（非索引）字段。为了优化入库的效率，我们将原来执行insert on duplicate key update语句进行切分采用多事务的方式，结果发生了”Deadlock found when trying to get lock“死锁问题。</p>\n<pre><code class=\"sql\">--- 表结构----\nCREATE TABLE `flow_data` (\n  `time` varchar(8) NOT NULL DEFAULT &#39;&#39;,\n  `domain` varchar(256) NOT NULL DEFAULT &#39;&#39;,\n  `v1` bigint(20) DEFAULT &#39;0&#39;,\n  `v2` bigint(20) DEFAULT &#39;0&#39;,\n  `v3` bigint(20) DEFAULT &#39;0&#39;,\n  `v4` bigint(20) DEFAULT &#39;0&#39;,\n  PRIMARY KEY (`time`,`domain`),\n  KEY `index_domain` (`domain`) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n--- 对应死锁的语句----\nINSERT INTO flow_data (time, domain, v1, v2, v3, v4) VALUES\n  (&#39;20201111&#39;,&#39;a.com&#39;,26420278,27235006,26189728,29158467),\n  (&#39;20201111&#39;,&#39;b.com&#39;,26420278,27235006,26189728,29158467),\n  (&#39;20201111&#39;,&#39;c.com&#39;,26420278,27235006,26189728,29158467) \nON DUPLICATE KEY UPDATE \n  v1=VALUES(v1),v2 =VALUES(v2),v3=VALUES(v3),v4 =VALUES(v4);</code></pre>\n<p><img src=\"/2020/11/11/mysql-lock/6.png\" alt></p>\n<h4 id=\"问题现象\"><a href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"></a>问题现象</h4><p><img src=\"/2020/11/11/mysql-lock/7.png\" alt></p>\n<p>我们分析下死锁信息，</p>\n<p>事务1正在等待别的事务的锁释放，这个锁是”lock_mode X locks gap before rec insert intention waiting“，直接翻译过来就是<font color=\"red\">插入意向锁在等待排他gap锁的释放</font>。</p>\n<p>事务2目前持有一个X锁，并且也在等别的事务的锁的释放，”lock_mode X locks gap before rec insert intention waiting”。</p>\n<h4 id=\"问题分析\"><a href=\"#问题分析\" class=\"headerlink\" title=\"问题分析\"></a>问题分析</h4><p>上面的死锁问题刚开始很疑惑，主要有几点</p>\n<ul>\n<li>为什么在RC隔离级别下会用了Gap锁？</li>\n<li>insert on duplicate key update语句是否在内部有导致了什么检查才会加锁？</li>\n</ul>\n<p>带着疑问，重新好好的复习了一下MySQL的锁知识和官方文档，也全网找了相关的问题。得出一下几个要点。</p>\n<ul>\n<li>insert on duplicate key update 语句在内部会<font color=\"red\">检测是否发生唯一键的冲突</font>，这个不难理解，例如原来有个domian=a.com，如果原来表里面没有a.com，那就INSERT；如果已经有了这个domain（为啥能知道有了这个domain，因为唯一键冲突），就UPDATE。</li>\n<li>在RC级别，在<font color=\"red\">进行外键约束检测和唯一键约束检测</font>的时候，会使用到Gap锁。</li>\n<li>同样在next-key lock一般作用在RR隔离等级的数据库，但是当出现在insert时候，<font color=\"red\">检测到唯一键冲突</font>的时候，会在冲突所在唯一索引出和之前的间隙处加Next-key lock。</li>\n<li><font color=\"red\">意向插入锁必须等待此间隙上的排它锁释放，才能获取</font>。</li>\n</ul>\n<p>所以得出死锁结论：<font color=\"red\">本质上就是两个事务同时获取到了不同间隙的X Next-key锁，而这个两个事务又同时想要向对方已经获取了next-key锁的间隙内插入新的数据，于是乎死锁出现了</font>。</p>\n<p><img src=\"/2020/11/11/mysql-lock/8.png\" alt></p>\n<h4 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h4><p>查找了网上的几种解决方法，包括如下：</p>\n<ul>\n<li>不用insert on duplicate key update语句，但是业务需要，这个不能换，最终这个没有采纳。</li>\n<li>笔者用的Mysql5.7,网上说Mysql5.6不会有这个问题，但是降级数据库是大隐患，也不采纳。</li>\n<li>insert on duplicate key update语句每次的批次少点，减少发生死锁的概率。这个确实可以，但是治标不治本。</li>\n<li>死锁后重试。</li>\n</ul>\n<p>最终笔者采用的是对domain先进行排序后再分批次 + 死锁后重试，用了这个方法后就没再出现过死锁。</p>\n<p>这里为啥排序后可以解决，因为导致这个问题的原因是每个事务的doamin都是乱序的，那么多事务执行就容易出现上面的问题。InnoDB的索引是按照规则进行排序的，那么将所有domian排序后再分批次，那么就不会出现。且为了保险也做了死锁重试来兜底。</p>"},{"title":"Mysql-InnoDB索引之单表使用索引详解(三)","description":"理解单表使用索引详解，为啥使用const而不是ref？多条件时是如何选择索引查询的？","date":"2020-07-31T06:43:52.000Z","_content":"## 概述\n本文主要讲解单表使用索引的几种情况，Mysql分别在使用主键索引，普通索引，唯一索引时是如何查询的，另外等值查询和范围查询是什么个情况。一般来说单表查询基本分成如下情况：\n- 没使用索引的全表扫描查询\n- 使用索引查询\n  - 针对主键或唯⼀⼆级索引的等值查询\n  - 针对普通⼆级索引的等值查询\n  - 针对索引列的范围查询\n  - 直接扫描整个索引\n<!--more-->\n## 正文\n\n### 表结构\n\n为了事情的发展，我们定义一个表结构\n\n```sql\nCREATE TABLE `single_table` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `key1` varchar(100) DEFAULT NULL,\n  `key2` int(11) DEFAULT NULL,\n  `key3` varchar(100) DEFAULT NULL,\n  `key_part1` varchar(100) DEFAULT NULL,\n  `key_part2` varchar(100) DEFAULT NULL,\n  `key_part3` varchar(100) DEFAULT NULL,\n  `common_field` varchar(100) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `idx_key2` (`key2`),\n  KEY `idx_key1` (`key1`),\n  KEY `idx_key3` (`key3`),\n  KEY `idx_key_part` (`key_part1`,`key_part2`,`key_part3`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n```\n\n| 列                            | 索引类型     |\n| ----------------------------- | ------------ |\n| id                            | 主键索引     |\n| key1                          | 普通索引     |\n| key2                          | 唯一索引     |\n| key3                          | 普通索引     |\n| key_part1,key_part2,key_part3 | 联合普通索引 |\n\n### 针对主键或唯⼀⼆级索引的等值查询\n\n#### 使用主键索引的等值查询\n\n例如我们现在有一条SQL，通过主键来查询一条数据。由于id是<font color=red>非空唯一</font>。所以Mysql会直接使用主键值在<font color=red>聚簇索引</font>中查找用户对应的记录。\n\n```sql\nSELECT\t*\tFROM\tsingle_table\tWHERE\tid\t=\t3;\n```\n\n查询示意图如下\n\n![主键索引等值查询示意图](mysql-index-single/1.png)\n\n通过EXPLAIN执行计划，查询的type = const 。const类型用于主键或唯一二级索引列与常数比较时，所以表最多有一个匹配行。<font color=green>读取1次，速度比较快</font>。\n\n不过这种const访问⽅法只能在主键列或者唯⼀⼆级索引列和⼀个常数进⾏等值⽐较时才有效，如果主键或者唯⼀⼆级索引是由多个列构成的话，索引中的每⼀个列都需要与常数进⾏等值⽐较，这个const访问⽅法才有效。\n\n![](mysql-index-single/2.png)\n\n\n#### 使用唯一索引的等值查询\n\n可以看到这个查询的执⾏分两步，第⼀步先从idx_key2对应的B+树索引中根据key2列与常数的等值⽐较条件定位到⼀条⼆级索引记录，然后再根据该记录的id值到聚簇索引中获取到完整的⽤户记录。所以这种情况下，执行计划下查询类型是属于<font color=red>const</font>\n\n```sql\nSELECT\t*\tFROM\tsingle_table\tWHERE\tkey2\t=\t4;\n```\n\n![唯一索引等值查询示意图](mysql-index-single/4.png)\n\n![](mysql-index-single/3.png)\n\n### 针对普通⼆级索引的等值查询\n#### 普通二级索引等值查询\n对于普通索引，不像主键索引和唯一索引，它允许有重复的值。\n\n```sql\nSELECT\t*\tFROM\tsingle_table\tWHERE\tkey1\t=\t'abc';\n```\n\n![普通索引的等值查询示意图](mysql-index-single/5.png)\n\n![](mysql-index-single/6.png)\n\n通过EXPLAIN执行计划，查询的type = ref。这种搜索条件为⼆级索引列与常数等值⽐较，采⽤⼆级索引来执⾏查询的访问⽅法称为：ref。\n\n#### 普通索引查询等值和NULL\n有时候我们不仅想找出某个⼆级索引列的值等于某个常数的记录，还想把该列的值为NULL的记录也找出来，就像下边这个查询：\n```sql\nSELECT\t*\tFROM\tsingle_demo\tWHERE\tkey1\t=\t'abc'\tOR\tkey1\tIS\tNULL;\n```\n\n![普通索引查询等值和NULL示意图](mysql-index-single/9.png)\n\n#### 包含NULL的唯一、普通索引\n不论是普通的⼆级索引，还是唯⼀⼆级索引，它们的索引列对包含NULL值的数量并不限制，所以我们采⽤key IS NULL这种形式的搜索条件最多只能使⽤ref 的访问⽅法，⽽不是const的访问⽅法。\n\n![](mysql-index-single/7.png)\n![](mysql-index-single/8.png)\n\n### 针对索引列的范围查询\n这个跟上面说的差不多，只是他是范围查询，通过EXPLAIN执行计划，查询的type = range。\n\n![](mysql-index-single/10.png)\n\n#### 明确range访问⽅法使⽤的范围区间\n在我们实际写SQL时，经常是需要确定一个范围区间的，例如使用⽤=、<=>、IN、NOT IN、IS NULL、IS NOT NULL、>、<、>=、<=、BETWEEN、!=（不等于也可以写成<>）或者LIKE 操作符连接起来，在加上AND 和 OR 操作符。所以确定查询区间是比较重要的。\n##### 所有搜索条件都可以使⽤某个索引的情况\n待续。。。\n\n### 多条件查询AND的情况\n⼀般情况下只能利⽤单个⼆级索引执⾏查询，⽐⽅说下边的这个查询：\n```sql\nSELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;\n```\n这个查询中包含了两个搜索条件，且他们使用的索引不同\n\n- key1 = 'abc'  使用普通索引key1等值查询\n- key2 > 1000 使用唯一索引key2范围查询\n\n这种情况下优化器⼀般会根据single_table表的统计数据来判断到底使⽤哪个条件到对应的⼆级索引中查询扫描的⾏数会更少，选择那个扫描⾏数较少的条件到对应的⼆级 索引中查询。然后将从该⼆级索引中查询到的结果经过回表得到完整的⽤户记录后再根据其余的WHERE条件过滤记录。\n上面的例子步骤如下：\n- 步骤1 ：优化器觉得key1 = 'abc' 使用的是 ref ，比使用range快，所以他选择key1作为查询条件\n- 步骤2 ：使用key1在索引idx_key1索引所在的B+树中找到对应的数据，可能多条。\n- 步骤3 ：通过步骤2查出来的数据现在需要做<font color=red>回表</font>操作，这时候再根据条件key2 > 1000到 完整的⽤户记录继续过滤。\n\n这里思考下，如果是 key2  = 'abc' AND key1 >1000 的情况，优化器是如何做的？\n由于key2 = 'abc' 是 const，所以会使用key2且忽略key1。 \n\n### 索引合并\n#### 交集情况\n上面我们说⼀般情况下只能利⽤单个⼆级索引执⾏查询。指的是一个查询存在两个不同索引时会使用其中一个索引去他对应的B+树查询出结果(索引列的值+主键)。然后在使用另外一个索引在回表时对结果进行过滤。\n但还有一种情况是索引合并，指的是两个索引都去对应的B+树查询结果(索引列的值+主键)。如果在通过主键取交集。再回表。\n```sql\nSELECT * FROM single_table WHERE key1 =\t'a'\tAND\tkey3 = 'b';\n```\n- 步骤1：从idx_key1⼆级索引对应的B+树中取出key1 = 'a'的相关记录。\n- 步骤2：从idx_key3⼆级索引对应的B+树中取出key3 = 'b'的相关记录。\n- 步骤3：⼆级索引的记录都是由索引列 + 主键构成的，所以我们可以计算出这两个结果集中id值的交集。\n- 步骤4：按照上⼀步⽣成的id值列表进⾏回表操作，也就是从聚簇索引中把指定id值的完整⽤户记录取出来，返回给⽤户。\n\n**Mysql中只有某些情况下才允许索引合并**\n- ⼆级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。\n\n```sql\n//能使用索引合并\nSELECT * FROM single_table WHERE key1 = 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'; \n\n//不能使用索引合并，原因是出现了范围\nSELECT * FROM single_table WHERE key1 > 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c';\n\n//不能使用索引合并，原因联合索引没有最左比配到\nSELECT * FROM single_table WHERE key1 = 'a' AND key_part2 = 'a'; \n```\n- 主键列可以是范围匹配\n\n这里可能有人会有疑惑。那到底是要使用索引合并还是不使用了？**对于这个问题，其实怎么选择是Mysql的优化器来决定的，总的来说他会通过计算执行成本，使用的IO等来判断选哪一个。**\n\n#### 并集情况\n我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是OR关系。\n```sql\nSELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'\n```\nMySQL在某些特定的情况下才可能会使⽤到Union索引合并。\n- 情况1：⼆级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况\n- 情况2：主键列可以是范围匹配\n- 情况3：使⽤Intersection索引合并的搜索条件\n\n情况3例如下面这条语句：\n```sql\nSELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');\n```\n优化器可能采⽤这样的⽅式来执⾏这个查询：\n- 先按照搜索条件key1 = 'a' AND key3 = 'b'从索引idx_key1和idx_key3中使⽤Intersection索引合并的⽅式得到⼀个主键集合。\n- 再按照搜索条件key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'从联合索引idx_key_part中得到另⼀个主键集合。\n- 采⽤Union索引合并的⽅式把上述两个主键集合取并集，然后进⾏回表操作，将结果返回给⽤户。\n\n## 总结\n本文通过部分实例讲述了Mysql使用索引是如何查询的。为什么我这条SQL使用的是ref而不是const。ref类型的查询是一种什么情况。\nSQL查询情况太多，笔者只能挑选出几种比较常见的进行讲解，但还有很多情况需要我们自己去分析。\n所以我们在判断一条SQL是否性能优时，应该使用执行计划EXPLAIN来进行判断。","source":"_posts/mysql-index-single.md","raw":"---\ntitle: Mysql-InnoDB索引之单表使用索引详解(三)\ntags:\n  - mysql\ncategories:  mysql\ndescription : 理解单表使用索引详解，为啥使用const而不是ref？多条件时是如何选择索引查询的？\ndate: 2020-07-31 14:43:52\n---\n## 概述\n本文主要讲解单表使用索引的几种情况，Mysql分别在使用主键索引，普通索引，唯一索引时是如何查询的，另外等值查询和范围查询是什么个情况。一般来说单表查询基本分成如下情况：\n- 没使用索引的全表扫描查询\n- 使用索引查询\n  - 针对主键或唯⼀⼆级索引的等值查询\n  - 针对普通⼆级索引的等值查询\n  - 针对索引列的范围查询\n  - 直接扫描整个索引\n<!--more-->\n## 正文\n\n### 表结构\n\n为了事情的发展，我们定义一个表结构\n\n```sql\nCREATE TABLE `single_table` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `key1` varchar(100) DEFAULT NULL,\n  `key2` int(11) DEFAULT NULL,\n  `key3` varchar(100) DEFAULT NULL,\n  `key_part1` varchar(100) DEFAULT NULL,\n  `key_part2` varchar(100) DEFAULT NULL,\n  `key_part3` varchar(100) DEFAULT NULL,\n  `common_field` varchar(100) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `idx_key2` (`key2`),\n  KEY `idx_key1` (`key1`),\n  KEY `idx_key3` (`key3`),\n  KEY `idx_key_part` (`key_part1`,`key_part2`,`key_part3`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n```\n\n| 列                            | 索引类型     |\n| ----------------------------- | ------------ |\n| id                            | 主键索引     |\n| key1                          | 普通索引     |\n| key2                          | 唯一索引     |\n| key3                          | 普通索引     |\n| key_part1,key_part2,key_part3 | 联合普通索引 |\n\n### 针对主键或唯⼀⼆级索引的等值查询\n\n#### 使用主键索引的等值查询\n\n例如我们现在有一条SQL，通过主键来查询一条数据。由于id是<font color=red>非空唯一</font>。所以Mysql会直接使用主键值在<font color=red>聚簇索引</font>中查找用户对应的记录。\n\n```sql\nSELECT\t*\tFROM\tsingle_table\tWHERE\tid\t=\t3;\n```\n\n查询示意图如下\n\n![主键索引等值查询示意图](mysql-index-single/1.png)\n\n通过EXPLAIN执行计划，查询的type = const 。const类型用于主键或唯一二级索引列与常数比较时，所以表最多有一个匹配行。<font color=green>读取1次，速度比较快</font>。\n\n不过这种const访问⽅法只能在主键列或者唯⼀⼆级索引列和⼀个常数进⾏等值⽐较时才有效，如果主键或者唯⼀⼆级索引是由多个列构成的话，索引中的每⼀个列都需要与常数进⾏等值⽐较，这个const访问⽅法才有效。\n\n![](mysql-index-single/2.png)\n\n\n#### 使用唯一索引的等值查询\n\n可以看到这个查询的执⾏分两步，第⼀步先从idx_key2对应的B+树索引中根据key2列与常数的等值⽐较条件定位到⼀条⼆级索引记录，然后再根据该记录的id值到聚簇索引中获取到完整的⽤户记录。所以这种情况下，执行计划下查询类型是属于<font color=red>const</font>\n\n```sql\nSELECT\t*\tFROM\tsingle_table\tWHERE\tkey2\t=\t4;\n```\n\n![唯一索引等值查询示意图](mysql-index-single/4.png)\n\n![](mysql-index-single/3.png)\n\n### 针对普通⼆级索引的等值查询\n#### 普通二级索引等值查询\n对于普通索引，不像主键索引和唯一索引，它允许有重复的值。\n\n```sql\nSELECT\t*\tFROM\tsingle_table\tWHERE\tkey1\t=\t'abc';\n```\n\n![普通索引的等值查询示意图](mysql-index-single/5.png)\n\n![](mysql-index-single/6.png)\n\n通过EXPLAIN执行计划，查询的type = ref。这种搜索条件为⼆级索引列与常数等值⽐较，采⽤⼆级索引来执⾏查询的访问⽅法称为：ref。\n\n#### 普通索引查询等值和NULL\n有时候我们不仅想找出某个⼆级索引列的值等于某个常数的记录，还想把该列的值为NULL的记录也找出来，就像下边这个查询：\n```sql\nSELECT\t*\tFROM\tsingle_demo\tWHERE\tkey1\t=\t'abc'\tOR\tkey1\tIS\tNULL;\n```\n\n![普通索引查询等值和NULL示意图](mysql-index-single/9.png)\n\n#### 包含NULL的唯一、普通索引\n不论是普通的⼆级索引，还是唯⼀⼆级索引，它们的索引列对包含NULL值的数量并不限制，所以我们采⽤key IS NULL这种形式的搜索条件最多只能使⽤ref 的访问⽅法，⽽不是const的访问⽅法。\n\n![](mysql-index-single/7.png)\n![](mysql-index-single/8.png)\n\n### 针对索引列的范围查询\n这个跟上面说的差不多，只是他是范围查询，通过EXPLAIN执行计划，查询的type = range。\n\n![](mysql-index-single/10.png)\n\n#### 明确range访问⽅法使⽤的范围区间\n在我们实际写SQL时，经常是需要确定一个范围区间的，例如使用⽤=、<=>、IN、NOT IN、IS NULL、IS NOT NULL、>、<、>=、<=、BETWEEN、!=（不等于也可以写成<>）或者LIKE 操作符连接起来，在加上AND 和 OR 操作符。所以确定查询区间是比较重要的。\n##### 所有搜索条件都可以使⽤某个索引的情况\n待续。。。\n\n### 多条件查询AND的情况\n⼀般情况下只能利⽤单个⼆级索引执⾏查询，⽐⽅说下边的这个查询：\n```sql\nSELECT * FROM single_table WHERE key1 = 'abc' AND key2 > 1000;\n```\n这个查询中包含了两个搜索条件，且他们使用的索引不同\n\n- key1 = 'abc'  使用普通索引key1等值查询\n- key2 > 1000 使用唯一索引key2范围查询\n\n这种情况下优化器⼀般会根据single_table表的统计数据来判断到底使⽤哪个条件到对应的⼆级索引中查询扫描的⾏数会更少，选择那个扫描⾏数较少的条件到对应的⼆级 索引中查询。然后将从该⼆级索引中查询到的结果经过回表得到完整的⽤户记录后再根据其余的WHERE条件过滤记录。\n上面的例子步骤如下：\n- 步骤1 ：优化器觉得key1 = 'abc' 使用的是 ref ，比使用range快，所以他选择key1作为查询条件\n- 步骤2 ：使用key1在索引idx_key1索引所在的B+树中找到对应的数据，可能多条。\n- 步骤3 ：通过步骤2查出来的数据现在需要做<font color=red>回表</font>操作，这时候再根据条件key2 > 1000到 完整的⽤户记录继续过滤。\n\n这里思考下，如果是 key2  = 'abc' AND key1 >1000 的情况，优化器是如何做的？\n由于key2 = 'abc' 是 const，所以会使用key2且忽略key1。 \n\n### 索引合并\n#### 交集情况\n上面我们说⼀般情况下只能利⽤单个⼆级索引执⾏查询。指的是一个查询存在两个不同索引时会使用其中一个索引去他对应的B+树查询出结果(索引列的值+主键)。然后在使用另外一个索引在回表时对结果进行过滤。\n但还有一种情况是索引合并，指的是两个索引都去对应的B+树查询结果(索引列的值+主键)。如果在通过主键取交集。再回表。\n```sql\nSELECT * FROM single_table WHERE key1 =\t'a'\tAND\tkey3 = 'b';\n```\n- 步骤1：从idx_key1⼆级索引对应的B+树中取出key1 = 'a'的相关记录。\n- 步骤2：从idx_key3⼆级索引对应的B+树中取出key3 = 'b'的相关记录。\n- 步骤3：⼆级索引的记录都是由索引列 + 主键构成的，所以我们可以计算出这两个结果集中id值的交集。\n- 步骤4：按照上⼀步⽣成的id值列表进⾏回表操作，也就是从聚簇索引中把指定id值的完整⽤户记录取出来，返回给⽤户。\n\n**Mysql中只有某些情况下才允许索引合并**\n- ⼆级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。\n\n```sql\n//能使用索引合并\nSELECT * FROM single_table WHERE key1 = 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'; \n\n//不能使用索引合并，原因是出现了范围\nSELECT * FROM single_table WHERE key1 > 'a' AND key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c';\n\n//不能使用索引合并，原因联合索引没有最左比配到\nSELECT * FROM single_table WHERE key1 = 'a' AND key_part2 = 'a'; \n```\n- 主键列可以是范围匹配\n\n这里可能有人会有疑惑。那到底是要使用索引合并还是不使用了？**对于这个问题，其实怎么选择是Mysql的优化器来决定的，总的来说他会通过计算执行成本，使用的IO等来判断选哪一个。**\n\n#### 并集情况\n我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是OR关系。\n```sql\nSELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'\n```\nMySQL在某些特定的情况下才可能会使⽤到Union索引合并。\n- 情况1：⼆级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况\n- 情况2：主键列可以是范围匹配\n- 情况3：使⽤Intersection索引合并的搜索条件\n\n情况3例如下面这条语句：\n```sql\nSELECT * FROM single_table WHERE key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c' OR (key1 = 'a' AND key3 = 'b');\n```\n优化器可能采⽤这样的⽅式来执⾏这个查询：\n- 先按照搜索条件key1 = 'a' AND key3 = 'b'从索引idx_key1和idx_key3中使⽤Intersection索引合并的⽅式得到⼀个主键集合。\n- 再按照搜索条件key_part1 = 'a' AND key_part2 = 'b' AND key_part3 = 'c'从联合索引idx_key_part中得到另⼀个主键集合。\n- 采⽤Union索引合并的⽅式把上述两个主键集合取并集，然后进⾏回表操作，将结果返回给⽤户。\n\n## 总结\n本文通过部分实例讲述了Mysql使用索引是如何查询的。为什么我这条SQL使用的是ref而不是const。ref类型的查询是一种什么情况。\nSQL查询情况太多，笔者只能挑选出几种比较常见的进行讲解，但还有很多情况需要我们自己去分析。\n所以我们在判断一条SQL是否性能优时，应该使用执行计划EXPLAIN来进行判断。","slug":"mysql-index-single","published":1,"updated":"2021-04-08T00:47:06.847Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvd001zqwv29xvu66f7","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文主要讲解单表使用索引的几种情况，Mysql分别在使用主键索引，普通索引，唯一索引时是如何查询的，另外等值查询和范围查询是什么个情况。一般来说单表查询基本分成如下情况：</p>\n<ul>\n<li>没使用索引的全表扫描查询</li>\n<li>使用索引查询<ul>\n<li>针对主键或唯⼀⼆级索引的等值查询</li>\n<li>针对普通⼆级索引的等值查询</li>\n<li>针对索引列的范围查询</li>\n<li>直接扫描整个索引<a id=\"more\"></a>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"表结构\"><a href=\"#表结构\" class=\"headerlink\" title=\"表结构\"></a>表结构</h3><p>为了事情的发展，我们定义一个表结构</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>single_table<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key1<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key2<span class=\"token punctuation\">`</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key3<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key_part1<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key_part2<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>key_part3<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>common_field<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">UNIQUE</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>idx_key2<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>key2<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>idx_key1<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>key1<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>idx_key3<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>key3<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">`</span>idx_key_part<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>key_part1<span class=\"token punctuation\">`</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">`</span>key_part2<span class=\"token punctuation\">`</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">`</span>key_part3<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token operator\">=</span><span class=\"token number\">2</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8mb4<span class=\"token punctuation\">;</span></code></pre>\n<table>\n<thead>\n<tr>\n<th>列</th>\n<th>索引类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键索引</td>\n</tr>\n<tr>\n<td>key1</td>\n<td>普通索引</td>\n</tr>\n<tr>\n<td>key2</td>\n<td>唯一索引</td>\n</tr>\n<tr>\n<td>key3</td>\n<td>普通索引</td>\n</tr>\n<tr>\n<td>key_part1,key_part2,key_part3</td>\n<td>联合普通索引</td>\n</tr>\n</tbody></table>\n<h3 id=\"针对主键或唯⼀⼆级索引的等值查询\"><a href=\"#针对主键或唯⼀⼆级索引的等值查询\" class=\"headerlink\" title=\"针对主键或唯⼀⼆级索引的等值查询\"></a>针对主键或唯⼀⼆级索引的等值查询</h3><h4 id=\"使用主键索引的等值查询\"><a href=\"#使用主键索引的等值查询\" class=\"headerlink\" title=\"使用主键索引的等值查询\"></a>使用主键索引的等值查询</h4><p>例如我们现在有一条SQL，通过主键来查询一条数据。由于id是<font color=\"red\">非空唯一</font>。所以Mysql会直接使用主键值在<font color=\"red\">聚簇索引</font>中查找用户对应的记录。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>    <span class=\"token operator\">*</span>    <span class=\"token keyword\">FROM</span>    single_table    <span class=\"token keyword\">WHERE</span>    id    <span class=\"token operator\">=</span>    <span class=\"token number\">3</span><span class=\"token punctuation\">;</span></code></pre>\n<p>查询示意图如下</p>\n<p><img src=\"/2020/07/31/mysql-index-single/1.png\" alt=\"主键索引等值查询示意图\"></p>\n<p>通过EXPLAIN执行计划，查询的type = const 。const类型用于主键或唯一二级索引列与常数比较时，所以表最多有一个匹配行。<font color=\"green\">读取1次，速度比较快</font>。</p>\n<p>不过这种const访问⽅法只能在主键列或者唯⼀⼆级索引列和⼀个常数进⾏等值⽐较时才有效，如果主键或者唯⼀⼆级索引是由多个列构成的话，索引中的每⼀个列都需要与常数进⾏等值⽐较，这个const访问⽅法才有效。</p>\n<p><img src=\"/2020/07/31/mysql-index-single/2.png\" alt></p>\n<h4 id=\"使用唯一索引的等值查询\"><a href=\"#使用唯一索引的等值查询\" class=\"headerlink\" title=\"使用唯一索引的等值查询\"></a>使用唯一索引的等值查询</h4><p>可以看到这个查询的执⾏分两步，第⼀步先从idx_key2对应的B+树索引中根据key2列与常数的等值⽐较条件定位到⼀条⼆级索引记录，然后再根据该记录的id值到聚簇索引中获取到完整的⽤户记录。所以这种情况下，执行计划下查询类型是属于<font color=\"red\">const</font></p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>    <span class=\"token operator\">*</span>    <span class=\"token keyword\">FROM</span>    single_table    <span class=\"token keyword\">WHERE</span>    key2    <span class=\"token operator\">=</span>    <span class=\"token number\">4</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-index-single/4.png\" alt=\"唯一索引等值查询示意图\"></p>\n<p><img src=\"/2020/07/31/mysql-index-single/3.png\" alt></p>\n<h3 id=\"针对普通⼆级索引的等值查询\"><a href=\"#针对普通⼆级索引的等值查询\" class=\"headerlink\" title=\"针对普通⼆级索引的等值查询\"></a>针对普通⼆级索引的等值查询</h3><h4 id=\"普通二级索引等值查询\"><a href=\"#普通二级索引等值查询\" class=\"headerlink\" title=\"普通二级索引等值查询\"></a>普通二级索引等值查询</h4><p>对于普通索引，不像主键索引和唯一索引，它允许有重复的值。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>    <span class=\"token operator\">*</span>    <span class=\"token keyword\">FROM</span>    single_table    <span class=\"token keyword\">WHERE</span>    key1    <span class=\"token operator\">=</span>    <span class=\"token string\">'abc'</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-index-single/5.png\" alt=\"普通索引的等值查询示意图\"></p>\n<p><img src=\"/2020/07/31/mysql-index-single/6.png\" alt></p>\n<p>通过EXPLAIN执行计划，查询的type = ref。这种搜索条件为⼆级索引列与常数等值⽐较，采⽤⼆级索引来执⾏查询的访问⽅法称为：ref。</p>\n<h4 id=\"普通索引查询等值和NULL\"><a href=\"#普通索引查询等值和NULL\" class=\"headerlink\" title=\"普通索引查询等值和NULL\"></a>普通索引查询等值和NULL</h4><p>有时候我们不仅想找出某个⼆级索引列的值等于某个常数的记录，还想把该列的值为NULL的记录也找出来，就像下边这个查询：</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>    <span class=\"token operator\">*</span>    <span class=\"token keyword\">FROM</span>    single_demo    <span class=\"token keyword\">WHERE</span>    key1    <span class=\"token operator\">=</span>    <span class=\"token string\">'abc'</span>    <span class=\"token operator\">OR</span>    key1    <span class=\"token operator\">IS</span>    <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/07/31/mysql-index-single/9.png\" alt=\"普通索引查询等值和NULL示意图\"></p>\n<h4 id=\"包含NULL的唯一、普通索引\"><a href=\"#包含NULL的唯一、普通索引\" class=\"headerlink\" title=\"包含NULL的唯一、普通索引\"></a>包含NULL的唯一、普通索引</h4><p>不论是普通的⼆级索引，还是唯⼀⼆级索引，它们的索引列对包含NULL值的数量并不限制，所以我们采⽤key IS NULL这种形式的搜索条件最多只能使⽤ref 的访问⽅法，⽽不是const的访问⽅法。</p>\n<p><img src=\"/2020/07/31/mysql-index-single/7.png\" alt><br><img src=\"/2020/07/31/mysql-index-single/8.png\" alt></p>\n<h3 id=\"针对索引列的范围查询\"><a href=\"#针对索引列的范围查询\" class=\"headerlink\" title=\"针对索引列的范围查询\"></a>针对索引列的范围查询</h3><p>这个跟上面说的差不多，只是他是范围查询，通过EXPLAIN执行计划，查询的type = range。</p>\n<p><img src=\"/2020/07/31/mysql-index-single/10.png\" alt></p>\n<h4 id=\"明确range访问⽅法使⽤的范围区间\"><a href=\"#明确range访问⽅法使⽤的范围区间\" class=\"headerlink\" title=\"明确range访问⽅法使⽤的范围区间\"></a>明确range访问⽅法使⽤的范围区间</h4><p>在我们实际写SQL时，经常是需要确定一个范围区间的，例如使用⽤=、&lt;=&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;=、&lt;=、BETWEEN、!=（不等于也可以写成&lt;&gt;）或者LIKE 操作符连接起来，在加上AND 和 OR 操作符。所以确定查询区间是比较重要的。</p>\n<h5 id=\"所有搜索条件都可以使⽤某个索引的情况\"><a href=\"#所有搜索条件都可以使⽤某个索引的情况\" class=\"headerlink\" title=\"所有搜索条件都可以使⽤某个索引的情况\"></a>所有搜索条件都可以使⽤某个索引的情况</h5><p>待续。。。</p>\n<h3 id=\"多条件查询AND的情况\"><a href=\"#多条件查询AND的情况\" class=\"headerlink\" title=\"多条件查询AND的情况\"></a>多条件查询AND的情况</h3><p>⼀般情况下只能利⽤单个⼆级索引执⾏查询，⽐⽅说下边的这个查询：</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> single_table <span class=\"token keyword\">WHERE</span> key1 <span class=\"token operator\">=</span> <span class=\"token string\">'abc'</span> <span class=\"token operator\">AND</span> key2 <span class=\"token operator\">></span> <span class=\"token number\">1000</span><span class=\"token punctuation\">;</span></code></pre>\n<p>这个查询中包含了两个搜索条件，且他们使用的索引不同</p>\n<ul>\n<li>key1 = ‘abc’  使用普通索引key1等值查询</li>\n<li>key2 &gt; 1000 使用唯一索引key2范围查询</li>\n</ul>\n<p>这种情况下优化器⼀般会根据single_table表的统计数据来判断到底使⽤哪个条件到对应的⼆级索引中查询扫描的⾏数会更少，选择那个扫描⾏数较少的条件到对应的⼆级 索引中查询。然后将从该⼆级索引中查询到的结果经过回表得到完整的⽤户记录后再根据其余的WHERE条件过滤记录。<br>上面的例子步骤如下：</p>\n<ul>\n<li>步骤1 ：优化器觉得key1 = ‘abc’ 使用的是 ref ，比使用range快，所以他选择key1作为查询条件</li>\n<li>步骤2 ：使用key1在索引idx_key1索引所在的B+树中找到对应的数据，可能多条。</li>\n<li>步骤3 ：通过步骤2查出来的数据现在需要做<font color=\"red\">回表</font>操作，这时候再根据条件key2 &gt; 1000到 完整的⽤户记录继续过滤。</li>\n</ul>\n<p>这里思考下，如果是 key2  = ‘abc’ AND key1 &gt;1000 的情况，优化器是如何做的？<br>由于key2 = ‘abc’ 是 const，所以会使用key2且忽略key1。 </p>\n<h3 id=\"索引合并\"><a href=\"#索引合并\" class=\"headerlink\" title=\"索引合并\"></a>索引合并</h3><h4 id=\"交集情况\"><a href=\"#交集情况\" class=\"headerlink\" title=\"交集情况\"></a>交集情况</h4><p>上面我们说⼀般情况下只能利⽤单个⼆级索引执⾏查询。指的是一个查询存在两个不同索引时会使用其中一个索引去他对应的B+树查询出结果(索引列的值+主键)。然后在使用另外一个索引在回表时对结果进行过滤。<br>但还有一种情况是索引合并，指的是两个索引都去对应的B+树查询结果(索引列的值+主键)。如果在通过主键取交集。再回表。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> single_table <span class=\"token keyword\">WHERE</span> key1 <span class=\"token operator\">=</span>    <span class=\"token string\">'a'</span>    <span class=\"token operator\">AND</span>    key3 <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span></code></pre>\n<ul>\n<li>步骤1：从idx_key1⼆级索引对应的B+树中取出key1 = ‘a’的相关记录。</li>\n<li>步骤2：从idx_key3⼆级索引对应的B+树中取出key3 = ‘b’的相关记录。</li>\n<li>步骤3：⼆级索引的记录都是由索引列 + 主键构成的，所以我们可以计算出这两个结果集中id值的交集。</li>\n<li>步骤4：按照上⼀步⽣成的id值列表进⾏回表操作，也就是从聚簇索引中把指定id值的完整⽤户记录取出来，返回给⽤户。</li>\n</ul>\n<p><strong>Mysql中只有某些情况下才允许索引合并</strong></p>\n<ul>\n<li>⼆级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</li>\n</ul>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token comment\" spellcheck=\"true\">//能使用索引合并</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> single_table <span class=\"token keyword\">WHERE</span> key1 <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">AND</span> key_part1 <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">AND</span> key_part2 <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span> <span class=\"token operator\">AND</span> key_part3 <span class=\"token operator\">=</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">;</span> \n\n<span class=\"token comment\" spellcheck=\"true\">//不能使用索引合并，原因是出现了范围</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> single_table <span class=\"token keyword\">WHERE</span> key1 <span class=\"token operator\">></span> <span class=\"token string\">'a'</span> <span class=\"token operator\">AND</span> key_part1 <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">AND</span> key_part2 <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span> <span class=\"token operator\">AND</span> key_part3 <span class=\"token operator\">=</span> <span class=\"token string\">'c'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//不能使用索引合并，原因联合索引没有最左比配到</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> single_table <span class=\"token keyword\">WHERE</span> key1 <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">AND</span> key_part2 <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">;</span> </code></pre>\n<ul>\n<li>主键列可以是范围匹配</li>\n</ul>\n<p>这里可能有人会有疑惑。那到底是要使用索引合并还是不使用了？<strong>对于这个问题，其实怎么选择是Mysql的优化器来决定的，总的来说他会通过计算执行成本，使用的IO等来判断选哪一个。</strong></p>\n<h4 id=\"并集情况\"><a href=\"#并集情况\" class=\"headerlink\" title=\"并集情况\"></a>并集情况</h4><p>我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是OR关系。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> single_table <span class=\"token keyword\">WHERE</span> key1 <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">OR</span> key3 <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span></code></pre>\n<p>MySQL在某些特定的情况下才可能会使⽤到Union索引合并。</p>\n<ul>\n<li>情况1：⼆级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况</li>\n<li>情况2：主键列可以是范围匹配</li>\n<li>情况3：使⽤Intersection索引合并的搜索条件</li>\n</ul>\n<p>情况3例如下面这条语句：</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> single_table <span class=\"token keyword\">WHERE</span> key_part1 <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">AND</span> key_part2 <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span> <span class=\"token operator\">AND</span> key_part3 <span class=\"token operator\">=</span> <span class=\"token string\">'c'</span> <span class=\"token operator\">OR</span> <span class=\"token punctuation\">(</span>key1 <span class=\"token operator\">=</span> <span class=\"token string\">'a'</span> <span class=\"token operator\">AND</span> key3 <span class=\"token operator\">=</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>优化器可能采⽤这样的⽅式来执⾏这个查询：</p>\n<ul>\n<li>先按照搜索条件key1 = ‘a’ AND key3 = ‘b’从索引idx_key1和idx_key3中使⽤Intersection索引合并的⽅式得到⼀个主键集合。</li>\n<li>再按照搜索条件key_part1 = ‘a’ AND key_part2 = ‘b’ AND key_part3 = ‘c’从联合索引idx_key_part中得到另⼀个主键集合。</li>\n<li>采⽤Union索引合并的⽅式把上述两个主键集合取并集，然后进⾏回表操作，将结果返回给⽤户。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文通过部分实例讲述了Mysql使用索引是如何查询的。为什么我这条SQL使用的是ref而不是const。ref类型的查询是一种什么情况。<br>SQL查询情况太多，笔者只能挑选出几种比较常见的进行讲解，但还有很多情况需要我们自己去分析。<br>所以我们在判断一条SQL是否性能优时，应该使用执行计划EXPLAIN来进行判断。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>本文主要讲解单表使用索引的几种情况，Mysql分别在使用主键索引，普通索引，唯一索引时是如何查询的，另外等值查询和范围查询是什么个情况。一般来说单表查询基本分成如下情况：</p>\n<ul>\n<li>没使用索引的全表扫描查询</li>\n<li>使用索引查询<ul>\n<li>针对主键或唯⼀⼆级索引的等值查询</li>\n<li>针对普通⼆级索引的等值查询</li>\n<li>针对索引列的范围查询</li>\n<li>直接扫描整个索引</li></ul></li></ul>","more":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2>\n\n\n\n<h3 id=\"表结构\"><a href=\"#表结构\" class=\"headerlink\" title=\"表结构\"></a>表结构</h3><p>为了事情的发展，我们定义一个表结构</p>\n<pre><code class=\"sql\">CREATE TABLE `single_table` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `key1` varchar(100) DEFAULT NULL,\n  `key2` int(11) DEFAULT NULL,\n  `key3` varchar(100) DEFAULT NULL,\n  `key_part1` varchar(100) DEFAULT NULL,\n  `key_part2` varchar(100) DEFAULT NULL,\n  `key_part3` varchar(100) DEFAULT NULL,\n  `common_field` varchar(100) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `idx_key2` (`key2`),\n  KEY `idx_key1` (`key1`),\n  KEY `idx_key3` (`key3`),\n  KEY `idx_key_part` (`key_part1`,`key_part2`,`key_part3`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;</code></pre>\n<table>\n<thead>\n<tr>\n<th>列</th>\n<th>索引类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>id</td>\n<td>主键索引</td>\n</tr>\n<tr>\n<td>key1</td>\n<td>普通索引</td>\n</tr>\n<tr>\n<td>key2</td>\n<td>唯一索引</td>\n</tr>\n<tr>\n<td>key3</td>\n<td>普通索引</td>\n</tr>\n<tr>\n<td>key_part1,key_part2,key_part3</td>\n<td>联合普通索引</td>\n</tr>\n</tbody></table>\n<h3 id=\"针对主键或唯⼀⼆级索引的等值查询\"><a href=\"#针对主键或唯⼀⼆级索引的等值查询\" class=\"headerlink\" title=\"针对主键或唯⼀⼆级索引的等值查询\"></a>针对主键或唯⼀⼆级索引的等值查询</h3><h4 id=\"使用主键索引的等值查询\"><a href=\"#使用主键索引的等值查询\" class=\"headerlink\" title=\"使用主键索引的等值查询\"></a>使用主键索引的等值查询</h4><p>例如我们现在有一条SQL，通过主键来查询一条数据。由于id是<font color=\"red\">非空唯一</font>。所以Mysql会直接使用主键值在<font color=\"red\">聚簇索引</font>中查找用户对应的记录。</p>\n<pre><code class=\"sql\">SELECT    *    FROM    single_table    WHERE    id    =    3;</code></pre>\n<p>查询示意图如下</p>\n<p><img src=\"/2020/07/31/mysql-index-single/1.png\" alt=\"主键索引等值查询示意图\"></p>\n<p>通过EXPLAIN执行计划，查询的type = const 。const类型用于主键或唯一二级索引列与常数比较时，所以表最多有一个匹配行。<font color=\"green\">读取1次，速度比较快</font>。</p>\n<p>不过这种const访问⽅法只能在主键列或者唯⼀⼆级索引列和⼀个常数进⾏等值⽐较时才有效，如果主键或者唯⼀⼆级索引是由多个列构成的话，索引中的每⼀个列都需要与常数进⾏等值⽐较，这个const访问⽅法才有效。</p>\n<p><img src=\"/2020/07/31/mysql-index-single/2.png\" alt></p>\n<h4 id=\"使用唯一索引的等值查询\"><a href=\"#使用唯一索引的等值查询\" class=\"headerlink\" title=\"使用唯一索引的等值查询\"></a>使用唯一索引的等值查询</h4><p>可以看到这个查询的执⾏分两步，第⼀步先从idx_key2对应的B+树索引中根据key2列与常数的等值⽐较条件定位到⼀条⼆级索引记录，然后再根据该记录的id值到聚簇索引中获取到完整的⽤户记录。所以这种情况下，执行计划下查询类型是属于<font color=\"red\">const</font></p>\n<pre><code class=\"sql\">SELECT    *    FROM    single_table    WHERE    key2    =    4;</code></pre>\n<p><img src=\"/2020/07/31/mysql-index-single/4.png\" alt=\"唯一索引等值查询示意图\"></p>\n<p><img src=\"/2020/07/31/mysql-index-single/3.png\" alt></p>\n<h3 id=\"针对普通⼆级索引的等值查询\"><a href=\"#针对普通⼆级索引的等值查询\" class=\"headerlink\" title=\"针对普通⼆级索引的等值查询\"></a>针对普通⼆级索引的等值查询</h3><h4 id=\"普通二级索引等值查询\"><a href=\"#普通二级索引等值查询\" class=\"headerlink\" title=\"普通二级索引等值查询\"></a>普通二级索引等值查询</h4><p>对于普通索引，不像主键索引和唯一索引，它允许有重复的值。</p>\n<pre><code class=\"sql\">SELECT    *    FROM    single_table    WHERE    key1    =    &#39;abc&#39;;</code></pre>\n<p><img src=\"/2020/07/31/mysql-index-single/5.png\" alt=\"普通索引的等值查询示意图\"></p>\n<p><img src=\"/2020/07/31/mysql-index-single/6.png\" alt></p>\n<p>通过EXPLAIN执行计划，查询的type = ref。这种搜索条件为⼆级索引列与常数等值⽐较，采⽤⼆级索引来执⾏查询的访问⽅法称为：ref。</p>\n<h4 id=\"普通索引查询等值和NULL\"><a href=\"#普通索引查询等值和NULL\" class=\"headerlink\" title=\"普通索引查询等值和NULL\"></a>普通索引查询等值和NULL</h4><p>有时候我们不仅想找出某个⼆级索引列的值等于某个常数的记录，还想把该列的值为NULL的记录也找出来，就像下边这个查询：</p>\n<pre><code class=\"sql\">SELECT    *    FROM    single_demo    WHERE    key1    =    &#39;abc&#39;    OR    key1    IS    NULL;</code></pre>\n<p><img src=\"/2020/07/31/mysql-index-single/9.png\" alt=\"普通索引查询等值和NULL示意图\"></p>\n<h4 id=\"包含NULL的唯一、普通索引\"><a href=\"#包含NULL的唯一、普通索引\" class=\"headerlink\" title=\"包含NULL的唯一、普通索引\"></a>包含NULL的唯一、普通索引</h4><p>不论是普通的⼆级索引，还是唯⼀⼆级索引，它们的索引列对包含NULL值的数量并不限制，所以我们采⽤key IS NULL这种形式的搜索条件最多只能使⽤ref 的访问⽅法，⽽不是const的访问⽅法。</p>\n<p><img src=\"/2020/07/31/mysql-index-single/7.png\" alt><br><img src=\"/2020/07/31/mysql-index-single/8.png\" alt></p>\n<h3 id=\"针对索引列的范围查询\"><a href=\"#针对索引列的范围查询\" class=\"headerlink\" title=\"针对索引列的范围查询\"></a>针对索引列的范围查询</h3><p>这个跟上面说的差不多，只是他是范围查询，通过EXPLAIN执行计划，查询的type = range。</p>\n<p><img src=\"/2020/07/31/mysql-index-single/10.png\" alt></p>\n<h4 id=\"明确range访问⽅法使⽤的范围区间\"><a href=\"#明确range访问⽅法使⽤的范围区间\" class=\"headerlink\" title=\"明确range访问⽅法使⽤的范围区间\"></a>明确range访问⽅法使⽤的范围区间</h4><p>在我们实际写SQL时，经常是需要确定一个范围区间的，例如使用⽤=、&lt;=&gt;、IN、NOT IN、IS NULL、IS NOT NULL、&gt;、&lt;、&gt;=、&lt;=、BETWEEN、!=（不等于也可以写成&lt;&gt;）或者LIKE 操作符连接起来，在加上AND 和 OR 操作符。所以确定查询区间是比较重要的。</p>\n<h5 id=\"所有搜索条件都可以使⽤某个索引的情况\"><a href=\"#所有搜索条件都可以使⽤某个索引的情况\" class=\"headerlink\" title=\"所有搜索条件都可以使⽤某个索引的情况\"></a>所有搜索条件都可以使⽤某个索引的情况</h5><p>待续。。。</p>\n<h3 id=\"多条件查询AND的情况\"><a href=\"#多条件查询AND的情况\" class=\"headerlink\" title=\"多条件查询AND的情况\"></a>多条件查询AND的情况</h3><p>⼀般情况下只能利⽤单个⼆级索引执⾏查询，⽐⽅说下边的这个查询：</p>\n<pre><code class=\"sql\">SELECT * FROM single_table WHERE key1 = &#39;abc&#39; AND key2 &gt; 1000;</code></pre>\n<p>这个查询中包含了两个搜索条件，且他们使用的索引不同</p>\n<ul>\n<li>key1 = ‘abc’  使用普通索引key1等值查询</li>\n<li>key2 &gt; 1000 使用唯一索引key2范围查询</li>\n</ul>\n<p>这种情况下优化器⼀般会根据single_table表的统计数据来判断到底使⽤哪个条件到对应的⼆级索引中查询扫描的⾏数会更少，选择那个扫描⾏数较少的条件到对应的⼆级 索引中查询。然后将从该⼆级索引中查询到的结果经过回表得到完整的⽤户记录后再根据其余的WHERE条件过滤记录。<br>上面的例子步骤如下：</p>\n<ul>\n<li>步骤1 ：优化器觉得key1 = ‘abc’ 使用的是 ref ，比使用range快，所以他选择key1作为查询条件</li>\n<li>步骤2 ：使用key1在索引idx_key1索引所在的B+树中找到对应的数据，可能多条。</li>\n<li>步骤3 ：通过步骤2查出来的数据现在需要做<font color=\"red\">回表</font>操作，这时候再根据条件key2 &gt; 1000到 完整的⽤户记录继续过滤。</li>\n</ul>\n<p>这里思考下，如果是 key2  = ‘abc’ AND key1 &gt;1000 的情况，优化器是如何做的？<br>由于key2 = ‘abc’ 是 const，所以会使用key2且忽略key1。 </p>\n<h3 id=\"索引合并\"><a href=\"#索引合并\" class=\"headerlink\" title=\"索引合并\"></a>索引合并</h3><h4 id=\"交集情况\"><a href=\"#交集情况\" class=\"headerlink\" title=\"交集情况\"></a>交集情况</h4><p>上面我们说⼀般情况下只能利⽤单个⼆级索引执⾏查询。指的是一个查询存在两个不同索引时会使用其中一个索引去他对应的B+树查询出结果(索引列的值+主键)。然后在使用另外一个索引在回表时对结果进行过滤。<br>但还有一种情况是索引合并，指的是两个索引都去对应的B+树查询结果(索引列的值+主键)。如果在通过主键取交集。再回表。</p>\n<pre><code class=\"sql\">SELECT * FROM single_table WHERE key1 =    &#39;a&#39;    AND    key3 = &#39;b&#39;;</code></pre>\n<ul>\n<li>步骤1：从idx_key1⼆级索引对应的B+树中取出key1 = ‘a’的相关记录。</li>\n<li>步骤2：从idx_key3⼆级索引对应的B+树中取出key3 = ‘b’的相关记录。</li>\n<li>步骤3：⼆级索引的记录都是由索引列 + 主键构成的，所以我们可以计算出这两个结果集中id值的交集。</li>\n<li>步骤4：按照上⼀步⽣成的id值列表进⾏回表操作，也就是从聚簇索引中把指定id值的完整⽤户记录取出来，返回给⽤户。</li>\n</ul>\n<p><strong>Mysql中只有某些情况下才允许索引合并</strong></p>\n<ul>\n<li>⼆级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。</li>\n</ul>\n<pre><code class=\"sql\">//能使用索引合并\nSELECT * FROM single_table WHERE key1 = &#39;a&#39; AND key_part1 = &#39;a&#39; AND key_part2 = &#39;b&#39; AND key_part3 = &#39;c&#39;; \n\n//不能使用索引合并，原因是出现了范围\nSELECT * FROM single_table WHERE key1 &gt; &#39;a&#39; AND key_part1 = &#39;a&#39; AND key_part2 = &#39;b&#39; AND key_part3 = &#39;c&#39;;\n\n//不能使用索引合并，原因联合索引没有最左比配到\nSELECT * FROM single_table WHERE key1 = &#39;a&#39; AND key_part2 = &#39;a&#39;; </code></pre>\n<ul>\n<li>主键列可以是范围匹配</li>\n</ul>\n<p>这里可能有人会有疑惑。那到底是要使用索引合并还是不使用了？<strong>对于这个问题，其实怎么选择是Mysql的优化器来决定的，总的来说他会通过计算执行成本，使用的IO等来判断选哪一个。</strong></p>\n<h4 id=\"并集情况\"><a href=\"#并集情况\" class=\"headerlink\" title=\"并集情况\"></a>并集情况</h4><p>我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是OR关系。</p>\n<pre><code class=\"sql\">SELECT * FROM single_table WHERE key1 = &#39;a&#39; OR key3 = &#39;b&#39;</code></pre>\n<p>MySQL在某些特定的情况下才可能会使⽤到Union索引合并。</p>\n<ul>\n<li>情况1：⼆级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只出现匹配部分列的情况</li>\n<li>情况2：主键列可以是范围匹配</li>\n<li>情况3：使⽤Intersection索引合并的搜索条件</li>\n</ul>\n<p>情况3例如下面这条语句：</p>\n<pre><code class=\"sql\">SELECT * FROM single_table WHERE key_part1 = &#39;a&#39; AND key_part2 = &#39;b&#39; AND key_part3 = &#39;c&#39; OR (key1 = &#39;a&#39; AND key3 = &#39;b&#39;);</code></pre>\n<p>优化器可能采⽤这样的⽅式来执⾏这个查询：</p>\n<ul>\n<li>先按照搜索条件key1 = ‘a’ AND key3 = ‘b’从索引idx_key1和idx_key3中使⽤Intersection索引合并的⽅式得到⼀个主键集合。</li>\n<li>再按照搜索条件key_part1 = ‘a’ AND key_part2 = ‘b’ AND key_part3 = ‘c’从联合索引idx_key_part中得到另⼀个主键集合。</li>\n<li>采⽤Union索引合并的⽅式把上述两个主键集合取并集，然后进⾏回表操作，将结果返回给⽤户。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文通过部分实例讲述了Mysql使用索引是如何查询的。为什么我这条SQL使用的是ref而不是const。ref类型的查询是一种什么情况。<br>SQL查询情况太多，笔者只能挑选出几种比较常见的进行讲解，但还有很多情况需要我们自己去分析。<br>所以我们在判断一条SQL是否性能优时，应该使用执行计划EXPLAIN来进行判断。</p>"},{"title":"MySQL-binlog、redolog、undolog日志详解","description":"一直不理解Mysql中binlog日志，redo日志，undo日志分别的作用。这篇文章主要介绍三种日志的作用，帮助理解","date":"2018-08-07T01:32:25.000Z","_content":"## MySQL三种重要的日志\nMySQL有三种重要的日志，分别是 binlog(归档日志)、redolog(重做日志)、redolog(撤销日志)。\n- binlog归档日志是数据库层面上的日志，主要用来做备份恢复和主从复制。\n- redolog重做日志是<font color=red>Innodb引擎层面上</font>的日志，主要用来保证数据的可靠性。<font color=red>用于故障恢复，实现事务的持久性机制</font>\n- undolog主要用于事务的回滚和MVCC 多版本并发控制。\n\n### binlog日志\nbinlog是MySQL数据库的二进制日志，用于记录用户<font color=red>对数据库操作的SQL语句</font>（(除了数据查询语句）信息。可以使用mysqlbin命令查看二进制日志的内容。\n\nbinlog的格式有三种：STATEMENT、ROW、MIXED 。可以通过my.conf来配置。\n\n```properties\n###binlog模式：ROW/STATEMENT/MIXED\nbinlog_format=ROW\n```\n\n- STATMENT模式(默认,语句模式)：基于SQL语句的复制，每一条会修改数据的sql语句会记录到binlog中。\n  - 优点，不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。\n  - 缺点，在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)\n- ROW模式(行模式)：基于行的复制，不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了\n  - 优点，不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题\n  - 会产生大量的日志\n- Mixed模式(混合模式)：以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式\n\n**binlog写入机制**\n\n![](mysql-log/2.png)\n\nbinlog日志在事务没有提交之前会想写入到binlog cache中， 每个线程都有一个binlog cache。在事务提交后才会一次性写入到文件系统的缓存file page中。\n\n然后mysql会根据你的sync_binlog配置决定是否马上刷新到磁盘中。\n\n- sync_binlog=0 的时候，表示每次提交事务都只 write到file page中，不 fsync到磁盘；\n- sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；\n- sync_binlog=N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。\n\n**可以通过如下命令查看binlog_cache_size大小**\n\n```\nshow variables like 'binlog_cache_size';\n```\n\n**验证binlog_cache_size设置是否合理**\n\n```\nmysql> show global status like 'binlog_cache_%';\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| Binlog_cache_disk_use | 1008  | #记录了使用临时文件写二进制日志的次数，越小越好\n| Binlog_cache_use      | 5721  | #使用缓冲的次数。越小越好\n+-----------------------+-------+\n2 rows in set (0.00 sec)\n```\n\n\n\n### redo日志\n\n上面我们说binlog是归档日志，开启后每次数据库执行了修改数据的语句都会被记录，<font color=red>那既然有了binlog日志，为啥还要有redo日志呢</font>？\n\n这里我们先了解一下一条更新语句是如何执行的？\n\n#### 一条更新语句的执行流程\n\n![更新语句执行过程](mysql-log/1.png)\n\n1. 执行器先找存储引擎(Innodb)取 ID=2 这一行，如果ID=2这一行所在的页不在内存中就从磁盘上读取所在页到内存然后返回给执行器，如果已经在内存则直接返回（<font color=red>MySQL最小存储单位是页，所以即使只是一条数据也是将所在页加载到内存</font>）\n2. 执行器拿到存储引擎给的行数据后执行修改操作并返回给存储引擎。\n3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redolog 里面，此时 redolog 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。\n4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。\n5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状\n态，更新完成。\n\n从上面的逻辑可以看出，当事务提交以后，MySQL是先将变化更新到内存然后在合适的时间把变化更新到磁盘，这样的设计主要是为了提高效率，毕竟每时每刻操作磁盘IO和查找成本都很高。假设在事务提交后变化写到了内存中，<font color=red>此时MySQL机器宕机了那就会导致提交后的事务数据丢失。</font> <font color=red>所以 redo日志是为了保证事务的持久性而存在的</font>。\n\n#### 为什么redolog就能保证事务的持久性机制?\nWAF（write ahead log）：当事务提交时，先写redo log，再修改页（这里的页，就是缓冲池中的数据页、索引页）。具体来说就是 ，<font color=red>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</font>。\n所以当事务提交后就会记录redo日志，在事务提交后但还没更新到磁盘此时MySQL宕机了，就可以通过redo日志进行恢复，保证了事务的持久性。\n\n#### redo日志特点\nInnoDB 的 redo log 是<font color=red>固定大小</font>（可以通过innodb_log_file_size参数指定大小）的。数据会<font color=red>从头开始写,写到末尾就又回到开头循环写</font>。\n\n在事务运行过程中，会不断地产生 redo log，这些 redo log 会先定入 redo log buffer(<font color=red>buffer可以认为是内存</font>)中，然后再将 redo log buffer 中的数据以某些方式顺序地写入到磁盘（各个操作的redo log 汇总到 redo log buffer，再由 redo log buffer 统一写磁盘，就能做到顺序写了）。这些方式有：\n- MySQL master 线程周期性任务 每秒一次，将 redo log buffer 刷新到磁盘(即使这个事务尚未提交)\n- MySQL master 线程周期性任务 每10秒一次，将 redo log buffer 刷新到磁盘\n- 当redo log buffer size 剩余空间小于1/2时(innodb_log_buffer_size参数)，将 redo log buffer 刷新到磁盘\n- 当 redo log file 大小已经达到某个域值快要\"不可用\"时（日志文件组轮流写文件），触发 async/sync flush checkpoint，及时将一些脏页刷新到磁盘，并同时将redo log buffer刷新到磁盘，然后更新redo log file 相应的 log sequence number值\n\n#### redo日志重要参数\nredo log buffer 的刷新到磁盘的时机由参数 <font color=red>innodb_flush_log_at_trx_commit</font> 参数控制，可取的值有：0、1、2\n- 0 : 表示每次事务提交时都只是把redo log留在 redo log buffer 中。此时可能你提交事务了，结果mysql宕机了，然后此时内存里的数据全部丢失。\n- 1 : 表示每次事务提交时都将redo log直接持久化到磁盘，只要事务提交成功，那么 redo log 就必然在磁盘里了\n- 2 : 提交事务的时候，把 redo 日志写入磁盘文件对应的 os cache 缓存里去，而不是直接进入磁盘文件，可能 1 秒后才会把 os cache 里的数据写入到磁盘文件里去\n\n可以看到，<font color=red>只有1才能真正地保证事务的持久性</font>，但是由于刷新操作 fsync() 是阻塞的，直到完成后才返回，我们知道写磁盘的速度是很慢的，因此 MySQL 的性能会明显地下降。如果不在乎事务丢失，0和2能获得更高的性能。\n\n### binlog日志和redo日志区别\n- redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\n- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\n- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。\n\n### undo日志\n简单来说，undo日志有两个作用：提供回滚和多个行版本控制(MVCC)。\nundolog是<font color=red>逻辑日志</font>。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。\n\n## 参考\n- 《MYSQL实战45讲》\n\n","source":"_posts/mysql-log.md","raw":"---\ntitle: MySQL-binlog、redolog、undolog日志详解\ntags:\n  - mysql\ncategories:  mysql\ndescription : 一直不理解Mysql中binlog日志，redo日志，undo日志分别的作用。这篇文章主要介绍三种日志的作用，帮助理解\ndate: 2018-08-07 09:32:25\n---\n## MySQL三种重要的日志\nMySQL有三种重要的日志，分别是 binlog(归档日志)、redolog(重做日志)、redolog(撤销日志)。\n- binlog归档日志是数据库层面上的日志，主要用来做备份恢复和主从复制。\n- redolog重做日志是<font color=red>Innodb引擎层面上</font>的日志，主要用来保证数据的可靠性。<font color=red>用于故障恢复，实现事务的持久性机制</font>\n- undolog主要用于事务的回滚和MVCC 多版本并发控制。\n\n### binlog日志\nbinlog是MySQL数据库的二进制日志，用于记录用户<font color=red>对数据库操作的SQL语句</font>（(除了数据查询语句）信息。可以使用mysqlbin命令查看二进制日志的内容。\n\nbinlog的格式有三种：STATEMENT、ROW、MIXED 。可以通过my.conf来配置。\n\n```properties\n###binlog模式：ROW/STATEMENT/MIXED\nbinlog_format=ROW\n```\n\n- STATMENT模式(默认,语句模式)：基于SQL语句的复制，每一条会修改数据的sql语句会记录到binlog中。\n  - 优点，不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。\n  - 缺点，在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)\n- ROW模式(行模式)：基于行的复制，不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了\n  - 优点，不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题\n  - 会产生大量的日志\n- Mixed模式(混合模式)：以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式\n\n**binlog写入机制**\n\n![](mysql-log/2.png)\n\nbinlog日志在事务没有提交之前会想写入到binlog cache中， 每个线程都有一个binlog cache。在事务提交后才会一次性写入到文件系统的缓存file page中。\n\n然后mysql会根据你的sync_binlog配置决定是否马上刷新到磁盘中。\n\n- sync_binlog=0 的时候，表示每次提交事务都只 write到file page中，不 fsync到磁盘；\n- sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；\n- sync_binlog=N(N>1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。\n\n**可以通过如下命令查看binlog_cache_size大小**\n\n```\nshow variables like 'binlog_cache_size';\n```\n\n**验证binlog_cache_size设置是否合理**\n\n```\nmysql> show global status like 'binlog_cache_%';\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| Binlog_cache_disk_use | 1008  | #记录了使用临时文件写二进制日志的次数，越小越好\n| Binlog_cache_use      | 5721  | #使用缓冲的次数。越小越好\n+-----------------------+-------+\n2 rows in set (0.00 sec)\n```\n\n\n\n### redo日志\n\n上面我们说binlog是归档日志，开启后每次数据库执行了修改数据的语句都会被记录，<font color=red>那既然有了binlog日志，为啥还要有redo日志呢</font>？\n\n这里我们先了解一下一条更新语句是如何执行的？\n\n#### 一条更新语句的执行流程\n\n![更新语句执行过程](mysql-log/1.png)\n\n1. 执行器先找存储引擎(Innodb)取 ID=2 这一行，如果ID=2这一行所在的页不在内存中就从磁盘上读取所在页到内存然后返回给执行器，如果已经在内存则直接返回（<font color=red>MySQL最小存储单位是页，所以即使只是一条数据也是将所在页加载到内存</font>）\n2. 执行器拿到存储引擎给的行数据后执行修改操作并返回给存储引擎。\n3. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redolog 里面，此时 redolog 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。\n4. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。\n5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状\n态，更新完成。\n\n从上面的逻辑可以看出，当事务提交以后，MySQL是先将变化更新到内存然后在合适的时间把变化更新到磁盘，这样的设计主要是为了提高效率，毕竟每时每刻操作磁盘IO和查找成本都很高。假设在事务提交后变化写到了内存中，<font color=red>此时MySQL机器宕机了那就会导致提交后的事务数据丢失。</font> <font color=red>所以 redo日志是为了保证事务的持久性而存在的</font>。\n\n#### 为什么redolog就能保证事务的持久性机制?\nWAF（write ahead log）：当事务提交时，先写redo log，再修改页（这里的页，就是缓冲池中的数据页、索引页）。具体来说就是 ，<font color=red>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</font>。\n所以当事务提交后就会记录redo日志，在事务提交后但还没更新到磁盘此时MySQL宕机了，就可以通过redo日志进行恢复，保证了事务的持久性。\n\n#### redo日志特点\nInnoDB 的 redo log 是<font color=red>固定大小</font>（可以通过innodb_log_file_size参数指定大小）的。数据会<font color=red>从头开始写,写到末尾就又回到开头循环写</font>。\n\n在事务运行过程中，会不断地产生 redo log，这些 redo log 会先定入 redo log buffer(<font color=red>buffer可以认为是内存</font>)中，然后再将 redo log buffer 中的数据以某些方式顺序地写入到磁盘（各个操作的redo log 汇总到 redo log buffer，再由 redo log buffer 统一写磁盘，就能做到顺序写了）。这些方式有：\n- MySQL master 线程周期性任务 每秒一次，将 redo log buffer 刷新到磁盘(即使这个事务尚未提交)\n- MySQL master 线程周期性任务 每10秒一次，将 redo log buffer 刷新到磁盘\n- 当redo log buffer size 剩余空间小于1/2时(innodb_log_buffer_size参数)，将 redo log buffer 刷新到磁盘\n- 当 redo log file 大小已经达到某个域值快要\"不可用\"时（日志文件组轮流写文件），触发 async/sync flush checkpoint，及时将一些脏页刷新到磁盘，并同时将redo log buffer刷新到磁盘，然后更新redo log file 相应的 log sequence number值\n\n#### redo日志重要参数\nredo log buffer 的刷新到磁盘的时机由参数 <font color=red>innodb_flush_log_at_trx_commit</font> 参数控制，可取的值有：0、1、2\n- 0 : 表示每次事务提交时都只是把redo log留在 redo log buffer 中。此时可能你提交事务了，结果mysql宕机了，然后此时内存里的数据全部丢失。\n- 1 : 表示每次事务提交时都将redo log直接持久化到磁盘，只要事务提交成功，那么 redo log 就必然在磁盘里了\n- 2 : 提交事务的时候，把 redo 日志写入磁盘文件对应的 os cache 缓存里去，而不是直接进入磁盘文件，可能 1 秒后才会把 os cache 里的数据写入到磁盘文件里去\n\n可以看到，<font color=red>只有1才能真正地保证事务的持久性</font>，但是由于刷新操作 fsync() 是阻塞的，直到完成后才返回，我们知道写磁盘的速度是很慢的，因此 MySQL 的性能会明显地下降。如果不在乎事务丢失，0和2能获得更高的性能。\n\n### binlog日志和redo日志区别\n- redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\n- redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\n- redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。\n\n### undo日志\n简单来说，undo日志有两个作用：提供回滚和多个行版本控制(MVCC)。\nundolog是<font color=red>逻辑日志</font>。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。\n\n## 参考\n- 《MYSQL实战45讲》\n\n","slug":"mysql-log","published":1,"updated":"2021-04-08T00:47:06.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvf0022qwv2gwed7t7d","content":"<h2 id=\"MySQL三种重要的日志\"><a href=\"#MySQL三种重要的日志\" class=\"headerlink\" title=\"MySQL三种重要的日志\"></a>MySQL三种重要的日志</h2><p>MySQL有三种重要的日志，分别是 binlog(归档日志)、redolog(重做日志)、redolog(撤销日志)。</p>\n<ul>\n<li>binlog归档日志是数据库层面上的日志，主要用来做备份恢复和主从复制。</li>\n<li>redolog重做日志是<font color=\"red\">Innodb引擎层面上</font>的日志，主要用来保证数据的可靠性。<font color=\"red\">用于故障恢复，实现事务的持久性机制</font></li>\n<li>undolog主要用于事务的回滚和MVCC 多版本并发控制。</li>\n</ul>\n<h3 id=\"binlog日志\"><a href=\"#binlog日志\" class=\"headerlink\" title=\"binlog日志\"></a>binlog日志</h3><p>binlog是MySQL数据库的二进制日志，用于记录用户<font color=\"red\">对数据库操作的SQL语句</font>（(除了数据查询语句）信息。可以使用mysqlbin命令查看二进制日志的内容。</p>\n<p>binlog的格式有三种：STATEMENT、ROW、MIXED 。可以通过my.conf来配置。</p>\n<pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\">###binlog模式：ROW/STATEMENT/MIXED</span>\n<span class=\"token attr-name\">binlog_format</span><span class=\"token punctuation\">=</span><span class=\"token attr-value\">ROW</span></code></pre>\n<ul>\n<li>STATMENT模式(默认,语句模式)：基于SQL语句的复制，每一条会修改数据的sql语句会记录到binlog中。<ul>\n<li>优点，不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。</li>\n<li>缺点，在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)</li>\n</ul>\n</li>\n<li>ROW模式(行模式)：基于行的复制，不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了<ul>\n<li>优点，不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题</li>\n<li>会产生大量的日志</li>\n</ul>\n</li>\n<li>Mixed模式(混合模式)：以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式</li>\n</ul>\n<p><strong>binlog写入机制</strong></p>\n<p><img src=\"/2018/08/07/mysql-log/2.png\" alt></p>\n<p>binlog日志在事务没有提交之前会想写入到binlog cache中， 每个线程都有一个binlog cache。在事务提交后才会一次性写入到文件系统的缓存file page中。</p>\n<p>然后mysql会根据你的sync_binlog配置决定是否马上刷新到磁盘中。</p>\n<ul>\n<li>sync_binlog=0 的时候，表示每次提交事务都只 write到file page中，不 fsync到磁盘；</li>\n<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>\n<li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>\n</ul>\n<p><strong>可以通过如下命令查看binlog_cache_size大小</strong></p>\n<pre><code>show variables like &#39;binlog_cache_size&#39;;</code></pre><p><strong>验证binlog_cache_size设置是否合理</strong></p>\n<pre><code>mysql&gt; show global status like &#39;binlog_cache_%&#39;;\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| Binlog_cache_disk_use | 1008  | #记录了使用临时文件写二进制日志的次数，越小越好\n| Binlog_cache_use      | 5721  | #使用缓冲的次数。越小越好\n+-----------------------+-------+\n2 rows in set (0.00 sec)</code></pre><h3 id=\"redo日志\"><a href=\"#redo日志\" class=\"headerlink\" title=\"redo日志\"></a>redo日志</h3><p>上面我们说binlog是归档日志，开启后每次数据库执行了修改数据的语句都会被记录，<font color=\"red\">那既然有了binlog日志，为啥还要有redo日志呢</font>？</p>\n<p>这里我们先了解一下一条更新语句是如何执行的？</p>\n<h4 id=\"一条更新语句的执行流程\"><a href=\"#一条更新语句的执行流程\" class=\"headerlink\" title=\"一条更新语句的执行流程\"></a>一条更新语句的执行流程</h4><p><img src=\"/2018/08/07/mysql-log/1.png\" alt=\"更新语句执行过程\"></p>\n<ol>\n<li>执行器先找存储引擎(Innodb)取 ID=2 这一行，如果ID=2这一行所在的页不在内存中就从磁盘上读取所在页到内存然后返回给执行器，如果已经在内存则直接返回（<font color=\"red\">MySQL最小存储单位是页，所以即使只是一条数据也是将所在页加载到内存</font>）</li>\n<li>执行器拿到存储引擎给的行数据后执行修改操作并返回给存储引擎。</li>\n<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redolog 里面，此时 redolog 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>\n<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>\n<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状<br>态，更新完成。</li>\n</ol>\n<p>从上面的逻辑可以看出，当事务提交以后，MySQL是先将变化更新到内存然后在合适的时间把变化更新到磁盘，这样的设计主要是为了提高效率，毕竟每时每刻操作磁盘IO和查找成本都很高。假设在事务提交后变化写到了内存中，<font color=\"red\">此时MySQL机器宕机了那就会导致提交后的事务数据丢失。</font> <font color=\"red\">所以 redo日志是为了保证事务的持久性而存在的</font>。</p>\n<h4 id=\"为什么redolog就能保证事务的持久性机制\"><a href=\"#为什么redolog就能保证事务的持久性机制\" class=\"headerlink\" title=\"为什么redolog就能保证事务的持久性机制?\"></a>为什么redolog就能保证事务的持久性机制?</h4><p>WAF（write ahead log）：当事务提交时，先写redo log，再修改页（这里的页，就是缓冲池中的数据页、索引页）。具体来说就是 ，<font color=\"red\">当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</font>。<br>所以当事务提交后就会记录redo日志，在事务提交后但还没更新到磁盘此时MySQL宕机了，就可以通过redo日志进行恢复，保证了事务的持久性。</p>\n<h4 id=\"redo日志特点\"><a href=\"#redo日志特点\" class=\"headerlink\" title=\"redo日志特点\"></a>redo日志特点</h4><p>InnoDB 的 redo log 是<font color=\"red\">固定大小</font>（可以通过innodb_log_file_size参数指定大小）的。数据会<font color=\"red\">从头开始写,写到末尾就又回到开头循环写</font>。</p>\n<p>在事务运行过程中，会不断地产生 redo log，这些 redo log 会先定入 redo log buffer(<font color=\"red\">buffer可以认为是内存</font>)中，然后再将 redo log buffer 中的数据以某些方式顺序地写入到磁盘（各个操作的redo log 汇总到 redo log buffer，再由 redo log buffer 统一写磁盘，就能做到顺序写了）。这些方式有：</p>\n<ul>\n<li>MySQL master 线程周期性任务 每秒一次，将 redo log buffer 刷新到磁盘(即使这个事务尚未提交)</li>\n<li>MySQL master 线程周期性任务 每10秒一次，将 redo log buffer 刷新到磁盘</li>\n<li>当redo log buffer size 剩余空间小于1/2时(innodb_log_buffer_size参数)，将 redo log buffer 刷新到磁盘</li>\n<li>当 redo log file 大小已经达到某个域值快要”不可用”时（日志文件组轮流写文件），触发 async/sync flush checkpoint，及时将一些脏页刷新到磁盘，并同时将redo log buffer刷新到磁盘，然后更新redo log file 相应的 log sequence number值</li>\n</ul>\n<h4 id=\"redo日志重要参数\"><a href=\"#redo日志重要参数\" class=\"headerlink\" title=\"redo日志重要参数\"></a>redo日志重要参数</h4><p>redo log buffer 的刷新到磁盘的时机由参数 <font color=\"red\">innodb_flush_log_at_trx_commit</font> 参数控制，可取的值有：0、1、2</p>\n<ul>\n<li>0 : 表示每次事务提交时都只是把redo log留在 redo log buffer 中。此时可能你提交事务了，结果mysql宕机了，然后此时内存里的数据全部丢失。</li>\n<li>1 : 表示每次事务提交时都将redo log直接持久化到磁盘，只要事务提交成功，那么 redo log 就必然在磁盘里了</li>\n<li>2 : 提交事务的时候，把 redo 日志写入磁盘文件对应的 os cache 缓存里去，而不是直接进入磁盘文件，可能 1 秒后才会把 os cache 里的数据写入到磁盘文件里去</li>\n</ul>\n<p>可以看到，<font color=\"red\">只有1才能真正地保证事务的持久性</font>，但是由于刷新操作 fsync() 是阻塞的，直到完成后才返回，我们知道写磁盘的速度是很慢的，因此 MySQL 的性能会明显地下降。如果不在乎事务丢失，0和2能获得更高的性能。</p>\n<h3 id=\"binlog日志和redo日志区别\"><a href=\"#binlog日志和redo日志区别\" class=\"headerlink\" title=\"binlog日志和redo日志区别\"></a>binlog日志和redo日志区别</h3><ul>\n<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>\n<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>\n<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。</li>\n</ul>\n<h3 id=\"undo日志\"><a href=\"#undo日志\" class=\"headerlink\" title=\"undo日志\"></a>undo日志</h3><p>简单来说，undo日志有两个作用：提供回滚和多个行版本控制(MVCC)。<br>undolog是<font color=\"red\">逻辑日志</font>。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《MYSQL实战45讲》</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"MySQL三种重要的日志\"><a href=\"#MySQL三种重要的日志\" class=\"headerlink\" title=\"MySQL三种重要的日志\"></a>MySQL三种重要的日志</h2><p>MySQL有三种重要的日志，分别是 binlog(归档日志)、redolog(重做日志)、redolog(撤销日志)。</p>\n<ul>\n<li>binlog归档日志是数据库层面上的日志，主要用来做备份恢复和主从复制。</li>\n<li>redolog重做日志是<font color=\"red\">Innodb引擎层面上</font>的日志，主要用来保证数据的可靠性。<font color=\"red\">用于故障恢复，实现事务的持久性机制</font></li>\n<li>undolog主要用于事务的回滚和MVCC 多版本并发控制。</li>\n</ul>\n<h3 id=\"binlog日志\"><a href=\"#binlog日志\" class=\"headerlink\" title=\"binlog日志\"></a>binlog日志</h3><p>binlog是MySQL数据库的二进制日志，用于记录用户<font color=\"red\">对数据库操作的SQL语句</font>（(除了数据查询语句）信息。可以使用mysqlbin命令查看二进制日志的内容。</p>\n<p>binlog的格式有三种：STATEMENT、ROW、MIXED 。可以通过my.conf来配置。</p>\n<pre><code class=\"properties\">###binlog模式：ROW/STATEMENT/MIXED\nbinlog_format=ROW</code></pre>\n<ul>\n<li>STATMENT模式(默认,语句模式)：基于SQL语句的复制，每一条会修改数据的sql语句会记录到binlog中。<ul>\n<li>优点，不需要记录每一条SQL语句与每行的数据变化，这样子binlog的日志也会比较少，减少了磁盘IO，提高性能。</li>\n<li>缺点，在某些情况下会导致master-slave中的数据不一致(如sleep()函数， last_insert_id()，以及user-defined functions(udf)等会出现问题)</li>\n</ul>\n</li>\n<li>ROW模式(行模式)：基于行的复制，不记录每一条SQL语句的上下文信息，仅需记录哪条数据被修改了，修改成了什么样子了<ul>\n<li>优点，不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题</li>\n<li>会产生大量的日志</li>\n</ul>\n</li>\n<li>Mixed模式(混合模式)：以上两种模式的混合使用，一般的复制使用STATEMENT模式保存binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择日志保存方式</li>\n</ul>\n<p><strong>binlog写入机制</strong></p>\n<p><img src=\"/2018/08/07/mysql-log/2.png\" alt></p>\n<p>binlog日志在事务没有提交之前会想写入到binlog cache中， 每个线程都有一个binlog cache。在事务提交后才会一次性写入到文件系统的缓存file page中。</p>\n<p>然后mysql会根据你的sync_binlog配置决定是否马上刷新到磁盘中。</p>\n<ul>\n<li>sync_binlog=0 的时候，表示每次提交事务都只 write到file page中，不 fsync到磁盘；</li>\n<li>sync_binlog=1 的时候，表示每次提交事务都会执行 fsync；</li>\n<li>sync_binlog=N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>\n</ul>\n<p><strong>可以通过如下命令查看binlog_cache_size大小</strong></p>\n<pre><code>show variables like &#39;binlog_cache_size&#39;;</code></pre><p><strong>验证binlog_cache_size设置是否合理</strong></p>\n<pre><code>mysql&gt; show global status like &#39;binlog_cache_%&#39;;\n+-----------------------+-------+\n| Variable_name         | Value |\n+-----------------------+-------+\n| Binlog_cache_disk_use | 1008  | #记录了使用临时文件写二进制日志的次数，越小越好\n| Binlog_cache_use      | 5721  | #使用缓冲的次数。越小越好\n+-----------------------+-------+\n2 rows in set (0.00 sec)</code></pre><h3 id=\"redo日志\"><a href=\"#redo日志\" class=\"headerlink\" title=\"redo日志\"></a>redo日志</h3><p>上面我们说binlog是归档日志，开启后每次数据库执行了修改数据的语句都会被记录，<font color=\"red\">那既然有了binlog日志，为啥还要有redo日志呢</font>？</p>\n<p>这里我们先了解一下一条更新语句是如何执行的？</p>\n<h4 id=\"一条更新语句的执行流程\"><a href=\"#一条更新语句的执行流程\" class=\"headerlink\" title=\"一条更新语句的执行流程\"></a>一条更新语句的执行流程</h4><p><img src=\"/2018/08/07/mysql-log/1.png\" alt=\"更新语句执行过程\"></p>\n<ol>\n<li>执行器先找存储引擎(Innodb)取 ID=2 这一行，如果ID=2这一行所在的页不在内存中就从磁盘上读取所在页到内存然后返回给执行器，如果已经在内存则直接返回（<font color=\"red\">MySQL最小存储单位是页，所以即使只是一条数据也是将所在页加载到内存</font>）</li>\n<li>执行器拿到存储引擎给的行数据后执行修改操作并返回给存储引擎。</li>\n<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redolog 里面，此时 redolog 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>\n<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>\n<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状<br>态，更新完成。</li>\n</ol>\n<p>从上面的逻辑可以看出，当事务提交以后，MySQL是先将变化更新到内存然后在合适的时间把变化更新到磁盘，这样的设计主要是为了提高效率，毕竟每时每刻操作磁盘IO和查找成本都很高。假设在事务提交后变化写到了内存中，<font color=\"red\">此时MySQL机器宕机了那就会导致提交后的事务数据丢失。</font> <font color=\"red\">所以 redo日志是为了保证事务的持久性而存在的</font>。</p>\n<h4 id=\"为什么redolog就能保证事务的持久性机制\"><a href=\"#为什么redolog就能保证事务的持久性机制\" class=\"headerlink\" title=\"为什么redolog就能保证事务的持久性机制?\"></a>为什么redolog就能保证事务的持久性机制?</h4><p>WAF（write ahead log）：当事务提交时，先写redo log，再修改页（这里的页，就是缓冲池中的数据页、索引页）。具体来说就是 ，<font color=\"red\">当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做</font>。<br>所以当事务提交后就会记录redo日志，在事务提交后但还没更新到磁盘此时MySQL宕机了，就可以通过redo日志进行恢复，保证了事务的持久性。</p>\n<h4 id=\"redo日志特点\"><a href=\"#redo日志特点\" class=\"headerlink\" title=\"redo日志特点\"></a>redo日志特点</h4><p>InnoDB 的 redo log 是<font color=\"red\">固定大小</font>（可以通过innodb_log_file_size参数指定大小）的。数据会<font color=\"red\">从头开始写,写到末尾就又回到开头循环写</font>。</p>\n<p>在事务运行过程中，会不断地产生 redo log，这些 redo log 会先定入 redo log buffer(<font color=\"red\">buffer可以认为是内存</font>)中，然后再将 redo log buffer 中的数据以某些方式顺序地写入到磁盘（各个操作的redo log 汇总到 redo log buffer，再由 redo log buffer 统一写磁盘，就能做到顺序写了）。这些方式有：</p>\n<ul>\n<li>MySQL master 线程周期性任务 每秒一次，将 redo log buffer 刷新到磁盘(即使这个事务尚未提交)</li>\n<li>MySQL master 线程周期性任务 每10秒一次，将 redo log buffer 刷新到磁盘</li>\n<li>当redo log buffer size 剩余空间小于1/2时(innodb_log_buffer_size参数)，将 redo log buffer 刷新到磁盘</li>\n<li>当 redo log file 大小已经达到某个域值快要”不可用”时（日志文件组轮流写文件），触发 async/sync flush checkpoint，及时将一些脏页刷新到磁盘，并同时将redo log buffer刷新到磁盘，然后更新redo log file 相应的 log sequence number值</li>\n</ul>\n<h4 id=\"redo日志重要参数\"><a href=\"#redo日志重要参数\" class=\"headerlink\" title=\"redo日志重要参数\"></a>redo日志重要参数</h4><p>redo log buffer 的刷新到磁盘的时机由参数 <font color=\"red\">innodb_flush_log_at_trx_commit</font> 参数控制，可取的值有：0、1、2</p>\n<ul>\n<li>0 : 表示每次事务提交时都只是把redo log留在 redo log buffer 中。此时可能你提交事务了，结果mysql宕机了，然后此时内存里的数据全部丢失。</li>\n<li>1 : 表示每次事务提交时都将redo log直接持久化到磁盘，只要事务提交成功，那么 redo log 就必然在磁盘里了</li>\n<li>2 : 提交事务的时候，把 redo 日志写入磁盘文件对应的 os cache 缓存里去，而不是直接进入磁盘文件，可能 1 秒后才会把 os cache 里的数据写入到磁盘文件里去</li>\n</ul>\n<p>可以看到，<font color=\"red\">只有1才能真正地保证事务的持久性</font>，但是由于刷新操作 fsync() 是阻塞的，直到完成后才返回，我们知道写磁盘的速度是很慢的，因此 MySQL 的性能会明显地下降。如果不在乎事务丢失，0和2能获得更高的性能。</p>\n<h3 id=\"binlog日志和redo日志区别\"><a href=\"#binlog日志和redo日志区别\" class=\"headerlink\" title=\"binlog日志和redo日志区别\"></a>binlog日志和redo日志区别</h3><ul>\n<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>\n<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>\n<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。</li>\n</ul>\n<h3 id=\"undo日志\"><a href=\"#undo日志\" class=\"headerlink\" title=\"undo日志\"></a>undo日志</h3><p>简单来说，undo日志有两个作用：提供回滚和多个行版本控制(MVCC)。<br>undolog是<font color=\"red\">逻辑日志</font>。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《MYSQL实战45讲》</li>\n</ul>\n"},{"title":"Mysql-InnoDB索引之索引结构详解(一)","description":"Mysql-InnoDB索引详解(一)","date":"2019-07-18T02:00:00.000Z","_content":"\n## InnoDB数据页结构\n\n页是InnoDB管理存储空间的基本单位，一个页一般大小为16KB，我们的记录是存放到页中的。其中Infimum + Supremum记录的是最小最大记录。User Records是真实存储我们插入的记录部分。\n![InnoDB数据页结构](mysql-index/1.png)\n\n| 字段               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| File Header        | 表示页的一些通用信息，占固定的38字节                         |\n| Page Header        | 表示数据页专有的一些信息，占固定的56个字节                   |\n| Infimum + Supremum | 两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节 |\n| User Records       | 真实存储我们插入的记录的部分，大小不固定                     |\n| Free Space         | 页中尚未使使用的部分，大小不确定                             |\n| Page Directory     | 页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多 |\n| File Trailer       | 用于检验页是否完整的部分，占用固定的8个字节                  |\n\n**InnoDB页中的数据如何查找**\n\n![InnoDB页中数据](mysql-index/8.png)\n\n如上图，数据在InnoDB中按照主键顺序连成一个单链表（图上没画），然后使用了一个槽的概念将数据进行分组。<font color=red>所以在一个数据页中查找指定主键值的记录过程</font>如下：\n\n- 通过二分法确定该记录所在槽，并找到该槽中主键值最小的记录。\n- 通过记录的next_record（也就是指向下一个数据的指针）遍历该槽所在组的各个记录。\n\n![InnoDB页直接双向链表连接](mysql-index/2.png)\n\n- 页与页之间在存储上是不连续的，而是通过双向链表关联起来\n- 每个页只有16KB的大小\n- 每个数据页中的记录会按照主键值从到大的顺序组成一个单向链表\n\n## 索引\n### 没有索引怎么查找?\n索引类似我们书的目录，例如查字典，先通过目录确定要查的字所在页数，然后可以快速找到。如果没有目录则需要一页一页查找。\n```\nSELECT\t[列名列表]\tFROM\t表名\tWHERE\t列名\t=\txxx;\n```\n例如上面的语句，在没有索引的情况下，结合图我们可以知道。在没有索引的情况下，不论是根据主键列或者其他列的值进⾏查找，由于我们并不能快速的定位到记录所在的⻚，所以只能从第⼀个⻚沿着双向链表⼀直往下 找，**在每⼀个⻚中根据我们刚刚唠叨过的查找⽅式去查找指定的记录**。\n\n### InnoDB中的索引方案\n\n```sql\nCREATE TABLE `index_demo` (\n  `c1` int(11) NOT NULL,\n  `c2` int(11) DEFAULT NULL,\n  `c3` char(11) DEFAULT NULL,\n  PRIMARY KEY (`c1`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\nINSERT INTO index_demo VALUES(1,4,'u'),(3,9,'d'),(5,3,'y');\n....\n```\n\nInnoDB索引采用B+树做为索引。如下图所示。\n![](mysql-index/4.png)\n\n下面分别解释下图中的信息。\n\n**B+树叶子节点**\n\n![](mysql-index/5.png)\n\n- 第一行的 2 0 3 表示的是record_type(参考前面的头信息中的record_type属性，2-最小记录;3-最大记录;0-普通用户记录;1-目录项记录)\n- (1,4,u),(3,9,d),(4,4,a)表示的是用户记录。橙色方格表示主键，所以页中用户记录按照主键排序。\n- B+树索引叶子节点存放的是用户的数据页。每个数据页按照主键值排序并组成一个双向链表。\n\n**非叶子节点**\n\nB+树索引的非叶子节点作为目录页。\n\n![](mysql-index/6.png)\n- 第一行的 1 表示的是record_type(参考前面的头信息中的record_type属性，2-最小记录;3-最大记录;0-普通用户记录;1-目录项记录)\n- 橙色方格代表的是每一个数据页中最小的主键值。绿色表示对应的页。例如(1,10)目录项表示指向页10，页10的最小主键索引是1。\n- 目录页也遵循数据页的规则，按照主键值的大小排序，且形成一个双向链表\n\n**总结**\n\n从图中可以看出来，B+树的节点其实可以分成好多层。实际用户记录其实都存放在B+树的最底层的节点上。非最底层存放的是目录。假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录,那么\n\n- 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录\n- 如果B+树有2层，最多能存放1000×100=100000条记录\n- 如果B+树有3层，最多能存放1000×1000×100=100000000条记录\n- 如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录\n\n所以一般来说B+数索引不会超过4层。\n\n### 根据索引方案，如何快速查找到一条数据\n\n例如现在我们要查找主键为20的记录(在页9上)。\n- 首先先从根节点(页33)查找，由于主键是20，采用二分法查找(1,30)(320,32)判断，1 < 20 < 320。所以往下查找页30\n- 如法炮制，12 < 20 < 209，所以往下查找页9\n- 页9是最底层节点，存放的是实际用户记录。所以我们直接可以在页中通过二分查找法查到对应的主键为20的记录\n\n## 聚簇索引\n\n我们上边介绍的B+树本身就是一个目录，或者说本身就是一个索引,它有两个特点\n1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：\n  - 页内的记录是按照主键的大小顺序排成一个单向链表。\n  - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。\n  - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。\n2. B+树的叶子节点存储的是完整的用户记录\n\n我们把具有这两种特性的B+树称为**聚簇索引**，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使⽤INDEX 语句去创建，**InnoDB存储引擎会⾃动的为我们创建聚簇索引**。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的<font color=#FF0000 >索引即数据，数据即索引</font>。\n\n## 二级索引\n我们上面介绍的索引其实是**聚簇索引**，只有在有主键值的使用才发挥所用。因为B+树中的数据都是按照主键进⾏排序的。那如果我们想以别的列作为搜索条 件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？\n其实不是，InnoDB在我们创建一张表时会提示我们创建主键，其实就是为了生成聚簇索引，聚簇索引存储了所有的用户数据，就是所谓的数据即索引。但是我们可以为其他非主键创建索引。\n\n例如我们为c2创建索引，按照c2列的大小作为数据页，则创建的索引如下。\n\n![](mysql-index/7.png)\n\n**这个B+树与上边介绍的聚簇索引有几处不同：**\n\n1. 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：\n - 页内的记录是按照c2列的大小顺序排成一个单向链表。\n - 各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。\n - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表。\n2. B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值\n3. 目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配\n\n**如何通过二级索引查找数据？**\n\n```\nSELECT * FROM index_demo WHERE C2 = 4\n```\n1. 确定目录项记录页,根据根页面。也就是页44，可以快速定位到目录项记录所在的页为页42（因为2 < 4 < 9）\n2. 通过目录项记录页确定用户记录真实所在的也。在页42中可以快速定位到实际存储用户记录的也，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2 < 4 ≤ 4，所 以确定实际存储用户记录的页在页34和页35中\n3. 到页34和页35中定位到具体的记录\n4. 但是这个B+树的叶子节点中的记录只存储了c2和c1（也就是主键）两个列，所以**我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录**，这个再去查一次聚簇索引的方式叫做<font color=#FF0000 >回表</font>。\n\n## 联合索引\n\n联合索引的方式与二级索引差不多，例如以c2,c3作为联合索引。再索引的结构上就是按照c2先排序然后再排序c3。\n\n## 问答\n\n**为什么MySQL索引要用B+树而不用B-或者其他**\n\n先来说下B类树的特点，B类树的特点：<font color=red>每层节点数目非常多，层数很少</font>。关系数据库的数据量经常能达到亿级别，所以索引也是非常大，必须存储在磁盘上。我们在查找一个数据时，最好的情况就是很快找到目标索引，然后读取数据。为了能减少磁盘IO的次数，**B树类这种每层节点数目多，层数少的就非常适合，我们只要最多遍历3到4层就能找到结果。**例如使用红黑树，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。\n\nB+和B-的最大区别在于B-树的每一个节点都有一个data域，试想一下我们是怎么最终查到数据的。首先先从顶层的页上查找，那我们首先先要将这个页从磁盘通过IO加载到内存，**磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时**。所以B-树每个节点多了一个data域无疑就是我们能一次IO加载到内存的节点数就少了，那就要多次IO查询，固然会效率比B+树低。\n\n## 参考\n\n- 本文参考《MYSQL高性能》，《MySQL 是怎样运行的：从根儿上理解 MySQL》","source":"_posts/mysql-index.md","raw":"---\ntitle: Mysql-InnoDB索引之索引结构详解(一)\ntags:\n  - mysql\ncategories:  mysql\ndescription : Mysql-InnoDB索引详解(一)\ndate: 2019-07-18 10:00:00\n---\n\n## InnoDB数据页结构\n\n页是InnoDB管理存储空间的基本单位，一个页一般大小为16KB，我们的记录是存放到页中的。其中Infimum + Supremum记录的是最小最大记录。User Records是真实存储我们插入的记录部分。\n![InnoDB数据页结构](mysql-index/1.png)\n\n| 字段               | 说明                                                         |\n| ------------------ | ------------------------------------------------------------ |\n| File Header        | 表示页的一些通用信息，占固定的38字节                         |\n| Page Header        | 表示数据页专有的一些信息，占固定的56个字节                   |\n| Infimum + Supremum | 两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节 |\n| User Records       | 真实存储我们插入的记录的部分，大小不固定                     |\n| Free Space         | 页中尚未使使用的部分，大小不确定                             |\n| Page Directory     | 页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多 |\n| File Trailer       | 用于检验页是否完整的部分，占用固定的8个字节                  |\n\n**InnoDB页中的数据如何查找**\n\n![InnoDB页中数据](mysql-index/8.png)\n\n如上图，数据在InnoDB中按照主键顺序连成一个单链表（图上没画），然后使用了一个槽的概念将数据进行分组。<font color=red>所以在一个数据页中查找指定主键值的记录过程</font>如下：\n\n- 通过二分法确定该记录所在槽，并找到该槽中主键值最小的记录。\n- 通过记录的next_record（也就是指向下一个数据的指针）遍历该槽所在组的各个记录。\n\n![InnoDB页直接双向链表连接](mysql-index/2.png)\n\n- 页与页之间在存储上是不连续的，而是通过双向链表关联起来\n- 每个页只有16KB的大小\n- 每个数据页中的记录会按照主键值从到大的顺序组成一个单向链表\n\n## 索引\n### 没有索引怎么查找?\n索引类似我们书的目录，例如查字典，先通过目录确定要查的字所在页数，然后可以快速找到。如果没有目录则需要一页一页查找。\n```\nSELECT\t[列名列表]\tFROM\t表名\tWHERE\t列名\t=\txxx;\n```\n例如上面的语句，在没有索引的情况下，结合图我们可以知道。在没有索引的情况下，不论是根据主键列或者其他列的值进⾏查找，由于我们并不能快速的定位到记录所在的⻚，所以只能从第⼀个⻚沿着双向链表⼀直往下 找，**在每⼀个⻚中根据我们刚刚唠叨过的查找⽅式去查找指定的记录**。\n\n### InnoDB中的索引方案\n\n```sql\nCREATE TABLE `index_demo` (\n  `c1` int(11) NOT NULL,\n  `c2` int(11) DEFAULT NULL,\n  `c3` char(11) DEFAULT NULL,\n  PRIMARY KEY (`c1`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\nINSERT INTO index_demo VALUES(1,4,'u'),(3,9,'d'),(5,3,'y');\n....\n```\n\nInnoDB索引采用B+树做为索引。如下图所示。\n![](mysql-index/4.png)\n\n下面分别解释下图中的信息。\n\n**B+树叶子节点**\n\n![](mysql-index/5.png)\n\n- 第一行的 2 0 3 表示的是record_type(参考前面的头信息中的record_type属性，2-最小记录;3-最大记录;0-普通用户记录;1-目录项记录)\n- (1,4,u),(3,9,d),(4,4,a)表示的是用户记录。橙色方格表示主键，所以页中用户记录按照主键排序。\n- B+树索引叶子节点存放的是用户的数据页。每个数据页按照主键值排序并组成一个双向链表。\n\n**非叶子节点**\n\nB+树索引的非叶子节点作为目录页。\n\n![](mysql-index/6.png)\n- 第一行的 1 表示的是record_type(参考前面的头信息中的record_type属性，2-最小记录;3-最大记录;0-普通用户记录;1-目录项记录)\n- 橙色方格代表的是每一个数据页中最小的主键值。绿色表示对应的页。例如(1,10)目录项表示指向页10，页10的最小主键索引是1。\n- 目录页也遵循数据页的规则，按照主键值的大小排序，且形成一个双向链表\n\n**总结**\n\n从图中可以看出来，B+树的节点其实可以分成好多层。实际用户记录其实都存放在B+树的最底层的节点上。非最底层存放的是目录。假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录,那么\n\n- 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录\n- 如果B+树有2层，最多能存放1000×100=100000条记录\n- 如果B+树有3层，最多能存放1000×1000×100=100000000条记录\n- 如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录\n\n所以一般来说B+数索引不会超过4层。\n\n### 根据索引方案，如何快速查找到一条数据\n\n例如现在我们要查找主键为20的记录(在页9上)。\n- 首先先从根节点(页33)查找，由于主键是20，采用二分法查找(1,30)(320,32)判断，1 < 20 < 320。所以往下查找页30\n- 如法炮制，12 < 20 < 209，所以往下查找页9\n- 页9是最底层节点，存放的是实际用户记录。所以我们直接可以在页中通过二分查找法查到对应的主键为20的记录\n\n## 聚簇索引\n\n我们上边介绍的B+树本身就是一个目录，或者说本身就是一个索引,它有两个特点\n1. 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：\n  - 页内的记录是按照主键的大小顺序排成一个单向链表。\n  - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。\n  - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。\n2. B+树的叶子节点存储的是完整的用户记录\n\n我们把具有这两种特性的B+树称为**聚簇索引**，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使⽤INDEX 语句去创建，**InnoDB存储引擎会⾃动的为我们创建聚簇索引**。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的<font color=#FF0000 >索引即数据，数据即索引</font>。\n\n## 二级索引\n我们上面介绍的索引其实是**聚簇索引**，只有在有主键值的使用才发挥所用。因为B+树中的数据都是按照主键进⾏排序的。那如果我们想以别的列作为搜索条 件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？\n其实不是，InnoDB在我们创建一张表时会提示我们创建主键，其实就是为了生成聚簇索引，聚簇索引存储了所有的用户数据，就是所谓的数据即索引。但是我们可以为其他非主键创建索引。\n\n例如我们为c2创建索引，按照c2列的大小作为数据页，则创建的索引如下。\n\n![](mysql-index/7.png)\n\n**这个B+树与上边介绍的聚簇索引有几处不同：**\n\n1. 使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：\n - 页内的记录是按照c2列的大小顺序排成一个单向链表。\n - 各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。\n - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表。\n2. B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值\n3. 目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配\n\n**如何通过二级索引查找数据？**\n\n```\nSELECT * FROM index_demo WHERE C2 = 4\n```\n1. 确定目录项记录页,根据根页面。也就是页44，可以快速定位到目录项记录所在的页为页42（因为2 < 4 < 9）\n2. 通过目录项记录页确定用户记录真实所在的也。在页42中可以快速定位到实际存储用户记录的也，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2 < 4 ≤ 4，所 以确定实际存储用户记录的页在页34和页35中\n3. 到页34和页35中定位到具体的记录\n4. 但是这个B+树的叶子节点中的记录只存储了c2和c1（也就是主键）两个列，所以**我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录**，这个再去查一次聚簇索引的方式叫做<font color=#FF0000 >回表</font>。\n\n## 联合索引\n\n联合索引的方式与二级索引差不多，例如以c2,c3作为联合索引。再索引的结构上就是按照c2先排序然后再排序c3。\n\n## 问答\n\n**为什么MySQL索引要用B+树而不用B-或者其他**\n\n先来说下B类树的特点，B类树的特点：<font color=red>每层节点数目非常多，层数很少</font>。关系数据库的数据量经常能达到亿级别，所以索引也是非常大，必须存储在磁盘上。我们在查找一个数据时，最好的情况就是很快找到目标索引，然后读取数据。为了能减少磁盘IO的次数，**B树类这种每层节点数目多，层数少的就非常适合，我们只要最多遍历3到4层就能找到结果。**例如使用红黑树，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。\n\nB+和B-的最大区别在于B-树的每一个节点都有一个data域，试想一下我们是怎么最终查到数据的。首先先从顶层的页上查找，那我们首先先要将这个页从磁盘通过IO加载到内存，**磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时**。所以B-树每个节点多了一个data域无疑就是我们能一次IO加载到内存的节点数就少了，那就要多次IO查询，固然会效率比B+树低。\n\n## 参考\n\n- 本文参考《MYSQL高性能》，《MySQL 是怎样运行的：从根儿上理解 MySQL》","slug":"mysql-index","published":1,"updated":"2021-04-08T00:47:06.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvg0026qwv29cdy8q8h","content":"<h2 id=\"InnoDB数据页结构\"><a href=\"#InnoDB数据页结构\" class=\"headerlink\" title=\"InnoDB数据页结构\"></a>InnoDB数据页结构</h2><p>页是InnoDB管理存储空间的基本单位，一个页一般大小为16KB，我们的记录是存放到页中的。其中Infimum + Supremum记录的是最小最大记录。User Records是真实存储我们插入的记录部分。<br><img src=\"/2019/07/18/mysql-index/1.png\" alt=\"InnoDB数据页结构\"></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File Header</td>\n<td>表示页的一些通用信息，占固定的38字节</td>\n</tr>\n<tr>\n<td>Page Header</td>\n<td>表示数据页专有的一些信息，占固定的56个字节</td>\n</tr>\n<tr>\n<td>Infimum + Supremum</td>\n<td>两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节</td>\n</tr>\n<tr>\n<td>User Records</td>\n<td>真实存储我们插入的记录的部分，大小不固定</td>\n</tr>\n<tr>\n<td>Free Space</td>\n<td>页中尚未使使用的部分，大小不确定</td>\n</tr>\n<tr>\n<td>Page Directory</td>\n<td>页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多</td>\n</tr>\n<tr>\n<td>File Trailer</td>\n<td>用于检验页是否完整的部分，占用固定的8个字节</td>\n</tr>\n</tbody></table>\n<p><strong>InnoDB页中的数据如何查找</strong></p>\n<p><img src=\"/2019/07/18/mysql-index/8.png\" alt=\"InnoDB页中数据\"></p>\n<p>如上图，数据在InnoDB中按照主键顺序连成一个单链表（图上没画），然后使用了一个槽的概念将数据进行分组。<font color=\"red\">所以在一个数据页中查找指定主键值的记录过程</font>如下：</p>\n<ul>\n<li>通过二分法确定该记录所在槽，并找到该槽中主键值最小的记录。</li>\n<li>通过记录的next_record（也就是指向下一个数据的指针）遍历该槽所在组的各个记录。</li>\n</ul>\n<p><img src=\"/2019/07/18/mysql-index/2.png\" alt=\"InnoDB页直接双向链表连接\"></p>\n<ul>\n<li>页与页之间在存储上是不连续的，而是通过双向链表关联起来</li>\n<li>每个页只有16KB的大小</li>\n<li>每个数据页中的记录会按照主键值从到大的顺序组成一个单向链表</li>\n</ul>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h3 id=\"没有索引怎么查找\"><a href=\"#没有索引怎么查找\" class=\"headerlink\" title=\"没有索引怎么查找?\"></a>没有索引怎么查找?</h3><p>索引类似我们书的目录，例如查字典，先通过目录确定要查的字所在页数，然后可以快速找到。如果没有目录则需要一页一页查找。</p>\n<pre><code>SELECT    [列名列表]    FROM    表名    WHERE    列名    =    xxx;</code></pre><p>例如上面的语句，在没有索引的情况下，结合图我们可以知道。在没有索引的情况下，不论是根据主键列或者其他列的值进⾏查找，由于我们并不能快速的定位到记录所在的⻚，所以只能从第⼀个⻚沿着双向链表⼀直往下 找，<strong>在每⼀个⻚中根据我们刚刚唠叨过的查找⽅式去查找指定的记录</strong>。</p>\n<h3 id=\"InnoDB中的索引方案\"><a href=\"#InnoDB中的索引方案\" class=\"headerlink\" title=\"InnoDB中的索引方案\"></a>InnoDB中的索引方案</h3><pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>index_demo<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">`</span><span class=\"token number\">c1</span><span class=\"token punctuation\">`</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span><span class=\"token number\">c2</span><span class=\"token punctuation\">`</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span><span class=\"token number\">c3</span><span class=\"token punctuation\">`</span> char<span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span><span class=\"token number\">c1</span><span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> index_demo <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token string\">'u'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">9</span><span class=\"token punctuation\">,</span><span class=\"token string\">'d'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token string\">'y'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre>\n<p>InnoDB索引采用B+树做为索引。如下图所示。<br><img src=\"/2019/07/18/mysql-index/4.png\" alt></p>\n<p>下面分别解释下图中的信息。</p>\n<p><strong>B+树叶子节点</strong></p>\n<p><img src=\"/2019/07/18/mysql-index/5.png\" alt></p>\n<ul>\n<li>第一行的 2 0 3 表示的是record_type(参考前面的头信息中的record_type属性，2-最小记录;3-最大记录;0-普通用户记录;1-目录项记录)</li>\n<li>(1,4,u),(3,9,d),(4,4,a)表示的是用户记录。橙色方格表示主键，所以页中用户记录按照主键排序。</li>\n<li>B+树索引叶子节点存放的是用户的数据页。每个数据页按照主键值排序并组成一个双向链表。</li>\n</ul>\n<p><strong>非叶子节点</strong></p>\n<p>B+树索引的非叶子节点作为目录页。</p>\n<p><img src=\"/2019/07/18/mysql-index/6.png\" alt></p>\n<ul>\n<li>第一行的 1 表示的是record_type(参考前面的头信息中的record_type属性，2-最小记录;3-最大记录;0-普通用户记录;1-目录项记录)</li>\n<li>橙色方格代表的是每一个数据页中最小的主键值。绿色表示对应的页。例如(1,10)目录项表示指向页10，页10的最小主键索引是1。</li>\n<li>目录页也遵循数据页的规则，按照主键值的大小排序，且形成一个双向链表</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>从图中可以看出来，B+树的节点其实可以分成好多层。实际用户记录其实都存放在B+树的最底层的节点上。非最底层存放的是目录。假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录,那么</p>\n<ul>\n<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录</li>\n<li>如果B+树有2层，最多能存放1000×100=100000条记录</li>\n<li>如果B+树有3层，最多能存放1000×1000×100=100000000条记录</li>\n<li>如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录</li>\n</ul>\n<p>所以一般来说B+数索引不会超过4层。</p>\n<h3 id=\"根据索引方案，如何快速查找到一条数据\"><a href=\"#根据索引方案，如何快速查找到一条数据\" class=\"headerlink\" title=\"根据索引方案，如何快速查找到一条数据\"></a>根据索引方案，如何快速查找到一条数据</h3><p>例如现在我们要查找主键为20的记录(在页9上)。</p>\n<ul>\n<li>首先先从根节点(页33)查找，由于主键是20，采用二分法查找(1,30)(320,32)判断，1 &lt; 20 &lt; 320。所以往下查找页30</li>\n<li>如法炮制，12 &lt; 20 &lt; 209，所以往下查找页9</li>\n<li>页9是最底层节点，存放的是实际用户记录。所以我们直接可以在页中通过二分查找法查到对应的主键为20的记录</li>\n</ul>\n<h2 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h2><p>我们上边介绍的B+树本身就是一个目录，或者说本身就是一个索引,它有两个特点</p>\n<ol>\n<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：<ul>\n<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>\n<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>\n<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>\n</ul>\n</li>\n<li>B+树的叶子节点存储的是完整的用户记录</li>\n</ol>\n<p>我们把具有这两种特性的B+树称为<strong>聚簇索引</strong>，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使⽤INDEX 语句去创建，<strong>InnoDB存储引擎会⾃动的为我们创建聚簇索引</strong>。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的<font color=\"#FF0000\">索引即数据，数据即索引</font>。</p>\n<h2 id=\"二级索引\"><a href=\"#二级索引\" class=\"headerlink\" title=\"二级索引\"></a>二级索引</h2><p>我们上面介绍的索引其实是<strong>聚簇索引</strong>，只有在有主键值的使用才发挥所用。因为B+树中的数据都是按照主键进⾏排序的。那如果我们想以别的列作为搜索条 件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？<br>其实不是，InnoDB在我们创建一张表时会提示我们创建主键，其实就是为了生成聚簇索引，聚簇索引存储了所有的用户数据，就是所谓的数据即索引。但是我们可以为其他非主键创建索引。</p>\n<p>例如我们为c2创建索引，按照c2列的大小作为数据页，则创建的索引如下。</p>\n<p><img src=\"/2019/07/18/mysql-index/7.png\" alt></p>\n<p><strong>这个B+树与上边介绍的聚簇索引有几处不同：</strong></p>\n<ol>\n<li>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：<ul>\n<li>页内的记录是按照c2列的大小顺序排成一个单向链表。</li>\n<li>各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。</li>\n<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表。</li>\n</ul>\n</li>\n<li>B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值</li>\n<li>目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配</li>\n</ol>\n<p><strong>如何通过二级索引查找数据？</strong></p>\n<pre><code>SELECT * FROM index_demo WHERE C2 = 4</code></pre><ol>\n<li>确定目录项记录页,根据根页面。也就是页44，可以快速定位到目录项记录所在的页为页42（因为2 &lt; 4 &lt; 9）</li>\n<li>通过目录项记录页确定用户记录真实所在的也。在页42中可以快速定位到实际存储用户记录的也，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4，所 以确定实际存储用户记录的页在页34和页35中</li>\n<li>到页34和页35中定位到具体的记录</li>\n<li>但是这个B+树的叶子节点中的记录只存储了c2和c1（也就是主键）两个列，所以<strong>我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录</strong>，这个再去查一次聚簇索引的方式叫做<font color=\"#FF0000\">回表</font>。</li>\n</ol>\n<h2 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h2><p>联合索引的方式与二级索引差不多，例如以c2,c3作为联合索引。再索引的结构上就是按照c2先排序然后再排序c3。</p>\n<h2 id=\"问答\"><a href=\"#问答\" class=\"headerlink\" title=\"问答\"></a>问答</h2><p><strong>为什么MySQL索引要用B+树而不用B-或者其他</strong></p>\n<p>先来说下B类树的特点，B类树的特点：<font color=\"red\">每层节点数目非常多，层数很少</font>。关系数据库的数据量经常能达到亿级别，所以索引也是非常大，必须存储在磁盘上。我们在查找一个数据时，最好的情况就是很快找到目标索引，然后读取数据。为了能减少磁盘IO的次数，<strong>B树类这种每层节点数目多，层数少的就非常适合，我们只要最多遍历3到4层就能找到结果。</strong>例如使用红黑树，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。</p>\n<p>B+和B-的最大区别在于B-树的每一个节点都有一个data域，试想一下我们是怎么最终查到数据的。首先先从顶层的页上查找，那我们首先先要将这个页从磁盘通过IO加载到内存，<strong>磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时</strong>。所以B-树每个节点多了一个data域无疑就是我们能一次IO加载到内存的节点数就少了，那就要多次IO查询，固然会效率比B+树低。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>本文参考《MYSQL高性能》，《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"InnoDB数据页结构\"><a href=\"#InnoDB数据页结构\" class=\"headerlink\" title=\"InnoDB数据页结构\"></a>InnoDB数据页结构</h2><p>页是InnoDB管理存储空间的基本单位，一个页一般大小为16KB，我们的记录是存放到页中的。其中Infimum + Supremum记录的是最小最大记录。User Records是真实存储我们插入的记录部分。<br><img src=\"/2019/07/18/mysql-index/1.png\" alt=\"InnoDB数据页结构\"></p>\n<table>\n<thead>\n<tr>\n<th>字段</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>File Header</td>\n<td>表示页的一些通用信息，占固定的38字节</td>\n</tr>\n<tr>\n<td>Page Header</td>\n<td>表示数据页专有的一些信息，占固定的56个字节</td>\n</tr>\n<tr>\n<td>Infimum + Supremum</td>\n<td>两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的26个字节</td>\n</tr>\n<tr>\n<td>User Records</td>\n<td>真实存储我们插入的记录的部分，大小不固定</td>\n</tr>\n<tr>\n<td>Free Space</td>\n<td>页中尚未使使用的部分，大小不确定</td>\n</tr>\n<tr>\n<td>Page Directory</td>\n<td>页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多</td>\n</tr>\n<tr>\n<td>File Trailer</td>\n<td>用于检验页是否完整的部分，占用固定的8个字节</td>\n</tr>\n</tbody></table>\n<p><strong>InnoDB页中的数据如何查找</strong></p>\n<p><img src=\"/2019/07/18/mysql-index/8.png\" alt=\"InnoDB页中数据\"></p>\n<p>如上图，数据在InnoDB中按照主键顺序连成一个单链表（图上没画），然后使用了一个槽的概念将数据进行分组。<font color=\"red\">所以在一个数据页中查找指定主键值的记录过程</font>如下：</p>\n<ul>\n<li>通过二分法确定该记录所在槽，并找到该槽中主键值最小的记录。</li>\n<li>通过记录的next_record（也就是指向下一个数据的指针）遍历该槽所在组的各个记录。</li>\n</ul>\n<p><img src=\"/2019/07/18/mysql-index/2.png\" alt=\"InnoDB页直接双向链表连接\"></p>\n<ul>\n<li>页与页之间在存储上是不连续的，而是通过双向链表关联起来</li>\n<li>每个页只有16KB的大小</li>\n<li>每个数据页中的记录会按照主键值从到大的顺序组成一个单向链表</li>\n</ul>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h3 id=\"没有索引怎么查找\"><a href=\"#没有索引怎么查找\" class=\"headerlink\" title=\"没有索引怎么查找?\"></a>没有索引怎么查找?</h3><p>索引类似我们书的目录，例如查字典，先通过目录确定要查的字所在页数，然后可以快速找到。如果没有目录则需要一页一页查找。</p>\n<pre><code>SELECT    [列名列表]    FROM    表名    WHERE    列名    =    xxx;</code></pre><p>例如上面的语句，在没有索引的情况下，结合图我们可以知道。在没有索引的情况下，不论是根据主键列或者其他列的值进⾏查找，由于我们并不能快速的定位到记录所在的⻚，所以只能从第⼀个⻚沿着双向链表⼀直往下 找，<strong>在每⼀个⻚中根据我们刚刚唠叨过的查找⽅式去查找指定的记录</strong>。</p>\n<h3 id=\"InnoDB中的索引方案\"><a href=\"#InnoDB中的索引方案\" class=\"headerlink\" title=\"InnoDB中的索引方案\"></a>InnoDB中的索引方案</h3><pre><code class=\"sql\">CREATE TABLE `index_demo` (\n  `c1` int(11) NOT NULL,\n  `c2` int(11) DEFAULT NULL,\n  `c3` char(11) DEFAULT NULL,\n  PRIMARY KEY (`c1`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\nINSERT INTO index_demo VALUES(1,4,&#39;u&#39;),(3,9,&#39;d&#39;),(5,3,&#39;y&#39;);\n....</code></pre>\n<p>InnoDB索引采用B+树做为索引。如下图所示。<br><img src=\"/2019/07/18/mysql-index/4.png\" alt></p>\n<p>下面分别解释下图中的信息。</p>\n<p><strong>B+树叶子节点</strong></p>\n<p><img src=\"/2019/07/18/mysql-index/5.png\" alt></p>\n<ul>\n<li>第一行的 2 0 3 表示的是record_type(参考前面的头信息中的record_type属性，2-最小记录;3-最大记录;0-普通用户记录;1-目录项记录)</li>\n<li>(1,4,u),(3,9,d),(4,4,a)表示的是用户记录。橙色方格表示主键，所以页中用户记录按照主键排序。</li>\n<li>B+树索引叶子节点存放的是用户的数据页。每个数据页按照主键值排序并组成一个双向链表。</li>\n</ul>\n<p><strong>非叶子节点</strong></p>\n<p>B+树索引的非叶子节点作为目录页。</p>\n<p><img src=\"/2019/07/18/mysql-index/6.png\" alt></p>\n<ul>\n<li>第一行的 1 表示的是record_type(参考前面的头信息中的record_type属性，2-最小记录;3-最大记录;0-普通用户记录;1-目录项记录)</li>\n<li>橙色方格代表的是每一个数据页中最小的主键值。绿色表示对应的页。例如(1,10)目录项表示指向页10，页10的最小主键索引是1。</li>\n<li>目录页也遵循数据页的规则，按照主键值的大小排序，且形成一个双向链表</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>从图中可以看出来，B+树的节点其实可以分成好多层。实际用户记录其实都存放在B+树的最底层的节点上。非最底层存放的是目录。假设所有存放用户记录的叶子节点代表的数据页可以存放100条用户记录，所有存放目录项记录的内节点代表的数据页可以存放1000条目录项记录,那么</p>\n<ul>\n<li>如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放100条记录</li>\n<li>如果B+树有2层，最多能存放1000×100=100000条记录</li>\n<li>如果B+树有3层，最多能存放1000×1000×100=100000000条记录</li>\n<li>如果B+树有4层，最多能存放1000×1000×1000×100=100000000000条记录</li>\n</ul>\n<p>所以一般来说B+数索引不会超过4层。</p>\n<h3 id=\"根据索引方案，如何快速查找到一条数据\"><a href=\"#根据索引方案，如何快速查找到一条数据\" class=\"headerlink\" title=\"根据索引方案，如何快速查找到一条数据\"></a>根据索引方案，如何快速查找到一条数据</h3><p>例如现在我们要查找主键为20的记录(在页9上)。</p>\n<ul>\n<li>首先先从根节点(页33)查找，由于主键是20，采用二分法查找(1,30)(320,32)判断，1 &lt; 20 &lt; 320。所以往下查找页30</li>\n<li>如法炮制，12 &lt; 20 &lt; 209，所以往下查找页9</li>\n<li>页9是最底层节点，存放的是实际用户记录。所以我们直接可以在页中通过二分查找法查到对应的主键为20的记录</li>\n</ul>\n<h2 id=\"聚簇索引\"><a href=\"#聚簇索引\" class=\"headerlink\" title=\"聚簇索引\"></a>聚簇索引</h2><p>我们上边介绍的B+树本身就是一个目录，或者说本身就是一个索引,它有两个特点</p>\n<ol>\n<li>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：<ul>\n<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>\n<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>\n<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>\n</ul>\n</li>\n<li>B+树的叶子节点存储的是完整的用户记录</li>\n</ol>\n<p>我们把具有这两种特性的B+树称为<strong>聚簇索引</strong>，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使⽤INDEX 语句去创建，<strong>InnoDB存储引擎会⾃动的为我们创建聚簇索引</strong>。另外有趣的一点是，在InnoDB存储引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的<font color=\"#FF0000\">索引即数据，数据即索引</font>。</p>\n<h2 id=\"二级索引\"><a href=\"#二级索引\" class=\"headerlink\" title=\"二级索引\"></a>二级索引</h2><p>我们上面介绍的索引其实是<strong>聚簇索引</strong>，只有在有主键值的使用才发挥所用。因为B+树中的数据都是按照主键进⾏排序的。那如果我们想以别的列作为搜索条 件该咋办呢？难道只能从头到尾沿着链表依次遍历记录么？<br>其实不是，InnoDB在我们创建一张表时会提示我们创建主键，其实就是为了生成聚簇索引，聚簇索引存储了所有的用户数据，就是所谓的数据即索引。但是我们可以为其他非主键创建索引。</p>\n<p>例如我们为c2创建索引，按照c2列的大小作为数据页，则创建的索引如下。</p>\n<p><img src=\"/2019/07/18/mysql-index/7.png\" alt></p>\n<p><strong>这个B+树与上边介绍的聚簇索引有几处不同：</strong></p>\n<ol>\n<li>使用记录c2列的大小进行记录和页的排序，这包括三个方面的含义：<ul>\n<li>页内的记录是按照c2列的大小顺序排成一个单向链表。</li>\n<li>各个存放用户记录的页也是根据页中记录的c2列大小顺序排成一个双向链表。</li>\n<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的c2列大小顺序排成一个双向链表。</li>\n</ul>\n</li>\n<li>B+树的叶子节点存储的并不是完整的用户记录，而只是c2列+主键这两个列的值</li>\n<li>目录项记录中不再是主键+页号的搭配，而变成了c2列+页号的搭配</li>\n</ol>\n<p><strong>如何通过二级索引查找数据？</strong></p>\n<pre><code>SELECT * FROM index_demo WHERE C2 = 4</code></pre><ol>\n<li>确定目录项记录页,根据根页面。也就是页44，可以快速定位到目录项记录所在的页为页42（因为2 &lt; 4 &lt; 9）</li>\n<li>通过目录项记录页确定用户记录真实所在的也。在页42中可以快速定位到实际存储用户记录的也，但是由于c2列并没有唯一性约束，所以c2列值为4的记录可能分布在多个数据页中，又因为2 &lt; 4 ≤ 4，所 以确定实际存储用户记录的页在页34和页35中</li>\n<li>到页34和页35中定位到具体的记录</li>\n<li>但是这个B+树的叶子节点中的记录只存储了c2和c1（也就是主键）两个列，所以<strong>我们必须再根据主键值去聚簇索引中再查找一遍完整的用户记录</strong>，这个再去查一次聚簇索引的方式叫做<font color=\"#FF0000\">回表</font>。</li>\n</ol>\n<h2 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h2><p>联合索引的方式与二级索引差不多，例如以c2,c3作为联合索引。再索引的结构上就是按照c2先排序然后再排序c3。</p>\n<h2 id=\"问答\"><a href=\"#问答\" class=\"headerlink\" title=\"问答\"></a>问答</h2><p><strong>为什么MySQL索引要用B+树而不用B-或者其他</strong></p>\n<p>先来说下B类树的特点，B类树的特点：<font color=\"red\">每层节点数目非常多，层数很少</font>。关系数据库的数据量经常能达到亿级别，所以索引也是非常大，必须存储在磁盘上。我们在查找一个数据时，最好的情况就是很快找到目标索引，然后读取数据。为了能减少磁盘IO的次数，<strong>B树类这种每层节点数目多，层数少的就非常适合，我们只要最多遍历3到4层就能找到结果。</strong>例如使用红黑树，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁，进而导致效率低下的情况。</p>\n<p>B+和B-的最大区别在于B-树的每一个节点都有一个data域，试想一下我们是怎么最终查到数据的。首先先从顶层的页上查找，那我们首先先要将这个页从磁盘通过IO加载到内存，<strong>磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时</strong>。所以B-树每个节点多了一个data域无疑就是我们能一次IO加载到内存的节点数就少了，那就要多次IO查询，固然会效率比B+树低。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>本文参考《MYSQL高性能》，《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>\n</ul>\n"},{"title":"记一次MySQL主从同步延迟排查","description":"记一次MySQL主从同步延迟排查和解决","date":"2020-08-19T07:25:29.000Z","_content":"\n## 问题分析和定位\n\n线上环境这几天在凌晨4点时报主从延迟。虽然我们项目对数据的时效性不是要求很高，但是出现了主从延迟肯定是哪个地方除了问题，为了保证稳定性需要排查一下问题原因。\n\n### 主从同步原理\n\n![](mysql-masterslave-solve/1.jpg)\n\n1. 主库对所有DDL和DML产生的日志写进binlog；\n2. 主库生成一个 log dump 线程，用来给从库I/O线程读取binlog；\n3. 从库的I/O Thread去请求主库的binlog，并将得到的binlog日志写到relay log文件中；\n4. 从库的SQL Thread会读取relay log文件中的日志解析成具体操作，将主库的DDL和DML操作事件重放。\n<!--more-->\n**详细过程**\n\n1. Slave上的IO进程连接到Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。\n2. Master接收到Slave的IO请求后，负责复制的进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息包括：**日志信息**，**Master的binlog文件名**，**本次返回的binlog的位置**\n3. Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端。并且**将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中**。\n4. Slave的SQL进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。\n\nSQL语言共分为四大类：查询语言DQL，控制语言DCL，操纵语言DML，定义语言DD\n\n- DQL：可以简单理解为SELECT语句；\n- DCL：GRANT、ROLLBACK和COMMIT一类语句；\n- DML：可以理解为CREATE一类的语句；\n- DDL：INSERT、UPDATE和DELETE语句都是；\n\n### 主从延迟可能原因\n从上面的原理分析，可以知道导致的原因可能是以下几种。\n- 网络原因。从库请求主库binlog延迟\n- 主库单位时间内产生DDL数量超过从库所能执行的范围\n- 从库执行大型的query语句导致锁表，从而导致执行同步过来的DDL语句延迟\n- 从库机器性能原因\n\n线上常见的事例：\n\n- 主机执行了大事务，例如在一个事务中通过delete操作删除了100w的数据，从机大概率会出现同步延迟\n- 主机执行了大量操作，比如主机的QPS从100升到1000，从机可能就会同步延迟\n- 从机上执行了耗时的操作，比如进行了OLAP【一种数据处理技bai术，专门设计用于支持复杂的分du析操作】查询，占用大量机器资源导致同步延迟\n- 从机上执行的操作长时间占用锁资源，导致同步操作等待，进而产生同步延迟\n- 从机配置不如主机，或者配置相同但数据库安装在错误的磁盘上，常见于主机数据库运行在SSD硬盘上，从机没有SSD硬盘或者从机数据库不在SSD硬盘上导致同步延迟\n\n个人觉得是<font color=red>主库单位时间内产生DDL数量超过从库所能执行的范围</font>这个原因比较大。所以从这开始排查。\n\n## 问题排查\n\n首先登录从库查看\n\n```\nmysql -h 从库IP -u 用户名 -p密码 -P 端口\n```\n\n```\n#执行查看主从同步情况\nshow slave status\\G;\n*************************** 1. row ***************************\n\t\t\t  #当前slave I/O状态\n               Slave_IO_State: Waiting for master to send event\n                  Master_Host: 主库IP\n                  Master_User: repl_user\n                  Master_Port: 主库端口\n                #重试时间，单位秒 默认60秒\n                Connect_Retry: 60\n              #当前I/O线程正在读取的主服务器二进制日志文件的名称\n              Master_Log_File: mysql-bin.000231\n          #同步读取二进制日志的位置，大于等于Exec_Master_Log_Pos\n          Read_Master_Log_Pos: 211281725\n          \t   #当前slave SQL线程正在读取并执行的relay log的文件名\n               Relay_Log_File: mysql-relay-bin.000230\n                #当前slave SQL线程正在读取并执行的relay log文件中的位置\n                Relay_Log_Pos: 10270447\n        Relay_Master_Log_File: mysql-bin.000231\n             Slave_IO_Running: Yes\n            Slave_SQL_Running: Yes\n              Replicate_Do_DB: wsportal\n          Replicate_Ignore_DB: \n           Replicate_Do_Table: \n       Replicate_Ignore_Table: \n      Replicate_Wild_Do_Table: \n  Replicate_Wild_Ignore_Table: root.domain_info,root.certificate\n                   Last_Errno: 0\n                   Last_Error: \n                 Skip_Counter: 0\n          #slave SQL线程当前执行的事件，对应在master相应的二进制日志中的position\n          Exec_Master_Log_Pos: 211281725\n              Relay_Log_Space: 10270667\n              Until_Condition: None\n               Until_Log_File: \n                Until_Log_Pos: 0\n           Master_SSL_Allowed: No\n           Master_SSL_CA_File: \n           Master_SSL_CA_Path: \n              Master_SSL_Cert: \n            Master_SSL_Cipher: \n               Master_SSL_Key: \n        #slave当前的时间戳和master记录该事件时的时间戳的差值\n        Seconds_Behind_Master: 0\nMaster_SSL_Verify_Server_Cert: No\n                Last_IO_Errno: 0\n                Last_IO_Error:\n                #代表最后一个执行的sql出错的原因\n               Last_SQL_Errno: 0\n               Last_SQL_Error: \n  Replicate_Ignore_Server_Ids: \n             Master_Server_Id: 12918051\n                  Master_UUID: 8ef54a4c-d0e5-11e7-aa5f-047d7bb918b6\n             Master_Info_File: mysql.slave_master_info\n                    SQL_Delay: 0\n          SQL_Remaining_Delay: NULL\n      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it\n           Master_Retry_Count: 86400\n                  Master_Bind: \n      Last_IO_Error_Timestamp: \n     Last_SQL_Error_Timestamp: \n               Master_SSL_Crl: \n           Master_SSL_Crlpath: \n           Retrieved_Gtid_Set: \n            Executed_Gtid_Set: \n                Auto_Position: 0\n```\n\n一般主从同步问题可以通过这几个点排查\n\n- Slave_IO_State 从库当前状态，用来判断从库是否断掉\n- Read_Master_Log_Pos 和 Exec_Master_Log_Pos  这个值如果相差太大表示主从出现了延迟\n- Seconds_Behind_Master 当前salve和master记录事件的时间戳，这个值如果越大证明延迟越严重\n\n**结合下原理和show slave status返回的结果来说明，大概流程是这样：**\n\n1. 从库先通过io线程读取主库的二进制文件（Master_Log_File）和位置（Read_Master_Log_Pos）然后缓存到本地（从库服务器）的中继文件（Relay_Log_File）中并记录已经读取到的位置（Relay_Log_Pos）。\n2. 再通过从库的sql线程去读取中继文件（Relay_Log_File），这个sql线程执行会记录已经执行到了哪个文（Relay_Master_Log_File）和哪个位置（Exec_Master_Log_Pos）。\n\n通过看show slave status发现一切正常，因为延迟是发生在凌晨4点。所以有可能的原因就是凌晨4点执行了大量的DDL导致的，之后恢复正常了。所以我们只能通过binlog日志查看凌晨4点时执行了什么语句。\n\n通过上面我们知道了从库是从主库的 mysql-bin.000231日志中同步过来的。所以看下这个binlog日志在凌晨4点时执行的所有DDL语句。\n\n导出主库上凌晨4:00~4:02的binlog日志。\n\n```\n#--base64-output=decode-rows -v 表示格式化DDL语句，因为binlog是二进制的\nmysqlbinlog --base64-output=decode-rows -v --start-datetime='2020-08-17 04:00:00' --stop-datetime='2020-08-17 04:02:00' -d wsportal mysql-bin.000231 > /home/xuzy/log/mysql_bin_231_4.log\n```\n\n```\ncat mysql_bin_231_4.log | grep 'INSERT' | wc -l\n结果 : 99412\ncat mysql_bin_231_4.log | grep 'INSERT' | grep 'dir_visit_report' | wc -l\n结果 : 43695\n```\n\n通过查看binlog日志，发现在2分钟内主库插入数据到表dir_visit_report一共执行了4万多次。感觉原因就是这个，然后继续查了下业务代码，发现是同事一个入库定时器写错了写成每天凌晨4点执行，其实是一个月执行一次，所以导致每天都报延迟。\n\n## 如何避免\n\n- 升级MySQL版本到5.7，使用并行复制\n- 升级Slave硬件配置\n- 优化网络\n- 业务上防止统一时间点大量更新操作\n- 修改binlog配置sync_binlog，innodb_flush_log_at_trx_commit (redo日志)\n- 使用混合模式复制的方式，通过binlog-format配置。项目上作者使用的是行模式，行模式的优点是能保证主从完全一致，但速度会比较慢。具体可以参考《[MYSQL中BINLOG_FORMAT的三种模式](https://www.cnblogs.com/xingyunfashi/p/8431780.html)》\n\n### sync_binlog\n\n- sync_binlog = 0 ，表示MySQL不控制binlog的刷新，由文件系统自己控制它的缓存的刷新\n\n- sync_binlog > 0 ，指定了两次刷新到磁盘的动作之间间隔多少次二进制日志写操作\n\n- sync_binlog = 1 ，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置\n\n### innodb_flush_log_at_trx_commit\n\n0 ： 提交事务的时候，不立即把 redo log buffer 里的数据刷入磁盘文件的，而是依靠 InnoDB 的主线程每秒执行一次刷新到磁盘\n\n1 ： 提交事务的时候，就必须把 redo log 从内存刷入到磁盘文件里去，只要事务提交成功，那么 redo log 就必然在磁盘里了\n\n2 ：提交事务的时候，把 redo 日志写入磁盘文件对应的 os cache 缓存里去，而不是直接进入磁盘文件，可能 1 秒后才会把 os cache 里的数据写入到磁盘文件里去\n\n## Mysql主从同步宕机恢复流程\n\n主从同步宕机是很常见的一种错误。下面分析几种情况的解决方法。\n\n### 从机宕机恢复\n\n丛机宕机后不在主节点获取数据入库，造成数据不一致。如果要让从机重新同步需要分两种情况：\n\n**从节点宕机时间短，主节点的binlog日志没变**\n\n这种情况下，假设从节点没宕机前是从主节点的mysqlmaster-bin.0010的binlog文件上同步数据，在我们发现从节点宕机后准备重新同步时，可以观察下当前时刻主节点是否还是使用mysqlmaster-bin.0010文件记录日志。如果是则可以直接重启从机的同步命令。\n\n这种情况下Mysql的从节点是可以知道从哪个Position开始同步出错的，所以主要重启就可以重新同步。\n\n```shell\nstart slave;\n```\n\n如何确定是否是同一个binlog。可以通过查看主节点和从节点当前使用的binlog信息。\n\n```\nmysql> show slave status\\G; #登陆从节点查看主从同步信息\nmysql> show master status;  #登陆主节点查看binlog信息\n```\n\n**从节点宕机时间长，主节点的binlog日志已变化**\n\n这种情况下从节点无法知道是从哪个binlog日志的哪个position上开始不执行同步的。这种情况下最好是**重新做同步**。步骤如下\n\n1. 对主库锁表 flush tables with read lock;\n2. 主库把数据备份到mysql.bak.sql文件（备份的时候可以指定重新刷新binlog文件,所以binlog文件就是最新的position很小）\n3. 从库导入mysql.bak.sql\n4. 从库重新设定同步\n\n```sql\nchange master to master_host = 'IP', master_user = 'root', master_port=3306, master_password='', master_log_file = 'mysqld-bin.000001', master_log_pos=3260;\n```","source":"_posts/mysql-masterslave-solve.md","raw":"---\ntitle: 记一次MySQL主从同步延迟排查\ntags:\n  - mysql\ncategories:  mysql\ndescription : 记一次MySQL主从同步延迟排查和解决\ndate: 2020-08-19 15:25:29\n---\n\n## 问题分析和定位\n\n线上环境这几天在凌晨4点时报主从延迟。虽然我们项目对数据的时效性不是要求很高，但是出现了主从延迟肯定是哪个地方除了问题，为了保证稳定性需要排查一下问题原因。\n\n### 主从同步原理\n\n![](mysql-masterslave-solve/1.jpg)\n\n1. 主库对所有DDL和DML产生的日志写进binlog；\n2. 主库生成一个 log dump 线程，用来给从库I/O线程读取binlog；\n3. 从库的I/O Thread去请求主库的binlog，并将得到的binlog日志写到relay log文件中；\n4. 从库的SQL Thread会读取relay log文件中的日志解析成具体操作，将主库的DDL和DML操作事件重放。\n<!--more-->\n**详细过程**\n\n1. Slave上的IO进程连接到Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。\n2. Master接收到Slave的IO请求后，负责复制的进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息包括：**日志信息**，**Master的binlog文件名**，**本次返回的binlog的位置**\n3. Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端。并且**将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中**。\n4. Slave的SQL进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。\n\nSQL语言共分为四大类：查询语言DQL，控制语言DCL，操纵语言DML，定义语言DD\n\n- DQL：可以简单理解为SELECT语句；\n- DCL：GRANT、ROLLBACK和COMMIT一类语句；\n- DML：可以理解为CREATE一类的语句；\n- DDL：INSERT、UPDATE和DELETE语句都是；\n\n### 主从延迟可能原因\n从上面的原理分析，可以知道导致的原因可能是以下几种。\n- 网络原因。从库请求主库binlog延迟\n- 主库单位时间内产生DDL数量超过从库所能执行的范围\n- 从库执行大型的query语句导致锁表，从而导致执行同步过来的DDL语句延迟\n- 从库机器性能原因\n\n线上常见的事例：\n\n- 主机执行了大事务，例如在一个事务中通过delete操作删除了100w的数据，从机大概率会出现同步延迟\n- 主机执行了大量操作，比如主机的QPS从100升到1000，从机可能就会同步延迟\n- 从机上执行了耗时的操作，比如进行了OLAP【一种数据处理技bai术，专门设计用于支持复杂的分du析操作】查询，占用大量机器资源导致同步延迟\n- 从机上执行的操作长时间占用锁资源，导致同步操作等待，进而产生同步延迟\n- 从机配置不如主机，或者配置相同但数据库安装在错误的磁盘上，常见于主机数据库运行在SSD硬盘上，从机没有SSD硬盘或者从机数据库不在SSD硬盘上导致同步延迟\n\n个人觉得是<font color=red>主库单位时间内产生DDL数量超过从库所能执行的范围</font>这个原因比较大。所以从这开始排查。\n\n## 问题排查\n\n首先登录从库查看\n\n```\nmysql -h 从库IP -u 用户名 -p密码 -P 端口\n```\n\n```\n#执行查看主从同步情况\nshow slave status\\G;\n*************************** 1. row ***************************\n\t\t\t  #当前slave I/O状态\n               Slave_IO_State: Waiting for master to send event\n                  Master_Host: 主库IP\n                  Master_User: repl_user\n                  Master_Port: 主库端口\n                #重试时间，单位秒 默认60秒\n                Connect_Retry: 60\n              #当前I/O线程正在读取的主服务器二进制日志文件的名称\n              Master_Log_File: mysql-bin.000231\n          #同步读取二进制日志的位置，大于等于Exec_Master_Log_Pos\n          Read_Master_Log_Pos: 211281725\n          \t   #当前slave SQL线程正在读取并执行的relay log的文件名\n               Relay_Log_File: mysql-relay-bin.000230\n                #当前slave SQL线程正在读取并执行的relay log文件中的位置\n                Relay_Log_Pos: 10270447\n        Relay_Master_Log_File: mysql-bin.000231\n             Slave_IO_Running: Yes\n            Slave_SQL_Running: Yes\n              Replicate_Do_DB: wsportal\n          Replicate_Ignore_DB: \n           Replicate_Do_Table: \n       Replicate_Ignore_Table: \n      Replicate_Wild_Do_Table: \n  Replicate_Wild_Ignore_Table: root.domain_info,root.certificate\n                   Last_Errno: 0\n                   Last_Error: \n                 Skip_Counter: 0\n          #slave SQL线程当前执行的事件，对应在master相应的二进制日志中的position\n          Exec_Master_Log_Pos: 211281725\n              Relay_Log_Space: 10270667\n              Until_Condition: None\n               Until_Log_File: \n                Until_Log_Pos: 0\n           Master_SSL_Allowed: No\n           Master_SSL_CA_File: \n           Master_SSL_CA_Path: \n              Master_SSL_Cert: \n            Master_SSL_Cipher: \n               Master_SSL_Key: \n        #slave当前的时间戳和master记录该事件时的时间戳的差值\n        Seconds_Behind_Master: 0\nMaster_SSL_Verify_Server_Cert: No\n                Last_IO_Errno: 0\n                Last_IO_Error:\n                #代表最后一个执行的sql出错的原因\n               Last_SQL_Errno: 0\n               Last_SQL_Error: \n  Replicate_Ignore_Server_Ids: \n             Master_Server_Id: 12918051\n                  Master_UUID: 8ef54a4c-d0e5-11e7-aa5f-047d7bb918b6\n             Master_Info_File: mysql.slave_master_info\n                    SQL_Delay: 0\n          SQL_Remaining_Delay: NULL\n      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it\n           Master_Retry_Count: 86400\n                  Master_Bind: \n      Last_IO_Error_Timestamp: \n     Last_SQL_Error_Timestamp: \n               Master_SSL_Crl: \n           Master_SSL_Crlpath: \n           Retrieved_Gtid_Set: \n            Executed_Gtid_Set: \n                Auto_Position: 0\n```\n\n一般主从同步问题可以通过这几个点排查\n\n- Slave_IO_State 从库当前状态，用来判断从库是否断掉\n- Read_Master_Log_Pos 和 Exec_Master_Log_Pos  这个值如果相差太大表示主从出现了延迟\n- Seconds_Behind_Master 当前salve和master记录事件的时间戳，这个值如果越大证明延迟越严重\n\n**结合下原理和show slave status返回的结果来说明，大概流程是这样：**\n\n1. 从库先通过io线程读取主库的二进制文件（Master_Log_File）和位置（Read_Master_Log_Pos）然后缓存到本地（从库服务器）的中继文件（Relay_Log_File）中并记录已经读取到的位置（Relay_Log_Pos）。\n2. 再通过从库的sql线程去读取中继文件（Relay_Log_File），这个sql线程执行会记录已经执行到了哪个文（Relay_Master_Log_File）和哪个位置（Exec_Master_Log_Pos）。\n\n通过看show slave status发现一切正常，因为延迟是发生在凌晨4点。所以有可能的原因就是凌晨4点执行了大量的DDL导致的，之后恢复正常了。所以我们只能通过binlog日志查看凌晨4点时执行了什么语句。\n\n通过上面我们知道了从库是从主库的 mysql-bin.000231日志中同步过来的。所以看下这个binlog日志在凌晨4点时执行的所有DDL语句。\n\n导出主库上凌晨4:00~4:02的binlog日志。\n\n```\n#--base64-output=decode-rows -v 表示格式化DDL语句，因为binlog是二进制的\nmysqlbinlog --base64-output=decode-rows -v --start-datetime='2020-08-17 04:00:00' --stop-datetime='2020-08-17 04:02:00' -d wsportal mysql-bin.000231 > /home/xuzy/log/mysql_bin_231_4.log\n```\n\n```\ncat mysql_bin_231_4.log | grep 'INSERT' | wc -l\n结果 : 99412\ncat mysql_bin_231_4.log | grep 'INSERT' | grep 'dir_visit_report' | wc -l\n结果 : 43695\n```\n\n通过查看binlog日志，发现在2分钟内主库插入数据到表dir_visit_report一共执行了4万多次。感觉原因就是这个，然后继续查了下业务代码，发现是同事一个入库定时器写错了写成每天凌晨4点执行，其实是一个月执行一次，所以导致每天都报延迟。\n\n## 如何避免\n\n- 升级MySQL版本到5.7，使用并行复制\n- 升级Slave硬件配置\n- 优化网络\n- 业务上防止统一时间点大量更新操作\n- 修改binlog配置sync_binlog，innodb_flush_log_at_trx_commit (redo日志)\n- 使用混合模式复制的方式，通过binlog-format配置。项目上作者使用的是行模式，行模式的优点是能保证主从完全一致，但速度会比较慢。具体可以参考《[MYSQL中BINLOG_FORMAT的三种模式](https://www.cnblogs.com/xingyunfashi/p/8431780.html)》\n\n### sync_binlog\n\n- sync_binlog = 0 ，表示MySQL不控制binlog的刷新，由文件系统自己控制它的缓存的刷新\n\n- sync_binlog > 0 ，指定了两次刷新到磁盘的动作之间间隔多少次二进制日志写操作\n\n- sync_binlog = 1 ，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置\n\n### innodb_flush_log_at_trx_commit\n\n0 ： 提交事务的时候，不立即把 redo log buffer 里的数据刷入磁盘文件的，而是依靠 InnoDB 的主线程每秒执行一次刷新到磁盘\n\n1 ： 提交事务的时候，就必须把 redo log 从内存刷入到磁盘文件里去，只要事务提交成功，那么 redo log 就必然在磁盘里了\n\n2 ：提交事务的时候，把 redo 日志写入磁盘文件对应的 os cache 缓存里去，而不是直接进入磁盘文件，可能 1 秒后才会把 os cache 里的数据写入到磁盘文件里去\n\n## Mysql主从同步宕机恢复流程\n\n主从同步宕机是很常见的一种错误。下面分析几种情况的解决方法。\n\n### 从机宕机恢复\n\n丛机宕机后不在主节点获取数据入库，造成数据不一致。如果要让从机重新同步需要分两种情况：\n\n**从节点宕机时间短，主节点的binlog日志没变**\n\n这种情况下，假设从节点没宕机前是从主节点的mysqlmaster-bin.0010的binlog文件上同步数据，在我们发现从节点宕机后准备重新同步时，可以观察下当前时刻主节点是否还是使用mysqlmaster-bin.0010文件记录日志。如果是则可以直接重启从机的同步命令。\n\n这种情况下Mysql的从节点是可以知道从哪个Position开始同步出错的，所以主要重启就可以重新同步。\n\n```shell\nstart slave;\n```\n\n如何确定是否是同一个binlog。可以通过查看主节点和从节点当前使用的binlog信息。\n\n```\nmysql> show slave status\\G; #登陆从节点查看主从同步信息\nmysql> show master status;  #登陆主节点查看binlog信息\n```\n\n**从节点宕机时间长，主节点的binlog日志已变化**\n\n这种情况下从节点无法知道是从哪个binlog日志的哪个position上开始不执行同步的。这种情况下最好是**重新做同步**。步骤如下\n\n1. 对主库锁表 flush tables with read lock;\n2. 主库把数据备份到mysql.bak.sql文件（备份的时候可以指定重新刷新binlog文件,所以binlog文件就是最新的position很小）\n3. 从库导入mysql.bak.sql\n4. 从库重新设定同步\n\n```sql\nchange master to master_host = 'IP', master_user = 'root', master_port=3306, master_password='', master_log_file = 'mysqld-bin.000001', master_log_pos=3260;\n```","slug":"mysql-masterslave-solve","published":1,"updated":"2021-04-08T00:47:06.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvh0029qwv21eef5q0l","content":"<h2 id=\"问题分析和定位\"><a href=\"#问题分析和定位\" class=\"headerlink\" title=\"问题分析和定位\"></a>问题分析和定位</h2><p>线上环境这几天在凌晨4点时报主从延迟。虽然我们项目对数据的时效性不是要求很高，但是出现了主从延迟肯定是哪个地方除了问题，为了保证稳定性需要排查一下问题原因。</p>\n<h3 id=\"主从同步原理\"><a href=\"#主从同步原理\" class=\"headerlink\" title=\"主从同步原理\"></a>主从同步原理</h3><p><img src=\"/2020/08/19/mysql-masterslave-solve/1.jpg\" alt></p>\n<ol>\n<li>主库对所有DDL和DML产生的日志写进binlog；</li>\n<li>主库生成一个 log dump 线程，用来给从库I/O线程读取binlog；</li>\n<li>从库的I/O Thread去请求主库的binlog，并将得到的binlog日志写到relay log文件中；</li>\n<li>从库的SQL Thread会读取relay log文件中的日志解析成具体操作，将主库的DDL和DML操作事件重放。<a id=\"more\"></a></li>\n</ol>\n<p><strong>详细过程</strong></p>\n<ol>\n<li>Slave上的IO进程连接到Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。</li>\n<li>Master接收到Slave的IO请求后，负责复制的进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息包括：<strong>日志信息</strong>，<strong>Master的binlog文件名</strong>，<strong>本次返回的binlog的位置</strong></li>\n<li>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端。并且<strong>将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中</strong>。</li>\n<li>Slave的SQL进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。</li>\n</ol>\n<p>SQL语言共分为四大类：查询语言DQL，控制语言DCL，操纵语言DML，定义语言DD</p>\n<ul>\n<li>DQL：可以简单理解为SELECT语句；</li>\n<li>DCL：GRANT、ROLLBACK和COMMIT一类语句；</li>\n<li>DML：可以理解为CREATE一类的语句；</li>\n<li>DDL：INSERT、UPDATE和DELETE语句都是；</li>\n</ul>\n<h3 id=\"主从延迟可能原因\"><a href=\"#主从延迟可能原因\" class=\"headerlink\" title=\"主从延迟可能原因\"></a>主从延迟可能原因</h3><p>从上面的原理分析，可以知道导致的原因可能是以下几种。</p>\n<ul>\n<li>网络原因。从库请求主库binlog延迟</li>\n<li>主库单位时间内产生DDL数量超过从库所能执行的范围</li>\n<li>从库执行大型的query语句导致锁表，从而导致执行同步过来的DDL语句延迟</li>\n<li>从库机器性能原因</li>\n</ul>\n<p>线上常见的事例：</p>\n<ul>\n<li>主机执行了大事务，例如在一个事务中通过delete操作删除了100w的数据，从机大概率会出现同步延迟</li>\n<li>主机执行了大量操作，比如主机的QPS从100升到1000，从机可能就会同步延迟</li>\n<li>从机上执行了耗时的操作，比如进行了OLAP【一种数据处理技bai术，专门设计用于支持复杂的分du析操作】查询，占用大量机器资源导致同步延迟</li>\n<li>从机上执行的操作长时间占用锁资源，导致同步操作等待，进而产生同步延迟</li>\n<li>从机配置不如主机，或者配置相同但数据库安装在错误的磁盘上，常见于主机数据库运行在SSD硬盘上，从机没有SSD硬盘或者从机数据库不在SSD硬盘上导致同步延迟</li>\n</ul>\n<p>个人觉得是<font color=\"red\">主库单位时间内产生DDL数量超过从库所能执行的范围</font>这个原因比较大。所以从这开始排查。</p>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><p>首先登录从库查看</p>\n<pre><code>mysql -h 从库IP -u 用户名 -p密码 -P 端口</code></pre><pre><code>#执行查看主从同步情况\nshow slave status\\G;\n*************************** 1. row ***************************\n              #当前slave I/O状态\n               Slave_IO_State: Waiting for master to send event\n                  Master_Host: 主库IP\n                  Master_User: repl_user\n                  Master_Port: 主库端口\n                #重试时间，单位秒 默认60秒\n                Connect_Retry: 60\n              #当前I/O线程正在读取的主服务器二进制日志文件的名称\n              Master_Log_File: mysql-bin.000231\n          #同步读取二进制日志的位置，大于等于Exec_Master_Log_Pos\n          Read_Master_Log_Pos: 211281725\n                 #当前slave SQL线程正在读取并执行的relay log的文件名\n               Relay_Log_File: mysql-relay-bin.000230\n                #当前slave SQL线程正在读取并执行的relay log文件中的位置\n                Relay_Log_Pos: 10270447\n        Relay_Master_Log_File: mysql-bin.000231\n             Slave_IO_Running: Yes\n            Slave_SQL_Running: Yes\n              Replicate_Do_DB: wsportal\n          Replicate_Ignore_DB: \n           Replicate_Do_Table: \n       Replicate_Ignore_Table: \n      Replicate_Wild_Do_Table: \n  Replicate_Wild_Ignore_Table: root.domain_info,root.certificate\n                   Last_Errno: 0\n                   Last_Error: \n                 Skip_Counter: 0\n          #slave SQL线程当前执行的事件，对应在master相应的二进制日志中的position\n          Exec_Master_Log_Pos: 211281725\n              Relay_Log_Space: 10270667\n              Until_Condition: None\n               Until_Log_File: \n                Until_Log_Pos: 0\n           Master_SSL_Allowed: No\n           Master_SSL_CA_File: \n           Master_SSL_CA_Path: \n              Master_SSL_Cert: \n            Master_SSL_Cipher: \n               Master_SSL_Key: \n        #slave当前的时间戳和master记录该事件时的时间戳的差值\n        Seconds_Behind_Master: 0\nMaster_SSL_Verify_Server_Cert: No\n                Last_IO_Errno: 0\n                Last_IO_Error:\n                #代表最后一个执行的sql出错的原因\n               Last_SQL_Errno: 0\n               Last_SQL_Error: \n  Replicate_Ignore_Server_Ids: \n             Master_Server_Id: 12918051\n                  Master_UUID: 8ef54a4c-d0e5-11e7-aa5f-047d7bb918b6\n             Master_Info_File: mysql.slave_master_info\n                    SQL_Delay: 0\n          SQL_Remaining_Delay: NULL\n      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it\n           Master_Retry_Count: 86400\n                  Master_Bind: \n      Last_IO_Error_Timestamp: \n     Last_SQL_Error_Timestamp: \n               Master_SSL_Crl: \n           Master_SSL_Crlpath: \n           Retrieved_Gtid_Set: \n            Executed_Gtid_Set: \n                Auto_Position: 0</code></pre><p>一般主从同步问题可以通过这几个点排查</p>\n<ul>\n<li>Slave_IO_State 从库当前状态，用来判断从库是否断掉</li>\n<li>Read_Master_Log_Pos 和 Exec_Master_Log_Pos  这个值如果相差太大表示主从出现了延迟</li>\n<li>Seconds_Behind_Master 当前salve和master记录事件的时间戳，这个值如果越大证明延迟越严重</li>\n</ul>\n<p><strong>结合下原理和show slave status返回的结果来说明，大概流程是这样：</strong></p>\n<ol>\n<li>从库先通过io线程读取主库的二进制文件（Master_Log_File）和位置（Read_Master_Log_Pos）然后缓存到本地（从库服务器）的中继文件（Relay_Log_File）中并记录已经读取到的位置（Relay_Log_Pos）。</li>\n<li>再通过从库的sql线程去读取中继文件（Relay_Log_File），这个sql线程执行会记录已经执行到了哪个文（Relay_Master_Log_File）和哪个位置（Exec_Master_Log_Pos）。</li>\n</ol>\n<p>通过看show slave status发现一切正常，因为延迟是发生在凌晨4点。所以有可能的原因就是凌晨4点执行了大量的DDL导致的，之后恢复正常了。所以我们只能通过binlog日志查看凌晨4点时执行了什么语句。</p>\n<p>通过上面我们知道了从库是从主库的 mysql-bin.000231日志中同步过来的。所以看下这个binlog日志在凌晨4点时执行的所有DDL语句。</p>\n<p>导出主库上凌晨4:00~4:02的binlog日志。</p>\n<pre><code>#--base64-output=decode-rows -v 表示格式化DDL语句，因为binlog是二进制的\nmysqlbinlog --base64-output=decode-rows -v --start-datetime=&#39;2020-08-17 04:00:00&#39; --stop-datetime=&#39;2020-08-17 04:02:00&#39; -d wsportal mysql-bin.000231 &gt; /home/xuzy/log/mysql_bin_231_4.log</code></pre><pre><code>cat mysql_bin_231_4.log | grep &#39;INSERT&#39; | wc -l\n结果 : 99412\ncat mysql_bin_231_4.log | grep &#39;INSERT&#39; | grep &#39;dir_visit_report&#39; | wc -l\n结果 : 43695</code></pre><p>通过查看binlog日志，发现在2分钟内主库插入数据到表dir_visit_report一共执行了4万多次。感觉原因就是这个，然后继续查了下业务代码，发现是同事一个入库定时器写错了写成每天凌晨4点执行，其实是一个月执行一次，所以导致每天都报延迟。</p>\n<h2 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h2><ul>\n<li>升级MySQL版本到5.7，使用并行复制</li>\n<li>升级Slave硬件配置</li>\n<li>优化网络</li>\n<li>业务上防止统一时间点大量更新操作</li>\n<li>修改binlog配置sync_binlog，innodb_flush_log_at_trx_commit (redo日志)</li>\n<li>使用混合模式复制的方式，通过binlog-format配置。项目上作者使用的是行模式，行模式的优点是能保证主从完全一致，但速度会比较慢。具体可以参考《<a href=\"https://www.cnblogs.com/xingyunfashi/p/8431780.html\" target=\"_blank\" rel=\"noopener\">MYSQL中BINLOG_FORMAT的三种模式</a>》</li>\n</ul>\n<h3 id=\"sync-binlog\"><a href=\"#sync-binlog\" class=\"headerlink\" title=\"sync_binlog\"></a>sync_binlog</h3><ul>\n<li><p>sync_binlog = 0 ，表示MySQL不控制binlog的刷新，由文件系统自己控制它的缓存的刷新</p>\n</li>\n<li><p>sync_binlog &gt; 0 ，指定了两次刷新到磁盘的动作之间间隔多少次二进制日志写操作</p>\n</li>\n<li><p>sync_binlog = 1 ，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置</p>\n</li>\n</ul>\n<h3 id=\"innodb-flush-log-at-trx-commit\"><a href=\"#innodb-flush-log-at-trx-commit\" class=\"headerlink\" title=\"innodb_flush_log_at_trx_commit\"></a>innodb_flush_log_at_trx_commit</h3><p>0 ： 提交事务的时候，不立即把 redo log buffer 里的数据刷入磁盘文件的，而是依靠 InnoDB 的主线程每秒执行一次刷新到磁盘</p>\n<p>1 ： 提交事务的时候，就必须把 redo log 从内存刷入到磁盘文件里去，只要事务提交成功，那么 redo log 就必然在磁盘里了</p>\n<p>2 ：提交事务的时候，把 redo 日志写入磁盘文件对应的 os cache 缓存里去，而不是直接进入磁盘文件，可能 1 秒后才会把 os cache 里的数据写入到磁盘文件里去</p>\n<h2 id=\"Mysql主从同步宕机恢复流程\"><a href=\"#Mysql主从同步宕机恢复流程\" class=\"headerlink\" title=\"Mysql主从同步宕机恢复流程\"></a>Mysql主从同步宕机恢复流程</h2><p>主从同步宕机是很常见的一种错误。下面分析几种情况的解决方法。</p>\n<h3 id=\"从机宕机恢复\"><a href=\"#从机宕机恢复\" class=\"headerlink\" title=\"从机宕机恢复\"></a>从机宕机恢复</h3><p>丛机宕机后不在主节点获取数据入库，造成数据不一致。如果要让从机重新同步需要分两种情况：</p>\n<p><strong>从节点宕机时间短，主节点的binlog日志没变</strong></p>\n<p>这种情况下，假设从节点没宕机前是从主节点的mysqlmaster-bin.0010的binlog文件上同步数据，在我们发现从节点宕机后准备重新同步时，可以观察下当前时刻主节点是否还是使用mysqlmaster-bin.0010文件记录日志。如果是则可以直接重启从机的同步命令。</p>\n<p>这种情况下Mysql的从节点是可以知道从哪个Position开始同步出错的，所以主要重启就可以重新同步。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">start slave;</code></pre>\n<p>如何确定是否是同一个binlog。可以通过查看主节点和从节点当前使用的binlog信息。</p>\n<pre><code>mysql&gt; show slave status\\G; #登陆从节点查看主从同步信息\nmysql&gt; show master status;  #登陆主节点查看binlog信息</code></pre><p><strong>从节点宕机时间长，主节点的binlog日志已变化</strong></p>\n<p>这种情况下从节点无法知道是从哪个binlog日志的哪个position上开始不执行同步的。这种情况下最好是<strong>重新做同步</strong>。步骤如下</p>\n<ol>\n<li>对主库锁表 flush tables with read lock;</li>\n<li>主库把数据备份到mysql.bak.sql文件（备份的时候可以指定重新刷新binlog文件,所以binlog文件就是最新的position很小）</li>\n<li>从库导入mysql.bak.sql</li>\n<li>从库重新设定同步</li>\n</ol>\n<pre class=\" language-sql\"><code class=\"language-sql\">change master <span class=\"token keyword\">to</span> master_host <span class=\"token operator\">=</span> <span class=\"token string\">'IP'</span><span class=\"token punctuation\">,</span> master_user <span class=\"token operator\">=</span> <span class=\"token string\">'root'</span><span class=\"token punctuation\">,</span> master_port<span class=\"token operator\">=</span><span class=\"token number\">3306</span><span class=\"token punctuation\">,</span> master_password<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> master_log_file <span class=\"token operator\">=</span> <span class=\"token string\">'mysqld-bin.000001'</span><span class=\"token punctuation\">,</span> master_log_pos<span class=\"token operator\">=</span><span class=\"token number\">3260</span><span class=\"token punctuation\">;</span></code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"问题分析和定位\"><a href=\"#问题分析和定位\" class=\"headerlink\" title=\"问题分析和定位\"></a>问题分析和定位</h2><p>线上环境这几天在凌晨4点时报主从延迟。虽然我们项目对数据的时效性不是要求很高，但是出现了主从延迟肯定是哪个地方除了问题，为了保证稳定性需要排查一下问题原因。</p>\n<h3 id=\"主从同步原理\"><a href=\"#主从同步原理\" class=\"headerlink\" title=\"主从同步原理\"></a>主从同步原理</h3><p><img src=\"/2020/08/19/mysql-masterslave-solve/1.jpg\" alt></p>\n<ol>\n<li>主库对所有DDL和DML产生的日志写进binlog；</li>\n<li>主库生成一个 log dump 线程，用来给从库I/O线程读取binlog；</li>\n<li>从库的I/O Thread去请求主库的binlog，并将得到的binlog日志写到relay log文件中；</li>\n<li>从库的SQL Thread会读取relay log文件中的日志解析成具体操作，将主库的DDL和DML操作事件重放。</li></ol>","more":"\n\n<p><strong>详细过程</strong></p>\n<ol>\n<li>Slave上的IO进程连接到Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。</li>\n<li>Master接收到Slave的IO请求后，负责复制的进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息包括：<strong>日志信息</strong>，<strong>Master的binlog文件名</strong>，<strong>本次返回的binlog的位置</strong></li>\n<li>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端。并且<strong>将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中</strong>。</li>\n<li>Slave的SQL进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。</li>\n</ol>\n<p>SQL语言共分为四大类：查询语言DQL，控制语言DCL，操纵语言DML，定义语言DD</p>\n<ul>\n<li>DQL：可以简单理解为SELECT语句；</li>\n<li>DCL：GRANT、ROLLBACK和COMMIT一类语句；</li>\n<li>DML：可以理解为CREATE一类的语句；</li>\n<li>DDL：INSERT、UPDATE和DELETE语句都是；</li>\n</ul>\n<h3 id=\"主从延迟可能原因\"><a href=\"#主从延迟可能原因\" class=\"headerlink\" title=\"主从延迟可能原因\"></a>主从延迟可能原因</h3><p>从上面的原理分析，可以知道导致的原因可能是以下几种。</p>\n<ul>\n<li>网络原因。从库请求主库binlog延迟</li>\n<li>主库单位时间内产生DDL数量超过从库所能执行的范围</li>\n<li>从库执行大型的query语句导致锁表，从而导致执行同步过来的DDL语句延迟</li>\n<li>从库机器性能原因</li>\n</ul>\n<p>线上常见的事例：</p>\n<ul>\n<li>主机执行了大事务，例如在一个事务中通过delete操作删除了100w的数据，从机大概率会出现同步延迟</li>\n<li>主机执行了大量操作，比如主机的QPS从100升到1000，从机可能就会同步延迟</li>\n<li>从机上执行了耗时的操作，比如进行了OLAP【一种数据处理技bai术，专门设计用于支持复杂的分du析操作】查询，占用大量机器资源导致同步延迟</li>\n<li>从机上执行的操作长时间占用锁资源，导致同步操作等待，进而产生同步延迟</li>\n<li>从机配置不如主机，或者配置相同但数据库安装在错误的磁盘上，常见于主机数据库运行在SSD硬盘上，从机没有SSD硬盘或者从机数据库不在SSD硬盘上导致同步延迟</li>\n</ul>\n<p>个人觉得是<font color=\"red\">主库单位时间内产生DDL数量超过从库所能执行的范围</font>这个原因比较大。所以从这开始排查。</p>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><p>首先登录从库查看</p>\n<pre><code>mysql -h 从库IP -u 用户名 -p密码 -P 端口</code></pre><pre><code>#执行查看主从同步情况\nshow slave status\\G;\n*************************** 1. row ***************************\n              #当前slave I/O状态\n               Slave_IO_State: Waiting for master to send event\n                  Master_Host: 主库IP\n                  Master_User: repl_user\n                  Master_Port: 主库端口\n                #重试时间，单位秒 默认60秒\n                Connect_Retry: 60\n              #当前I/O线程正在读取的主服务器二进制日志文件的名称\n              Master_Log_File: mysql-bin.000231\n          #同步读取二进制日志的位置，大于等于Exec_Master_Log_Pos\n          Read_Master_Log_Pos: 211281725\n                 #当前slave SQL线程正在读取并执行的relay log的文件名\n               Relay_Log_File: mysql-relay-bin.000230\n                #当前slave SQL线程正在读取并执行的relay log文件中的位置\n                Relay_Log_Pos: 10270447\n        Relay_Master_Log_File: mysql-bin.000231\n             Slave_IO_Running: Yes\n            Slave_SQL_Running: Yes\n              Replicate_Do_DB: wsportal\n          Replicate_Ignore_DB: \n           Replicate_Do_Table: \n       Replicate_Ignore_Table: \n      Replicate_Wild_Do_Table: \n  Replicate_Wild_Ignore_Table: root.domain_info,root.certificate\n                   Last_Errno: 0\n                   Last_Error: \n                 Skip_Counter: 0\n          #slave SQL线程当前执行的事件，对应在master相应的二进制日志中的position\n          Exec_Master_Log_Pos: 211281725\n              Relay_Log_Space: 10270667\n              Until_Condition: None\n               Until_Log_File: \n                Until_Log_Pos: 0\n           Master_SSL_Allowed: No\n           Master_SSL_CA_File: \n           Master_SSL_CA_Path: \n              Master_SSL_Cert: \n            Master_SSL_Cipher: \n               Master_SSL_Key: \n        #slave当前的时间戳和master记录该事件时的时间戳的差值\n        Seconds_Behind_Master: 0\nMaster_SSL_Verify_Server_Cert: No\n                Last_IO_Errno: 0\n                Last_IO_Error:\n                #代表最后一个执行的sql出错的原因\n               Last_SQL_Errno: 0\n               Last_SQL_Error: \n  Replicate_Ignore_Server_Ids: \n             Master_Server_Id: 12918051\n                  Master_UUID: 8ef54a4c-d0e5-11e7-aa5f-047d7bb918b6\n             Master_Info_File: mysql.slave_master_info\n                    SQL_Delay: 0\n          SQL_Remaining_Delay: NULL\n      Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it\n           Master_Retry_Count: 86400\n                  Master_Bind: \n      Last_IO_Error_Timestamp: \n     Last_SQL_Error_Timestamp: \n               Master_SSL_Crl: \n           Master_SSL_Crlpath: \n           Retrieved_Gtid_Set: \n            Executed_Gtid_Set: \n                Auto_Position: 0</code></pre><p>一般主从同步问题可以通过这几个点排查</p>\n<ul>\n<li>Slave_IO_State 从库当前状态，用来判断从库是否断掉</li>\n<li>Read_Master_Log_Pos 和 Exec_Master_Log_Pos  这个值如果相差太大表示主从出现了延迟</li>\n<li>Seconds_Behind_Master 当前salve和master记录事件的时间戳，这个值如果越大证明延迟越严重</li>\n</ul>\n<p><strong>结合下原理和show slave status返回的结果来说明，大概流程是这样：</strong></p>\n<ol>\n<li>从库先通过io线程读取主库的二进制文件（Master_Log_File）和位置（Read_Master_Log_Pos）然后缓存到本地（从库服务器）的中继文件（Relay_Log_File）中并记录已经读取到的位置（Relay_Log_Pos）。</li>\n<li>再通过从库的sql线程去读取中继文件（Relay_Log_File），这个sql线程执行会记录已经执行到了哪个文（Relay_Master_Log_File）和哪个位置（Exec_Master_Log_Pos）。</li>\n</ol>\n<p>通过看show slave status发现一切正常，因为延迟是发生在凌晨4点。所以有可能的原因就是凌晨4点执行了大量的DDL导致的，之后恢复正常了。所以我们只能通过binlog日志查看凌晨4点时执行了什么语句。</p>\n<p>通过上面我们知道了从库是从主库的 mysql-bin.000231日志中同步过来的。所以看下这个binlog日志在凌晨4点时执行的所有DDL语句。</p>\n<p>导出主库上凌晨4:00~4:02的binlog日志。</p>\n<pre><code>#--base64-output=decode-rows -v 表示格式化DDL语句，因为binlog是二进制的\nmysqlbinlog --base64-output=decode-rows -v --start-datetime=&#39;2020-08-17 04:00:00&#39; --stop-datetime=&#39;2020-08-17 04:02:00&#39; -d wsportal mysql-bin.000231 &gt; /home/xuzy/log/mysql_bin_231_4.log</code></pre><pre><code>cat mysql_bin_231_4.log | grep &#39;INSERT&#39; | wc -l\n结果 : 99412\ncat mysql_bin_231_4.log | grep &#39;INSERT&#39; | grep &#39;dir_visit_report&#39; | wc -l\n结果 : 43695</code></pre><p>通过查看binlog日志，发现在2分钟内主库插入数据到表dir_visit_report一共执行了4万多次。感觉原因就是这个，然后继续查了下业务代码，发现是同事一个入库定时器写错了写成每天凌晨4点执行，其实是一个月执行一次，所以导致每天都报延迟。</p>\n<h2 id=\"如何避免\"><a href=\"#如何避免\" class=\"headerlink\" title=\"如何避免\"></a>如何避免</h2><ul>\n<li>升级MySQL版本到5.7，使用并行复制</li>\n<li>升级Slave硬件配置</li>\n<li>优化网络</li>\n<li>业务上防止统一时间点大量更新操作</li>\n<li>修改binlog配置sync_binlog，innodb_flush_log_at_trx_commit (redo日志)</li>\n<li>使用混合模式复制的方式，通过binlog-format配置。项目上作者使用的是行模式，行模式的优点是能保证主从完全一致，但速度会比较慢。具体可以参考《<a href=\"https://www.cnblogs.com/xingyunfashi/p/8431780.html\" target=\"_blank\" rel=\"noopener\">MYSQL中BINLOG_FORMAT的三种模式</a>》</li>\n</ul>\n<h3 id=\"sync-binlog\"><a href=\"#sync-binlog\" class=\"headerlink\" title=\"sync_binlog\"></a>sync_binlog</h3><ul>\n<li><p>sync_binlog = 0 ，表示MySQL不控制binlog的刷新，由文件系统自己控制它的缓存的刷新</p>\n</li>\n<li><p>sync_binlog &gt; 0 ，指定了两次刷新到磁盘的动作之间间隔多少次二进制日志写操作</p>\n</li>\n<li><p>sync_binlog = 1 ，表示每次事务提交，MySQL都会把binlog刷下去，是最安全但是性能损耗最大的设置</p>\n</li>\n</ul>\n<h3 id=\"innodb-flush-log-at-trx-commit\"><a href=\"#innodb-flush-log-at-trx-commit\" class=\"headerlink\" title=\"innodb_flush_log_at_trx_commit\"></a>innodb_flush_log_at_trx_commit</h3><p>0 ： 提交事务的时候，不立即把 redo log buffer 里的数据刷入磁盘文件的，而是依靠 InnoDB 的主线程每秒执行一次刷新到磁盘</p>\n<p>1 ： 提交事务的时候，就必须把 redo log 从内存刷入到磁盘文件里去，只要事务提交成功，那么 redo log 就必然在磁盘里了</p>\n<p>2 ：提交事务的时候，把 redo 日志写入磁盘文件对应的 os cache 缓存里去，而不是直接进入磁盘文件，可能 1 秒后才会把 os cache 里的数据写入到磁盘文件里去</p>\n<h2 id=\"Mysql主从同步宕机恢复流程\"><a href=\"#Mysql主从同步宕机恢复流程\" class=\"headerlink\" title=\"Mysql主从同步宕机恢复流程\"></a>Mysql主从同步宕机恢复流程</h2><p>主从同步宕机是很常见的一种错误。下面分析几种情况的解决方法。</p>\n<h3 id=\"从机宕机恢复\"><a href=\"#从机宕机恢复\" class=\"headerlink\" title=\"从机宕机恢复\"></a>从机宕机恢复</h3><p>丛机宕机后不在主节点获取数据入库，造成数据不一致。如果要让从机重新同步需要分两种情况：</p>\n<p><strong>从节点宕机时间短，主节点的binlog日志没变</strong></p>\n<p>这种情况下，假设从节点没宕机前是从主节点的mysqlmaster-bin.0010的binlog文件上同步数据，在我们发现从节点宕机后准备重新同步时，可以观察下当前时刻主节点是否还是使用mysqlmaster-bin.0010文件记录日志。如果是则可以直接重启从机的同步命令。</p>\n<p>这种情况下Mysql的从节点是可以知道从哪个Position开始同步出错的，所以主要重启就可以重新同步。</p>\n<pre><code class=\"shell\">start slave;</code></pre>\n<p>如何确定是否是同一个binlog。可以通过查看主节点和从节点当前使用的binlog信息。</p>\n<pre><code>mysql&gt; show slave status\\G; #登陆从节点查看主从同步信息\nmysql&gt; show master status;  #登陆主节点查看binlog信息</code></pre><p><strong>从节点宕机时间长，主节点的binlog日志已变化</strong></p>\n<p>这种情况下从节点无法知道是从哪个binlog日志的哪个position上开始不执行同步的。这种情况下最好是<strong>重新做同步</strong>。步骤如下</p>\n<ol>\n<li>对主库锁表 flush tables with read lock;</li>\n<li>主库把数据备份到mysql.bak.sql文件（备份的时候可以指定重新刷新binlog文件,所以binlog文件就是最新的position很小）</li>\n<li>从库导入mysql.bak.sql</li>\n<li>从库重新设定同步</li>\n</ol>\n<pre><code class=\"sql\">change master to master_host = &#39;IP&#39;, master_user = &#39;root&#39;, master_port=3306, master_password=&#39;&#39;, master_log_file = &#39;mysqld-bin.000001&#39;, master_log_pos=3260;</code></pre>"},{"title":"MySQL事务隔离级别原理和MVCC详解","description":"用大白话讲解事务隔离级别和多版本并发控制(MVCC)的原理。","date":"2020-08-30T08:04:21.000Z","_content":"\n## 事务\n\n### 概述\n\n先定义一个表，方便后面说明。\n\n```sql\nCREATE\tTABLE hero(\n   \tnumber\tINT,\n   \tname\tVARCHAR(100),\n   \tcountry\tvarchar(100),\n   \tPRIMARY\tKEY\t(number)\n)\tEngine=InnoDB\tCHARSET=utf8;\nINSERT INTO\thero VALUES(1,\t'索罗','cn');\n```\n\nMySQL是一个客户端/服务器架构。对于MySQL这个服务器来说，可以有很多客户端与其连接。每个客户端与服务器连接上之后，就可以称之为⼀个会话（Session）。事务是用来保证一个或多个数据库操作要嘛全部成功，要嘛全部回滚。事务要求我们要保证<font color=red>原子性、一致性、隔离性、持久性</font>。\n\n- 原子性，多个操作是一个不可分割的整体，要么全做，要么全不做的规则称之为原⼦性。\n- 一致性，在事务操作之前和之后，数据都是保持一个相同的状态，数据库的完整性没有被破坏。\n- 隔离性，保证多个事务之间不互相影响的规则称之为隔离性。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。\n- 持久性，事务操作完成后，数据会被刷新到磁盘永久保存，即便是系统故障也不会丢失。\n\n<font color=red>由于多个事务之间是并发执行的，要使得的事务之间互相不影响保证隔离性，只能对事务进行排队访问(锁)，但是这样的效果效率底下，如果不使用排队，多个事务之间同时操作则会出现如下问题：</font>\n<!--more-->\n### 事务并发执行可能出现的问题\n\n#### 脏写\n\n如果⼀个事务修改了另⼀个未提交事务修改过的数据，那就意味着发⽣了脏写。\n\n| 时间编号 | Session A                                      | Session B                                      |\n| -------- | ---------------------------------------------- | ---------------------------------------------- |\n| 1        | begin;                                         |                                                |\n| 2        |                                                | begin;                                         |\n| 3        |                                                | UPDAE hero SET name = '路飞' WHERE number = 1; |\n| 4        | UPDAE hero SET name = '乔巴' WHERE number = 1; |                                                |\n| 5        | commit;                                        |                                                |\n| 6        |                                                | rollback;                                      |\n\n在事务B先把值改成路飞后，事务A又把值改成了乔巴。事务A先提交后事务B回滚成原始值。导致了<font color=red>事务A明明把值改了但最后缺没有任何变化</font>。\n\n#### 脏读\n\n如果⼀个事务读到了另⼀个未提交事务修改过的数据，那就意味着发⽣了脏读。\n\n| 时间编号 | Session A                          | Session B                                      |\n| -------- | ---------------------------------- | ---------------------------------------------- |\n| 1        | begin;                             |                                                |\n| 2        |                                    | begin;                                         |\n| 3        |                                    | UPDAE hero SET name = '路飞' WHERE number = 1; |\n| 4        | SELECT * FROM hero WHERE hero = 1; |                                                |\n| 5        | commit;                            |                                                |\n| 6        |                                    | rollback;                                      |\n\n在事务A的4时刻如果读取到的name='路飞'，但是最后事务B回滚后事务A就读取到了一个不存在的数据。\n\n#### 不可重复读\n\n如果⼀个事务只能读到另⼀个已经提交的事务修改过的数据，并且其他事务每对该数据进⾏⼀次修改并提交后，该事务都能查询得到最新值，那就意味着发⽣了不可重复读。\n\n| 时间编号 | Session A                                                    | Session B                                                    |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1        | begin;                                                       |                                                              |\n| 2        | SELECT * FROM hero WHERE hero = 1;<br />(此时读取到的值是''索罗'') |                                                              |\n| 3        |                                                              | begin;<br />UPDAE hero SET name = '路飞' WHERE number = 1;<br />commit; |\n| 4        | SELECT * FROM hero WHERE hero = 1;<br />(如果读到的值是'路飞'，则意味发生了不可重复读) |                                                              |\n| 5        |                                                              | begin;<br />UPDAE hero SET name = '乔巴' WHERE number = 1;<br />commit; |\n| 6        | SELECT * FROM hero WHERE hero = 1;<br />(如果读到的值是'乔巴'，则意味发生了不可重复读) |                                                              |\n\n#### 幻读\n\n如果⼀个事务先根据某些条件查询出⼀些记录，之后另⼀个事务⼜向表中插⼊了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另⼀个事务插⼊的记录也读出来，那就意味着发⽣了幻读。\n\n| 时间编号 | Session A                                                    | Session B                             |\n| -------- | ------------------------------------------------------------ | ------------------------------------- |\n| 1        | begin;                                                       |                                       |\n| 2        | SELECT * FROM hero WHERE hero > 0;<br />(此时读取到的值是''索罗'') |                                       |\n| 3        |                                                              | INSERT INTO hero VALUE(2,'路飞','cn') |\n| 4        | SELECT * FROM hero WHERE hero > 0;<br />(此时读取到的值是''索罗''、“路飞”，则意味发生了幻读) |                                       |\n\n### 隔离级别概述与实现原理(重点)\n\n#### 隔离级别基础知识\n\n由此可见，并发事务会引起上面说的4种问题，严重性从大到小 ：脏写，脏读，不可重复读，幻读。\n\nMySQL为了保证事务能在并发下执行（提高性能）又想尽量减少上面的4个问题，所以制定了事务隔离级别用来解决上面说的4种问题，<font color=red>级别越高越能解决问题，相对的性能越低</font>。\n\n- READ UNCOMMITTED（未提交读），<font color=blue>一个事务还没提交时，它做的变更就能被别的事务看到</font>。\n- READ COMMITTED（已提交读），<font color=blue>一个事务提交之后，它做的变更才会被其他事务看到</font>。\n- REPEATABLE READ（可重复读），<font color=blue>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</font>。\n- SERIALIZABLE（可串⾏化），<font color=blue>顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</font>。\n\n**不同隔离级别下可以和不可以解决问题的对照表**\n\n| 隔离级别                     | 脏读     | 不可重复读 | 幻读     |\n| ---------------------------- | -------- | ---------- | -------- |\n| READ UNCOMMITTED（未提交读） | 可能发生 | 可能发生   | 可能发生 |\n| READ COMMITTED（已提交读）   | 不发生   | 可能发生   | 可能发生 |\n| REPEATABLE READ（可重复读）  | 不发生   | 不发生     | 可能发生 |\n| SERIALIZABLE（可串⾏化）     | 不发生   | 不发生     | 不发生   |\n\n- READ UNCOMMITTED 隔离级别下，可能发⽣脏读 、 不可重复读和幻读问题。\n- READ COMMITTED 隔离级别下，可能发⽣不可重复读和幻读问题，但是不可以发⽣脏读问题。\n- REPEATABLE READ 隔离级别下，可能发⽣幻读问题，但是不可以发⽣脏读和不可重复读的问题。\n- SERIALIZABLE 隔离级别下，各种问题都不可以发⽣。\n\n**我们举个例子帮助理解下**。例如可重复读，按照意思就是说我一个事务启动的时候就已经将启动这一时刻的数据做了一个\"快照\"，例如事务启动这一时刻我读取到的number = 1是'路飞‘，那我不管这个事务后面怎么再去读取number = 1的数据也都只会是路飞。那这样的话我们分析下，\n\n- 脏读指得是一个事务读取到没提交事务修改过的数据，那由于我做了\"快照\"只能读取最开始的值，所以不会发生。\n- 不可重复读也是如此，这就不说了。\n- <font color=red>可重复读下可能发生幻读，后面原理详解说明</font>\n\n#### 原理\n\n那隔离级别到底是基于什么原理来实现脏读，不可重复读和幻读的呢。答案就是MVCC(多版本并发控制)。用大白话大概解释下实现的原理：<font color=red>我们以前说过Undo日志，他用来记录数据更改前的值，用来实现回滚，其实他也是MVCC的关键。MySQL将数据的更变记录形成一条链条，每个更变记录上记录着对应操作的事务ID，然后通过判断事务ID来决定读取到的内容是哪个。下面具体分析</font>。\n\n##### 版本链\n\n对于使⽤InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：\n\n- trx_id ： 每次⼀个事务对某条聚簇索引记录进⾏改动时都会将改动这条记录的事务ID记录到这里。\n- roll_pointer ：每次对某条聚簇索引记录进⾏改动时，都会把旧的版本写⼊到undo⽇志中，然后这个隐藏列就相当于⼀个指针，可以通过它来找到该记录修改前的信息。\n\n两个事务做的操作如下(**最开始假设原来的索罗这条数据是事务ID=80插入的**)：\n\n| 时间编号 | trx_id = 100                                   | trx_id = 200                                   |\n| -------- | ---------------------------------------------- | ---------------------------------------------- |\n| 1        | begin                                          |                                                |\n| 2        |                                                | begin                                          |\n| 3        | update hexo set name = '路飞' where number = 1 |                                                |\n| 4        | update hexo set name = '乔巴' where number = 1 |                                                |\n| 5        | commit                                         |                                                |\n| 6        |                                                | update hexo set name = '娜美' where number = 1 |\n| 7        |                                                | update hexo set name = '罗宾' where number = 1 |\n| 8        |                                                | commit                                         |\n\n**小贴士 : 为什么图例上没有那种两个事务交叉更新同一条数据的情况? 这种情况不可能发生，更一条记录更新时，InnoDB就会将这条记录锁起来了，其他事务是必须等这个事务更新后才能操作，只能阻塞。但是对于读的话可以读，但是会会读取到什么内容不一定(<font color=red>其实隔离机制就是用来解决这个读取的问题，读到哪个值就是不同隔离机制决定的</font>)。**\n\n所以，上面的版本链用图示表示如下\n\n![](mysql-mvcc/1.png)\n\n对该记录每次更新后，都会将旧值放到⼀条undo⽇志中，就算是该记录的⼀个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成⼀个链表，我们把这个链表称之为<font color=red>版本链</font>，版本链的头节点就是当前记录最新的值。\n\n**READ UNCOMMITTED（未提交读）、SERIALIZABLE（串行化）如何实现？**\n\n由于未提交读是**一个事务还没提交时，它做的变更就能被别的事务看到**。所以如果设置的是未提交读级别的隔离，那每次只要读取版本链的最新数据，也就是当前内存数据就可以了。对于串行化隔离级别，InnoDB使用的是加锁的方式，所以也是读取内存最新值。\n\n##### ReadView\n\n对于使⽤READ COMMITTED（读提交）和REPEATABLE READ（可重复读）隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另⼀个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核⼼问题就是：<font color=red>需要判断⼀下版本链中的哪个版本是当前事务可⻅的</font>。所以提出了⼀个ReadView的概念。ReadView中包含4个内容：\n\n- m_ids：表示在⽣成ReadView时当前系统中活跃的读写事务的事务id列表。 \n- min_trx_id：表示在⽣成ReadView时当前系统中活跃的读写事务中最⼩的事务id，也就是m_ids中的最⼩值。\n- max_trx_id：表示⽣成ReadView时系统中应该分配给下⼀个事务的id值。\n- creator_trx_id：表示⽣成该ReadView的事务的事务id。\n\n**小贴士：只有在对表中的记录做改动时（执⾏INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在⼀个只读事务中的事务id值都默认为0。**\n\n有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可⻅：\n\n- 如果被访问的版本的trx_id值与ReadView中的creator_trx_id值相同，表示<font color=red>当前事务访问的是自己修改的记录，该版本可以被访问</font>。\n- 如果被访问的版本的trx_id值小于min_trx_id，表示<font color=red>被访问版本在当前事务生成前已经提交了，该版本可以访问</font>。\n- 如果被访问的版本的trx_id值大于max_trx_id，表示<font color=red>被访问版本在当前事务生成后才生成，该版本不能被访问</font>。\n- 如果被访问的版本在min_trx_id、max_trx_id之间，需要判断下被访问版本的trx_id值是不是在m_ids列表中。\n  - <font color=green>如果在就表示创建ReadView时被访问版本对应的事务是活跃的，该版本不能被访问</font>。\n  - <font color=green>如果不在就表创建ReadView时被访问版本对应的事务已经提交了，该版本可以被访问</font>。\n\n如果某个版本不可访问就顺着版本链继续找下一个直到最后一个版本。\n\n**现在我们来分析下READ COMMITTED（读提交）和REPEATABLE READ（可重复读）的不同**。\n\n- <font color=blue>读提交隔离级别规定只要是事务提交了，那更变马上就可以看到</font>。\n- <font color=blue>可重复读隔离级别规定只能看到事务启动时的版本，后面即使其他事务做了更变提交了，我也看不到</font>。\n\n所以，MREAD COMMITTED和REPEATABLE READ隔离级别的的⼀个⾮常⼤的区别就是它们⽣成ReadView的时机不同所以才能使得他们能达到不同的效果。\n\n**READ COMMITTED（读提交） —— 每次读取数据前都⽣成⼀个ReadView**\n\n**假设1：**假设现在事务100做了更新还没提交，事务200做了其他表的更新但是还没更新number=1的数据。新事务执行了如下语句，那他得到的值是什么，我们来分析下。\n\n```sql\nSELECT * FROM hero WHERE number = 1;\n```\n\n![](mysql-mvcc/2.png)\n\n由于是每次读取时生成ReadView。所以此时生成了一个ReadView，此时\n\n- m_ids = [100,200]\n- min_trx_id = 100\n- max_trx_id = 201\n- creator_trx_id = 0 （由于只读事务创建的事务ID都是0）\n\n从乔巴开始判断，由于trx_id=100在m_Ids中，不符合。直到索罗trx_id=80，不在m_ids中，该版本可以被访问\n\n**假设2：**假设现在事务100已经提交，事务200更新成‘罗宾’，假设1中的新事务执行了\n\n```sql\nSELECT * FROM hero WHERE number = 1;\n```\n\n![](mysql-mvcc/1.png)\n\n由于每次读取时都生成ReadView，所以此时生成了一个ReadView，\n\n- m_ids = [200]（此时事务100已经提交了，所以活跃的只有200）\n- min_trx_id = 200 (最小的活跃事务ID)\n- max_trx_id = 201\n- creator_trx_id = 0（由于只读事务创建的事务ID都是0）\n\n从版本的第一个‘罗宾’开始判断，由于该版本trx_id = 200，在m_ids中，不符合。到‘乔巴’trx_id=100不在m_ids中，符合，该版本可以被访问。\n\n**REPEATABLE READ（可重复读） —— 在第⼀次读取数据时⽣成⼀个ReadView**\n\n**假设1：**假设现在事务100，事务200是活跃的，事务100刚更新了‘路飞’，‘乔巴’，事务200更新了其他表的数据但是还没更新number=1的数据。此时来了一个事务300。\n\n```sql\nSELECT * FROM hero WHERE number = 1;\n```\n\n![版本链图](mysql-mvcc/2.png)\n\n在第一个读取数据时生成了，所以这条查询语句对应的ReadView。\n\n- m_ids = [100，200]\n- min_trx_id = 100 (最小的活跃事务ID)\n- max_trx_id = 201\n- creator_trx_id = 0（由于只读事务创建的事务ID都是0）\n\n从‘乔巴’开始判断，trx_id = 100 , 在m_ids中，不能被访问，继续下一步到‘索罗’可以了。\n\n**假设2：**假设现在事务100提交了，事务200做了更新到‘罗宾’后还没提交，假设1中的事务300继续执行了查询number = 1。现在的版本链如下。\n\n![](mysql-mvcc/1.png)\n\n由于在第一次读取数据时已经生成了，所以ReadView还是下面的样子\n\n- m_ids = [100，200]\n- min_trx_id = 100 (最小的活跃事务ID)\n- max_trx_id = 201\n- creator_trx_id = 0（由于只读事务创建的事务ID都是0）\n\n从‘罗宾’开始判断，由于trx_id在m_ids中，不符合。到‘乔巴’trx_id=100也在m_ids中，不符合。直到‘索罗’符合。\n\n#### 幻读怎么办？\n\n我们再来理解一下幻读的情况，**如果⼀个事务先根据某些条件查询出⼀些记录，之后另⼀个事务⼜向表中插⼊了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另⼀个事务插⼊的记录也读出来，那就意味着发⽣了幻读**。\n\n**为什么可重复读可能发生幻读？**通过分析可重复读的原理，我们列举两个例子。新建一张表\n\n```sql\nCREATE TABLE `dept` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8\ninsert into dept(name) values(\"后勤部\");\n```\n\n**例子1：**在可重复读隔离级别下\n\n| 事务1              | 事务2                                    |\n| ------------------ | ---------------------------------------- |\n| begin              | begin                                    |\n| select * from dept |                                          |\n|                    | insert into dept(name) values ('研发部') |\n|                    | commit                                   |\n| select * from dept |                                          |\n| commit             |                                          |\n\n这种情况下由于是可重复读，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。所以不会发生幻读。\n\n**例子2：**在可重复读隔离级别下\n\n| 事务1                           | 事务2                                    |\n| ------------------------------- | ---------------------------------------- |\n| begin                           | begin                                    |\n| select * from dept              |                                          |\n|                                 | insert into dept(name) values ('研发部') |\n|                                 | commit                                   |\n| update dept set name = '财务部' |                                          |\n| commit                          |                                          |\n\n在可重复读隔离级别下，我们觉得预期的结果应该是后勤部被更改成财务部，表中的数据有研发部，财务部。但实际上表中的两条数据都是财务部。发生了幻读。\n\n**为什么?** RR级别中，通过MVCC机制读取到的是快照数据，所以没问题。然而在做Update的情况下都是需要读取当前最新数据的，所以就出现了上面的情况。\n\n**如何解决幻读？**\n\n很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：\n\n- 使用串行化读的隔离级别\n- MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)\n\n所谓的next-key locks是记录锁加间隙(gap)锁的组合。只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。\n\n实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。\n\n## 总结\n\n- MVCC（多版本并发控制）指的就是在使⽤ READ COMMITTD （读提交）、 REPEATABLE READ（可重复读）这两种隔离级别的事务在执⾏普通的 SEELCT 操作时访问记录的版本链的过程，这样⼦可以使不同事务的 读-写 、 写-读 操作并发执⾏，从⽽提升系统性能。\n- MVCC的关键是使用undo日志组成一条链。\n- 对于读未提交、串行化直接读取的内存最新值。\n- 脏写是不会发生的，因为一个事务在更新数据时，如果另一个事务也要更新必须等到在更新的事务提交。","source":"_posts/mysql-mvcc.md","raw":"---\ntitle: MySQL事务隔离级别原理和MVCC详解\ntags:\n  - mysql\ncategories:  mysql\ndescription : 用大白话讲解事务隔离级别和多版本并发控制(MVCC)的原理。\ndate: 2020-08-30 16:04:21\n---\n\n## 事务\n\n### 概述\n\n先定义一个表，方便后面说明。\n\n```sql\nCREATE\tTABLE hero(\n   \tnumber\tINT,\n   \tname\tVARCHAR(100),\n   \tcountry\tvarchar(100),\n   \tPRIMARY\tKEY\t(number)\n)\tEngine=InnoDB\tCHARSET=utf8;\nINSERT INTO\thero VALUES(1,\t'索罗','cn');\n```\n\nMySQL是一个客户端/服务器架构。对于MySQL这个服务器来说，可以有很多客户端与其连接。每个客户端与服务器连接上之后，就可以称之为⼀个会话（Session）。事务是用来保证一个或多个数据库操作要嘛全部成功，要嘛全部回滚。事务要求我们要保证<font color=red>原子性、一致性、隔离性、持久性</font>。\n\n- 原子性，多个操作是一个不可分割的整体，要么全做，要么全不做的规则称之为原⼦性。\n- 一致性，在事务操作之前和之后，数据都是保持一个相同的状态，数据库的完整性没有被破坏。\n- 隔离性，保证多个事务之间不互相影响的规则称之为隔离性。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。\n- 持久性，事务操作完成后，数据会被刷新到磁盘永久保存，即便是系统故障也不会丢失。\n\n<font color=red>由于多个事务之间是并发执行的，要使得的事务之间互相不影响保证隔离性，只能对事务进行排队访问(锁)，但是这样的效果效率底下，如果不使用排队，多个事务之间同时操作则会出现如下问题：</font>\n<!--more-->\n### 事务并发执行可能出现的问题\n\n#### 脏写\n\n如果⼀个事务修改了另⼀个未提交事务修改过的数据，那就意味着发⽣了脏写。\n\n| 时间编号 | Session A                                      | Session B                                      |\n| -------- | ---------------------------------------------- | ---------------------------------------------- |\n| 1        | begin;                                         |                                                |\n| 2        |                                                | begin;                                         |\n| 3        |                                                | UPDAE hero SET name = '路飞' WHERE number = 1; |\n| 4        | UPDAE hero SET name = '乔巴' WHERE number = 1; |                                                |\n| 5        | commit;                                        |                                                |\n| 6        |                                                | rollback;                                      |\n\n在事务B先把值改成路飞后，事务A又把值改成了乔巴。事务A先提交后事务B回滚成原始值。导致了<font color=red>事务A明明把值改了但最后缺没有任何变化</font>。\n\n#### 脏读\n\n如果⼀个事务读到了另⼀个未提交事务修改过的数据，那就意味着发⽣了脏读。\n\n| 时间编号 | Session A                          | Session B                                      |\n| -------- | ---------------------------------- | ---------------------------------------------- |\n| 1        | begin;                             |                                                |\n| 2        |                                    | begin;                                         |\n| 3        |                                    | UPDAE hero SET name = '路飞' WHERE number = 1; |\n| 4        | SELECT * FROM hero WHERE hero = 1; |                                                |\n| 5        | commit;                            |                                                |\n| 6        |                                    | rollback;                                      |\n\n在事务A的4时刻如果读取到的name='路飞'，但是最后事务B回滚后事务A就读取到了一个不存在的数据。\n\n#### 不可重复读\n\n如果⼀个事务只能读到另⼀个已经提交的事务修改过的数据，并且其他事务每对该数据进⾏⼀次修改并提交后，该事务都能查询得到最新值，那就意味着发⽣了不可重复读。\n\n| 时间编号 | Session A                                                    | Session B                                                    |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 1        | begin;                                                       |                                                              |\n| 2        | SELECT * FROM hero WHERE hero = 1;<br />(此时读取到的值是''索罗'') |                                                              |\n| 3        |                                                              | begin;<br />UPDAE hero SET name = '路飞' WHERE number = 1;<br />commit; |\n| 4        | SELECT * FROM hero WHERE hero = 1;<br />(如果读到的值是'路飞'，则意味发生了不可重复读) |                                                              |\n| 5        |                                                              | begin;<br />UPDAE hero SET name = '乔巴' WHERE number = 1;<br />commit; |\n| 6        | SELECT * FROM hero WHERE hero = 1;<br />(如果读到的值是'乔巴'，则意味发生了不可重复读) |                                                              |\n\n#### 幻读\n\n如果⼀个事务先根据某些条件查询出⼀些记录，之后另⼀个事务⼜向表中插⼊了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另⼀个事务插⼊的记录也读出来，那就意味着发⽣了幻读。\n\n| 时间编号 | Session A                                                    | Session B                             |\n| -------- | ------------------------------------------------------------ | ------------------------------------- |\n| 1        | begin;                                                       |                                       |\n| 2        | SELECT * FROM hero WHERE hero > 0;<br />(此时读取到的值是''索罗'') |                                       |\n| 3        |                                                              | INSERT INTO hero VALUE(2,'路飞','cn') |\n| 4        | SELECT * FROM hero WHERE hero > 0;<br />(此时读取到的值是''索罗''、“路飞”，则意味发生了幻读) |                                       |\n\n### 隔离级别概述与实现原理(重点)\n\n#### 隔离级别基础知识\n\n由此可见，并发事务会引起上面说的4种问题，严重性从大到小 ：脏写，脏读，不可重复读，幻读。\n\nMySQL为了保证事务能在并发下执行（提高性能）又想尽量减少上面的4个问题，所以制定了事务隔离级别用来解决上面说的4种问题，<font color=red>级别越高越能解决问题，相对的性能越低</font>。\n\n- READ UNCOMMITTED（未提交读），<font color=blue>一个事务还没提交时，它做的变更就能被别的事务看到</font>。\n- READ COMMITTED（已提交读），<font color=blue>一个事务提交之后，它做的变更才会被其他事务看到</font>。\n- REPEATABLE READ（可重复读），<font color=blue>一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</font>。\n- SERIALIZABLE（可串⾏化），<font color=blue>顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</font>。\n\n**不同隔离级别下可以和不可以解决问题的对照表**\n\n| 隔离级别                     | 脏读     | 不可重复读 | 幻读     |\n| ---------------------------- | -------- | ---------- | -------- |\n| READ UNCOMMITTED（未提交读） | 可能发生 | 可能发生   | 可能发生 |\n| READ COMMITTED（已提交读）   | 不发生   | 可能发生   | 可能发生 |\n| REPEATABLE READ（可重复读）  | 不发生   | 不发生     | 可能发生 |\n| SERIALIZABLE（可串⾏化）     | 不发生   | 不发生     | 不发生   |\n\n- READ UNCOMMITTED 隔离级别下，可能发⽣脏读 、 不可重复读和幻读问题。\n- READ COMMITTED 隔离级别下，可能发⽣不可重复读和幻读问题，但是不可以发⽣脏读问题。\n- REPEATABLE READ 隔离级别下，可能发⽣幻读问题，但是不可以发⽣脏读和不可重复读的问题。\n- SERIALIZABLE 隔离级别下，各种问题都不可以发⽣。\n\n**我们举个例子帮助理解下**。例如可重复读，按照意思就是说我一个事务启动的时候就已经将启动这一时刻的数据做了一个\"快照\"，例如事务启动这一时刻我读取到的number = 1是'路飞‘，那我不管这个事务后面怎么再去读取number = 1的数据也都只会是路飞。那这样的话我们分析下，\n\n- 脏读指得是一个事务读取到没提交事务修改过的数据，那由于我做了\"快照\"只能读取最开始的值，所以不会发生。\n- 不可重复读也是如此，这就不说了。\n- <font color=red>可重复读下可能发生幻读，后面原理详解说明</font>\n\n#### 原理\n\n那隔离级别到底是基于什么原理来实现脏读，不可重复读和幻读的呢。答案就是MVCC(多版本并发控制)。用大白话大概解释下实现的原理：<font color=red>我们以前说过Undo日志，他用来记录数据更改前的值，用来实现回滚，其实他也是MVCC的关键。MySQL将数据的更变记录形成一条链条，每个更变记录上记录着对应操作的事务ID，然后通过判断事务ID来决定读取到的内容是哪个。下面具体分析</font>。\n\n##### 版本链\n\n对于使⽤InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：\n\n- trx_id ： 每次⼀个事务对某条聚簇索引记录进⾏改动时都会将改动这条记录的事务ID记录到这里。\n- roll_pointer ：每次对某条聚簇索引记录进⾏改动时，都会把旧的版本写⼊到undo⽇志中，然后这个隐藏列就相当于⼀个指针，可以通过它来找到该记录修改前的信息。\n\n两个事务做的操作如下(**最开始假设原来的索罗这条数据是事务ID=80插入的**)：\n\n| 时间编号 | trx_id = 100                                   | trx_id = 200                                   |\n| -------- | ---------------------------------------------- | ---------------------------------------------- |\n| 1        | begin                                          |                                                |\n| 2        |                                                | begin                                          |\n| 3        | update hexo set name = '路飞' where number = 1 |                                                |\n| 4        | update hexo set name = '乔巴' where number = 1 |                                                |\n| 5        | commit                                         |                                                |\n| 6        |                                                | update hexo set name = '娜美' where number = 1 |\n| 7        |                                                | update hexo set name = '罗宾' where number = 1 |\n| 8        |                                                | commit                                         |\n\n**小贴士 : 为什么图例上没有那种两个事务交叉更新同一条数据的情况? 这种情况不可能发生，更一条记录更新时，InnoDB就会将这条记录锁起来了，其他事务是必须等这个事务更新后才能操作，只能阻塞。但是对于读的话可以读，但是会会读取到什么内容不一定(<font color=red>其实隔离机制就是用来解决这个读取的问题，读到哪个值就是不同隔离机制决定的</font>)。**\n\n所以，上面的版本链用图示表示如下\n\n![](mysql-mvcc/1.png)\n\n对该记录每次更新后，都会将旧值放到⼀条undo⽇志中，就算是该记录的⼀个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成⼀个链表，我们把这个链表称之为<font color=red>版本链</font>，版本链的头节点就是当前记录最新的值。\n\n**READ UNCOMMITTED（未提交读）、SERIALIZABLE（串行化）如何实现？**\n\n由于未提交读是**一个事务还没提交时，它做的变更就能被别的事务看到**。所以如果设置的是未提交读级别的隔离，那每次只要读取版本链的最新数据，也就是当前内存数据就可以了。对于串行化隔离级别，InnoDB使用的是加锁的方式，所以也是读取内存最新值。\n\n##### ReadView\n\n对于使⽤READ COMMITTED（读提交）和REPEATABLE READ（可重复读）隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另⼀个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核⼼问题就是：<font color=red>需要判断⼀下版本链中的哪个版本是当前事务可⻅的</font>。所以提出了⼀个ReadView的概念。ReadView中包含4个内容：\n\n- m_ids：表示在⽣成ReadView时当前系统中活跃的读写事务的事务id列表。 \n- min_trx_id：表示在⽣成ReadView时当前系统中活跃的读写事务中最⼩的事务id，也就是m_ids中的最⼩值。\n- max_trx_id：表示⽣成ReadView时系统中应该分配给下⼀个事务的id值。\n- creator_trx_id：表示⽣成该ReadView的事务的事务id。\n\n**小贴士：只有在对表中的记录做改动时（执⾏INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在⼀个只读事务中的事务id值都默认为0。**\n\n有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可⻅：\n\n- 如果被访问的版本的trx_id值与ReadView中的creator_trx_id值相同，表示<font color=red>当前事务访问的是自己修改的记录，该版本可以被访问</font>。\n- 如果被访问的版本的trx_id值小于min_trx_id，表示<font color=red>被访问版本在当前事务生成前已经提交了，该版本可以访问</font>。\n- 如果被访问的版本的trx_id值大于max_trx_id，表示<font color=red>被访问版本在当前事务生成后才生成，该版本不能被访问</font>。\n- 如果被访问的版本在min_trx_id、max_trx_id之间，需要判断下被访问版本的trx_id值是不是在m_ids列表中。\n  - <font color=green>如果在就表示创建ReadView时被访问版本对应的事务是活跃的，该版本不能被访问</font>。\n  - <font color=green>如果不在就表创建ReadView时被访问版本对应的事务已经提交了，该版本可以被访问</font>。\n\n如果某个版本不可访问就顺着版本链继续找下一个直到最后一个版本。\n\n**现在我们来分析下READ COMMITTED（读提交）和REPEATABLE READ（可重复读）的不同**。\n\n- <font color=blue>读提交隔离级别规定只要是事务提交了，那更变马上就可以看到</font>。\n- <font color=blue>可重复读隔离级别规定只能看到事务启动时的版本，后面即使其他事务做了更变提交了，我也看不到</font>。\n\n所以，MREAD COMMITTED和REPEATABLE READ隔离级别的的⼀个⾮常⼤的区别就是它们⽣成ReadView的时机不同所以才能使得他们能达到不同的效果。\n\n**READ COMMITTED（读提交） —— 每次读取数据前都⽣成⼀个ReadView**\n\n**假设1：**假设现在事务100做了更新还没提交，事务200做了其他表的更新但是还没更新number=1的数据。新事务执行了如下语句，那他得到的值是什么，我们来分析下。\n\n```sql\nSELECT * FROM hero WHERE number = 1;\n```\n\n![](mysql-mvcc/2.png)\n\n由于是每次读取时生成ReadView。所以此时生成了一个ReadView，此时\n\n- m_ids = [100,200]\n- min_trx_id = 100\n- max_trx_id = 201\n- creator_trx_id = 0 （由于只读事务创建的事务ID都是0）\n\n从乔巴开始判断，由于trx_id=100在m_Ids中，不符合。直到索罗trx_id=80，不在m_ids中，该版本可以被访问\n\n**假设2：**假设现在事务100已经提交，事务200更新成‘罗宾’，假设1中的新事务执行了\n\n```sql\nSELECT * FROM hero WHERE number = 1;\n```\n\n![](mysql-mvcc/1.png)\n\n由于每次读取时都生成ReadView，所以此时生成了一个ReadView，\n\n- m_ids = [200]（此时事务100已经提交了，所以活跃的只有200）\n- min_trx_id = 200 (最小的活跃事务ID)\n- max_trx_id = 201\n- creator_trx_id = 0（由于只读事务创建的事务ID都是0）\n\n从版本的第一个‘罗宾’开始判断，由于该版本trx_id = 200，在m_ids中，不符合。到‘乔巴’trx_id=100不在m_ids中，符合，该版本可以被访问。\n\n**REPEATABLE READ（可重复读） —— 在第⼀次读取数据时⽣成⼀个ReadView**\n\n**假设1：**假设现在事务100，事务200是活跃的，事务100刚更新了‘路飞’，‘乔巴’，事务200更新了其他表的数据但是还没更新number=1的数据。此时来了一个事务300。\n\n```sql\nSELECT * FROM hero WHERE number = 1;\n```\n\n![版本链图](mysql-mvcc/2.png)\n\n在第一个读取数据时生成了，所以这条查询语句对应的ReadView。\n\n- m_ids = [100，200]\n- min_trx_id = 100 (最小的活跃事务ID)\n- max_trx_id = 201\n- creator_trx_id = 0（由于只读事务创建的事务ID都是0）\n\n从‘乔巴’开始判断，trx_id = 100 , 在m_ids中，不能被访问，继续下一步到‘索罗’可以了。\n\n**假设2：**假设现在事务100提交了，事务200做了更新到‘罗宾’后还没提交，假设1中的事务300继续执行了查询number = 1。现在的版本链如下。\n\n![](mysql-mvcc/1.png)\n\n由于在第一次读取数据时已经生成了，所以ReadView还是下面的样子\n\n- m_ids = [100，200]\n- min_trx_id = 100 (最小的活跃事务ID)\n- max_trx_id = 201\n- creator_trx_id = 0（由于只读事务创建的事务ID都是0）\n\n从‘罗宾’开始判断，由于trx_id在m_ids中，不符合。到‘乔巴’trx_id=100也在m_ids中，不符合。直到‘索罗’符合。\n\n#### 幻读怎么办？\n\n我们再来理解一下幻读的情况，**如果⼀个事务先根据某些条件查询出⼀些记录，之后另⼀个事务⼜向表中插⼊了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另⼀个事务插⼊的记录也读出来，那就意味着发⽣了幻读**。\n\n**为什么可重复读可能发生幻读？**通过分析可重复读的原理，我们列举两个例子。新建一张表\n\n```sql\nCREATE TABLE `dept` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8\ninsert into dept(name) values(\"后勤部\");\n```\n\n**例子1：**在可重复读隔离级别下\n\n| 事务1              | 事务2                                    |\n| ------------------ | ---------------------------------------- |\n| begin              | begin                                    |\n| select * from dept |                                          |\n|                    | insert into dept(name) values ('研发部') |\n|                    | commit                                   |\n| select * from dept |                                          |\n| commit             |                                          |\n\n这种情况下由于是可重复读，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。所以不会发生幻读。\n\n**例子2：**在可重复读隔离级别下\n\n| 事务1                           | 事务2                                    |\n| ------------------------------- | ---------------------------------------- |\n| begin                           | begin                                    |\n| select * from dept              |                                          |\n|                                 | insert into dept(name) values ('研发部') |\n|                                 | commit                                   |\n| update dept set name = '财务部' |                                          |\n| commit                          |                                          |\n\n在可重复读隔离级别下，我们觉得预期的结果应该是后勤部被更改成财务部，表中的数据有研发部，财务部。但实际上表中的两条数据都是财务部。发生了幻读。\n\n**为什么?** RR级别中，通过MVCC机制读取到的是快照数据，所以没问题。然而在做Update的情况下都是需要读取当前最新数据的，所以就出现了上面的情况。\n\n**如何解决幻读？**\n\n很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：\n\n- 使用串行化读的隔离级别\n- MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)\n\n所谓的next-key locks是记录锁加间隙(gap)锁的组合。只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。\n\n实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。\n\n## 总结\n\n- MVCC（多版本并发控制）指的就是在使⽤ READ COMMITTD （读提交）、 REPEATABLE READ（可重复读）这两种隔离级别的事务在执⾏普通的 SEELCT 操作时访问记录的版本链的过程，这样⼦可以使不同事务的 读-写 、 写-读 操作并发执⾏，从⽽提升系统性能。\n- MVCC的关键是使用undo日志组成一条链。\n- 对于读未提交、串行化直接读取的内存最新值。\n- 脏写是不会发生的，因为一个事务在更新数据时，如果另一个事务也要更新必须等到在更新的事务提交。","slug":"mysql-mvcc","published":1,"updated":"2021-04-08T00:47:06.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvi002dqwv2a6o1e3ab","content":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>先定义一个表，方便后面说明。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span>    <span class=\"token keyword\">TABLE</span> hero<span class=\"token punctuation\">(</span>\n       number    <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n       name    <span class=\"token keyword\">VARCHAR</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       country    <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n       <span class=\"token keyword\">PRIMARY</span>    <span class=\"token keyword\">KEY</span>    <span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>    <span class=\"token keyword\">Engine</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span>    <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span>    hero <span class=\"token keyword\">VALUES</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>    <span class=\"token string\">'索罗'</span><span class=\"token punctuation\">,</span><span class=\"token string\">'cn'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>MySQL是一个客户端/服务器架构。对于MySQL这个服务器来说，可以有很多客户端与其连接。每个客户端与服务器连接上之后，就可以称之为⼀个会话（Session）。事务是用来保证一个或多个数据库操作要嘛全部成功，要嘛全部回滚。事务要求我们要保证<font color=\"red\">原子性、一致性、隔离性、持久性</font>。</p>\n<ul>\n<li>原子性，多个操作是一个不可分割的整体，要么全做，要么全不做的规则称之为原⼦性。</li>\n<li>一致性，在事务操作之前和之后，数据都是保持一个相同的状态，数据库的完整性没有被破坏。</li>\n<li>隔离性，保证多个事务之间不互相影响的规则称之为隔离性。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li>\n<li>持久性，事务操作完成后，数据会被刷新到磁盘永久保存，即便是系统故障也不会丢失。</li>\n</ul>\n<p><font color=\"red\">由于多个事务之间是并发执行的，要使得的事务之间互相不影响保证隔离性，只能对事务进行排队访问(锁)，但是这样的效果效率底下，如果不使用排队，多个事务之间同时操作则会出现如下问题：</font></p>\n<a id=\"more\"></a>\n<h3 id=\"事务并发执行可能出现的问题\"><a href=\"#事务并发执行可能出现的问题\" class=\"headerlink\" title=\"事务并发执行可能出现的问题\"></a>事务并发执行可能出现的问题</h3><h4 id=\"脏写\"><a href=\"#脏写\" class=\"headerlink\" title=\"脏写\"></a>脏写</h4><p>如果⼀个事务修改了另⼀个未提交事务修改过的数据，那就意味着发⽣了脏写。</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>Session A</th>\n<th>Session B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin;</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n<td>begin;</td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td>UPDAE hero SET name = ‘路飞’ WHERE number = 1;</td>\n</tr>\n<tr>\n<td>4</td>\n<td>UPDAE hero SET name = ‘乔巴’ WHERE number = 1;</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>commit;</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td></td>\n<td>rollback;</td>\n</tr>\n</tbody></table>\n<p>在事务B先把值改成路飞后，事务A又把值改成了乔巴。事务A先提交后事务B回滚成原始值。导致了<font color=\"red\">事务A明明把值改了但最后缺没有任何变化</font>。</p>\n<h4 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h4><p>如果⼀个事务读到了另⼀个未提交事务修改过的数据，那就意味着发⽣了脏读。</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>Session A</th>\n<th>Session B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin;</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n<td>begin;</td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td>UPDAE hero SET name = ‘路飞’ WHERE number = 1;</td>\n</tr>\n<tr>\n<td>4</td>\n<td>SELECT * FROM hero WHERE hero = 1;</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>commit;</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td></td>\n<td>rollback;</td>\n</tr>\n</tbody></table>\n<p>在事务A的4时刻如果读取到的name=’路飞’，但是最后事务B回滚后事务A就读取到了一个不存在的数据。</p>\n<h4 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h4><p>如果⼀个事务只能读到另⼀个已经提交的事务修改过的数据，并且其他事务每对该数据进⾏⼀次修改并提交后，该事务都能查询得到最新值，那就意味着发⽣了不可重复读。</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>Session A</th>\n<th>Session B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin;</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>SELECT * FROM hero WHERE hero = 1;<br>(此时读取到的值是’’索罗’’)</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td>begin;<br>UPDAE hero SET name = ‘路飞’ WHERE number = 1;<br>commit;</td>\n</tr>\n<tr>\n<td>4</td>\n<td>SELECT * FROM hero WHERE hero = 1;<br>(如果读到的值是’路飞’，则意味发生了不可重复读)</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td></td>\n<td>begin;<br>UPDAE hero SET name = ‘乔巴’ WHERE number = 1;<br>commit;</td>\n</tr>\n<tr>\n<td>6</td>\n<td>SELECT * FROM hero WHERE hero = 1;<br>(如果读到的值是’乔巴’，则意味发生了不可重复读)</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h4><p>如果⼀个事务先根据某些条件查询出⼀些记录，之后另⼀个事务⼜向表中插⼊了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另⼀个事务插⼊的记录也读出来，那就意味着发⽣了幻读。</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>Session A</th>\n<th>Session B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin;</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>SELECT * FROM hero WHERE hero &gt; 0;<br>(此时读取到的值是’’索罗’’)</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td>INSERT INTO hero VALUE(2,’路飞’,’cn’)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>SELECT * FROM hero WHERE hero &gt; 0;<br>(此时读取到的值是’’索罗’’、“路飞”，则意味发生了幻读)</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"隔离级别概述与实现原理-重点\"><a href=\"#隔离级别概述与实现原理-重点\" class=\"headerlink\" title=\"隔离级别概述与实现原理(重点)\"></a>隔离级别概述与实现原理(重点)</h3><h4 id=\"隔离级别基础知识\"><a href=\"#隔离级别基础知识\" class=\"headerlink\" title=\"隔离级别基础知识\"></a>隔离级别基础知识</h4><p>由此可见，并发事务会引起上面说的4种问题，严重性从大到小 ：脏写，脏读，不可重复读，幻读。</p>\n<p>MySQL为了保证事务能在并发下执行（提高性能）又想尽量减少上面的4个问题，所以制定了事务隔离级别用来解决上面说的4种问题，<font color=\"red\">级别越高越能解决问题，相对的性能越低</font>。</p>\n<ul>\n<li>READ UNCOMMITTED（未提交读），<font color=\"blue\">一个事务还没提交时，它做的变更就能被别的事务看到</font>。</li>\n<li>READ COMMITTED（已提交读），<font color=\"blue\">一个事务提交之后，它做的变更才会被其他事务看到</font>。</li>\n<li>REPEATABLE READ（可重复读），<font color=\"blue\">一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</font>。</li>\n<li>SERIALIZABLE（可串⾏化），<font color=\"blue\">顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</font>。</li>\n</ul>\n<p><strong>不同隔离级别下可以和不可以解决问题的对照表</strong></p>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>READ UNCOMMITTED（未提交读）</td>\n<td>可能发生</td>\n<td>可能发生</td>\n<td>可能发生</td>\n</tr>\n<tr>\n<td>READ COMMITTED（已提交读）</td>\n<td>不发生</td>\n<td>可能发生</td>\n<td>可能发生</td>\n</tr>\n<tr>\n<td>REPEATABLE READ（可重复读）</td>\n<td>不发生</td>\n<td>不发生</td>\n<td>可能发生</td>\n</tr>\n<tr>\n<td>SERIALIZABLE（可串⾏化）</td>\n<td>不发生</td>\n<td>不发生</td>\n<td>不发生</td>\n</tr>\n</tbody></table>\n<ul>\n<li>READ UNCOMMITTED 隔离级别下，可能发⽣脏读 、 不可重复读和幻读问题。</li>\n<li>READ COMMITTED 隔离级别下，可能发⽣不可重复读和幻读问题，但是不可以发⽣脏读问题。</li>\n<li>REPEATABLE READ 隔离级别下，可能发⽣幻读问题，但是不可以发⽣脏读和不可重复读的问题。</li>\n<li>SERIALIZABLE 隔离级别下，各种问题都不可以发⽣。</li>\n</ul>\n<p><strong>我们举个例子帮助理解下</strong>。例如可重复读，按照意思就是说我一个事务启动的时候就已经将启动这一时刻的数据做了一个”快照”，例如事务启动这一时刻我读取到的number = 1是’路飞‘，那我不管这个事务后面怎么再去读取number = 1的数据也都只会是路飞。那这样的话我们分析下，</p>\n<ul>\n<li>脏读指得是一个事务读取到没提交事务修改过的数据，那由于我做了”快照”只能读取最开始的值，所以不会发生。</li>\n<li>不可重复读也是如此，这就不说了。</li>\n<li><font color=\"red\">可重复读下可能发生幻读，后面原理详解说明</font></li>\n</ul>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>那隔离级别到底是基于什么原理来实现脏读，不可重复读和幻读的呢。答案就是MVCC(多版本并发控制)。用大白话大概解释下实现的原理：<font color=\"red\">我们以前说过Undo日志，他用来记录数据更改前的值，用来实现回滚，其实他也是MVCC的关键。MySQL将数据的更变记录形成一条链条，每个更变记录上记录着对应操作的事务ID，然后通过判断事务ID来决定读取到的内容是哪个。下面具体分析</font>。</p>\n<h5 id=\"版本链\"><a href=\"#版本链\" class=\"headerlink\" title=\"版本链\"></a>版本链</h5><p>对于使⽤InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</p>\n<ul>\n<li>trx_id ： 每次⼀个事务对某条聚簇索引记录进⾏改动时都会将改动这条记录的事务ID记录到这里。</li>\n<li>roll_pointer ：每次对某条聚簇索引记录进⾏改动时，都会把旧的版本写⼊到undo⽇志中，然后这个隐藏列就相当于⼀个指针，可以通过它来找到该记录修改前的信息。</li>\n</ul>\n<p>两个事务做的操作如下(<strong>最开始假设原来的索罗这条数据是事务ID=80插入的</strong>)：</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>trx_id = 100</th>\n<th>trx_id = 200</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n<td>begin</td>\n</tr>\n<tr>\n<td>3</td>\n<td>update hexo set name = ‘路飞’ where number = 1</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>update hexo set name = ‘乔巴’ where number = 1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>commit</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td></td>\n<td>update hexo set name = ‘娜美’ where number = 1</td>\n</tr>\n<tr>\n<td>7</td>\n<td></td>\n<td>update hexo set name = ‘罗宾’ where number = 1</td>\n</tr>\n<tr>\n<td>8</td>\n<td></td>\n<td>commit</td>\n</tr>\n</tbody></table>\n<p><strong>小贴士 : 为什么图例上没有那种两个事务交叉更新同一条数据的情况? 这种情况不可能发生，更一条记录更新时，InnoDB就会将这条记录锁起来了，其他事务是必须等这个事务更新后才能操作，只能阻塞。但是对于读的话可以读，但是会会读取到什么内容不一定(<font color=\"red\">其实隔离机制就是用来解决这个读取的问题，读到哪个值就是不同隔离机制决定的</font>)。</strong></p>\n<p>所以，上面的版本链用图示表示如下</p>\n<p><img src=\"/2020/08/30/mysql-mvcc/1.png\" alt></p>\n<p>对该记录每次更新后，都会将旧值放到⼀条undo⽇志中，就算是该记录的⼀个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成⼀个链表，我们把这个链表称之为<font color=\"red\">版本链</font>，版本链的头节点就是当前记录最新的值。</p>\n<p><strong>READ UNCOMMITTED（未提交读）、SERIALIZABLE（串行化）如何实现？</strong></p>\n<p>由于未提交读是<strong>一个事务还没提交时，它做的变更就能被别的事务看到</strong>。所以如果设置的是未提交读级别的隔离，那每次只要读取版本链的最新数据，也就是当前内存数据就可以了。对于串行化隔离级别，InnoDB使用的是加锁的方式，所以也是读取内存最新值。</p>\n<h5 id=\"ReadView\"><a href=\"#ReadView\" class=\"headerlink\" title=\"ReadView\"></a>ReadView</h5><p>对于使⽤READ COMMITTED（读提交）和REPEATABLE READ（可重复读）隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另⼀个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核⼼问题就是：<font color=\"red\">需要判断⼀下版本链中的哪个版本是当前事务可⻅的</font>。所以提出了⼀个ReadView的概念。ReadView中包含4个内容：</p>\n<ul>\n<li>m_ids：表示在⽣成ReadView时当前系统中活跃的读写事务的事务id列表。 </li>\n<li>min_trx_id：表示在⽣成ReadView时当前系统中活跃的读写事务中最⼩的事务id，也就是m_ids中的最⼩值。</li>\n<li>max_trx_id：表示⽣成ReadView时系统中应该分配给下⼀个事务的id值。</li>\n<li>creator_trx_id：表示⽣成该ReadView的事务的事务id。</li>\n</ul>\n<p><strong>小贴士：只有在对表中的记录做改动时（执⾏INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在⼀个只读事务中的事务id值都默认为0。</strong></p>\n<p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可⻅：</p>\n<ul>\n<li>如果被访问的版本的trx_id值与ReadView中的creator_trx_id值相同，表示<font color=\"red\">当前事务访问的是自己修改的记录，该版本可以被访问</font>。</li>\n<li>如果被访问的版本的trx_id值小于min_trx_id，表示<font color=\"red\">被访问版本在当前事务生成前已经提交了，该版本可以访问</font>。</li>\n<li>如果被访问的版本的trx_id值大于max_trx_id，表示<font color=\"red\">被访问版本在当前事务生成后才生成，该版本不能被访问</font>。</li>\n<li>如果被访问的版本在min_trx_id、max_trx_id之间，需要判断下被访问版本的trx_id值是不是在m_ids列表中。<ul>\n<li><font color=\"green\">如果在就表示创建ReadView时被访问版本对应的事务是活跃的，该版本不能被访问</font>。</li>\n<li><font color=\"green\">如果不在就表创建ReadView时被访问版本对应的事务已经提交了，该版本可以被访问</font>。</li>\n</ul>\n</li>\n</ul>\n<p>如果某个版本不可访问就顺着版本链继续找下一个直到最后一个版本。</p>\n<p><strong>现在我们来分析下READ COMMITTED（读提交）和REPEATABLE READ（可重复读）的不同</strong>。</p>\n<ul>\n<li><font color=\"blue\">读提交隔离级别规定只要是事务提交了，那更变马上就可以看到</font>。</li>\n<li><font color=\"blue\">可重复读隔离级别规定只能看到事务启动时的版本，后面即使其他事务做了更变提交了，我也看不到</font>。</li>\n</ul>\n<p>所以，MREAD COMMITTED和REPEATABLE READ隔离级别的的⼀个⾮常⼤的区别就是它们⽣成ReadView的时机不同所以才能使得他们能达到不同的效果。</p>\n<p><strong>READ COMMITTED（读提交） —— 每次读取数据前都⽣成⼀个ReadView</strong></p>\n<p><strong>假设1：</strong>假设现在事务100做了更新还没提交，事务200做了其他表的更新但是还没更新number=1的数据。新事务执行了如下语句，那他得到的值是什么，我们来分析下。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> hero <span class=\"token keyword\">WHERE</span> number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/08/30/mysql-mvcc/2.png\" alt></p>\n<p>由于是每次读取时生成ReadView。所以此时生成了一个ReadView，此时</p>\n<ul>\n<li>m_ids = [100,200]</li>\n<li>min_trx_id = 100</li>\n<li>max_trx_id = 201</li>\n<li>creator_trx_id = 0 （由于只读事务创建的事务ID都是0）</li>\n</ul>\n<p>从乔巴开始判断，由于trx_id=100在m_Ids中，不符合。直到索罗trx_id=80，不在m_ids中，该版本可以被访问</p>\n<p><strong>假设2：</strong>假设现在事务100已经提交，事务200更新成‘罗宾’，假设1中的新事务执行了</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> hero <span class=\"token keyword\">WHERE</span> number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/08/30/mysql-mvcc/1.png\" alt></p>\n<p>由于每次读取时都生成ReadView，所以此时生成了一个ReadView，</p>\n<ul>\n<li>m_ids = [200]（此时事务100已经提交了，所以活跃的只有200）</li>\n<li>min_trx_id = 200 (最小的活跃事务ID)</li>\n<li>max_trx_id = 201</li>\n<li>creator_trx_id = 0（由于只读事务创建的事务ID都是0）</li>\n</ul>\n<p>从版本的第一个‘罗宾’开始判断，由于该版本trx_id = 200，在m_ids中，不符合。到‘乔巴’trx_id=100不在m_ids中，符合，该版本可以被访问。</p>\n<p><strong>REPEATABLE READ（可重复读） —— 在第⼀次读取数据时⽣成⼀个ReadView</strong></p>\n<p><strong>假设1：</strong>假设现在事务100，事务200是活跃的，事务100刚更新了‘路飞’，‘乔巴’，事务200更新了其他表的数据但是还没更新number=1的数据。此时来了一个事务300。</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> hero <span class=\"token keyword\">WHERE</span> number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/08/30/mysql-mvcc/2.png\" alt=\"版本链图\"></p>\n<p>在第一个读取数据时生成了，所以这条查询语句对应的ReadView。</p>\n<ul>\n<li>m_ids = [100，200]</li>\n<li>min_trx_id = 100 (最小的活跃事务ID)</li>\n<li>max_trx_id = 201</li>\n<li>creator_trx_id = 0（由于只读事务创建的事务ID都是0）</li>\n</ul>\n<p>从‘乔巴’开始判断，trx_id = 100 , 在m_ids中，不能被访问，继续下一步到‘索罗’可以了。</p>\n<p><strong>假设2：</strong>假设现在事务100提交了，事务200做了更新到‘罗宾’后还没提交，假设1中的事务300继续执行了查询number = 1。现在的版本链如下。</p>\n<p><img src=\"/2020/08/30/mysql-mvcc/1.png\" alt></p>\n<p>由于在第一次读取数据时已经生成了，所以ReadView还是下面的样子</p>\n<ul>\n<li>m_ids = [100，200]</li>\n<li>min_trx_id = 100 (最小的活跃事务ID)</li>\n<li>max_trx_id = 201</li>\n<li>creator_trx_id = 0（由于只读事务创建的事务ID都是0）</li>\n</ul>\n<p>从‘罗宾’开始判断，由于trx_id在m_ids中，不符合。到‘乔巴’trx_id=100也在m_ids中，不符合。直到‘索罗’符合。</p>\n<h4 id=\"幻读怎么办？\"><a href=\"#幻读怎么办？\" class=\"headerlink\" title=\"幻读怎么办？\"></a>幻读怎么办？</h4><p>我们再来理解一下幻读的情况，<strong>如果⼀个事务先根据某些条件查询出⼀些记录，之后另⼀个事务⼜向表中插⼊了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另⼀个事务插⼊的记录也读出来，那就意味着发⽣了幻读</strong>。</p>\n<p><strong>为什么可重复读可能发生幻读？</strong>通过分析可重复读的原理，我们列举两个例子。新建一张表</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> <span class=\"token punctuation\">`</span>dept<span class=\"token punctuation\">`</span> <span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span> <span class=\"token keyword\">int</span><span class=\"token punctuation\">(</span><span class=\"token number\">11</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">NOT</span> <span class=\"token boolean\">NULL</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">`</span>name<span class=\"token punctuation\">`</span> <span class=\"token keyword\">varchar</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token boolean\">NULL</span><span class=\"token punctuation\">,</span>\n  <span class=\"token keyword\">PRIMARY</span> <span class=\"token keyword\">KEY</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">`</span>id<span class=\"token punctuation\">`</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span> <span class=\"token keyword\">ENGINE</span><span class=\"token operator\">=</span><span class=\"token keyword\">InnoDB</span> <span class=\"token keyword\">AUTO_INCREMENT</span><span class=\"token operator\">=</span><span class=\"token number\">12</span> <span class=\"token keyword\">DEFAULT</span> <span class=\"token keyword\">CHARSET</span><span class=\"token operator\">=</span>utf8\n<span class=\"token keyword\">insert</span> <span class=\"token keyword\">into</span> dept<span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">values</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"后勤部\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><strong>例子1：</strong>在可重复读隔离级别下</p>\n<table>\n<thead>\n<tr>\n<th>事务1</th>\n<th>事务2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>begin</td>\n<td>begin</td>\n</tr>\n<tr>\n<td>select * from dept</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>insert into dept(name) values (‘研发部’)</td>\n</tr>\n<tr>\n<td></td>\n<td>commit</td>\n</tr>\n<tr>\n<td>select * from dept</td>\n<td></td>\n</tr>\n<tr>\n<td>commit</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>这种情况下由于是可重复读，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。所以不会发生幻读。</p>\n<p><strong>例子2：</strong>在可重复读隔离级别下</p>\n<table>\n<thead>\n<tr>\n<th>事务1</th>\n<th>事务2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>begin</td>\n<td>begin</td>\n</tr>\n<tr>\n<td>select * from dept</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>insert into dept(name) values (‘研发部’)</td>\n</tr>\n<tr>\n<td></td>\n<td>commit</td>\n</tr>\n<tr>\n<td>update dept set name = ‘财务部’</td>\n<td></td>\n</tr>\n<tr>\n<td>commit</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>在可重复读隔离级别下，我们觉得预期的结果应该是后勤部被更改成财务部，表中的数据有研发部，财务部。但实际上表中的两条数据都是财务部。发生了幻读。</p>\n<p><strong>为什么?</strong> RR级别中，通过MVCC机制读取到的是快照数据，所以没问题。然而在做Update的情况下都是需要读取当前最新数据的，所以就出现了上面的情况。</p>\n<p><strong>如何解决幻读？</strong></p>\n<p>很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：</p>\n<ul>\n<li>使用串行化读的隔离级别</li>\n<li>MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)</li>\n</ul>\n<p>所谓的next-key locks是记录锁加间隙(gap)锁的组合。只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。</p>\n<p>实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>MVCC（多版本并发控制）指的就是在使⽤ READ COMMITTD （读提交）、 REPEATABLE READ（可重复读）这两种隔离级别的事务在执⾏普通的 SEELCT 操作时访问记录的版本链的过程，这样⼦可以使不同事务的 读-写 、 写-读 操作并发执⾏，从⽽提升系统性能。</li>\n<li>MVCC的关键是使用undo日志组成一条链。</li>\n<li>对于读未提交、串行化直接读取的内存最新值。</li>\n<li>脏写是不会发生的，因为一个事务在更新数据时，如果另一个事务也要更新必须等到在更新的事务提交。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>先定义一个表，方便后面说明。</p>\n<pre><code class=\"sql\">CREATE    TABLE hero(\n       number    INT,\n       name    VARCHAR(100),\n       country    varchar(100),\n       PRIMARY    KEY    (number)\n)    Engine=InnoDB    CHARSET=utf8;\nINSERT INTO    hero VALUES(1,    &#39;索罗&#39;,&#39;cn&#39;);</code></pre>\n<p>MySQL是一个客户端/服务器架构。对于MySQL这个服务器来说，可以有很多客户端与其连接。每个客户端与服务器连接上之后，就可以称之为⼀个会话（Session）。事务是用来保证一个或多个数据库操作要嘛全部成功，要嘛全部回滚。事务要求我们要保证<font color=\"red\">原子性、一致性、隔离性、持久性</font>。</p>\n<ul>\n<li>原子性，多个操作是一个不可分割的整体，要么全做，要么全不做的规则称之为原⼦性。</li>\n<li>一致性，在事务操作之前和之后，数据都是保持一个相同的状态，数据库的完整性没有被破坏。</li>\n<li>隔离性，保证多个事务之间不互相影响的规则称之为隔离性。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li>\n<li>持久性，事务操作完成后，数据会被刷新到磁盘永久保存，即便是系统故障也不会丢失。</li>\n</ul>\n<p><font color=\"red\">由于多个事务之间是并发执行的，要使得的事务之间互相不影响保证隔离性，只能对事务进行排队访问(锁)，但是这样的效果效率底下，如果不使用排队，多个事务之间同时操作则会出现如下问题：</font></p>","more":"<h3 id=\"事务并发执行可能出现的问题\"><a href=\"#事务并发执行可能出现的问题\" class=\"headerlink\" title=\"事务并发执行可能出现的问题\"></a>事务并发执行可能出现的问题</h3><h4 id=\"脏写\"><a href=\"#脏写\" class=\"headerlink\" title=\"脏写\"></a>脏写</h4><p>如果⼀个事务修改了另⼀个未提交事务修改过的数据，那就意味着发⽣了脏写。</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>Session A</th>\n<th>Session B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin;</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n<td>begin;</td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td>UPDAE hero SET name = ‘路飞’ WHERE number = 1;</td>\n</tr>\n<tr>\n<td>4</td>\n<td>UPDAE hero SET name = ‘乔巴’ WHERE number = 1;</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>commit;</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td></td>\n<td>rollback;</td>\n</tr>\n</tbody></table>\n<p>在事务B先把值改成路飞后，事务A又把值改成了乔巴。事务A先提交后事务B回滚成原始值。导致了<font color=\"red\">事务A明明把值改了但最后缺没有任何变化</font>。</p>\n<h4 id=\"脏读\"><a href=\"#脏读\" class=\"headerlink\" title=\"脏读\"></a>脏读</h4><p>如果⼀个事务读到了另⼀个未提交事务修改过的数据，那就意味着发⽣了脏读。</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>Session A</th>\n<th>Session B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin;</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n<td>begin;</td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td>UPDAE hero SET name = ‘路飞’ WHERE number = 1;</td>\n</tr>\n<tr>\n<td>4</td>\n<td>SELECT * FROM hero WHERE hero = 1;</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>commit;</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td></td>\n<td>rollback;</td>\n</tr>\n</tbody></table>\n<p>在事务A的4时刻如果读取到的name=’路飞’，但是最后事务B回滚后事务A就读取到了一个不存在的数据。</p>\n<h4 id=\"不可重复读\"><a href=\"#不可重复读\" class=\"headerlink\" title=\"不可重复读\"></a>不可重复读</h4><p>如果⼀个事务只能读到另⼀个已经提交的事务修改过的数据，并且其他事务每对该数据进⾏⼀次修改并提交后，该事务都能查询得到最新值，那就意味着发⽣了不可重复读。</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>Session A</th>\n<th>Session B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin;</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>SELECT * FROM hero WHERE hero = 1;<br>(此时读取到的值是’’索罗’’)</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td>begin;<br>UPDAE hero SET name = ‘路飞’ WHERE number = 1;<br>commit;</td>\n</tr>\n<tr>\n<td>4</td>\n<td>SELECT * FROM hero WHERE hero = 1;<br>(如果读到的值是’路飞’，则意味发生了不可重复读)</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td></td>\n<td>begin;<br>UPDAE hero SET name = ‘乔巴’ WHERE number = 1;<br>commit;</td>\n</tr>\n<tr>\n<td>6</td>\n<td>SELECT * FROM hero WHERE hero = 1;<br>(如果读到的值是’乔巴’，则意味发生了不可重复读)</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"幻读\"><a href=\"#幻读\" class=\"headerlink\" title=\"幻读\"></a>幻读</h4><p>如果⼀个事务先根据某些条件查询出⼀些记录，之后另⼀个事务⼜向表中插⼊了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另⼀个事务插⼊的记录也读出来，那就意味着发⽣了幻读。</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>Session A</th>\n<th>Session B</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin;</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>SELECT * FROM hero WHERE hero &gt; 0;<br>(此时读取到的值是’’索罗’’)</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td></td>\n<td>INSERT INTO hero VALUE(2,’路飞’,’cn’)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>SELECT * FROM hero WHERE hero &gt; 0;<br>(此时读取到的值是’’索罗’’、“路飞”，则意味发生了幻读)</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"隔离级别概述与实现原理-重点\"><a href=\"#隔离级别概述与实现原理-重点\" class=\"headerlink\" title=\"隔离级别概述与实现原理(重点)\"></a>隔离级别概述与实现原理(重点)</h3><h4 id=\"隔离级别基础知识\"><a href=\"#隔离级别基础知识\" class=\"headerlink\" title=\"隔离级别基础知识\"></a>隔离级别基础知识</h4><p>由此可见，并发事务会引起上面说的4种问题，严重性从大到小 ：脏写，脏读，不可重复读，幻读。</p>\n<p>MySQL为了保证事务能在并发下执行（提高性能）又想尽量减少上面的4个问题，所以制定了事务隔离级别用来解决上面说的4种问题，<font color=\"red\">级别越高越能解决问题，相对的性能越低</font>。</p>\n<ul>\n<li>READ UNCOMMITTED（未提交读），<font color=\"blue\">一个事务还没提交时，它做的变更就能被别的事务看到</font>。</li>\n<li>READ COMMITTED（已提交读），<font color=\"blue\">一个事务提交之后，它做的变更才会被其他事务看到</font>。</li>\n<li>REPEATABLE READ（可重复读），<font color=\"blue\">一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</font>。</li>\n<li>SERIALIZABLE（可串⾏化），<font color=\"blue\">顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</font>。</li>\n</ul>\n<p><strong>不同隔离级别下可以和不可以解决问题的对照表</strong></p>\n<table>\n<thead>\n<tr>\n<th>隔离级别</th>\n<th>脏读</th>\n<th>不可重复读</th>\n<th>幻读</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>READ UNCOMMITTED（未提交读）</td>\n<td>可能发生</td>\n<td>可能发生</td>\n<td>可能发生</td>\n</tr>\n<tr>\n<td>READ COMMITTED（已提交读）</td>\n<td>不发生</td>\n<td>可能发生</td>\n<td>可能发生</td>\n</tr>\n<tr>\n<td>REPEATABLE READ（可重复读）</td>\n<td>不发生</td>\n<td>不发生</td>\n<td>可能发生</td>\n</tr>\n<tr>\n<td>SERIALIZABLE（可串⾏化）</td>\n<td>不发生</td>\n<td>不发生</td>\n<td>不发生</td>\n</tr>\n</tbody></table>\n<ul>\n<li>READ UNCOMMITTED 隔离级别下，可能发⽣脏读 、 不可重复读和幻读问题。</li>\n<li>READ COMMITTED 隔离级别下，可能发⽣不可重复读和幻读问题，但是不可以发⽣脏读问题。</li>\n<li>REPEATABLE READ 隔离级别下，可能发⽣幻读问题，但是不可以发⽣脏读和不可重复读的问题。</li>\n<li>SERIALIZABLE 隔离级别下，各种问题都不可以发⽣。</li>\n</ul>\n<p><strong>我们举个例子帮助理解下</strong>。例如可重复读，按照意思就是说我一个事务启动的时候就已经将启动这一时刻的数据做了一个”快照”，例如事务启动这一时刻我读取到的number = 1是’路飞‘，那我不管这个事务后面怎么再去读取number = 1的数据也都只会是路飞。那这样的话我们分析下，</p>\n<ul>\n<li>脏读指得是一个事务读取到没提交事务修改过的数据，那由于我做了”快照”只能读取最开始的值，所以不会发生。</li>\n<li>不可重复读也是如此，这就不说了。</li>\n<li><font color=\"red\">可重复读下可能发生幻读，后面原理详解说明</font></li>\n</ul>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>那隔离级别到底是基于什么原理来实现脏读，不可重复读和幻读的呢。答案就是MVCC(多版本并发控制)。用大白话大概解释下实现的原理：<font color=\"red\">我们以前说过Undo日志，他用来记录数据更改前的值，用来实现回滚，其实他也是MVCC的关键。MySQL将数据的更变记录形成一条链条，每个更变记录上记录着对应操作的事务ID，然后通过判断事务ID来决定读取到的内容是哪个。下面具体分析</font>。</p>\n<h5 id=\"版本链\"><a href=\"#版本链\" class=\"headerlink\" title=\"版本链\"></a>版本链</h5><p>对于使⽤InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列：</p>\n<ul>\n<li>trx_id ： 每次⼀个事务对某条聚簇索引记录进⾏改动时都会将改动这条记录的事务ID记录到这里。</li>\n<li>roll_pointer ：每次对某条聚簇索引记录进⾏改动时，都会把旧的版本写⼊到undo⽇志中，然后这个隐藏列就相当于⼀个指针，可以通过它来找到该记录修改前的信息。</li>\n</ul>\n<p>两个事务做的操作如下(<strong>最开始假设原来的索罗这条数据是事务ID=80插入的</strong>)：</p>\n<table>\n<thead>\n<tr>\n<th>时间编号</th>\n<th>trx_id = 100</th>\n<th>trx_id = 200</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>begin</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td></td>\n<td>begin</td>\n</tr>\n<tr>\n<td>3</td>\n<td>update hexo set name = ‘路飞’ where number = 1</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>update hexo set name = ‘乔巴’ where number = 1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>commit</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td></td>\n<td>update hexo set name = ‘娜美’ where number = 1</td>\n</tr>\n<tr>\n<td>7</td>\n<td></td>\n<td>update hexo set name = ‘罗宾’ where number = 1</td>\n</tr>\n<tr>\n<td>8</td>\n<td></td>\n<td>commit</td>\n</tr>\n</tbody></table>\n<p><strong>小贴士 : 为什么图例上没有那种两个事务交叉更新同一条数据的情况? 这种情况不可能发生，更一条记录更新时，InnoDB就会将这条记录锁起来了，其他事务是必须等这个事务更新后才能操作，只能阻塞。但是对于读的话可以读，但是会会读取到什么内容不一定(<font color=\"red\">其实隔离机制就是用来解决这个读取的问题，读到哪个值就是不同隔离机制决定的</font>)。</strong></p>\n<p>所以，上面的版本链用图示表示如下</p>\n<p><img src=\"/2020/08/30/mysql-mvcc/1.png\" alt></p>\n<p>对该记录每次更新后，都会将旧值放到⼀条undo⽇志中，就算是该记录的⼀个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成⼀个链表，我们把这个链表称之为<font color=\"red\">版本链</font>，版本链的头节点就是当前记录最新的值。</p>\n<p><strong>READ UNCOMMITTED（未提交读）、SERIALIZABLE（串行化）如何实现？</strong></p>\n<p>由于未提交读是<strong>一个事务还没提交时，它做的变更就能被别的事务看到</strong>。所以如果设置的是未提交读级别的隔离，那每次只要读取版本链的最新数据，也就是当前内存数据就可以了。对于串行化隔离级别，InnoDB使用的是加锁的方式，所以也是读取内存最新值。</p>\n<h5 id=\"ReadView\"><a href=\"#ReadView\" class=\"headerlink\" title=\"ReadView\"></a>ReadView</h5><p>对于使⽤READ COMMITTED（读提交）和REPEATABLE READ（可重复读）隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另⼀个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核⼼问题就是：<font color=\"red\">需要判断⼀下版本链中的哪个版本是当前事务可⻅的</font>。所以提出了⼀个ReadView的概念。ReadView中包含4个内容：</p>\n<ul>\n<li>m_ids：表示在⽣成ReadView时当前系统中活跃的读写事务的事务id列表。 </li>\n<li>min_trx_id：表示在⽣成ReadView时当前系统中活跃的读写事务中最⼩的事务id，也就是m_ids中的最⼩值。</li>\n<li>max_trx_id：表示⽣成ReadView时系统中应该分配给下⼀个事务的id值。</li>\n<li>creator_trx_id：表示⽣成该ReadView的事务的事务id。</li>\n</ul>\n<p><strong>小贴士：只有在对表中的记录做改动时（执⾏INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在⼀个只读事务中的事务id值都默认为0。</strong></p>\n<p>有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可⻅：</p>\n<ul>\n<li>如果被访问的版本的trx_id值与ReadView中的creator_trx_id值相同，表示<font color=\"red\">当前事务访问的是自己修改的记录，该版本可以被访问</font>。</li>\n<li>如果被访问的版本的trx_id值小于min_trx_id，表示<font color=\"red\">被访问版本在当前事务生成前已经提交了，该版本可以访问</font>。</li>\n<li>如果被访问的版本的trx_id值大于max_trx_id，表示<font color=\"red\">被访问版本在当前事务生成后才生成，该版本不能被访问</font>。</li>\n<li>如果被访问的版本在min_trx_id、max_trx_id之间，需要判断下被访问版本的trx_id值是不是在m_ids列表中。<ul>\n<li><font color=\"green\">如果在就表示创建ReadView时被访问版本对应的事务是活跃的，该版本不能被访问</font>。</li>\n<li><font color=\"green\">如果不在就表创建ReadView时被访问版本对应的事务已经提交了，该版本可以被访问</font>。</li>\n</ul>\n</li>\n</ul>\n<p>如果某个版本不可访问就顺着版本链继续找下一个直到最后一个版本。</p>\n<p><strong>现在我们来分析下READ COMMITTED（读提交）和REPEATABLE READ（可重复读）的不同</strong>。</p>\n<ul>\n<li><font color=\"blue\">读提交隔离级别规定只要是事务提交了，那更变马上就可以看到</font>。</li>\n<li><font color=\"blue\">可重复读隔离级别规定只能看到事务启动时的版本，后面即使其他事务做了更变提交了，我也看不到</font>。</li>\n</ul>\n<p>所以，MREAD COMMITTED和REPEATABLE READ隔离级别的的⼀个⾮常⼤的区别就是它们⽣成ReadView的时机不同所以才能使得他们能达到不同的效果。</p>\n<p><strong>READ COMMITTED（读提交） —— 每次读取数据前都⽣成⼀个ReadView</strong></p>\n<p><strong>假设1：</strong>假设现在事务100做了更新还没提交，事务200做了其他表的更新但是还没更新number=1的数据。新事务执行了如下语句，那他得到的值是什么，我们来分析下。</p>\n<pre><code class=\"sql\">SELECT * FROM hero WHERE number = 1;</code></pre>\n<p><img src=\"/2020/08/30/mysql-mvcc/2.png\" alt></p>\n<p>由于是每次读取时生成ReadView。所以此时生成了一个ReadView，此时</p>\n<ul>\n<li>m_ids = [100,200]</li>\n<li>min_trx_id = 100</li>\n<li>max_trx_id = 201</li>\n<li>creator_trx_id = 0 （由于只读事务创建的事务ID都是0）</li>\n</ul>\n<p>从乔巴开始判断，由于trx_id=100在m_Ids中，不符合。直到索罗trx_id=80，不在m_ids中，该版本可以被访问</p>\n<p><strong>假设2：</strong>假设现在事务100已经提交，事务200更新成‘罗宾’，假设1中的新事务执行了</p>\n<pre><code class=\"sql\">SELECT * FROM hero WHERE number = 1;</code></pre>\n<p><img src=\"/2020/08/30/mysql-mvcc/1.png\" alt></p>\n<p>由于每次读取时都生成ReadView，所以此时生成了一个ReadView，</p>\n<ul>\n<li>m_ids = [200]（此时事务100已经提交了，所以活跃的只有200）</li>\n<li>min_trx_id = 200 (最小的活跃事务ID)</li>\n<li>max_trx_id = 201</li>\n<li>creator_trx_id = 0（由于只读事务创建的事务ID都是0）</li>\n</ul>\n<p>从版本的第一个‘罗宾’开始判断，由于该版本trx_id = 200，在m_ids中，不符合。到‘乔巴’trx_id=100不在m_ids中，符合，该版本可以被访问。</p>\n<p><strong>REPEATABLE READ（可重复读） —— 在第⼀次读取数据时⽣成⼀个ReadView</strong></p>\n<p><strong>假设1：</strong>假设现在事务100，事务200是活跃的，事务100刚更新了‘路飞’，‘乔巴’，事务200更新了其他表的数据但是还没更新number=1的数据。此时来了一个事务300。</p>\n<pre><code class=\"sql\">SELECT * FROM hero WHERE number = 1;</code></pre>\n<p><img src=\"/2020/08/30/mysql-mvcc/2.png\" alt=\"版本链图\"></p>\n<p>在第一个读取数据时生成了，所以这条查询语句对应的ReadView。</p>\n<ul>\n<li>m_ids = [100，200]</li>\n<li>min_trx_id = 100 (最小的活跃事务ID)</li>\n<li>max_trx_id = 201</li>\n<li>creator_trx_id = 0（由于只读事务创建的事务ID都是0）</li>\n</ul>\n<p>从‘乔巴’开始判断，trx_id = 100 , 在m_ids中，不能被访问，继续下一步到‘索罗’可以了。</p>\n<p><strong>假设2：</strong>假设现在事务100提交了，事务200做了更新到‘罗宾’后还没提交，假设1中的事务300继续执行了查询number = 1。现在的版本链如下。</p>\n<p><img src=\"/2020/08/30/mysql-mvcc/1.png\" alt></p>\n<p>由于在第一次读取数据时已经生成了，所以ReadView还是下面的样子</p>\n<ul>\n<li>m_ids = [100，200]</li>\n<li>min_trx_id = 100 (最小的活跃事务ID)</li>\n<li>max_trx_id = 201</li>\n<li>creator_trx_id = 0（由于只读事务创建的事务ID都是0）</li>\n</ul>\n<p>从‘罗宾’开始判断，由于trx_id在m_ids中，不符合。到‘乔巴’trx_id=100也在m_ids中，不符合。直到‘索罗’符合。</p>\n<h4 id=\"幻读怎么办？\"><a href=\"#幻读怎么办？\" class=\"headerlink\" title=\"幻读怎么办？\"></a>幻读怎么办？</h4><p>我们再来理解一下幻读的情况，<strong>如果⼀个事务先根据某些条件查询出⼀些记录，之后另⼀个事务⼜向表中插⼊了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另⼀个事务插⼊的记录也读出来，那就意味着发⽣了幻读</strong>。</p>\n<p><strong>为什么可重复读可能发生幻读？</strong>通过分析可重复读的原理，我们列举两个例子。新建一张表</p>\n<pre><code class=\"sql\">CREATE TABLE `dept` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(20) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8\ninsert into dept(name) values(&quot;后勤部&quot;);</code></pre>\n<p><strong>例子1：</strong>在可重复读隔离级别下</p>\n<table>\n<thead>\n<tr>\n<th>事务1</th>\n<th>事务2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>begin</td>\n<td>begin</td>\n</tr>\n<tr>\n<td>select * from dept</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>insert into dept(name) values (‘研发部’)</td>\n</tr>\n<tr>\n<td></td>\n<td>commit</td>\n</tr>\n<tr>\n<td>select * from dept</td>\n<td></td>\n</tr>\n<tr>\n<td>commit</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>这种情况下由于是可重复读，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。所以不会发生幻读。</p>\n<p><strong>例子2：</strong>在可重复读隔离级别下</p>\n<table>\n<thead>\n<tr>\n<th>事务1</th>\n<th>事务2</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>begin</td>\n<td>begin</td>\n</tr>\n<tr>\n<td>select * from dept</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td>insert into dept(name) values (‘研发部’)</td>\n</tr>\n<tr>\n<td></td>\n<td>commit</td>\n</tr>\n<tr>\n<td>update dept set name = ‘财务部’</td>\n<td></td>\n</tr>\n<tr>\n<td>commit</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>在可重复读隔离级别下，我们觉得预期的结果应该是后勤部被更改成财务部，表中的数据有研发部，财务部。但实际上表中的两条数据都是财务部。发生了幻读。</p>\n<p><strong>为什么?</strong> RR级别中，通过MVCC机制读取到的是快照数据，所以没问题。然而在做Update的情况下都是需要读取当前最新数据的，所以就出现了上面的情况。</p>\n<p><strong>如何解决幻读？</strong></p>\n<p>很明显可重复读的隔离级别没有办法彻底的解决幻读的问题，如果我们的项目中需要解决幻读的话也有两个办法：</p>\n<ul>\n<li>使用串行化读的隔离级别</li>\n<li>MVCC+next-key locks：next-key locks由record locks(索引加锁) 和 gap locks(间隙锁，每次锁住的不光是需要使用的数据，还会锁住这些数据附近的数据)</li>\n</ul>\n<p>所谓的next-key locks是记录锁加间隙(gap)锁的组合。只在REPEATABLE READ或以上的隔离级别下的特定操作才会取得gap lock或nextkey lock。</p>\n<p>实际上很多的项目中是不会使用到上面的两种方法的，串行化读的性能太差，而且其实幻读很多时候是我们完全可以接受的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>MVCC（多版本并发控制）指的就是在使⽤ READ COMMITTD （读提交）、 REPEATABLE READ（可重复读）这两种隔离级别的事务在执⾏普通的 SEELCT 操作时访问记录的版本链的过程，这样⼦可以使不同事务的 读-写 、 写-读 操作并发执⾏，从⽽提升系统性能。</li>\n<li>MVCC的关键是使用undo日志组成一条链。</li>\n<li>对于读未提交、串行化直接读取的内存最新值。</li>\n<li>脏写是不会发生的，因为一个事务在更新数据时，如果另一个事务也要更新必须等到在更新的事务提交。</li>\n</ul>"},{"title":"Redis5.0集群搭建和水平扩展（一）","description":"详解Redis5.0集群搭建和水平扩展","date":"2020-09-01T07:46:34.000Z","_content":"\n## 概述\n\nredis集群是一个由多个主从节点群组成的分布式服务器群，它具有<font color=red>复制、高可用和分片特性</font>。总结来说他的特点和好处包括：\n\n- Redis的集群方式是无中心化的集群，每个KEY通过 **虚拟槽分区算法** 计算KEY存储在哪台机器上。\n- Redis集群不需要sentinel哨兵也能完成**节点转移、故障转移**的功能。\n- 可水平扩展据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。\n- Redis集群槽的范围是0 -16383（2^4 * 2^10）。\n\n![RedisCluster架构图](redis-cluster-build/1.png)\n<!--more-->\nredis集群搭建如上图所示，通过多个master节点实现高性能，每个master下设置salve来实现高可用。\n- 当集群性能不够时，可通过增加新的master来实现更高的性能。\n- 当master宕机时，redis集群能实现自动的故障转移来保证高可用。\n\n## Redis5.0集群搭建\n\n### Redis安装\n本次安装采用一主一从 + 3主 的集群模式。三台主机端口分别是9851、9852、9853。\n\n![Redis安装架构图](redis-cluster-build/2.png)\n\n安装Redis没什么好说的，直接看命令。安装以后就可以使用redis命令了。\n\n```shell\n#卸载\nrpm -qa|grep redis #查看是否有存在旧的redis\nrpm -e redis-3.0.7.ws4-1.el6.x86_64 删掉旧的redis\n## 安装\ncd /usr/local/src/\ntar -zxvf redis-5.0.7.tar.gz\ncd redis-5.0.7/\nmake\nmake install\n```\n### Redis配置\n为了更好的管理，我们先在建立9851~9856的目录存放6个Redis实例的配置文件。\n\n![](redis-cluster-build/3.png)\n\n在每个目录下建立一个redis.conf配置文件。配置内容如下（**注意每个目录的配置有些不同，自行修改**）。这里只提供了几个重要的参数，redis还有很多参数需要自己去看。\n```shell\n#后台方式运行\ndaemonize yes\n#redis实例PID的存放路径\npidfile \"/etc/redis/9851/redis.pid\"\n#端口\nport 9851\n#日志文件地址\nlogfile \"/etc/redis/9851/redis.log\"\n#基础路径，存放dump aof文件的地址\ndir \"/etc/redis/9851\"\ndatabases 16\n#这里我只采用rdb快照方式，可以根据实际选择配置\nsave 900 1\nrepl-backlog-size 64mb\nstop-writes-on-bgsave-error yes\nrdbcompression yes\nrdbchecksum yes\ndbfilename \"dump.rdb\"\n#重点配置，这个就是搭建集群的关键\ncluster-enabled yes\n#集群节点信息文件\ncluster-config-file node.conf\n#表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)\ncluster-node-timeout 15000\n```\n### 启动Redis实例\n分别启动6个Redis实例。可以看到6个实例已经启动。\n\n```shell\nredis-server /etc/redis/9851/redis.conf\nredis-server /etc/redis/9852/redis.conf\nredis-server /etc/redis/9853/redis.conf\nredis-server /etc/redis/9854/redis.conf\nredis-server /etc/redis/9855/redis.conf\nredis-server /etc/redis/9856/redis.conf\n```\n\n![](redis-cluster-build/4.png)\n\n### 配置集群\n\nRedis启动后，我们就可以开始配置集群，Redis高版本提供了--cluster命令可以很快速的的进行搭建和分槽\n\n```shell\nredis-cli --cluster create 10.8.198.152:9851 10.8.198.152:9852 10.8.198.152:9853 10.8.198.152:9854 10.8.198.152:9855 10.8.198.152:9856 --cluster-replicas 1\n```\n\n![](redis-cluster-build/5.png)\n\n执行后，会打印出Master和Slave的信息并**提示我们是否自动分槽**，我们按照提示输入'YES'。\n\n<font color=red>到这里。Redis集群搭建完成。</font>\n\n我们可以通过如下这些命令查看集群信息。\n\n**redis-cli --cluster check IP:PORT**\n\n这个信息可以看主从节点信息。\n\n![](redis-cluster-build/7.png)\n\n**客户端登陆后执行cluster slots查看分槽信息**\n\n从图可以看出\n\n- 0 ~ 5460 槽在端口9851实例上，对应的从节点是9854\n- 5461 ~ 10922 槽在端口9852实例上，对应的从节点是9855\n- 10923 ~ 16383 槽在端口9853实例上，对应的从节点是9856\n\n![](redis-cluster-build/6.png)\n\n**模拟存入一个key，看是否存入且主从节气上都有对应的值**\n\n```java\nredisTemplate.opsForValue().set(\"name\",\"myLive\");\n```\n\n![](redis-cluster-build/8.png)\n\n可以发现，值已经存入了主从机器上。\n\n**模拟9852机器宕机后是否能实现故障转移**\n\n通过命令杀掉9852机器\n\n```shell\n[root@Slave3 redis]# kill -9 PID(9852对应的PID)\n```\n\n![9855成为新的master](redis-cluster-build/9.png)\n\n重新启动9852机器。\n\n![9852重新启动后成为9855的从服务器](redis-cluster-build/10.png)","source":"_posts/redis-cluster-build.md","raw":"---\ntitle: Redis5.0集群搭建和水平扩展（一）\ntags:\n  - redis\ncategories: redis\ndescription : 详解Redis5.0集群搭建和水平扩展\ndate: 2020-09-01 15:46:34\n---\n\n## 概述\n\nredis集群是一个由多个主从节点群组成的分布式服务器群，它具有<font color=red>复制、高可用和分片特性</font>。总结来说他的特点和好处包括：\n\n- Redis的集群方式是无中心化的集群，每个KEY通过 **虚拟槽分区算法** 计算KEY存储在哪台机器上。\n- Redis集群不需要sentinel哨兵也能完成**节点转移、故障转移**的功能。\n- 可水平扩展据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。\n- Redis集群槽的范围是0 -16383（2^4 * 2^10）。\n\n![RedisCluster架构图](redis-cluster-build/1.png)\n<!--more-->\nredis集群搭建如上图所示，通过多个master节点实现高性能，每个master下设置salve来实现高可用。\n- 当集群性能不够时，可通过增加新的master来实现更高的性能。\n- 当master宕机时，redis集群能实现自动的故障转移来保证高可用。\n\n## Redis5.0集群搭建\n\n### Redis安装\n本次安装采用一主一从 + 3主 的集群模式。三台主机端口分别是9851、9852、9853。\n\n![Redis安装架构图](redis-cluster-build/2.png)\n\n安装Redis没什么好说的，直接看命令。安装以后就可以使用redis命令了。\n\n```shell\n#卸载\nrpm -qa|grep redis #查看是否有存在旧的redis\nrpm -e redis-3.0.7.ws4-1.el6.x86_64 删掉旧的redis\n## 安装\ncd /usr/local/src/\ntar -zxvf redis-5.0.7.tar.gz\ncd redis-5.0.7/\nmake\nmake install\n```\n### Redis配置\n为了更好的管理，我们先在建立9851~9856的目录存放6个Redis实例的配置文件。\n\n![](redis-cluster-build/3.png)\n\n在每个目录下建立一个redis.conf配置文件。配置内容如下（**注意每个目录的配置有些不同，自行修改**）。这里只提供了几个重要的参数，redis还有很多参数需要自己去看。\n```shell\n#后台方式运行\ndaemonize yes\n#redis实例PID的存放路径\npidfile \"/etc/redis/9851/redis.pid\"\n#端口\nport 9851\n#日志文件地址\nlogfile \"/etc/redis/9851/redis.log\"\n#基础路径，存放dump aof文件的地址\ndir \"/etc/redis/9851\"\ndatabases 16\n#这里我只采用rdb快照方式，可以根据实际选择配置\nsave 900 1\nrepl-backlog-size 64mb\nstop-writes-on-bgsave-error yes\nrdbcompression yes\nrdbchecksum yes\ndbfilename \"dump.rdb\"\n#重点配置，这个就是搭建集群的关键\ncluster-enabled yes\n#集群节点信息文件\ncluster-config-file node.conf\n#表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)\ncluster-node-timeout 15000\n```\n### 启动Redis实例\n分别启动6个Redis实例。可以看到6个实例已经启动。\n\n```shell\nredis-server /etc/redis/9851/redis.conf\nredis-server /etc/redis/9852/redis.conf\nredis-server /etc/redis/9853/redis.conf\nredis-server /etc/redis/9854/redis.conf\nredis-server /etc/redis/9855/redis.conf\nredis-server /etc/redis/9856/redis.conf\n```\n\n![](redis-cluster-build/4.png)\n\n### 配置集群\n\nRedis启动后，我们就可以开始配置集群，Redis高版本提供了--cluster命令可以很快速的的进行搭建和分槽\n\n```shell\nredis-cli --cluster create 10.8.198.152:9851 10.8.198.152:9852 10.8.198.152:9853 10.8.198.152:9854 10.8.198.152:9855 10.8.198.152:9856 --cluster-replicas 1\n```\n\n![](redis-cluster-build/5.png)\n\n执行后，会打印出Master和Slave的信息并**提示我们是否自动分槽**，我们按照提示输入'YES'。\n\n<font color=red>到这里。Redis集群搭建完成。</font>\n\n我们可以通过如下这些命令查看集群信息。\n\n**redis-cli --cluster check IP:PORT**\n\n这个信息可以看主从节点信息。\n\n![](redis-cluster-build/7.png)\n\n**客户端登陆后执行cluster slots查看分槽信息**\n\n从图可以看出\n\n- 0 ~ 5460 槽在端口9851实例上，对应的从节点是9854\n- 5461 ~ 10922 槽在端口9852实例上，对应的从节点是9855\n- 10923 ~ 16383 槽在端口9853实例上，对应的从节点是9856\n\n![](redis-cluster-build/6.png)\n\n**模拟存入一个key，看是否存入且主从节气上都有对应的值**\n\n```java\nredisTemplate.opsForValue().set(\"name\",\"myLive\");\n```\n\n![](redis-cluster-build/8.png)\n\n可以发现，值已经存入了主从机器上。\n\n**模拟9852机器宕机后是否能实现故障转移**\n\n通过命令杀掉9852机器\n\n```shell\n[root@Slave3 redis]# kill -9 PID(9852对应的PID)\n```\n\n![9855成为新的master](redis-cluster-build/9.png)\n\n重新启动9852机器。\n\n![9852重新启动后成为9855的从服务器](redis-cluster-build/10.png)","slug":"redis-cluster-build","published":1,"updated":"2021-04-08T00:47:06.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvi002gqwv259jp3j0j","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>redis集群是一个由多个主从节点群组成的分布式服务器群，它具有<font color=\"red\">复制、高可用和分片特性</font>。总结来说他的特点和好处包括：</p>\n<ul>\n<li>Redis的集群方式是无中心化的集群，每个KEY通过 <strong>虚拟槽分区算法</strong> 计算KEY存储在哪台机器上。</li>\n<li>Redis集群不需要sentinel哨兵也能完成<strong>节点转移、故障转移</strong>的功能。</li>\n<li>可水平扩展据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。</li>\n<li>Redis集群槽的范围是0 -16383（2^4 * 2^10）。</li>\n</ul>\n<p><img src=\"/2020/09/01/redis-cluster-build/1.png\" alt=\"RedisCluster架构图\"></p>\n<a id=\"more\"></a>\n<p>redis集群搭建如上图所示，通过多个master节点实现高性能，每个master下设置salve来实现高可用。</p>\n<ul>\n<li>当集群性能不够时，可通过增加新的master来实现更高的性能。</li>\n<li>当master宕机时，redis集群能实现自动的故障转移来保证高可用。</li>\n</ul>\n<h2 id=\"Redis5-0集群搭建\"><a href=\"#Redis5-0集群搭建\" class=\"headerlink\" title=\"Redis5.0集群搭建\"></a>Redis5.0集群搭建</h2><h3 id=\"Redis安装\"><a href=\"#Redis安装\" class=\"headerlink\" title=\"Redis安装\"></a>Redis安装</h3><p>本次安装采用一主一从 + 3主 的集群模式。三台主机端口分别是9851、9852、9853。</p>\n<p><img src=\"/2020/09/01/redis-cluster-build/2.png\" alt=\"Redis安装架构图\"></p>\n<p>安装Redis没什么好说的，直接看命令。安装以后就可以使用redis命令了。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#卸载\nrpm -qa|grep redis #查看是否有存在旧的redis\nrpm -e redis-3.0.7.ws4-1.el6.x86_64 删掉旧的redis\n## 安装\ncd /usr/local/src/\ntar -zxvf redis-5.0.7.tar.gz\ncd redis-5.0.7/\nmake\nmake install</code></pre>\n<h3 id=\"Redis配置\"><a href=\"#Redis配置\" class=\"headerlink\" title=\"Redis配置\"></a>Redis配置</h3><p>为了更好的管理，我们先在建立9851~9856的目录存放6个Redis实例的配置文件。</p>\n<p><img src=\"/2020/09/01/redis-cluster-build/3.png\" alt></p>\n<p>在每个目录下建立一个redis.conf配置文件。配置内容如下（<strong>注意每个目录的配置有些不同，自行修改</strong>）。这里只提供了几个重要的参数，redis还有很多参数需要自己去看。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#后台方式运行\ndaemonize yes\n#redis实例PID的存放路径\npidfile \"/etc/redis/9851/redis.pid\"\n#端口\nport 9851\n#日志文件地址\nlogfile \"/etc/redis/9851/redis.log\"\n#基础路径，存放dump aof文件的地址\ndir \"/etc/redis/9851\"\ndatabases 16\n#这里我只采用rdb快照方式，可以根据实际选择配置\nsave 900 1\nrepl-backlog-size 64mb\nstop-writes-on-bgsave-error yes\nrdbcompression yes\nrdbchecksum yes\ndbfilename \"dump.rdb\"\n#重点配置，这个就是搭建集群的关键\ncluster-enabled yes\n#集群节点信息文件\ncluster-config-file node.conf\n#表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)\ncluster-node-timeout 15000</code></pre>\n<h3 id=\"启动Redis实例\"><a href=\"#启动Redis实例\" class=\"headerlink\" title=\"启动Redis实例\"></a>启动Redis实例</h3><p>分别启动6个Redis实例。可以看到6个实例已经启动。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">redis-server /etc/redis/9851/redis.conf\nredis-server /etc/redis/9852/redis.conf\nredis-server /etc/redis/9853/redis.conf\nredis-server /etc/redis/9854/redis.conf\nredis-server /etc/redis/9855/redis.conf\nredis-server /etc/redis/9856/redis.conf</code></pre>\n<p><img src=\"/2020/09/01/redis-cluster-build/4.png\" alt></p>\n<h3 id=\"配置集群\"><a href=\"#配置集群\" class=\"headerlink\" title=\"配置集群\"></a>配置集群</h3><p>Redis启动后，我们就可以开始配置集群，Redis高版本提供了–cluster命令可以很快速的的进行搭建和分槽</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">redis-cli --cluster create 10.8.198.152:9851 10.8.198.152:9852 10.8.198.152:9853 10.8.198.152:9854 10.8.198.152:9855 10.8.198.152:9856 --cluster-replicas 1</code></pre>\n<p><img src=\"/2020/09/01/redis-cluster-build/5.png\" alt></p>\n<p>执行后，会打印出Master和Slave的信息并<strong>提示我们是否自动分槽</strong>，我们按照提示输入’YES’。</p>\n<p><font color=\"red\">到这里。Redis集群搭建完成。</font></p>\n<p>我们可以通过如下这些命令查看集群信息。</p>\n<p><strong>redis-cli –cluster check IP:PORT</strong></p>\n<p>这个信息可以看主从节点信息。</p>\n<p><img src=\"/2020/09/01/redis-cluster-build/7.png\" alt></p>\n<p><strong>客户端登陆后执行cluster slots查看分槽信息</strong></p>\n<p>从图可以看出</p>\n<ul>\n<li>0 ~ 5460 槽在端口9851实例上，对应的从节点是9854</li>\n<li>5461 ~ 10922 槽在端口9852实例上，对应的从节点是9855</li>\n<li>10923 ~ 16383 槽在端口9853实例上，对应的从节点是9856</li>\n</ul>\n<p><img src=\"/2020/09/01/redis-cluster-build/6.png\" alt></p>\n<p><strong>模拟存入一个key，看是否存入且主从节气上都有对应的值</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\">redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">opsForValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"name\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"myLive\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2020/09/01/redis-cluster-build/8.png\" alt></p>\n<p>可以发现，值已经存入了主从机器上。</p>\n<p><strong>模拟9852机器宕机后是否能实现故障转移</strong></p>\n<p>通过命令杀掉9852机器</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[root@Slave3 redis]# kill -9 PID(9852对应的PID)</code></pre>\n<p><img src=\"/2020/09/01/redis-cluster-build/9.png\" alt=\"9855成为新的master\"></p>\n<p>重新启动9852机器。</p>\n<p><img src=\"/2020/09/01/redis-cluster-build/10.png\" alt=\"9852重新启动后成为9855的从服务器\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>redis集群是一个由多个主从节点群组成的分布式服务器群，它具有<font color=\"red\">复制、高可用和分片特性</font>。总结来说他的特点和好处包括：</p>\n<ul>\n<li>Redis的集群方式是无中心化的集群，每个KEY通过 <strong>虚拟槽分区算法</strong> 计算KEY存储在哪台机器上。</li>\n<li>Redis集群不需要sentinel哨兵也能完成<strong>节点转移、故障转移</strong>的功能。</li>\n<li>可水平扩展据官方文档称可以线性扩展到上万个节点(官方推荐不超过1000个节点)。</li>\n<li>Redis集群槽的范围是0 -16383（2^4 * 2^10）。</li>\n</ul>\n<p><img src=\"/2020/09/01/redis-cluster-build/1.png\" alt=\"RedisCluster架构图\"></p>","more":"<p>redis集群搭建如上图所示，通过多个master节点实现高性能，每个master下设置salve来实现高可用。</p>\n<ul>\n<li>当集群性能不够时，可通过增加新的master来实现更高的性能。</li>\n<li>当master宕机时，redis集群能实现自动的故障转移来保证高可用。</li>\n</ul>\n<h2 id=\"Redis5-0集群搭建\"><a href=\"#Redis5-0集群搭建\" class=\"headerlink\" title=\"Redis5.0集群搭建\"></a>Redis5.0集群搭建</h2><h3 id=\"Redis安装\"><a href=\"#Redis安装\" class=\"headerlink\" title=\"Redis安装\"></a>Redis安装</h3><p>本次安装采用一主一从 + 3主 的集群模式。三台主机端口分别是9851、9852、9853。</p>\n<p><img src=\"/2020/09/01/redis-cluster-build/2.png\" alt=\"Redis安装架构图\"></p>\n<p>安装Redis没什么好说的，直接看命令。安装以后就可以使用redis命令了。</p>\n<pre><code class=\"shell\">#卸载\nrpm -qa|grep redis #查看是否有存在旧的redis\nrpm -e redis-3.0.7.ws4-1.el6.x86_64 删掉旧的redis\n## 安装\ncd /usr/local/src/\ntar -zxvf redis-5.0.7.tar.gz\ncd redis-5.0.7/\nmake\nmake install</code></pre>\n<h3 id=\"Redis配置\"><a href=\"#Redis配置\" class=\"headerlink\" title=\"Redis配置\"></a>Redis配置</h3><p>为了更好的管理，我们先在建立9851~9856的目录存放6个Redis实例的配置文件。</p>\n<p><img src=\"/2020/09/01/redis-cluster-build/3.png\" alt></p>\n<p>在每个目录下建立一个redis.conf配置文件。配置内容如下（<strong>注意每个目录的配置有些不同，自行修改</strong>）。这里只提供了几个重要的参数，redis还有很多参数需要自己去看。</p>\n<pre><code class=\"shell\">#后台方式运行\ndaemonize yes\n#redis实例PID的存放路径\npidfile &quot;/etc/redis/9851/redis.pid&quot;\n#端口\nport 9851\n#日志文件地址\nlogfile &quot;/etc/redis/9851/redis.log&quot;\n#基础路径，存放dump aof文件的地址\ndir &quot;/etc/redis/9851&quot;\ndatabases 16\n#这里我只采用rdb快照方式，可以根据实际选择配置\nsave 900 1\nrepl-backlog-size 64mb\nstop-writes-on-bgsave-error yes\nrdbcompression yes\nrdbchecksum yes\ndbfilename &quot;dump.rdb&quot;\n#重点配置，这个就是搭建集群的关键\ncluster-enabled yes\n#集群节点信息文件\ncluster-config-file node.conf\n#表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)\ncluster-node-timeout 15000</code></pre>\n<h3 id=\"启动Redis实例\"><a href=\"#启动Redis实例\" class=\"headerlink\" title=\"启动Redis实例\"></a>启动Redis实例</h3><p>分别启动6个Redis实例。可以看到6个实例已经启动。</p>\n<pre><code class=\"shell\">redis-server /etc/redis/9851/redis.conf\nredis-server /etc/redis/9852/redis.conf\nredis-server /etc/redis/9853/redis.conf\nredis-server /etc/redis/9854/redis.conf\nredis-server /etc/redis/9855/redis.conf\nredis-server /etc/redis/9856/redis.conf</code></pre>\n<p><img src=\"/2020/09/01/redis-cluster-build/4.png\" alt></p>\n<h3 id=\"配置集群\"><a href=\"#配置集群\" class=\"headerlink\" title=\"配置集群\"></a>配置集群</h3><p>Redis启动后，我们就可以开始配置集群，Redis高版本提供了–cluster命令可以很快速的的进行搭建和分槽</p>\n<pre><code class=\"shell\">redis-cli --cluster create 10.8.198.152:9851 10.8.198.152:9852 10.8.198.152:9853 10.8.198.152:9854 10.8.198.152:9855 10.8.198.152:9856 --cluster-replicas 1</code></pre>\n<p><img src=\"/2020/09/01/redis-cluster-build/5.png\" alt></p>\n<p>执行后，会打印出Master和Slave的信息并<strong>提示我们是否自动分槽</strong>，我们按照提示输入’YES’。</p>\n<p><font color=\"red\">到这里。Redis集群搭建完成。</font></p>\n<p>我们可以通过如下这些命令查看集群信息。</p>\n<p><strong>redis-cli –cluster check IP:PORT</strong></p>\n<p>这个信息可以看主从节点信息。</p>\n<p><img src=\"/2020/09/01/redis-cluster-build/7.png\" alt></p>\n<p><strong>客户端登陆后执行cluster slots查看分槽信息</strong></p>\n<p>从图可以看出</p>\n<ul>\n<li>0 ~ 5460 槽在端口9851实例上，对应的从节点是9854</li>\n<li>5461 ~ 10922 槽在端口9852实例上，对应的从节点是9855</li>\n<li>10923 ~ 16383 槽在端口9853实例上，对应的从节点是9856</li>\n</ul>\n<p><img src=\"/2020/09/01/redis-cluster-build/6.png\" alt></p>\n<p><strong>模拟存入一个key，看是否存入且主从节气上都有对应的值</strong></p>\n<pre><code class=\"java\">redisTemplate.opsForValue().set(&quot;name&quot;,&quot;myLive&quot;);</code></pre>\n<p><img src=\"/2020/09/01/redis-cluster-build/8.png\" alt></p>\n<p>可以发现，值已经存入了主从机器上。</p>\n<p><strong>模拟9852机器宕机后是否能实现故障转移</strong></p>\n<p>通过命令杀掉9852机器</p>\n<pre><code class=\"shell\">[root@Slave3 redis]# kill -9 PID(9852对应的PID)</code></pre>\n<p><img src=\"/2020/09/01/redis-cluster-build/9.png\" alt=\"9855成为新的master\"></p>\n<p>重新启动9852机器。</p>\n<p><img src=\"/2020/09/01/redis-cluster-build/10.png\" alt=\"9852重新启动后成为9855的从服务器\"></p>"},{"title":"基于springBoot-aop实现redis分布式限流","description":"基于springBoot+redis+aop+自定义标签实现分布式限流","date":"2019-02-18T09:14:00.000Z","_content":"## 项目介绍\n### 原理\n通过给api-url设置一个redis-key并设置过期时间。当每次url被请求时key的值加一，如果在过期时间内增加到一定数量后则进行限流。在原理上通过使用redis键值过期时间作为限流的单位时间，在单位时间内如果访问的次数大于指定次数后禁止继续访问，当键值过期后再次访问时重新计算单位时间内的允许访问次数。\n<!--more-->\n采用aop+自定义注解的方式，在每次调用controller类时对方法进行增强，aop扫描所有注有**@RateLimiter**的方法并环绕增强。\n### 项目测试\n\n```java\n//指定testone这个url在10秒内只能有5次请求，如果超过则报错\n@RequestMapping(\"/testone\")\n@RateLimiter(key = \"ratelimit:testOne\", limit = 5, expire = 10, message = MESSAGE, isLimiterIp = true)\n    public String testOne(HttpServletRequest request) {\n        return \"正常请求\";\n}\n```\n\n连续在10秒内访问5次\n\n```json\n{\"code\":\"400\",\"msg\":\"FAIL\",\"desc\":\"触发限流\"}\n```\n\n## 代码实现\n\n### MAVEN包\n```xml\n<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<!--aop支持-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-aop</artifactId>\n\t\t</dependency>\n\t\t<!--添加redis支持-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-data-redis</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-devtools</artifactId>\n\t\t\t<scope>runtime</scope>\n\t\t\t<optional>true</optional>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-pool2</artifactId>\n\t\t\t<version>2.6.0</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-lang3</artifactId>\n\t\t\t<version>3.7</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>com.google.guava</groupId>\n\t\t\t<artifactId>guava</artifactId>\n\t\t\t<version>26.0-jre</version>\n\t\t</dependency>\n\n\t</dependencies>\n````\n\n### SpringBoot配置\n\n```yaml\nspring:\n  redis:\n    database: 0\n    host: 127.0.0.1\n    jedis:\n      pool:\n        #最大连接数据库连接数,设 0 为没有限制\n        max-active: 8\n        #最大等待连接中的数量,设 0 为没有限制\n        max-idle: 8\n        #最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。\n        max-wait: -1ms\n        #最小等待连接中的数量,设 0 为没有限制\n        min-idle: 0\n    lettuce:\n      pool:\n        max-active: 8\n        max-idle: 8\n        max-wait: -1ms\n        min-idle: 0\n      shutdown-timeout: 100ms\n    password: ''\n    port: 6379\n```\n\n### 代码\n#### 自定义注解\n\n```java\npackage com.xzy.springbootredisdemo.annotation;\n\nimport java.lang.annotation.*;\n\n/***\n * 限流注解\n * key--表示限流模块名，指定该值用于区分不同应用，不同场景，推荐格式为：应用名:模块名:ip:接口名:方法名\n * limit--表示单位时间允许通过的请求数\n * expire--incr的值的过期时间，业务中表示限流的单位时间。\n * isLimiterIp -- 是否根据IP进行过滤，如果为true，则key为ratelimit:url:ip的方式存储，这样可以根据ip来限流\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimiter {\n    /**\n     * 限流key\n     * @return\n     */\n    String key() default \"rate:limiter\";\n    /**\n     * 单位时间限制通过请求数\n     * @return\n     */\n    long limit() default 10;\n    /**\n     * 过期时间，单位秒\n     * @return\n     */\n    long expire() default 1;\n    String message() default \"限制访问\";\n    /***\n     * 是否精确到ip控制\n     * * @return\n     */\n    boolean isLimiterIp() default false;\n}\n\n```\n#### Redis配置类\n\n```java\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.CacheManager;\nimport org.springframework.cache.annotation.CachingConfigurerSupport;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.cache.RedisCacheConfiguration;\nimport org.springframework.data.redis.cache.RedisCacheManager;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.RedisSerializationContext;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\nimport java.time.Duration;\n@Configuration\n@EnableCaching\npublic class RedisCacheConfig extends CachingConfigurerSupport {\n    private static final Logger logger = LoggerFactory.getLogger(RedisCacheConfig.class);\n    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory factory) {\n        RedisSerializer<String> redisSerializer = new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        //解决查询缓存转换异常的问题\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置序列化（解决乱码的问题）,过期时间30秒\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofSeconds(30))\n                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))\n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))\n                .disableCachingNullValues();\n        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)\n                .cacheDefaults(config)\n                .build();\n        return cacheManager;\n    }\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        RedisSerializer<String> redisSerializer = new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        template.setConnectionFactory(factory);\n        //key序列化方式\n        template.setKeySerializer(redisSerializer);\n        //value序列化\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        //value hashmap序列化\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        return template;\n    }\n}\n```\n\n#### AOP增强\n\n对使用了@RateLimiter注解的方法进行环绕增强\n\n```java\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.xzy.springbootredisdemo.annotation.RateLimiter;\nimport com.xzy.springbootredisdemo.util.IpUtil;\nimport com.xzy.springbootredisdemo.util.ResultVo;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.Signature;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.script.DefaultRedisScript;\nimport org.springframework.scripting.support.ResourceScriptSource;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.http.HttpServletRequest;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\n\n//aop支持\n@Aspect\n@Component\npublic class RateLimterHandler {\n    private static final Logger logger = LoggerFactory.getLogger(RateLimterHandler.class);\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n    \n    private DefaultRedisScript<Long> redisScript;\n\n    //@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的inti()方法\n    @PostConstruct\n    public void init() {\n        redisScript = new DefaultRedisScript<>();\n        redisScript.setResultType(Long.class);\n        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(\"rateLimter.lua\")));\n        logger.info(\"RateLimterHandler[分布式限流处理器]脚本加载完成\");\n    }\n\n    //定义切点方法为注解RateLimiter名称为rateLimiter\n    @Pointcut(\"@annotation(com.xzy.springbootredisdemo.annotation.RateLimiter)\")\n    public void rateLimiter() {\n    }\n\n    @Around(\"@annotation(rateLimiter)\")\n    public Object around(ProceedingJoinPoint proceedingJoinPoint, RateLimiter rateLimiter) throws Throwable {\n        Signature signature = proceedingJoinPoint.getSignature();\n        if (!(signature instanceof MethodSignature)) {\n            throw new IllegalArgumentException(\"注释应该配置在方法上\");\n        }\n        //获取方法参数\n        HttpServletRequest request = getArgsRequest(proceedingJoinPoint);\n        //获取注解参数\n        // 限流模块key\n        String limitKey = rateLimiter.key();\n        Preconditions.checkNotNull(limitKey); //判断是否为空\n        //是否根据ip进行限流\n        boolean isLimiterIp = rateLimiter.isLimiterIp();\n        if (isLimiterIp && request != null) {\n            if (request != null) {\n                String ip = IpUtil.getIpAddr(request);\n                limitKey += \":\" + ip;\n            }\n        }\n        //限流阀值\n        long limitTimes = rateLimiter.limit();\n        // 限流超时时间\n        long expireTime = rateLimiter.expire();\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"RateLimterHandler[分布式限流处理器]参数值为-limitTimes={},limitTimeout={}\", limitTimes, expireTime);\n        }\n        //限流提示语\n        String message = rateLimiter.message();\n        //执行lua脚本\n        List<String> keyList = Lists.newArrayList();\n        keyList.add(limitKey);\n        Long result = (Long) redisTemplate.execute(redisScript, keyList, expireTime, limitTimes);\n        if (result == 0) {\n            Type type = getMethodReturnType(proceedingJoinPoint);\n            logger.info(\"由于超过单位时间=\" + expireTime + \"-允许的请求次数=\" + limitTimes + \"[触发限流]\");\n            return limitErrorReturn(type, message);\n        }\n        return proceedingJoinPoint.proceed();\n    }\n\n\n    public Object limitErrorReturn(Type type, String msg) {\n        switch (type.getTypeName()) {\n            case \"java.lang.String\":\n                return msg;\n            case \"java.util.Map\":\n                Map<String, String> resultMap = Maps.newHashMap();\n                resultMap.put(\"code\", \"-1\");\n                resultMap.put(\"message\", msg);\n                return resultMap;\n            case \"com.xzy.springbootredisdemo.util.ResultVo\":\n                return ResultVo.getErrorResultVo(msg);\n            default:\n                return msg;\n        }\n    }\n\n\n    public HttpServletRequest getArgsRequest(ProceedingJoinPoint proceedingJoinPoint) throws NoSuchMethodException {\n        //获取方法参数\n        Object[] args = proceedingJoinPoint.getArgs();\n        HttpServletRequest request = null;\n        for (Object o : args) {\n            if (o instanceof HttpServletRequest) {\n                request = (HttpServletRequest) o;\n            }\n        }\n        return request;\n    }\n\n    /***\n     * 获取返回值类型\n     * @param proceedingJoinPoint\n     * @return\n     * @throws NoSuchMethodException\n     */\n    public Type getMethodReturnType(ProceedingJoinPoint proceedingJoinPoint) throws NoSuchMethodException {\n        Signature signature = proceedingJoinPoint.getSignature();\n        MethodSignature methodSignature = (MethodSignature) signature;\n        Object target = proceedingJoinPoint.getTarget();\n        Method currentMethod = target.getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes());\n        return currentMethod.getAnnotatedReturnType().getType();\n    }\n\n}\n\n```\n\n#### 枚举类\n\n```java\npublic interface BaseEnum {\n    public String getCode();\n    public String getMsg();\n}\npublic enum SystemResultEnum implements BaseEnum {\n    SUCCESS(\"1\", \"成功\"),\n    FAIL(\"0\", \"系统错误\"),\n    NO_AUTH_USER(\"2\", \"未注册用户\"),\n    NO_AD_USER(\"3\", \"待审核用户\");\n    SystemResultEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n    private String code;\n    private String msg;\n    public String getCode() {\n        return code;\n    }\n    public void setCode(String code) {\n        this.code = code;\n    }\n    public String getMsg() {\n        return msg;\n    }\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n}\n```\n\n#### Lua脚本\n\n```lua\n-- 获取KEY\nlocal key1 = KEYS[1]\n-- incr可以实现自动设置key并设置初始值为1\nlocal val = redis.call('incr', key1)\n-- 获取key1剩下的时间\nlocal ttl = redis.call('ttl',key1)\n\n--获取ARGV内的参数并打印\n-- ARGV[1]超时时间\nlocal expire = ARGV[1]\n-- ARGV[2]单位时间允许通过的请求数\nlocal times = ARGV[2]\n\n-- 日志打印 没什么用\n-- redis.log(redis.LOG_DEBUG,tostring(times))\n-- redis.log(redis.LOG_DEBUG,tostring(expire))\n-- redis.log(redis.LOG_NOTICE, \"incr \"..key1..\" \"..val);\n-- val == 1 表示是第一次访问，此时是第一次访问，设置过期时间\nif val == 1 then\n    redis.call('expire',key1,tonumber(expire))\nelse\n    if ttl == -1 then\n        redis.call('expire',key1,tonumber(expire))\n    end\nend\n\nif val > tonumber(times) then\n    return 0\nend\n    return 1\n```\n\n\n\n#### 控制层\n\n```java\n@RestController\npublic class TestController {\n    private static final String MESSAGE = \"{\\\"code\\\":\\\"400\\\",\\\"msg\\\":\\\"FAIL\\\",\\\"desc\\\":\\\"触发限流\\\"}\";\n\n    @RequestMapping(\"/testone\")\n    @RateLimiter(key = \"ratelimit:testOne\", limit = 5, expire = 10, message = MESSAGE, isLimiterIp = true)\n    public String testOne(HttpServletRequest request) {\n        return \"正常请求\";\n    }\n    @RequestMapping(\"/testtwo\")\n    @RateLimiter(key = \"ratelimit:testTwo\", limit = 5, expire = 10, isLimiterIp = false)\n    public Map testTow(HttpServletRequest request){\n        Map<String,String> resultMap = Maps.newHashMap();\n        resultMap.put(\"code\", \"1\");\n        resultMap.put(\"message\" , \"success\");\n        return resultMap;\n    }\n    @RequestMapping(\"/testthree\")\n    @RateLimiter(key = \"ratelimit:testThree\", limit = 5, expire = 10, isLimiterIp = false)\n    public ResultVo testThree(HttpServletRequest request){\n        return ResultVo.getSuccessResultVo();\n    }\n}\n```","source":"_posts/redis-aop-limit-boot.md","raw":"---\ntitle: 基于springBoot-aop实现redis分布式限流\ntags:\n  - redis\n  - 项目实践\ncategories: redis\ndescription : 基于springBoot+redis+aop+自定义标签实现分布式限流\ndate: 2019-02-18 17:14:00\n---\n## 项目介绍\n### 原理\n通过给api-url设置一个redis-key并设置过期时间。当每次url被请求时key的值加一，如果在过期时间内增加到一定数量后则进行限流。在原理上通过使用redis键值过期时间作为限流的单位时间，在单位时间内如果访问的次数大于指定次数后禁止继续访问，当键值过期后再次访问时重新计算单位时间内的允许访问次数。\n<!--more-->\n采用aop+自定义注解的方式，在每次调用controller类时对方法进行增强，aop扫描所有注有**@RateLimiter**的方法并环绕增强。\n### 项目测试\n\n```java\n//指定testone这个url在10秒内只能有5次请求，如果超过则报错\n@RequestMapping(\"/testone\")\n@RateLimiter(key = \"ratelimit:testOne\", limit = 5, expire = 10, message = MESSAGE, isLimiterIp = true)\n    public String testOne(HttpServletRequest request) {\n        return \"正常请求\";\n}\n```\n\n连续在10秒内访问5次\n\n```json\n{\"code\":\"400\",\"msg\":\"FAIL\",\"desc\":\"触发限流\"}\n```\n\n## 代码实现\n\n### MAVEN包\n```xml\n<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<!--aop支持-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-aop</artifactId>\n\t\t</dependency>\n\t\t<!--添加redis支持-->\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-data-redis</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-devtools</artifactId>\n\t\t\t<scope>runtime</scope>\n\t\t\t<optional>true</optional>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-pool2</artifactId>\n\t\t\t<version>2.6.0</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.apache.commons</groupId>\n\t\t\t<artifactId>commons-lang3</artifactId>\n\t\t\t<version>3.7</version>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>com.google.guava</groupId>\n\t\t\t<artifactId>guava</artifactId>\n\t\t\t<version>26.0-jre</version>\n\t\t</dependency>\n\n\t</dependencies>\n````\n\n### SpringBoot配置\n\n```yaml\nspring:\n  redis:\n    database: 0\n    host: 127.0.0.1\n    jedis:\n      pool:\n        #最大连接数据库连接数,设 0 为没有限制\n        max-active: 8\n        #最大等待连接中的数量,设 0 为没有限制\n        max-idle: 8\n        #最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。\n        max-wait: -1ms\n        #最小等待连接中的数量,设 0 为没有限制\n        min-idle: 0\n    lettuce:\n      pool:\n        max-active: 8\n        max-idle: 8\n        max-wait: -1ms\n        min-idle: 0\n      shutdown-timeout: 100ms\n    password: ''\n    port: 6379\n```\n\n### 代码\n#### 自定义注解\n\n```java\npackage com.xzy.springbootredisdemo.annotation;\n\nimport java.lang.annotation.*;\n\n/***\n * 限流注解\n * key--表示限流模块名，指定该值用于区分不同应用，不同场景，推荐格式为：应用名:模块名:ip:接口名:方法名\n * limit--表示单位时间允许通过的请求数\n * expire--incr的值的过期时间，业务中表示限流的单位时间。\n * isLimiterIp -- 是否根据IP进行过滤，如果为true，则key为ratelimit:url:ip的方式存储，这样可以根据ip来限流\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimiter {\n    /**\n     * 限流key\n     * @return\n     */\n    String key() default \"rate:limiter\";\n    /**\n     * 单位时间限制通过请求数\n     * @return\n     */\n    long limit() default 10;\n    /**\n     * 过期时间，单位秒\n     * @return\n     */\n    long expire() default 1;\n    String message() default \"限制访问\";\n    /***\n     * 是否精确到ip控制\n     * * @return\n     */\n    boolean isLimiterIp() default false;\n}\n\n```\n#### Redis配置类\n\n```java\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.CacheManager;\nimport org.springframework.cache.annotation.CachingConfigurerSupport;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.cache.RedisCacheConfiguration;\nimport org.springframework.data.redis.cache.RedisCacheManager;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.RedisSerializationContext;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\nimport java.time.Duration;\n@Configuration\n@EnableCaching\npublic class RedisCacheConfig extends CachingConfigurerSupport {\n    private static final Logger logger = LoggerFactory.getLogger(RedisCacheConfig.class);\n    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory factory) {\n        RedisSerializer<String> redisSerializer = new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        //解决查询缓存转换异常的问题\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置序列化（解决乱码的问题）,过期时间30秒\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofSeconds(30))\n                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))\n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))\n                .disableCachingNullValues();\n        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)\n                .cacheDefaults(config)\n                .build();\n        return cacheManager;\n    }\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        RedisSerializer<String> redisSerializer = new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        template.setConnectionFactory(factory);\n        //key序列化方式\n        template.setKeySerializer(redisSerializer);\n        //value序列化\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        //value hashmap序列化\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        return template;\n    }\n}\n```\n\n#### AOP增强\n\n对使用了@RateLimiter注解的方法进行环绕增强\n\n```java\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.xzy.springbootredisdemo.annotation.RateLimiter;\nimport com.xzy.springbootredisdemo.util.IpUtil;\nimport com.xzy.springbootredisdemo.util.ResultVo;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.Signature;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.script.DefaultRedisScript;\nimport org.springframework.scripting.support.ResourceScriptSource;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.http.HttpServletRequest;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\n\n//aop支持\n@Aspect\n@Component\npublic class RateLimterHandler {\n    private static final Logger logger = LoggerFactory.getLogger(RateLimterHandler.class);\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n    \n    private DefaultRedisScript<Long> redisScript;\n\n    //@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的inti()方法\n    @PostConstruct\n    public void init() {\n        redisScript = new DefaultRedisScript<>();\n        redisScript.setResultType(Long.class);\n        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(\"rateLimter.lua\")));\n        logger.info(\"RateLimterHandler[分布式限流处理器]脚本加载完成\");\n    }\n\n    //定义切点方法为注解RateLimiter名称为rateLimiter\n    @Pointcut(\"@annotation(com.xzy.springbootredisdemo.annotation.RateLimiter)\")\n    public void rateLimiter() {\n    }\n\n    @Around(\"@annotation(rateLimiter)\")\n    public Object around(ProceedingJoinPoint proceedingJoinPoint, RateLimiter rateLimiter) throws Throwable {\n        Signature signature = proceedingJoinPoint.getSignature();\n        if (!(signature instanceof MethodSignature)) {\n            throw new IllegalArgumentException(\"注释应该配置在方法上\");\n        }\n        //获取方法参数\n        HttpServletRequest request = getArgsRequest(proceedingJoinPoint);\n        //获取注解参数\n        // 限流模块key\n        String limitKey = rateLimiter.key();\n        Preconditions.checkNotNull(limitKey); //判断是否为空\n        //是否根据ip进行限流\n        boolean isLimiterIp = rateLimiter.isLimiterIp();\n        if (isLimiterIp && request != null) {\n            if (request != null) {\n                String ip = IpUtil.getIpAddr(request);\n                limitKey += \":\" + ip;\n            }\n        }\n        //限流阀值\n        long limitTimes = rateLimiter.limit();\n        // 限流超时时间\n        long expireTime = rateLimiter.expire();\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"RateLimterHandler[分布式限流处理器]参数值为-limitTimes={},limitTimeout={}\", limitTimes, expireTime);\n        }\n        //限流提示语\n        String message = rateLimiter.message();\n        //执行lua脚本\n        List<String> keyList = Lists.newArrayList();\n        keyList.add(limitKey);\n        Long result = (Long) redisTemplate.execute(redisScript, keyList, expireTime, limitTimes);\n        if (result == 0) {\n            Type type = getMethodReturnType(proceedingJoinPoint);\n            logger.info(\"由于超过单位时间=\" + expireTime + \"-允许的请求次数=\" + limitTimes + \"[触发限流]\");\n            return limitErrorReturn(type, message);\n        }\n        return proceedingJoinPoint.proceed();\n    }\n\n\n    public Object limitErrorReturn(Type type, String msg) {\n        switch (type.getTypeName()) {\n            case \"java.lang.String\":\n                return msg;\n            case \"java.util.Map\":\n                Map<String, String> resultMap = Maps.newHashMap();\n                resultMap.put(\"code\", \"-1\");\n                resultMap.put(\"message\", msg);\n                return resultMap;\n            case \"com.xzy.springbootredisdemo.util.ResultVo\":\n                return ResultVo.getErrorResultVo(msg);\n            default:\n                return msg;\n        }\n    }\n\n\n    public HttpServletRequest getArgsRequest(ProceedingJoinPoint proceedingJoinPoint) throws NoSuchMethodException {\n        //获取方法参数\n        Object[] args = proceedingJoinPoint.getArgs();\n        HttpServletRequest request = null;\n        for (Object o : args) {\n            if (o instanceof HttpServletRequest) {\n                request = (HttpServletRequest) o;\n            }\n        }\n        return request;\n    }\n\n    /***\n     * 获取返回值类型\n     * @param proceedingJoinPoint\n     * @return\n     * @throws NoSuchMethodException\n     */\n    public Type getMethodReturnType(ProceedingJoinPoint proceedingJoinPoint) throws NoSuchMethodException {\n        Signature signature = proceedingJoinPoint.getSignature();\n        MethodSignature methodSignature = (MethodSignature) signature;\n        Object target = proceedingJoinPoint.getTarget();\n        Method currentMethod = target.getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes());\n        return currentMethod.getAnnotatedReturnType().getType();\n    }\n\n}\n\n```\n\n#### 枚举类\n\n```java\npublic interface BaseEnum {\n    public String getCode();\n    public String getMsg();\n}\npublic enum SystemResultEnum implements BaseEnum {\n    SUCCESS(\"1\", \"成功\"),\n    FAIL(\"0\", \"系统错误\"),\n    NO_AUTH_USER(\"2\", \"未注册用户\"),\n    NO_AD_USER(\"3\", \"待审核用户\");\n    SystemResultEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n    private String code;\n    private String msg;\n    public String getCode() {\n        return code;\n    }\n    public void setCode(String code) {\n        this.code = code;\n    }\n    public String getMsg() {\n        return msg;\n    }\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n}\n```\n\n#### Lua脚本\n\n```lua\n-- 获取KEY\nlocal key1 = KEYS[1]\n-- incr可以实现自动设置key并设置初始值为1\nlocal val = redis.call('incr', key1)\n-- 获取key1剩下的时间\nlocal ttl = redis.call('ttl',key1)\n\n--获取ARGV内的参数并打印\n-- ARGV[1]超时时间\nlocal expire = ARGV[1]\n-- ARGV[2]单位时间允许通过的请求数\nlocal times = ARGV[2]\n\n-- 日志打印 没什么用\n-- redis.log(redis.LOG_DEBUG,tostring(times))\n-- redis.log(redis.LOG_DEBUG,tostring(expire))\n-- redis.log(redis.LOG_NOTICE, \"incr \"..key1..\" \"..val);\n-- val == 1 表示是第一次访问，此时是第一次访问，设置过期时间\nif val == 1 then\n    redis.call('expire',key1,tonumber(expire))\nelse\n    if ttl == -1 then\n        redis.call('expire',key1,tonumber(expire))\n    end\nend\n\nif val > tonumber(times) then\n    return 0\nend\n    return 1\n```\n\n\n\n#### 控制层\n\n```java\n@RestController\npublic class TestController {\n    private static final String MESSAGE = \"{\\\"code\\\":\\\"400\\\",\\\"msg\\\":\\\"FAIL\\\",\\\"desc\\\":\\\"触发限流\\\"}\";\n\n    @RequestMapping(\"/testone\")\n    @RateLimiter(key = \"ratelimit:testOne\", limit = 5, expire = 10, message = MESSAGE, isLimiterIp = true)\n    public String testOne(HttpServletRequest request) {\n        return \"正常请求\";\n    }\n    @RequestMapping(\"/testtwo\")\n    @RateLimiter(key = \"ratelimit:testTwo\", limit = 5, expire = 10, isLimiterIp = false)\n    public Map testTow(HttpServletRequest request){\n        Map<String,String> resultMap = Maps.newHashMap();\n        resultMap.put(\"code\", \"1\");\n        resultMap.put(\"message\" , \"success\");\n        return resultMap;\n    }\n    @RequestMapping(\"/testthree\")\n    @RateLimiter(key = \"ratelimit:testThree\", limit = 5, expire = 10, isLimiterIp = false)\n    public ResultVo testThree(HttpServletRequest request){\n        return ResultVo.getSuccessResultVo();\n    }\n}\n```","slug":"redis-aop-limit-boot","published":1,"updated":"2021-04-08T00:47:06.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvj002kqwv229tjfcf0","content":"<h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>通过给api-url设置一个redis-key并设置过期时间。当每次url被请求时key的值加一，如果在过期时间内增加到一定数量后则进行限流。在原理上通过使用redis键值过期时间作为限流的单位时间，在单位时间内如果访问的次数大于指定次数后禁止继续访问，当键值过期后再次访问时重新计算单位时间内的允许访问次数。</p>\n<a id=\"more\"></a>\n<p>采用aop+自定义注解的方式，在每次调用controller类时对方法进行增强，aop扫描所有注有<strong>@RateLimiter</strong>的方法并环绕增强。</p>\n<h3 id=\"项目测试\"><a href=\"#项目测试\" class=\"headerlink\" title=\"项目测试\"></a>项目测试</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//指定testone这个url在10秒内只能有5次请求，如果超过则报错</span>\n<span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/testone\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@RateLimiter</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"ratelimit:testOne\"</span><span class=\"token punctuation\">,</span> limit <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> expire <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> message <span class=\"token operator\">=</span> MESSAGE<span class=\"token punctuation\">,</span> isLimiterIp <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">testOne</span><span class=\"token punctuation\">(</span>HttpServletRequest request<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"正常请求\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>连续在10秒内访问5次</p>\n<pre class=\" language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span><span class=\"token property\">\"code\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"400\"</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"msg\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"FAIL\"</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"desc\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"触发限流\"</span><span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"MAVEN包\"><a href=\"#MAVEN包\" class=\"headerlink\" title=\"MAVEN包\"></a>MAVEN包</h3><pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependencies</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-web<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token comment\" spellcheck=\"true\">&lt;!--aop支持--></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-aop<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token comment\" spellcheck=\"true\">&lt;!--添加redis支持--></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-data-redis<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-devtools<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>scope</span><span class=\"token punctuation\">></span></span>runtime<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>scope</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>optional</span><span class=\"token punctuation\">></span></span>true<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>optional</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>scope</span><span class=\"token punctuation\">></span></span>test<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>scope</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.apache.commons<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>commons-pool2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>2.6.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.apache.commons<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>commons-lang3<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>3.7<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span>\n\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>com.google.guava<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>guava<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>26.0-jre<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependencies</span><span class=\"token punctuation\">></span></span></code></pre>\n<h3 id=\"SpringBoot配置\"><a href=\"#SpringBoot配置\" class=\"headerlink\" title=\"SpringBoot配置\"></a>SpringBoot配置</h3><pre class=\" language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">spring</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">redis</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">database</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\n    <span class=\"token key atrule\">host</span><span class=\"token punctuation\">:</span> 127.0.0.1\n    <span class=\"token key atrule\">jedis</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">pool</span><span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\">#最大连接数据库连接数,设 0 为没有限制</span>\n        <span class=\"token key atrule\">max-active</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>\n        <span class=\"token comment\" spellcheck=\"true\">#最大等待连接中的数量,设 0 为没有限制</span>\n        <span class=\"token key atrule\">max-idle</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>\n        <span class=\"token comment\" spellcheck=\"true\">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span>\n        <span class=\"token key atrule\">max-wait</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">-</span>1ms\n        <span class=\"token comment\" spellcheck=\"true\">#最小等待连接中的数量,设 0 为没有限制</span>\n        <span class=\"token key atrule\">min-idle</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\n    <span class=\"token key atrule\">lettuce</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">pool</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">max-active</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>\n        <span class=\"token key atrule\">max-idle</span><span class=\"token punctuation\">:</span> <span class=\"token number\">8</span>\n        <span class=\"token key atrule\">max-wait</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">-</span>1ms\n        <span class=\"token key atrule\">min-idle</span><span class=\"token punctuation\">:</span> <span class=\"token number\">0</span>\n      <span class=\"token key atrule\">shutdown-timeout</span><span class=\"token punctuation\">:</span> 100ms\n    <span class=\"token key atrule\">password</span><span class=\"token punctuation\">:</span> <span class=\"token string\">''</span>\n    <span class=\"token key atrule\">port</span><span class=\"token punctuation\">:</span> <span class=\"token number\">6379</span></code></pre>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> com<span class=\"token punctuation\">.</span>xzy<span class=\"token punctuation\">.</span>springbootredisdemo<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>*<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/***\n * 限流注解\n * key--表示限流模块名，指定该值用于区分不同应用，不同场景，推荐格式为：应用名:模块名:ip:接口名:方法名\n * limit--表示单位时间允许通过的请求数\n * expire--incr的值的过期时间，业务中表示限流的单位时间。\n * isLimiterIp -- 是否根据IP进行过滤，如果为true，则key为ratelimit:url:ip的方式存储，这样可以根据ip来限流\n */</span>\n<span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span>ElementType<span class=\"token punctuation\">.</span>METHOD<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span>RetentionPolicy<span class=\"token punctuation\">.</span>RUNTIME<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Documented</span>\n<span class=\"token keyword\">public</span> @<span class=\"token keyword\">interface</span> <span class=\"token class-name\">RateLimiter</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 限流key\n     * @return\n     */</span>\n    String <span class=\"token function\">key</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token string\">\"rate:limiter\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 单位时间限制通过请求数\n     * @return\n     */</span>\n    <span class=\"token keyword\">long</span> <span class=\"token function\">limit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 过期时间，单位秒\n     * @return\n     */</span>\n    <span class=\"token keyword\">long</span> <span class=\"token function\">expire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    String <span class=\"token function\">message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token string\">\"限制访问\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 是否精确到ip控制\n     * * @return\n     */</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">isLimiterIp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"Redis配置类\"><a href=\"#Redis配置类\" class=\"headerlink\" title=\"Redis配置类\"></a>Redis配置类</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>fasterxml<span class=\"token punctuation\">.</span>jackson<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>JsonAutoDetect<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>fasterxml<span class=\"token punctuation\">.</span>jackson<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>PropertyAccessor<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>fasterxml<span class=\"token punctuation\">.</span>jackson<span class=\"token punctuation\">.</span>databind<span class=\"token punctuation\">.</span>ObjectMapper<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>slf4j<span class=\"token punctuation\">.</span>Logger<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>slf4j<span class=\"token punctuation\">.</span>LoggerFactory<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>CacheManager<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>CachingConfigurerSupport<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>EnableCaching<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>Bean<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>context<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>Configuration<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>RedisCacheConfiguration<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>RedisCacheManager<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>connection<span class=\"token punctuation\">.</span>RedisConnectionFactory<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>RedisTemplate<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>serializer<span class=\"token punctuation\">.</span>Jackson2JsonRedisSerializer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>serializer<span class=\"token punctuation\">.</span>RedisSerializationContext<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>serializer<span class=\"token punctuation\">.</span>RedisSerializer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>serializer<span class=\"token punctuation\">.</span>StringRedisSerializer<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">.</span>Duration<span class=\"token punctuation\">;</span>\n<span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token annotation punctuation\">@EnableCaching</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RedisCacheConfig</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">CachingConfigurerSupport</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Logger logger <span class=\"token operator\">=</span> LoggerFactory<span class=\"token punctuation\">.</span><span class=\"token function\">getLogger</span><span class=\"token punctuation\">(</span>RedisCacheConfig<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> CacheManager <span class=\"token function\">cacheManager</span><span class=\"token punctuation\">(</span>RedisConnectionFactory factory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        RedisSerializer<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> redisSerializer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringRedisSerializer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Jackson2JsonRedisSerializer</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//解决查询缓存转换异常的问题</span>\n        ObjectMapper om <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectMapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        om<span class=\"token punctuation\">.</span><span class=\"token function\">setVisibility</span><span class=\"token punctuation\">(</span>PropertyAccessor<span class=\"token punctuation\">.</span>ALL<span class=\"token punctuation\">,</span> JsonAutoDetect<span class=\"token punctuation\">.</span>Visibility<span class=\"token punctuation\">.</span>ANY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        om<span class=\"token punctuation\">.</span><span class=\"token function\">enableDefaultTyping</span><span class=\"token punctuation\">(</span>ObjectMapper<span class=\"token punctuation\">.</span>DefaultTyping<span class=\"token punctuation\">.</span>NON_FINAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        jackson2JsonRedisSerializer<span class=\"token punctuation\">.</span><span class=\"token function\">setObjectMapper</span><span class=\"token punctuation\">(</span>om<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 配置序列化（解决乱码的问题）,过期时间30秒</span>\n        RedisCacheConfiguration config <span class=\"token operator\">=</span> RedisCacheConfiguration<span class=\"token punctuation\">.</span><span class=\"token function\">defaultCacheConfig</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">entryTtl</span><span class=\"token punctuation\">(</span>Duration<span class=\"token punctuation\">.</span><span class=\"token function\">ofSeconds</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">serializeKeysWith</span><span class=\"token punctuation\">(</span>RedisSerializationContext<span class=\"token punctuation\">.</span>SerializationPair<span class=\"token punctuation\">.</span><span class=\"token function\">fromSerializer</span><span class=\"token punctuation\">(</span>redisSerializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">serializeValuesWith</span><span class=\"token punctuation\">(</span>RedisSerializationContext<span class=\"token punctuation\">.</span>SerializationPair<span class=\"token punctuation\">.</span><span class=\"token function\">fromSerializer</span><span class=\"token punctuation\">(</span>jackson2JsonRedisSerializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">disableCachingNullValues</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        RedisCacheManager cacheManager <span class=\"token operator\">=</span> RedisCacheManager<span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">cacheDefaults</span><span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> cacheManager<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> RedisTemplate<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> <span class=\"token function\">redisTemplate</span><span class=\"token punctuation\">(</span>RedisConnectionFactory factory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        RedisTemplate<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> template <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RedisTemplate</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        RedisSerializer<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> redisSerializer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringRedisSerializer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Jackson2JsonRedisSerializer</span><span class=\"token punctuation\">(</span>Object<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ObjectMapper om <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ObjectMapper</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        om<span class=\"token punctuation\">.</span><span class=\"token function\">setVisibility</span><span class=\"token punctuation\">(</span>PropertyAccessor<span class=\"token punctuation\">.</span>ALL<span class=\"token punctuation\">,</span> JsonAutoDetect<span class=\"token punctuation\">.</span>Visibility<span class=\"token punctuation\">.</span>ANY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        om<span class=\"token punctuation\">.</span><span class=\"token function\">enableDefaultTyping</span><span class=\"token punctuation\">(</span>ObjectMapper<span class=\"token punctuation\">.</span>DefaultTyping<span class=\"token punctuation\">.</span>NON_FINAL<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        jackson2JsonRedisSerializer<span class=\"token punctuation\">.</span><span class=\"token function\">setObjectMapper</span><span class=\"token punctuation\">(</span>om<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        template<span class=\"token punctuation\">.</span><span class=\"token function\">setConnectionFactory</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//key序列化方式</span>\n        template<span class=\"token punctuation\">.</span><span class=\"token function\">setKeySerializer</span><span class=\"token punctuation\">(</span>redisSerializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//value序列化</span>\n        template<span class=\"token punctuation\">.</span><span class=\"token function\">setValueSerializer</span><span class=\"token punctuation\">(</span>jackson2JsonRedisSerializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//value hashmap序列化</span>\n        template<span class=\"token punctuation\">.</span><span class=\"token function\">setHashValueSerializer</span><span class=\"token punctuation\">(</span>jackson2JsonRedisSerializer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> template<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"AOP增强\"><a href=\"#AOP增强\" class=\"headerlink\" title=\"AOP增强\"></a>AOP增强</h4><p>对使用了@RateLimiter注解的方法进行环绕增强</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>google<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>base<span class=\"token punctuation\">.</span>Preconditions<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>google<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>collect<span class=\"token punctuation\">.</span>Lists<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>google<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>collect<span class=\"token punctuation\">.</span>Maps<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>xzy<span class=\"token punctuation\">.</span>springbootredisdemo<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>RateLimiter<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>xzy<span class=\"token punctuation\">.</span>springbootredisdemo<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>IpUtil<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>xzy<span class=\"token punctuation\">.</span>springbootredisdemo<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>ResultVo<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>aspectj<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>ProceedingJoinPoint<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>aspectj<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>Signature<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>aspectj<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>Around<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>aspectj<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>Aspect<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>aspectj<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>Pointcut<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>aspectj<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span>MethodSignature<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>slf4j<span class=\"token punctuation\">.</span>Logger<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>slf4j<span class=\"token punctuation\">.</span>LoggerFactory<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>beans<span class=\"token punctuation\">.</span>factory<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>Autowired<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>io<span class=\"token punctuation\">.</span>ClassPathResource<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>RedisTemplate<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>redis<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>script<span class=\"token punctuation\">.</span>DefaultRedisScript<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>scripting<span class=\"token punctuation\">.</span>support<span class=\"token punctuation\">.</span>ResourceScriptSource<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>stereotype<span class=\"token punctuation\">.</span>Component<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> javax<span class=\"token punctuation\">.</span>annotation<span class=\"token punctuation\">.</span>PostConstruct<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> javax<span class=\"token punctuation\">.</span>servlet<span class=\"token punctuation\">.</span>http<span class=\"token punctuation\">.</span>HttpServletRequest<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span>Method<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>reflect<span class=\"token punctuation\">.</span>Type<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>List<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>Map<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//aop支持</span>\n<span class=\"token annotation punctuation\">@Aspect</span>\n<span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RateLimterHandler</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Logger logger <span class=\"token operator\">=</span> LoggerFactory<span class=\"token punctuation\">.</span><span class=\"token function\">getLogger</span><span class=\"token punctuation\">(</span>RateLimterHandler<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@Autowired</span>\n    <span class=\"token keyword\">private</span> RedisTemplate redisTemplate<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">private</span> DefaultRedisScript<span class=\"token operator\">&lt;</span>Long<span class=\"token operator\">></span> redisScript<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的inti()方法</span>\n    <span class=\"token annotation punctuation\">@PostConstruct</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        redisScript <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultRedisScript</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        redisScript<span class=\"token punctuation\">.</span><span class=\"token function\">setResultType</span><span class=\"token punctuation\">(</span>Long<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        redisScript<span class=\"token punctuation\">.</span><span class=\"token function\">setScriptSource</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ResourceScriptSource</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassPathResource</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"rateLimter.lua\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"RateLimterHandler[分布式限流处理器]脚本加载完成\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//定义切点方法为注解RateLimiter名称为rateLimiter</span>\n    <span class=\"token annotation punctuation\">@Pointcut</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@annotation(com.xzy.springbootredisdemo.annotation.RateLimiter)\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">rateLimiter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Around</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"@annotation(rateLimiter)\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> Object <span class=\"token function\">around</span><span class=\"token punctuation\">(</span>ProceedingJoinPoint proceedingJoinPoint<span class=\"token punctuation\">,</span> RateLimiter rateLimiter<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n        Signature signature <span class=\"token operator\">=</span> proceedingJoinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">getSignature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>signature <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">MethodSignature</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"注释应该配置在方法上\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//获取方法参数</span>\n        HttpServletRequest request <span class=\"token operator\">=</span> <span class=\"token function\">getArgsRequest</span><span class=\"token punctuation\">(</span>proceedingJoinPoint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//获取注解参数</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 限流模块key</span>\n        String limitKey <span class=\"token operator\">=</span> rateLimiter<span class=\"token punctuation\">.</span><span class=\"token function\">key</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Preconditions<span class=\"token punctuation\">.</span><span class=\"token function\">checkNotNull</span><span class=\"token punctuation\">(</span>limitKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//判断是否为空</span>\n        <span class=\"token comment\" spellcheck=\"true\">//是否根据ip进行限流</span>\n        <span class=\"token keyword\">boolean</span> isLimiterIp <span class=\"token operator\">=</span> rateLimiter<span class=\"token punctuation\">.</span><span class=\"token function\">isLimiterIp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isLimiterIp <span class=\"token operator\">&amp;&amp;</span> request <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                String ip <span class=\"token operator\">=</span> IpUtil<span class=\"token punctuation\">.</span><span class=\"token function\">getIpAddr</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                limitKey <span class=\"token operator\">+=</span> <span class=\"token string\">\":\"</span> <span class=\"token operator\">+</span> ip<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//限流阀值</span>\n        <span class=\"token keyword\">long</span> limitTimes <span class=\"token operator\">=</span> rateLimiter<span class=\"token punctuation\">.</span><span class=\"token function\">limit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 限流超时时间</span>\n        <span class=\"token keyword\">long</span> expireTime <span class=\"token operator\">=</span> rateLimiter<span class=\"token punctuation\">.</span><span class=\"token function\">expire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">isDebugEnabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            logger<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"RateLimterHandler[分布式限流处理器]参数值为-limitTimes={},limitTimeout={}\"</span><span class=\"token punctuation\">,</span> limitTimes<span class=\"token punctuation\">,</span> expireTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//限流提示语</span>\n        String message <span class=\"token operator\">=</span> rateLimiter<span class=\"token punctuation\">.</span><span class=\"token function\">message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//执行lua脚本</span>\n        List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> keyList <span class=\"token operator\">=</span> Lists<span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        keyList<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>limitKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Long result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Long<span class=\"token punctuation\">)</span> redisTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span>redisScript<span class=\"token punctuation\">,</span> keyList<span class=\"token punctuation\">,</span> expireTime<span class=\"token punctuation\">,</span> limitTimes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Type type <span class=\"token operator\">=</span> <span class=\"token function\">getMethodReturnType</span><span class=\"token punctuation\">(</span>proceedingJoinPoint<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"由于超过单位时间=\"</span> <span class=\"token operator\">+</span> expireTime <span class=\"token operator\">+</span> <span class=\"token string\">\"-允许的请求次数=\"</span> <span class=\"token operator\">+</span> limitTimes <span class=\"token operator\">+</span> <span class=\"token string\">\"[触发限流]\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">limitErrorReturn</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> proceedingJoinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">proceed</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> Object <span class=\"token function\">limitErrorReturn</span><span class=\"token punctuation\">(</span>Type type<span class=\"token punctuation\">,</span> String msg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">.</span><span class=\"token function\">getTypeName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">\"java.lang.String\"</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> msg<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">\"java.util.Map\"</span><span class=\"token operator\">:</span>\n                Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> String<span class=\"token operator\">></span> resultMap <span class=\"token operator\">=</span> Maps<span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                resultMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"code\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"-1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                resultMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span><span class=\"token punctuation\">,</span> msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> resultMap<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">case</span> <span class=\"token string\">\"com.xzy.springbootredisdemo.util.ResultVo\"</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> ResultVo<span class=\"token punctuation\">.</span><span class=\"token function\">getErrorResultVo</span><span class=\"token punctuation\">(</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n                <span class=\"token keyword\">return</span> msg<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">public</span> HttpServletRequest <span class=\"token function\">getArgsRequest</span><span class=\"token punctuation\">(</span>ProceedingJoinPoint proceedingJoinPoint<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> NoSuchMethodException <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//获取方法参数</span>\n        Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args <span class=\"token operator\">=</span> proceedingJoinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">getArgs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        HttpServletRequest request <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Object o <span class=\"token operator\">:</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>o <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">HttpServletRequest</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                request <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>HttpServletRequest<span class=\"token punctuation\">)</span> o<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> request<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 获取返回值类型\n     * @param proceedingJoinPoint\n     * @return\n     * @throws NoSuchMethodException\n     */</span>\n    <span class=\"token keyword\">public</span> Type <span class=\"token function\">getMethodReturnType</span><span class=\"token punctuation\">(</span>ProceedingJoinPoint proceedingJoinPoint<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> NoSuchMethodException <span class=\"token punctuation\">{</span>\n        Signature signature <span class=\"token operator\">=</span> proceedingJoinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">getSignature</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        MethodSignature methodSignature <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>MethodSignature<span class=\"token punctuation\">)</span> signature<span class=\"token punctuation\">;</span>\n        Object target <span class=\"token operator\">=</span> proceedingJoinPoint<span class=\"token punctuation\">.</span><span class=\"token function\">getTarget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Method currentMethod <span class=\"token operator\">=</span> target<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getMethod</span><span class=\"token punctuation\">(</span>methodSignature<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> methodSignature<span class=\"token punctuation\">.</span><span class=\"token function\">getParameterTypes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> currentMethod<span class=\"token punctuation\">.</span><span class=\"token function\">getAnnotatedReturnType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h4 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">BaseEnum</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getMsg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">enum</span> SystemResultEnum <span class=\"token keyword\">implements</span> <span class=\"token class-name\">BaseEnum</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">SUCCESS</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"成功\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">FAIL</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"0\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"系统错误\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">NO_AUTH_USER</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"未注册用户\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">NO_AD_USER</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"3\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"待审核用户\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">SystemResultEnum</span><span class=\"token punctuation\">(</span>String code<span class=\"token punctuation\">,</span> String msg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>code <span class=\"token operator\">=</span> code<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>msg <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">private</span> String code<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> String msg<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> code<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setCode</span><span class=\"token punctuation\">(</span>String code<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>code <span class=\"token operator\">=</span> code<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getMsg</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> msg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setMsg</span><span class=\"token punctuation\">(</span>String msg<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>msg <span class=\"token operator\">=</span> msg<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"Lua脚本\"><a href=\"#Lua脚本\" class=\"headerlink\" title=\"Lua脚本\"></a>Lua脚本</h4><pre class=\" language-lua\"><code class=\"language-lua\"><span class=\"token comment\" spellcheck=\"true\">-- 获取KEY</span>\n<span class=\"token keyword\">local</span> key1 <span class=\"token operator\">=</span> KEYS<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\" spellcheck=\"true\">-- incr可以实现自动设置key并设置初始值为1</span>\n<span class=\"token keyword\">local</span> val <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'incr'</span><span class=\"token punctuation\">,</span> key1<span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">-- 获取key1剩下的时间</span>\n<span class=\"token keyword\">local</span> ttl <span class=\"token operator\">=</span> redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ttl'</span><span class=\"token punctuation\">,</span>key1<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">--获取ARGV内的参数并打印</span>\n<span class=\"token comment\" spellcheck=\"true\">-- ARGV[1]超时时间</span>\n<span class=\"token keyword\">local</span> expire <span class=\"token operator\">=</span> ARGV<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n<span class=\"token comment\" spellcheck=\"true\">-- ARGV[2]单位时间允许通过的请求数</span>\n<span class=\"token keyword\">local</span> times <span class=\"token operator\">=</span> ARGV<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span>\n\n<span class=\"token comment\" spellcheck=\"true\">-- 日志打印 没什么用</span>\n<span class=\"token comment\" spellcheck=\"true\">-- redis.log(redis.LOG_DEBUG,tostring(times))</span>\n<span class=\"token comment\" spellcheck=\"true\">-- redis.log(redis.LOG_DEBUG,tostring(expire))</span>\n<span class=\"token comment\" spellcheck=\"true\">-- redis.log(redis.LOG_NOTICE, \"incr \"..key1..\" \"..val);</span>\n<span class=\"token comment\" spellcheck=\"true\">-- val == 1 表示是第一次访问，此时是第一次访问，设置过期时间</span>\n<span class=\"token keyword\">if</span> val <span class=\"token operator\">==</span> <span class=\"token number\">1</span> <span class=\"token keyword\">then</span>\n    redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'expire'</span><span class=\"token punctuation\">,</span>key1<span class=\"token punctuation\">,</span><span class=\"token function\">tonumber</span><span class=\"token punctuation\">(</span>expire<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">else</span>\n    <span class=\"token keyword\">if</span> ttl <span class=\"token operator\">==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token keyword\">then</span>\n        redis<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'expire'</span><span class=\"token punctuation\">,</span>key1<span class=\"token punctuation\">,</span><span class=\"token function\">tonumber</span><span class=\"token punctuation\">(</span>expire<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">if</span> val <span class=\"token operator\">></span> <span class=\"token function\">tonumber</span><span class=\"token punctuation\">(</span>times<span class=\"token punctuation\">)</span> <span class=\"token keyword\">then</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n<span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span></code></pre>\n<h4 id=\"控制层\"><a href=\"#控制层\" class=\"headerlink\" title=\"控制层\"></a>控制层</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RestController</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">TestController</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String MESSAGE <span class=\"token operator\">=</span> <span class=\"token string\">\"{\\\"code\\\":\\\"400\\\",\\\"msg\\\":\\\"FAIL\\\",\\\"desc\\\":\\\"触发限流\\\"}\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/testone\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@RateLimiter</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"ratelimit:testOne\"</span><span class=\"token punctuation\">,</span> limit <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> expire <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> message <span class=\"token operator\">=</span> MESSAGE<span class=\"token punctuation\">,</span> isLimiterIp <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">testOne</span><span class=\"token punctuation\">(</span>HttpServletRequest request<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"正常请求\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/testtwo\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@RateLimiter</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"ratelimit:testTwo\"</span><span class=\"token punctuation\">,</span> limit <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> expire <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> isLimiterIp <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> Map <span class=\"token function\">testTow</span><span class=\"token punctuation\">(</span>HttpServletRequest request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span>String<span class=\"token operator\">></span> resultMap <span class=\"token operator\">=</span> Maps<span class=\"token punctuation\">.</span><span class=\"token function\">newHashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        resultMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"code\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        resultMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"message\"</span> <span class=\"token punctuation\">,</span> <span class=\"token string\">\"success\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> resultMap<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/testthree\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@RateLimiter</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"ratelimit:testThree\"</span><span class=\"token punctuation\">,</span> limit <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> expire <span class=\"token operator\">=</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> isLimiterIp <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> ResultVo <span class=\"token function\">testThree</span><span class=\"token punctuation\">(</span>HttpServletRequest request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> ResultVo<span class=\"token punctuation\">.</span><span class=\"token function\">getSuccessResultVo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>通过给api-url设置一个redis-key并设置过期时间。当每次url被请求时key的值加一，如果在过期时间内增加到一定数量后则进行限流。在原理上通过使用redis键值过期时间作为限流的单位时间，在单位时间内如果访问的次数大于指定次数后禁止继续访问，当键值过期后再次访问时重新计算单位时间内的允许访问次数。</p>","more":"<p>采用aop+自定义注解的方式，在每次调用controller类时对方法进行增强，aop扫描所有注有<strong>@RateLimiter</strong>的方法并环绕增强。</p>\n<h3 id=\"项目测试\"><a href=\"#项目测试\" class=\"headerlink\" title=\"项目测试\"></a>项目测试</h3><pre><code class=\"java\">//指定testone这个url在10秒内只能有5次请求，如果超过则报错\n@RequestMapping(&quot;/testone&quot;)\n@RateLimiter(key = &quot;ratelimit:testOne&quot;, limit = 5, expire = 10, message = MESSAGE, isLimiterIp = true)\n    public String testOne(HttpServletRequest request) {\n        return &quot;正常请求&quot;;\n}</code></pre>\n<p>连续在10秒内访问5次</p>\n<pre><code class=\"json\">{&quot;code&quot;:&quot;400&quot;,&quot;msg&quot;:&quot;FAIL&quot;,&quot;desc&quot;:&quot;触发限流&quot;}</code></pre>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"MAVEN包\"><a href=\"#MAVEN包\" class=\"headerlink\" title=\"MAVEN包\"></a>MAVEN包</h3><pre><code class=\"xml\">&lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;!--aop支持--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!--添加redis支持--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;\n            &lt;version&gt;2.6.0&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n            &lt;version&gt;3.7&lt;/version&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n            &lt;artifactId&gt;guava&lt;/artifactId&gt;\n            &lt;version&gt;26.0-jre&lt;/version&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;</code></pre>\n<h3 id=\"SpringBoot配置\"><a href=\"#SpringBoot配置\" class=\"headerlink\" title=\"SpringBoot配置\"></a>SpringBoot配置</h3><pre><code class=\"yaml\">spring:\n  redis:\n    database: 0\n    host: 127.0.0.1\n    jedis:\n      pool:\n        #最大连接数据库连接数,设 0 为没有限制\n        max-active: 8\n        #最大等待连接中的数量,设 0 为没有限制\n        max-idle: 8\n        #最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。\n        max-wait: -1ms\n        #最小等待连接中的数量,设 0 为没有限制\n        min-idle: 0\n    lettuce:\n      pool:\n        max-active: 8\n        max-idle: 8\n        max-wait: -1ms\n        min-idle: 0\n      shutdown-timeout: 100ms\n    password: &#39;&#39;\n    port: 6379</code></pre>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><pre><code class=\"java\">package com.xzy.springbootredisdemo.annotation;\n\nimport java.lang.annotation.*;\n\n/***\n * 限流注解\n * key--表示限流模块名，指定该值用于区分不同应用，不同场景，推荐格式为：应用名:模块名:ip:接口名:方法名\n * limit--表示单位时间允许通过的请求数\n * expire--incr的值的过期时间，业务中表示限流的单位时间。\n * isLimiterIp -- 是否根据IP进行过滤，如果为true，则key为ratelimit:url:ip的方式存储，这样可以根据ip来限流\n */\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimiter {\n    /**\n     * 限流key\n     * @return\n     */\n    String key() default &quot;rate:limiter&quot;;\n    /**\n     * 单位时间限制通过请求数\n     * @return\n     */\n    long limit() default 10;\n    /**\n     * 过期时间，单位秒\n     * @return\n     */\n    long expire() default 1;\n    String message() default &quot;限制访问&quot;;\n    /***\n     * 是否精确到ip控制\n     * * @return\n     */\n    boolean isLimiterIp() default false;\n}\n</code></pre>\n<h4 id=\"Redis配置类\"><a href=\"#Redis配置类\" class=\"headerlink\" title=\"Redis配置类\"></a>Redis配置类</h4><pre><code class=\"java\">import com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.cache.CacheManager;\nimport org.springframework.cache.annotation.CachingConfigurerSupport;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.cache.RedisCacheConfiguration;\nimport org.springframework.data.redis.cache.RedisCacheManager;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;\nimport org.springframework.data.redis.serializer.RedisSerializationContext;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\nimport java.time.Duration;\n@Configuration\n@EnableCaching\npublic class RedisCacheConfig extends CachingConfigurerSupport {\n    private static final Logger logger = LoggerFactory.getLogger(RedisCacheConfig.class);\n    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory factory) {\n        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        //解决查询缓存转换异常的问题\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置序列化（解决乱码的问题）,过期时间30秒\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofSeconds(30))\n                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))\n                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))\n                .disableCachingNullValues();\n        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)\n                .cacheDefaults(config)\n                .build();\n        return cacheManager;\n    }\n    @Bean\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();\n        RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        template.setConnectionFactory(factory);\n        //key序列化方式\n        template.setKeySerializer(redisSerializer);\n        //value序列化\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        //value hashmap序列化\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        return template;\n    }\n}</code></pre>\n<h4 id=\"AOP增强\"><a href=\"#AOP增强\" class=\"headerlink\" title=\"AOP增强\"></a>AOP增强</h4><p>对使用了@RateLimiter注解的方法进行环绕增强</p>\n<pre><code class=\"java\">import com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.xzy.springbootredisdemo.annotation.RateLimiter;\nimport com.xzy.springbootredisdemo.util.IpUtil;\nimport com.xzy.springbootredisdemo.util.ResultVo;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.Signature;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Pointcut;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.core.script.DefaultRedisScript;\nimport org.springframework.scripting.support.ResourceScriptSource;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.http.HttpServletRequest;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Map;\n\n//aop支持\n@Aspect\n@Component\npublic class RateLimterHandler {\n    private static final Logger logger = LoggerFactory.getLogger(RateLimterHandler.class);\n\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    private DefaultRedisScript&lt;Long&gt; redisScript;\n\n    //@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的inti()方法\n    @PostConstruct\n    public void init() {\n        redisScript = new DefaultRedisScript&lt;&gt;();\n        redisScript.setResultType(Long.class);\n        redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(&quot;rateLimter.lua&quot;)));\n        logger.info(&quot;RateLimterHandler[分布式限流处理器]脚本加载完成&quot;);\n    }\n\n    //定义切点方法为注解RateLimiter名称为rateLimiter\n    @Pointcut(&quot;@annotation(com.xzy.springbootredisdemo.annotation.RateLimiter)&quot;)\n    public void rateLimiter() {\n    }\n\n    @Around(&quot;@annotation(rateLimiter)&quot;)\n    public Object around(ProceedingJoinPoint proceedingJoinPoint, RateLimiter rateLimiter) throws Throwable {\n        Signature signature = proceedingJoinPoint.getSignature();\n        if (!(signature instanceof MethodSignature)) {\n            throw new IllegalArgumentException(&quot;注释应该配置在方法上&quot;);\n        }\n        //获取方法参数\n        HttpServletRequest request = getArgsRequest(proceedingJoinPoint);\n        //获取注解参数\n        // 限流模块key\n        String limitKey = rateLimiter.key();\n        Preconditions.checkNotNull(limitKey); //判断是否为空\n        //是否根据ip进行限流\n        boolean isLimiterIp = rateLimiter.isLimiterIp();\n        if (isLimiterIp &amp;&amp; request != null) {\n            if (request != null) {\n                String ip = IpUtil.getIpAddr(request);\n                limitKey += &quot;:&quot; + ip;\n            }\n        }\n        //限流阀值\n        long limitTimes = rateLimiter.limit();\n        // 限流超时时间\n        long expireTime = rateLimiter.expire();\n        if (logger.isDebugEnabled()) {\n            logger.debug(&quot;RateLimterHandler[分布式限流处理器]参数值为-limitTimes={},limitTimeout={}&quot;, limitTimes, expireTime);\n        }\n        //限流提示语\n        String message = rateLimiter.message();\n        //执行lua脚本\n        List&lt;String&gt; keyList = Lists.newArrayList();\n        keyList.add(limitKey);\n        Long result = (Long) redisTemplate.execute(redisScript, keyList, expireTime, limitTimes);\n        if (result == 0) {\n            Type type = getMethodReturnType(proceedingJoinPoint);\n            logger.info(&quot;由于超过单位时间=&quot; + expireTime + &quot;-允许的请求次数=&quot; + limitTimes + &quot;[触发限流]&quot;);\n            return limitErrorReturn(type, message);\n        }\n        return proceedingJoinPoint.proceed();\n    }\n\n\n    public Object limitErrorReturn(Type type, String msg) {\n        switch (type.getTypeName()) {\n            case &quot;java.lang.String&quot;:\n                return msg;\n            case &quot;java.util.Map&quot;:\n                Map&lt;String, String&gt; resultMap = Maps.newHashMap();\n                resultMap.put(&quot;code&quot;, &quot;-1&quot;);\n                resultMap.put(&quot;message&quot;, msg);\n                return resultMap;\n            case &quot;com.xzy.springbootredisdemo.util.ResultVo&quot;:\n                return ResultVo.getErrorResultVo(msg);\n            default:\n                return msg;\n        }\n    }\n\n\n    public HttpServletRequest getArgsRequest(ProceedingJoinPoint proceedingJoinPoint) throws NoSuchMethodException {\n        //获取方法参数\n        Object[] args = proceedingJoinPoint.getArgs();\n        HttpServletRequest request = null;\n        for (Object o : args) {\n            if (o instanceof HttpServletRequest) {\n                request = (HttpServletRequest) o;\n            }\n        }\n        return request;\n    }\n\n    /***\n     * 获取返回值类型\n     * @param proceedingJoinPoint\n     * @return\n     * @throws NoSuchMethodException\n     */\n    public Type getMethodReturnType(ProceedingJoinPoint proceedingJoinPoint) throws NoSuchMethodException {\n        Signature signature = proceedingJoinPoint.getSignature();\n        MethodSignature methodSignature = (MethodSignature) signature;\n        Object target = proceedingJoinPoint.getTarget();\n        Method currentMethod = target.getClass().getMethod(methodSignature.getName(), methodSignature.getParameterTypes());\n        return currentMethod.getAnnotatedReturnType().getType();\n    }\n\n}\n</code></pre>\n<h4 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h4><pre><code class=\"java\">public interface BaseEnum {\n    public String getCode();\n    public String getMsg();\n}\npublic enum SystemResultEnum implements BaseEnum {\n    SUCCESS(&quot;1&quot;, &quot;成功&quot;),\n    FAIL(&quot;0&quot;, &quot;系统错误&quot;),\n    NO_AUTH_USER(&quot;2&quot;, &quot;未注册用户&quot;),\n    NO_AD_USER(&quot;3&quot;, &quot;待审核用户&quot;);\n    SystemResultEnum(String code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n    private String code;\n    private String msg;\n    public String getCode() {\n        return code;\n    }\n    public void setCode(String code) {\n        this.code = code;\n    }\n    public String getMsg() {\n        return msg;\n    }\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n}</code></pre>\n<h4 id=\"Lua脚本\"><a href=\"#Lua脚本\" class=\"headerlink\" title=\"Lua脚本\"></a>Lua脚本</h4><pre><code class=\"lua\">-- 获取KEY\nlocal key1 = KEYS[1]\n-- incr可以实现自动设置key并设置初始值为1\nlocal val = redis.call(&#39;incr&#39;, key1)\n-- 获取key1剩下的时间\nlocal ttl = redis.call(&#39;ttl&#39;,key1)\n\n--获取ARGV内的参数并打印\n-- ARGV[1]超时时间\nlocal expire = ARGV[1]\n-- ARGV[2]单位时间允许通过的请求数\nlocal times = ARGV[2]\n\n-- 日志打印 没什么用\n-- redis.log(redis.LOG_DEBUG,tostring(times))\n-- redis.log(redis.LOG_DEBUG,tostring(expire))\n-- redis.log(redis.LOG_NOTICE, &quot;incr &quot;..key1..&quot; &quot;..val);\n-- val == 1 表示是第一次访问，此时是第一次访问，设置过期时间\nif val == 1 then\n    redis.call(&#39;expire&#39;,key1,tonumber(expire))\nelse\n    if ttl == -1 then\n        redis.call(&#39;expire&#39;,key1,tonumber(expire))\n    end\nend\n\nif val &gt; tonumber(times) then\n    return 0\nend\n    return 1</code></pre>\n<h4 id=\"控制层\"><a href=\"#控制层\" class=\"headerlink\" title=\"控制层\"></a>控制层</h4><pre><code class=\"java\">@RestController\npublic class TestController {\n    private static final String MESSAGE = &quot;{\\&quot;code\\&quot;:\\&quot;400\\&quot;,\\&quot;msg\\&quot;:\\&quot;FAIL\\&quot;,\\&quot;desc\\&quot;:\\&quot;触发限流\\&quot;}&quot;;\n\n    @RequestMapping(&quot;/testone&quot;)\n    @RateLimiter(key = &quot;ratelimit:testOne&quot;, limit = 5, expire = 10, message = MESSAGE, isLimiterIp = true)\n    public String testOne(HttpServletRequest request) {\n        return &quot;正常请求&quot;;\n    }\n    @RequestMapping(&quot;/testtwo&quot;)\n    @RateLimiter(key = &quot;ratelimit:testTwo&quot;, limit = 5, expire = 10, isLimiterIp = false)\n    public Map testTow(HttpServletRequest request){\n        Map&lt;String,String&gt; resultMap = Maps.newHashMap();\n        resultMap.put(&quot;code&quot;, &quot;1&quot;);\n        resultMap.put(&quot;message&quot; , &quot;success&quot;);\n        return resultMap;\n    }\n    @RequestMapping(&quot;/testthree&quot;)\n    @RateLimiter(key = &quot;ratelimit:testThree&quot;, limit = 5, expire = 10, isLimiterIp = false)\n    public ResultVo testThree(HttpServletRequest request){\n        return ResultVo.getSuccessResultVo();\n    }\n}</code></pre>"},{"title":"Redis5.0集群搭建和水平扩展（二）","description":"详解Redis5.0集群搭建和水平扩展","date":"2020-09-02T03:13:00.000Z","_content":"\n## Redis5.0集群水平扩展\n\n上节介绍了集群的搭建，这节开始详解水平扩展。假设现在由于资源使用情况，我们需要增加一组主从（9857、9858）加入到集群中。\n\n![](redis-cluster-build-2/2.png)\n<!--more-->\n当前Redis集群情况如下，\n\n![](redis-cluster-build-2/1.png)\n\n- 槽（0 - 5460）           主：10.8.198.152:9851 从：  10.8.198.152.9856\n- 槽（5461 - 10922）   主：10.8.198.152:9852 从：  10.8.198.152.9854\n- 槽（10923 - 16381） 主：10.8.198.152:9853 从：  10.8.198.152.9855\n\n### **增加9857、9858实例**\n\n新增两个目录并修改其配置文件，如何修改参照上一篇文章。此时启动9857、9858后还没有加入到集群中。\n\n```shell\n[root@Slave3 redis]# mkdir 9857\n[root@Slave3 redis]# mkdir 9858\n[root@Slave3 redis]# cp /etc/redis/9851/redis.conf /etc/redis/9857/\n[root@Slave3 redis]# cp /etc/redis/9851/redis.conf /etc/redis/9858/\n##修改9857、9858配置文件，并启动\n[root@Slave3 redis]# redis-server /etc/redis/9857/redis.conf\n[root@Slave3 redis]# redis-server /etc/redis/9858/redis.conf\n```\n\n### **配置9857为集群主节点**\n\n```shell\nredis-cli --cluster add-node 10.8.198.152:9857 10.8.198.152:9851\n```\n\n![](redis-cluster-build-2/3.png)\n\n### **为9857分配槽(空槽道迁移)**\n\n#### **方案1**\n\n上面我们将9857加入到集群后还没分配槽，此时9857还没有作用。接下去需要为其分配槽。原来我们3个master已经将槽分配完了，此时加入一个新maser则需要将其中一台master的槽进行拆分。\n\n**重新分配集群上的槽给9857**\n\n```shell\nredis-cli --cluster reshard 10.8.198.152:9851\n```\n\n![](redis-cluster-build-2/4.png)\n\n此时会询问**分出多少槽出来？分给哪个节点？** 我们按照提示输入。\n接下去会询问我们分配槽的方式，有两种方式\n\n- all，以将所有节点用作散列槽的源节点\n- done，选择从哪个节点上拿出来节点\n\nall是随机的，比如说我们要分出1000个，则3个主节点分别拿出333个，333个，334个节点分别9857，这里我们选择done，从9857拿1000个给9857。\n\n#### **方案2**\n\n<font color=red>这种方案相对与上一种方案有缺陷，他只能迁移一个槽</font>\n\n```shell\nredis-cli --cluster add-node 10.8.198.152:9857 10.8.198.152:9851\n```\n\n![](redis-cluster-build-2/3.png)\n\n（1）先登录9851查看下要迁移的槽上有没有存了KEY，没有才能迁移\n\n```shell\n#cluster getkeysinslot 槽道号 查找范围\n10.8.198.152:9851>cluster getkeysinslot 1000 2000\n(empty list or set)\n```\n\n（2）登录需要导入的节点9857，执行命令cluster setslot 槽道号 importing 源节点id，将9857节点上1000槽道的状态变更为importing\n\n```\n10.8.198.152:9857>cluster setslot 1000 importing 419ff0823f0ff4cfb1ffc4c002665ad077911cc2\n```\n\n![](redis-cluster-build-2/8.png)\n\n（3）登录需要导出的节点9851，执行命令cluster setslot 槽道号 migrating 目标节点id，将9851节点上的460槽道的状态变更为migrating。\n\n```shell\n10.8.198.152:9851>cluster setslot 1000 migrating 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\n```\n\n![](redis-cluster-build-2/9.png)\n\n（4）通知进行迁移的两个节点槽道迁移了，使用命令**cluster setslot 槽道号 node 迁入节点id**，需要在两个节点上均进行操作。槽号1000就被迁移了。\n\n```shell\n# 迁出节点9851上执行命令，后面跟的id为迁入节点的id\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851> cluster setslot 1000 node 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\nOK\n#迁入节点9857上执行命令，后面跟的id为迁入节点的id\n[root@Slave3 redis]# redis-cli -p 9857 -h 10.8.198.152\n10.8.198.152:9857> cluster setslot 1000 node 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\nOK\n10.8.198.152:9857> cluster nodes\nf08cdba85763f71de3a1cbac8a45962594ab09aa 10.8.198.152:9852@19852 master - 0 1599038877000 2 connected 5461-10922\nb8cc9aeca57e1332b6f42b7e183cce686033c2d6 10.8.198.152:9854@19854 slave 419ff0823f0ff4cfb1ffc4c002665ad077911cc2 0 1599038878000 1 connected\n286fe16d33dbbafa9f13e9a11d4351c37e085155 10.8.198.152:9853@19853 master - 0 1599038879000 3 connected 10923-16383\naf6115f83a145c63a75916608084712f96d44c34 10.8.198.152:9855@19855 slave f08cdba85763f71de3a1cbac8a45962594ab09aa 0 1599038879489 2 connected\n5e2af503c816eeff7ed2cfb2249f0ceb1f5306da 10.8.198.152:9857@19857 myself,master - 0 1599038878000 7 connected 1000\n14901a2ff5242f302103bbca4bfa6e2dade0a95b 10.8.198.152:9856@19856 slave 286fe16d33dbbafa9f13e9a11d4351c37e085155 0 1599038880000 3 connected\n419ff0823f0ff4cfb1ffc4c002665ad077911cc2 10.8.198.152:9851@19851 master - 0 1599038880492 1 connected 0-999 1001-5460\n```\n\n\n\n### **为9857分配槽(非空槽道迁移)**\n\n<font color=red>正常情况下，到这一步应该要将9851上的1000个槽分配给9857成功，但是由于我们9851上要转移的槽上有存了key了导致我们转移失败。</font>\n\n![当转移2号槽时失败](redis-cluster-build-2/5.png)\n\n#### **解决方案1**\n\n解决方法：\n\n1. 删除节点9851上的所有key，可以使用flushdb\n2. 执行 redis-cli \\--cluster fix 10.8.198.152:9851 修复节点\n3. 重新从 redis-cli \\--cluster reshard 10.8.198.152.9851 命令重新分配槽\n\n#### **解决方案2**\n\n假设要迁移9851上的槽654到9857\n\n首先先保证9857加入到集群了\n\n```shell\n redis-cli --cluster add-node 10.8.198.152：9857 10.8.198.152：9851\n```\n\n当前cluster nodes信息\n\n```shell\n10.8.198.152:9851> cluster nodes\n5bc658cd4d8cc35097e0a79e140069262161b827 10.8.198.152:9855@19855 slave bb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 0 1599040212180 5 connected\na26317d89a7b09c0c9d77139cd8be94588c9b127 10.8.198.152:9853@19853 master - 0 1599040210000 3 connected 10923-16383\nbb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 10.8.198.152:9852@19852 master - 0 1599040210175 2 connected 5461-10922\n1f797b67ba0ae4966610d8596431980f5cce4858 10.8.198.152:9854@19854 slave 5015fbe7c523681a59e13f86f0ddc27b1ac542f8 0 1599040212000 4 connected\n5015fbe7c523681a59e13f86f0ddc27b1ac542f8 10.8.198.152:9851@19851 myself,master - 0 1599040211000 1 connected 0-5460\n0a286334e831f426de9e30c7990cffb40a1e4102 10.8.198.152:9857@19857 master - 0 1599040211000 0 connected\n150ef7fd331f57f3d11e8b2372ba991c41c850d7 10.8.198.152:9856@19856 slave a26317d89a7b09c0c9d77139cd8be94588c9b127 0 1599040213182 6 connected\n```\n\n（1）检查654槽是否有数据\n\n```shell\n#cluster getkeysinslot 槽道号 查找范围\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851> cluster getkeysinslot 654 2000\n1) \"\\xac\\xed\\x00\\x05t\\x00\\tkey_45618\"\n```\n\n（2）登录需要导入的节点9857，执行命令cluster setslot 槽道号 importing 源节点id，将8000节点上654槽道的状态变更为importing。\n\n```shell\n[root@Slave3 redis]# redis-cli -p 9857 -h 10.8.198.152\n10.8.198.152:9857> cluster setslot 654 importing 5015fbe7c523681a59e13f86f0ddc27b1ac542f8\nOK\n```\n\n（3）登录需要导出的节点9851，执行命令cluster setslot 槽道号 migrating 目标节点id，将9851节点上的654槽道的状态变更为migrating。\n\n```shell\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851> cluster setslot 654 migrating 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n```\n\n（4）**登录源节点9851**，将741槽道对应的数据（一个个的key-value），以及槽道保存key信息的map（{槽道号:[age,...]}），一并迁入到9857节点，使用如下命令完成。\n\n- host：目标Redis的IP地址\n- port：目标Redis的端口\n- key|\"\"：Redis 3.0.6 后如果需要迁移多个键，此处为空字符串\"\"\n- destination-db：目标Redis的数据库索引\n- timeout：迁移的超时时间（单位为毫秒）\n- copy：如果添加此选项后，迁移后不删除源键。\n- replace：如果添加此选项`migrate`不管目标Redis是否存在该键都会正常迁移进行数据覆盖\n- keys：如果要删除多个建，填写`keys key1 key2 key3`\n\n```shell\n10.8.198.152:9851> migrate 10.8.198.152 9857 \"\" 0 1000 keys \"\\xac\\xed\\x00\\x05t\\x00\\tkey_45618\"\nOK\n```\n\n（5）通知进行迁移的两个节点槽道迁移了，到了这一步这个和上面空槽道的迁移操作一样。\n\n```shell\n10.8.198.152:9851> cluster setslot 654 node 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n10.8.198.152:9857> cluster setslot 654 node 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n10.8.198.152:9857> cluster nodes\nbb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 10.8.198.152:9852@19852 master - 0 1599040905000 2 connected 5461-10922\n5bc658cd4d8cc35097e0a79e140069262161b827 10.8.198.152:9855@19855 slave bb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 0 1599040909085 2 connected\n1f797b67ba0ae4966610d8596431980f5cce4858 10.8.198.152:9854@19854 slave 5015fbe7c523681a59e13f86f0ddc27b1ac542f8 0 1599040906000 1 connected\na26317d89a7b09c0c9d77139cd8be94588c9b127 10.8.198.152:9853@19853 master - 0 1599040908083 3 connected 10923-16383\n5015fbe7c523681a59e13f86f0ddc27b1ac542f8 10.8.198.152:9851@19851 master - 0 1599040907082 1 connected 0-653 655-5460\n150ef7fd331f57f3d11e8b2372ba991c41c850d7 10.8.198.152:9856@19856 slave a26317d89a7b09c0c9d77139cd8be94588c9b127 0 1599040907000 3 connected\n0a286334e831f426de9e30c7990cffb40a1e4102 10.8.198.152:9857@19857 myself,master - 0 1599040907000 7 connected 654\n```\n\n<font color=red>这种方案其实是先保证了对应的槽上没有KEY了再进行迁移，如果有数据则需要通过migrate进行迁移。个人感觉太繁琐了。。。</font>\n\n### **为9857分配从节点9858**\n\n此时9857上已经分配了槽，但是还没有为他分配从节点。我们需要将9858配置成9857的从节点\n\n![](redis-cluster-build-2/6.png)\n\n方法如下:\n\n将9858也加入到集群中。\n\n```shell\nredis-cli --cluster add-node 10.8.198.152:9858 10.8.198.152:9851\n```\n\n登录9858客户端\n\n```shell\nredis-cli -p 9858 -h 10.8.198.152\n```\n\n指定9858为9857的从节点\n\n```shell\n10.8.198.152:9858> cluster replicate 9857的ID\n```\n\n至此，扩容完成。\n\n![](redis-cluster-build-2/7.png)\n\n## 小知识\n\n### 查看KEY在哪个槽上\n\n```shell\n10.8.198.152:9851> cluster keyslot keyname\n```","source":"_posts/redis-cluster-build-2.md","raw":"---\ntitle: Redis5.0集群搭建和水平扩展（二）\ntags:\n  - redis\ncategories: redis\ndescription : 详解Redis5.0集群搭建和水平扩展\ndate: 2020-09-02 11:13:00\n---\n\n## Redis5.0集群水平扩展\n\n上节介绍了集群的搭建，这节开始详解水平扩展。假设现在由于资源使用情况，我们需要增加一组主从（9857、9858）加入到集群中。\n\n![](redis-cluster-build-2/2.png)\n<!--more-->\n当前Redis集群情况如下，\n\n![](redis-cluster-build-2/1.png)\n\n- 槽（0 - 5460）           主：10.8.198.152:9851 从：  10.8.198.152.9856\n- 槽（5461 - 10922）   主：10.8.198.152:9852 从：  10.8.198.152.9854\n- 槽（10923 - 16381） 主：10.8.198.152:9853 从：  10.8.198.152.9855\n\n### **增加9857、9858实例**\n\n新增两个目录并修改其配置文件，如何修改参照上一篇文章。此时启动9857、9858后还没有加入到集群中。\n\n```shell\n[root@Slave3 redis]# mkdir 9857\n[root@Slave3 redis]# mkdir 9858\n[root@Slave3 redis]# cp /etc/redis/9851/redis.conf /etc/redis/9857/\n[root@Slave3 redis]# cp /etc/redis/9851/redis.conf /etc/redis/9858/\n##修改9857、9858配置文件，并启动\n[root@Slave3 redis]# redis-server /etc/redis/9857/redis.conf\n[root@Slave3 redis]# redis-server /etc/redis/9858/redis.conf\n```\n\n### **配置9857为集群主节点**\n\n```shell\nredis-cli --cluster add-node 10.8.198.152:9857 10.8.198.152:9851\n```\n\n![](redis-cluster-build-2/3.png)\n\n### **为9857分配槽(空槽道迁移)**\n\n#### **方案1**\n\n上面我们将9857加入到集群后还没分配槽，此时9857还没有作用。接下去需要为其分配槽。原来我们3个master已经将槽分配完了，此时加入一个新maser则需要将其中一台master的槽进行拆分。\n\n**重新分配集群上的槽给9857**\n\n```shell\nredis-cli --cluster reshard 10.8.198.152:9851\n```\n\n![](redis-cluster-build-2/4.png)\n\n此时会询问**分出多少槽出来？分给哪个节点？** 我们按照提示输入。\n接下去会询问我们分配槽的方式，有两种方式\n\n- all，以将所有节点用作散列槽的源节点\n- done，选择从哪个节点上拿出来节点\n\nall是随机的，比如说我们要分出1000个，则3个主节点分别拿出333个，333个，334个节点分别9857，这里我们选择done，从9857拿1000个给9857。\n\n#### **方案2**\n\n<font color=red>这种方案相对与上一种方案有缺陷，他只能迁移一个槽</font>\n\n```shell\nredis-cli --cluster add-node 10.8.198.152:9857 10.8.198.152:9851\n```\n\n![](redis-cluster-build-2/3.png)\n\n（1）先登录9851查看下要迁移的槽上有没有存了KEY，没有才能迁移\n\n```shell\n#cluster getkeysinslot 槽道号 查找范围\n10.8.198.152:9851>cluster getkeysinslot 1000 2000\n(empty list or set)\n```\n\n（2）登录需要导入的节点9857，执行命令cluster setslot 槽道号 importing 源节点id，将9857节点上1000槽道的状态变更为importing\n\n```\n10.8.198.152:9857>cluster setslot 1000 importing 419ff0823f0ff4cfb1ffc4c002665ad077911cc2\n```\n\n![](redis-cluster-build-2/8.png)\n\n（3）登录需要导出的节点9851，执行命令cluster setslot 槽道号 migrating 目标节点id，将9851节点上的460槽道的状态变更为migrating。\n\n```shell\n10.8.198.152:9851>cluster setslot 1000 migrating 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\n```\n\n![](redis-cluster-build-2/9.png)\n\n（4）通知进行迁移的两个节点槽道迁移了，使用命令**cluster setslot 槽道号 node 迁入节点id**，需要在两个节点上均进行操作。槽号1000就被迁移了。\n\n```shell\n# 迁出节点9851上执行命令，后面跟的id为迁入节点的id\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851> cluster setslot 1000 node 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\nOK\n#迁入节点9857上执行命令，后面跟的id为迁入节点的id\n[root@Slave3 redis]# redis-cli -p 9857 -h 10.8.198.152\n10.8.198.152:9857> cluster setslot 1000 node 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\nOK\n10.8.198.152:9857> cluster nodes\nf08cdba85763f71de3a1cbac8a45962594ab09aa 10.8.198.152:9852@19852 master - 0 1599038877000 2 connected 5461-10922\nb8cc9aeca57e1332b6f42b7e183cce686033c2d6 10.8.198.152:9854@19854 slave 419ff0823f0ff4cfb1ffc4c002665ad077911cc2 0 1599038878000 1 connected\n286fe16d33dbbafa9f13e9a11d4351c37e085155 10.8.198.152:9853@19853 master - 0 1599038879000 3 connected 10923-16383\naf6115f83a145c63a75916608084712f96d44c34 10.8.198.152:9855@19855 slave f08cdba85763f71de3a1cbac8a45962594ab09aa 0 1599038879489 2 connected\n5e2af503c816eeff7ed2cfb2249f0ceb1f5306da 10.8.198.152:9857@19857 myself,master - 0 1599038878000 7 connected 1000\n14901a2ff5242f302103bbca4bfa6e2dade0a95b 10.8.198.152:9856@19856 slave 286fe16d33dbbafa9f13e9a11d4351c37e085155 0 1599038880000 3 connected\n419ff0823f0ff4cfb1ffc4c002665ad077911cc2 10.8.198.152:9851@19851 master - 0 1599038880492 1 connected 0-999 1001-5460\n```\n\n\n\n### **为9857分配槽(非空槽道迁移)**\n\n<font color=red>正常情况下，到这一步应该要将9851上的1000个槽分配给9857成功，但是由于我们9851上要转移的槽上有存了key了导致我们转移失败。</font>\n\n![当转移2号槽时失败](redis-cluster-build-2/5.png)\n\n#### **解决方案1**\n\n解决方法：\n\n1. 删除节点9851上的所有key，可以使用flushdb\n2. 执行 redis-cli \\--cluster fix 10.8.198.152:9851 修复节点\n3. 重新从 redis-cli \\--cluster reshard 10.8.198.152.9851 命令重新分配槽\n\n#### **解决方案2**\n\n假设要迁移9851上的槽654到9857\n\n首先先保证9857加入到集群了\n\n```shell\n redis-cli --cluster add-node 10.8.198.152：9857 10.8.198.152：9851\n```\n\n当前cluster nodes信息\n\n```shell\n10.8.198.152:9851> cluster nodes\n5bc658cd4d8cc35097e0a79e140069262161b827 10.8.198.152:9855@19855 slave bb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 0 1599040212180 5 connected\na26317d89a7b09c0c9d77139cd8be94588c9b127 10.8.198.152:9853@19853 master - 0 1599040210000 3 connected 10923-16383\nbb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 10.8.198.152:9852@19852 master - 0 1599040210175 2 connected 5461-10922\n1f797b67ba0ae4966610d8596431980f5cce4858 10.8.198.152:9854@19854 slave 5015fbe7c523681a59e13f86f0ddc27b1ac542f8 0 1599040212000 4 connected\n5015fbe7c523681a59e13f86f0ddc27b1ac542f8 10.8.198.152:9851@19851 myself,master - 0 1599040211000 1 connected 0-5460\n0a286334e831f426de9e30c7990cffb40a1e4102 10.8.198.152:9857@19857 master - 0 1599040211000 0 connected\n150ef7fd331f57f3d11e8b2372ba991c41c850d7 10.8.198.152:9856@19856 slave a26317d89a7b09c0c9d77139cd8be94588c9b127 0 1599040213182 6 connected\n```\n\n（1）检查654槽是否有数据\n\n```shell\n#cluster getkeysinslot 槽道号 查找范围\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851> cluster getkeysinslot 654 2000\n1) \"\\xac\\xed\\x00\\x05t\\x00\\tkey_45618\"\n```\n\n（2）登录需要导入的节点9857，执行命令cluster setslot 槽道号 importing 源节点id，将8000节点上654槽道的状态变更为importing。\n\n```shell\n[root@Slave3 redis]# redis-cli -p 9857 -h 10.8.198.152\n10.8.198.152:9857> cluster setslot 654 importing 5015fbe7c523681a59e13f86f0ddc27b1ac542f8\nOK\n```\n\n（3）登录需要导出的节点9851，执行命令cluster setslot 槽道号 migrating 目标节点id，将9851节点上的654槽道的状态变更为migrating。\n\n```shell\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851> cluster setslot 654 migrating 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n```\n\n（4）**登录源节点9851**，将741槽道对应的数据（一个个的key-value），以及槽道保存key信息的map（{槽道号:[age,...]}），一并迁入到9857节点，使用如下命令完成。\n\n- host：目标Redis的IP地址\n- port：目标Redis的端口\n- key|\"\"：Redis 3.0.6 后如果需要迁移多个键，此处为空字符串\"\"\n- destination-db：目标Redis的数据库索引\n- timeout：迁移的超时时间（单位为毫秒）\n- copy：如果添加此选项后，迁移后不删除源键。\n- replace：如果添加此选项`migrate`不管目标Redis是否存在该键都会正常迁移进行数据覆盖\n- keys：如果要删除多个建，填写`keys key1 key2 key3`\n\n```shell\n10.8.198.152:9851> migrate 10.8.198.152 9857 \"\" 0 1000 keys \"\\xac\\xed\\x00\\x05t\\x00\\tkey_45618\"\nOK\n```\n\n（5）通知进行迁移的两个节点槽道迁移了，到了这一步这个和上面空槽道的迁移操作一样。\n\n```shell\n10.8.198.152:9851> cluster setslot 654 node 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n10.8.198.152:9857> cluster setslot 654 node 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n10.8.198.152:9857> cluster nodes\nbb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 10.8.198.152:9852@19852 master - 0 1599040905000 2 connected 5461-10922\n5bc658cd4d8cc35097e0a79e140069262161b827 10.8.198.152:9855@19855 slave bb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 0 1599040909085 2 connected\n1f797b67ba0ae4966610d8596431980f5cce4858 10.8.198.152:9854@19854 slave 5015fbe7c523681a59e13f86f0ddc27b1ac542f8 0 1599040906000 1 connected\na26317d89a7b09c0c9d77139cd8be94588c9b127 10.8.198.152:9853@19853 master - 0 1599040908083 3 connected 10923-16383\n5015fbe7c523681a59e13f86f0ddc27b1ac542f8 10.8.198.152:9851@19851 master - 0 1599040907082 1 connected 0-653 655-5460\n150ef7fd331f57f3d11e8b2372ba991c41c850d7 10.8.198.152:9856@19856 slave a26317d89a7b09c0c9d77139cd8be94588c9b127 0 1599040907000 3 connected\n0a286334e831f426de9e30c7990cffb40a1e4102 10.8.198.152:9857@19857 myself,master - 0 1599040907000 7 connected 654\n```\n\n<font color=red>这种方案其实是先保证了对应的槽上没有KEY了再进行迁移，如果有数据则需要通过migrate进行迁移。个人感觉太繁琐了。。。</font>\n\n### **为9857分配从节点9858**\n\n此时9857上已经分配了槽，但是还没有为他分配从节点。我们需要将9858配置成9857的从节点\n\n![](redis-cluster-build-2/6.png)\n\n方法如下:\n\n将9858也加入到集群中。\n\n```shell\nredis-cli --cluster add-node 10.8.198.152:9858 10.8.198.152:9851\n```\n\n登录9858客户端\n\n```shell\nredis-cli -p 9858 -h 10.8.198.152\n```\n\n指定9858为9857的从节点\n\n```shell\n10.8.198.152:9858> cluster replicate 9857的ID\n```\n\n至此，扩容完成。\n\n![](redis-cluster-build-2/7.png)\n\n## 小知识\n\n### 查看KEY在哪个槽上\n\n```shell\n10.8.198.152:9851> cluster keyslot keyname\n```","slug":"redis-cluster-build-2","published":1,"updated":"2021-04-08T00:47:06.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvk002oqwv2f6a705s4","content":"<h2 id=\"Redis5-0集群水平扩展\"><a href=\"#Redis5-0集群水平扩展\" class=\"headerlink\" title=\"Redis5.0集群水平扩展\"></a>Redis5.0集群水平扩展</h2><p>上节介绍了集群的搭建，这节开始详解水平扩展。假设现在由于资源使用情况，我们需要增加一组主从（9857、9858）加入到集群中。</p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/2.png\" alt></p>\n<a id=\"more\"></a>\n<p>当前Redis集群情况如下，</p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/1.png\" alt></p>\n<ul>\n<li>槽（0 - 5460）           主：10.8.198.152:9851 从：  10.8.198.152.9856</li>\n<li>槽（5461 - 10922）   主：10.8.198.152:9852 从：  10.8.198.152.9854</li>\n<li>槽（10923 - 16381） 主：10.8.198.152:9853 从：  10.8.198.152.9855</li>\n</ul>\n<h3 id=\"增加9857、9858实例\"><a href=\"#增加9857、9858实例\" class=\"headerlink\" title=\"增加9857、9858实例\"></a><strong>增加9857、9858实例</strong></h3><p>新增两个目录并修改其配置文件，如何修改参照上一篇文章。此时启动9857、9858后还没有加入到集群中。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[root@Slave3 redis]# mkdir 9857\n[root@Slave3 redis]# mkdir 9858\n[root@Slave3 redis]# cp /etc/redis/9851/redis.conf /etc/redis/9857/\n[root@Slave3 redis]# cp /etc/redis/9851/redis.conf /etc/redis/9858/\n##修改9857、9858配置文件，并启动\n[root@Slave3 redis]# redis-server /etc/redis/9857/redis.conf\n[root@Slave3 redis]# redis-server /etc/redis/9858/redis.conf</code></pre>\n<h3 id=\"配置9857为集群主节点\"><a href=\"#配置9857为集群主节点\" class=\"headerlink\" title=\"配置9857为集群主节点\"></a><strong>配置9857为集群主节点</strong></h3><pre class=\" language-shell\"><code class=\"language-shell\">redis-cli --cluster add-node 10.8.198.152:9857 10.8.198.152:9851</code></pre>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/3.png\" alt></p>\n<h3 id=\"为9857分配槽-空槽道迁移\"><a href=\"#为9857分配槽-空槽道迁移\" class=\"headerlink\" title=\"为9857分配槽(空槽道迁移)\"></a><strong>为9857分配槽(空槽道迁移)</strong></h3><h4 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a><strong>方案1</strong></h4><p>上面我们将9857加入到集群后还没分配槽，此时9857还没有作用。接下去需要为其分配槽。原来我们3个master已经将槽分配完了，此时加入一个新maser则需要将其中一台master的槽进行拆分。</p>\n<p><strong>重新分配集群上的槽给9857</strong></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">redis-cli --cluster reshard 10.8.198.152:9851</code></pre>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/4.png\" alt></p>\n<p>此时会询问<strong>分出多少槽出来？分给哪个节点？</strong> 我们按照提示输入。<br>接下去会询问我们分配槽的方式，有两种方式</p>\n<ul>\n<li>all，以将所有节点用作散列槽的源节点</li>\n<li>done，选择从哪个节点上拿出来节点</li>\n</ul>\n<p>all是随机的，比如说我们要分出1000个，则3个主节点分别拿出333个，333个，334个节点分别9857，这里我们选择done，从9857拿1000个给9857。</p>\n<h4 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a><strong>方案2</strong></h4><p><font color=\"red\">这种方案相对与上一种方案有缺陷，他只能迁移一个槽</font></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">redis-cli --cluster add-node 10.8.198.152:9857 10.8.198.152:9851</code></pre>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/3.png\" alt></p>\n<p>（1）先登录9851查看下要迁移的槽上有没有存了KEY，没有才能迁移</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#cluster getkeysinslot 槽道号 查找范围\n10.8.198.152:9851>cluster getkeysinslot 1000 2000\n(empty list or set)</code></pre>\n<p>（2）登录需要导入的节点9857，执行命令cluster setslot 槽道号 importing 源节点id，将9857节点上1000槽道的状态变更为importing</p>\n<pre><code>10.8.198.152:9857&gt;cluster setslot 1000 importing 419ff0823f0ff4cfb1ffc4c002665ad077911cc2</code></pre><p><img src=\"/2020/09/02/redis-cluster-build-2/8.png\" alt></p>\n<p>（3）登录需要导出的节点9851，执行命令cluster setslot 槽道号 migrating 目标节点id，将9851节点上的460槽道的状态变更为migrating。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">10.8.198.152:9851>cluster setslot 1000 migrating 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da</code></pre>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/9.png\" alt></p>\n<p>（4）通知进行迁移的两个节点槽道迁移了，使用命令<strong>cluster setslot 槽道号 node 迁入节点id</strong>，需要在两个节点上均进行操作。槽号1000就被迁移了。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\"># 迁出节点9851上执行命令，后面跟的id为迁入节点的id\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851> cluster setslot 1000 node 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\nOK\n#迁入节点9857上执行命令，后面跟的id为迁入节点的id\n[root@Slave3 redis]# redis-cli -p 9857 -h 10.8.198.152\n10.8.198.152:9857> cluster setslot 1000 node 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\nOK\n10.8.198.152:9857> cluster nodes\nf08cdba85763f71de3a1cbac8a45962594ab09aa 10.8.198.152:9852@19852 master - 0 1599038877000 2 connected 5461-10922\nb8cc9aeca57e1332b6f42b7e183cce686033c2d6 10.8.198.152:9854@19854 slave 419ff0823f0ff4cfb1ffc4c002665ad077911cc2 0 1599038878000 1 connected\n286fe16d33dbbafa9f13e9a11d4351c37e085155 10.8.198.152:9853@19853 master - 0 1599038879000 3 connected 10923-16383\naf6115f83a145c63a75916608084712f96d44c34 10.8.198.152:9855@19855 slave f08cdba85763f71de3a1cbac8a45962594ab09aa 0 1599038879489 2 connected\n5e2af503c816eeff7ed2cfb2249f0ceb1f5306da 10.8.198.152:9857@19857 myself,master - 0 1599038878000 7 connected 1000\n14901a2ff5242f302103bbca4bfa6e2dade0a95b 10.8.198.152:9856@19856 slave 286fe16d33dbbafa9f13e9a11d4351c37e085155 0 1599038880000 3 connected\n419ff0823f0ff4cfb1ffc4c002665ad077911cc2 10.8.198.152:9851@19851 master - 0 1599038880492 1 connected 0-999 1001-5460</code></pre>\n<h3 id=\"为9857分配槽-非空槽道迁移\"><a href=\"#为9857分配槽-非空槽道迁移\" class=\"headerlink\" title=\"为9857分配槽(非空槽道迁移)\"></a><strong>为9857分配槽(非空槽道迁移)</strong></h3><p><font color=\"red\">正常情况下，到这一步应该要将9851上的1000个槽分配给9857成功，但是由于我们9851上要转移的槽上有存了key了导致我们转移失败。</font></p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/5.png\" alt=\"当转移2号槽时失败\"></p>\n<h4 id=\"解决方案1\"><a href=\"#解决方案1\" class=\"headerlink\" title=\"解决方案1\"></a><strong>解决方案1</strong></h4><p>解决方法：</p>\n<ol>\n<li>删除节点9851上的所有key，可以使用flushdb</li>\n<li>执行 redis-cli --cluster fix 10.8.198.152:9851 修复节点</li>\n<li>重新从 redis-cli --cluster reshard 10.8.198.152.9851 命令重新分配槽</li>\n</ol>\n<h4 id=\"解决方案2\"><a href=\"#解决方案2\" class=\"headerlink\" title=\"解决方案2\"></a><strong>解决方案2</strong></h4><p>假设要迁移9851上的槽654到9857</p>\n<p>首先先保证9857加入到集群了</p>\n<pre class=\" language-shell\"><code class=\"language-shell\"> redis-cli --cluster add-node 10.8.198.152：9857 10.8.198.152：9851</code></pre>\n<p>当前cluster nodes信息</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">10.8.198.152:9851> cluster nodes\n5bc658cd4d8cc35097e0a79e140069262161b827 10.8.198.152:9855@19855 slave bb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 0 1599040212180 5 connected\na26317d89a7b09c0c9d77139cd8be94588c9b127 10.8.198.152:9853@19853 master - 0 1599040210000 3 connected 10923-16383\nbb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 10.8.198.152:9852@19852 master - 0 1599040210175 2 connected 5461-10922\n1f797b67ba0ae4966610d8596431980f5cce4858 10.8.198.152:9854@19854 slave 5015fbe7c523681a59e13f86f0ddc27b1ac542f8 0 1599040212000 4 connected\n5015fbe7c523681a59e13f86f0ddc27b1ac542f8 10.8.198.152:9851@19851 myself,master - 0 1599040211000 1 connected 0-5460\n0a286334e831f426de9e30c7990cffb40a1e4102 10.8.198.152:9857@19857 master - 0 1599040211000 0 connected\n150ef7fd331f57f3d11e8b2372ba991c41c850d7 10.8.198.152:9856@19856 slave a26317d89a7b09c0c9d77139cd8be94588c9b127 0 1599040213182 6 connected</code></pre>\n<p>（1）检查654槽是否有数据</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#cluster getkeysinslot 槽道号 查找范围\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851> cluster getkeysinslot 654 2000\n1) \"\\xac\\xed\\x00\\x05t\\x00\\tkey_45618\"</code></pre>\n<p>（2）登录需要导入的节点9857，执行命令cluster setslot 槽道号 importing 源节点id，将8000节点上654槽道的状态变更为importing。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[root@Slave3 redis]# redis-cli -p 9857 -h 10.8.198.152\n10.8.198.152:9857> cluster setslot 654 importing 5015fbe7c523681a59e13f86f0ddc27b1ac542f8\nOK</code></pre>\n<p>（3）登录需要导出的节点9851，执行命令cluster setslot 槽道号 migrating 目标节点id，将9851节点上的654槽道的状态变更为migrating。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851> cluster setslot 654 migrating 0a286334e831f426de9e30c7990cffb40a1e4102\nOK</code></pre>\n<p>（4）<strong>登录源节点9851</strong>，将741槽道对应的数据（一个个的key-value），以及槽道保存key信息的map（{槽道号:[age,…]}），一并迁入到9857节点，使用如下命令完成。</p>\n<ul>\n<li>host：目标Redis的IP地址</li>\n<li>port：目标Redis的端口</li>\n<li>key|””：Redis 3.0.6 后如果需要迁移多个键，此处为空字符串””</li>\n<li>destination-db：目标Redis的数据库索引</li>\n<li>timeout：迁移的超时时间（单位为毫秒）</li>\n<li>copy：如果添加此选项后，迁移后不删除源键。</li>\n<li>replace：如果添加此选项<code>migrate</code>不管目标Redis是否存在该键都会正常迁移进行数据覆盖</li>\n<li>keys：如果要删除多个建，填写<code>keys key1 key2 key3</code></li>\n</ul>\n<pre class=\" language-shell\"><code class=\"language-shell\">10.8.198.152:9851> migrate 10.8.198.152 9857 \"\" 0 1000 keys \"\\xac\\xed\\x00\\x05t\\x00\\tkey_45618\"\nOK</code></pre>\n<p>（5）通知进行迁移的两个节点槽道迁移了，到了这一步这个和上面空槽道的迁移操作一样。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">10.8.198.152:9851> cluster setslot 654 node 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n10.8.198.152:9857> cluster setslot 654 node 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n10.8.198.152:9857> cluster nodes\nbb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 10.8.198.152:9852@19852 master - 0 1599040905000 2 connected 5461-10922\n5bc658cd4d8cc35097e0a79e140069262161b827 10.8.198.152:9855@19855 slave bb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 0 1599040909085 2 connected\n1f797b67ba0ae4966610d8596431980f5cce4858 10.8.198.152:9854@19854 slave 5015fbe7c523681a59e13f86f0ddc27b1ac542f8 0 1599040906000 1 connected\na26317d89a7b09c0c9d77139cd8be94588c9b127 10.8.198.152:9853@19853 master - 0 1599040908083 3 connected 10923-16383\n5015fbe7c523681a59e13f86f0ddc27b1ac542f8 10.8.198.152:9851@19851 master - 0 1599040907082 1 connected 0-653 655-5460\n150ef7fd331f57f3d11e8b2372ba991c41c850d7 10.8.198.152:9856@19856 slave a26317d89a7b09c0c9d77139cd8be94588c9b127 0 1599040907000 3 connected\n0a286334e831f426de9e30c7990cffb40a1e4102 10.8.198.152:9857@19857 myself,master - 0 1599040907000 7 connected 654</code></pre>\n<p><font color=\"red\">这种方案其实是先保证了对应的槽上没有KEY了再进行迁移，如果有数据则需要通过migrate进行迁移。个人感觉太繁琐了。。。</font></p>\n<h3 id=\"为9857分配从节点9858\"><a href=\"#为9857分配从节点9858\" class=\"headerlink\" title=\"为9857分配从节点9858\"></a><strong>为9857分配从节点9858</strong></h3><p>此时9857上已经分配了槽，但是还没有为他分配从节点。我们需要将9858配置成9857的从节点</p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/6.png\" alt></p>\n<p>方法如下:</p>\n<p>将9858也加入到集群中。</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">redis-cli --cluster add-node 10.8.198.152:9858 10.8.198.152:9851</code></pre>\n<p>登录9858客户端</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">redis-cli -p 9858 -h 10.8.198.152</code></pre>\n<p>指定9858为9857的从节点</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">10.8.198.152:9858> cluster replicate 9857的ID</code></pre>\n<p>至此，扩容完成。</p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/7.png\" alt></p>\n<h2 id=\"小知识\"><a href=\"#小知识\" class=\"headerlink\" title=\"小知识\"></a>小知识</h2><h3 id=\"查看KEY在哪个槽上\"><a href=\"#查看KEY在哪个槽上\" class=\"headerlink\" title=\"查看KEY在哪个槽上\"></a>查看KEY在哪个槽上</h3><pre class=\" language-shell\"><code class=\"language-shell\">10.8.198.152:9851> cluster keyslot keyname</code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"Redis5-0集群水平扩展\"><a href=\"#Redis5-0集群水平扩展\" class=\"headerlink\" title=\"Redis5.0集群水平扩展\"></a>Redis5.0集群水平扩展</h2><p>上节介绍了集群的搭建，这节开始详解水平扩展。假设现在由于资源使用情况，我们需要增加一组主从（9857、9858）加入到集群中。</p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/2.png\" alt></p>","more":"<p>当前Redis集群情况如下，</p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/1.png\" alt></p>\n<ul>\n<li>槽（0 - 5460）           主：10.8.198.152:9851 从：  10.8.198.152.9856</li>\n<li>槽（5461 - 10922）   主：10.8.198.152:9852 从：  10.8.198.152.9854</li>\n<li>槽（10923 - 16381） 主：10.8.198.152:9853 从：  10.8.198.152.9855</li>\n</ul>\n<h3 id=\"增加9857、9858实例\"><a href=\"#增加9857、9858实例\" class=\"headerlink\" title=\"增加9857、9858实例\"></a><strong>增加9857、9858实例</strong></h3><p>新增两个目录并修改其配置文件，如何修改参照上一篇文章。此时启动9857、9858后还没有加入到集群中。</p>\n<pre><code class=\"shell\">[root@Slave3 redis]# mkdir 9857\n[root@Slave3 redis]# mkdir 9858\n[root@Slave3 redis]# cp /etc/redis/9851/redis.conf /etc/redis/9857/\n[root@Slave3 redis]# cp /etc/redis/9851/redis.conf /etc/redis/9858/\n##修改9857、9858配置文件，并启动\n[root@Slave3 redis]# redis-server /etc/redis/9857/redis.conf\n[root@Slave3 redis]# redis-server /etc/redis/9858/redis.conf</code></pre>\n<h3 id=\"配置9857为集群主节点\"><a href=\"#配置9857为集群主节点\" class=\"headerlink\" title=\"配置9857为集群主节点\"></a><strong>配置9857为集群主节点</strong></h3><pre><code class=\"shell\">redis-cli --cluster add-node 10.8.198.152:9857 10.8.198.152:9851</code></pre>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/3.png\" alt></p>\n<h3 id=\"为9857分配槽-空槽道迁移\"><a href=\"#为9857分配槽-空槽道迁移\" class=\"headerlink\" title=\"为9857分配槽(空槽道迁移)\"></a><strong>为9857分配槽(空槽道迁移)</strong></h3><h4 id=\"方案1\"><a href=\"#方案1\" class=\"headerlink\" title=\"方案1\"></a><strong>方案1</strong></h4><p>上面我们将9857加入到集群后还没分配槽，此时9857还没有作用。接下去需要为其分配槽。原来我们3个master已经将槽分配完了，此时加入一个新maser则需要将其中一台master的槽进行拆分。</p>\n<p><strong>重新分配集群上的槽给9857</strong></p>\n<pre><code class=\"shell\">redis-cli --cluster reshard 10.8.198.152:9851</code></pre>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/4.png\" alt></p>\n<p>此时会询问<strong>分出多少槽出来？分给哪个节点？</strong> 我们按照提示输入。<br>接下去会询问我们分配槽的方式，有两种方式</p>\n<ul>\n<li>all，以将所有节点用作散列槽的源节点</li>\n<li>done，选择从哪个节点上拿出来节点</li>\n</ul>\n<p>all是随机的，比如说我们要分出1000个，则3个主节点分别拿出333个，333个，334个节点分别9857，这里我们选择done，从9857拿1000个给9857。</p>\n<h4 id=\"方案2\"><a href=\"#方案2\" class=\"headerlink\" title=\"方案2\"></a><strong>方案2</strong></h4><p><font color=\"red\">这种方案相对与上一种方案有缺陷，他只能迁移一个槽</font></p>\n<pre><code class=\"shell\">redis-cli --cluster add-node 10.8.198.152:9857 10.8.198.152:9851</code></pre>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/3.png\" alt></p>\n<p>（1）先登录9851查看下要迁移的槽上有没有存了KEY，没有才能迁移</p>\n<pre><code class=\"shell\">#cluster getkeysinslot 槽道号 查找范围\n10.8.198.152:9851&gt;cluster getkeysinslot 1000 2000\n(empty list or set)</code></pre>\n<p>（2）登录需要导入的节点9857，执行命令cluster setslot 槽道号 importing 源节点id，将9857节点上1000槽道的状态变更为importing</p>\n<pre><code>10.8.198.152:9857&gt;cluster setslot 1000 importing 419ff0823f0ff4cfb1ffc4c002665ad077911cc2</code></pre><p><img src=\"/2020/09/02/redis-cluster-build-2/8.png\" alt></p>\n<p>（3）登录需要导出的节点9851，执行命令cluster setslot 槽道号 migrating 目标节点id，将9851节点上的460槽道的状态变更为migrating。</p>\n<pre><code class=\"shell\">10.8.198.152:9851&gt;cluster setslot 1000 migrating 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da</code></pre>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/9.png\" alt></p>\n<p>（4）通知进行迁移的两个节点槽道迁移了，使用命令<strong>cluster setslot 槽道号 node 迁入节点id</strong>，需要在两个节点上均进行操作。槽号1000就被迁移了。</p>\n<pre><code class=\"shell\"># 迁出节点9851上执行命令，后面跟的id为迁入节点的id\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851&gt; cluster setslot 1000 node 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\nOK\n#迁入节点9857上执行命令，后面跟的id为迁入节点的id\n[root@Slave3 redis]# redis-cli -p 9857 -h 10.8.198.152\n10.8.198.152:9857&gt; cluster setslot 1000 node 5e2af503c816eeff7ed2cfb2249f0ceb1f5306da\nOK\n10.8.198.152:9857&gt; cluster nodes\nf08cdba85763f71de3a1cbac8a45962594ab09aa 10.8.198.152:9852@19852 master - 0 1599038877000 2 connected 5461-10922\nb8cc9aeca57e1332b6f42b7e183cce686033c2d6 10.8.198.152:9854@19854 slave 419ff0823f0ff4cfb1ffc4c002665ad077911cc2 0 1599038878000 1 connected\n286fe16d33dbbafa9f13e9a11d4351c37e085155 10.8.198.152:9853@19853 master - 0 1599038879000 3 connected 10923-16383\naf6115f83a145c63a75916608084712f96d44c34 10.8.198.152:9855@19855 slave f08cdba85763f71de3a1cbac8a45962594ab09aa 0 1599038879489 2 connected\n5e2af503c816eeff7ed2cfb2249f0ceb1f5306da 10.8.198.152:9857@19857 myself,master - 0 1599038878000 7 connected 1000\n14901a2ff5242f302103bbca4bfa6e2dade0a95b 10.8.198.152:9856@19856 slave 286fe16d33dbbafa9f13e9a11d4351c37e085155 0 1599038880000 3 connected\n419ff0823f0ff4cfb1ffc4c002665ad077911cc2 10.8.198.152:9851@19851 master - 0 1599038880492 1 connected 0-999 1001-5460</code></pre>\n<h3 id=\"为9857分配槽-非空槽道迁移\"><a href=\"#为9857分配槽-非空槽道迁移\" class=\"headerlink\" title=\"为9857分配槽(非空槽道迁移)\"></a><strong>为9857分配槽(非空槽道迁移)</strong></h3><p><font color=\"red\">正常情况下，到这一步应该要将9851上的1000个槽分配给9857成功，但是由于我们9851上要转移的槽上有存了key了导致我们转移失败。</font></p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/5.png\" alt=\"当转移2号槽时失败\"></p>\n<h4 id=\"解决方案1\"><a href=\"#解决方案1\" class=\"headerlink\" title=\"解决方案1\"></a><strong>解决方案1</strong></h4><p>解决方法：</p>\n<ol>\n<li>删除节点9851上的所有key，可以使用flushdb</li>\n<li>执行 redis-cli --cluster fix 10.8.198.152:9851 修复节点</li>\n<li>重新从 redis-cli --cluster reshard 10.8.198.152.9851 命令重新分配槽</li>\n</ol>\n<h4 id=\"解决方案2\"><a href=\"#解决方案2\" class=\"headerlink\" title=\"解决方案2\"></a><strong>解决方案2</strong></h4><p>假设要迁移9851上的槽654到9857</p>\n<p>首先先保证9857加入到集群了</p>\n<pre><code class=\"shell\"> redis-cli --cluster add-node 10.8.198.152：9857 10.8.198.152：9851</code></pre>\n<p>当前cluster nodes信息</p>\n<pre><code class=\"shell\">10.8.198.152:9851&gt; cluster nodes\n5bc658cd4d8cc35097e0a79e140069262161b827 10.8.198.152:9855@19855 slave bb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 0 1599040212180 5 connected\na26317d89a7b09c0c9d77139cd8be94588c9b127 10.8.198.152:9853@19853 master - 0 1599040210000 3 connected 10923-16383\nbb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 10.8.198.152:9852@19852 master - 0 1599040210175 2 connected 5461-10922\n1f797b67ba0ae4966610d8596431980f5cce4858 10.8.198.152:9854@19854 slave 5015fbe7c523681a59e13f86f0ddc27b1ac542f8 0 1599040212000 4 connected\n5015fbe7c523681a59e13f86f0ddc27b1ac542f8 10.8.198.152:9851@19851 myself,master - 0 1599040211000 1 connected 0-5460\n0a286334e831f426de9e30c7990cffb40a1e4102 10.8.198.152:9857@19857 master - 0 1599040211000 0 connected\n150ef7fd331f57f3d11e8b2372ba991c41c850d7 10.8.198.152:9856@19856 slave a26317d89a7b09c0c9d77139cd8be94588c9b127 0 1599040213182 6 connected</code></pre>\n<p>（1）检查654槽是否有数据</p>\n<pre><code class=\"shell\">#cluster getkeysinslot 槽道号 查找范围\n[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851&gt; cluster getkeysinslot 654 2000\n1) &quot;\\xac\\xed\\x00\\x05t\\x00\\tkey_45618&quot;</code></pre>\n<p>（2）登录需要导入的节点9857，执行命令cluster setslot 槽道号 importing 源节点id，将8000节点上654槽道的状态变更为importing。</p>\n<pre><code class=\"shell\">[root@Slave3 redis]# redis-cli -p 9857 -h 10.8.198.152\n10.8.198.152:9857&gt; cluster setslot 654 importing 5015fbe7c523681a59e13f86f0ddc27b1ac542f8\nOK</code></pre>\n<p>（3）登录需要导出的节点9851，执行命令cluster setslot 槽道号 migrating 目标节点id，将9851节点上的654槽道的状态变更为migrating。</p>\n<pre><code class=\"shell\">[root@Slave3 redis]# redis-cli -p 9851 -h 10.8.198.152\n10.8.198.152:9851&gt; cluster setslot 654 migrating 0a286334e831f426de9e30c7990cffb40a1e4102\nOK</code></pre>\n<p>（4）<strong>登录源节点9851</strong>，将741槽道对应的数据（一个个的key-value），以及槽道保存key信息的map（{槽道号:[age,…]}），一并迁入到9857节点，使用如下命令完成。</p>\n<ul>\n<li>host：目标Redis的IP地址</li>\n<li>port：目标Redis的端口</li>\n<li>key|””：Redis 3.0.6 后如果需要迁移多个键，此处为空字符串””</li>\n<li>destination-db：目标Redis的数据库索引</li>\n<li>timeout：迁移的超时时间（单位为毫秒）</li>\n<li>copy：如果添加此选项后，迁移后不删除源键。</li>\n<li>replace：如果添加此选项<code>migrate</code>不管目标Redis是否存在该键都会正常迁移进行数据覆盖</li>\n<li>keys：如果要删除多个建，填写<code>keys key1 key2 key3</code></li>\n</ul>\n<pre><code class=\"shell\">10.8.198.152:9851&gt; migrate 10.8.198.152 9857 &quot;&quot; 0 1000 keys &quot;\\xac\\xed\\x00\\x05t\\x00\\tkey_45618&quot;\nOK</code></pre>\n<p>（5）通知进行迁移的两个节点槽道迁移了，到了这一步这个和上面空槽道的迁移操作一样。</p>\n<pre><code class=\"shell\">10.8.198.152:9851&gt; cluster setslot 654 node 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n10.8.198.152:9857&gt; cluster setslot 654 node 0a286334e831f426de9e30c7990cffb40a1e4102\nOK\n10.8.198.152:9857&gt; cluster nodes\nbb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 10.8.198.152:9852@19852 master - 0 1599040905000 2 connected 5461-10922\n5bc658cd4d8cc35097e0a79e140069262161b827 10.8.198.152:9855@19855 slave bb3900b30983e0b41ed48ffe4be0e2d52b4d89b4 0 1599040909085 2 connected\n1f797b67ba0ae4966610d8596431980f5cce4858 10.8.198.152:9854@19854 slave 5015fbe7c523681a59e13f86f0ddc27b1ac542f8 0 1599040906000 1 connected\na26317d89a7b09c0c9d77139cd8be94588c9b127 10.8.198.152:9853@19853 master - 0 1599040908083 3 connected 10923-16383\n5015fbe7c523681a59e13f86f0ddc27b1ac542f8 10.8.198.152:9851@19851 master - 0 1599040907082 1 connected 0-653 655-5460\n150ef7fd331f57f3d11e8b2372ba991c41c850d7 10.8.198.152:9856@19856 slave a26317d89a7b09c0c9d77139cd8be94588c9b127 0 1599040907000 3 connected\n0a286334e831f426de9e30c7990cffb40a1e4102 10.8.198.152:9857@19857 myself,master - 0 1599040907000 7 connected 654</code></pre>\n<p><font color=\"red\">这种方案其实是先保证了对应的槽上没有KEY了再进行迁移，如果有数据则需要通过migrate进行迁移。个人感觉太繁琐了。。。</font></p>\n<h3 id=\"为9857分配从节点9858\"><a href=\"#为9857分配从节点9858\" class=\"headerlink\" title=\"为9857分配从节点9858\"></a><strong>为9857分配从节点9858</strong></h3><p>此时9857上已经分配了槽，但是还没有为他分配从节点。我们需要将9858配置成9857的从节点</p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/6.png\" alt></p>\n<p>方法如下:</p>\n<p>将9858也加入到集群中。</p>\n<pre><code class=\"shell\">redis-cli --cluster add-node 10.8.198.152:9858 10.8.198.152:9851</code></pre>\n<p>登录9858客户端</p>\n<pre><code class=\"shell\">redis-cli -p 9858 -h 10.8.198.152</code></pre>\n<p>指定9858为9857的从节点</p>\n<pre><code class=\"shell\">10.8.198.152:9858&gt; cluster replicate 9857的ID</code></pre>\n<p>至此，扩容完成。</p>\n<p><img src=\"/2020/09/02/redis-cluster-build-2/7.png\" alt></p>\n<h2 id=\"小知识\"><a href=\"#小知识\" class=\"headerlink\" title=\"小知识\"></a>小知识</h2><h3 id=\"查看KEY在哪个槽上\"><a href=\"#查看KEY在哪个槽上\" class=\"headerlink\" title=\"查看KEY在哪个槽上\"></a>查看KEY在哪个槽上</h3><pre><code class=\"shell\">10.8.198.152:9851&gt; cluster keyslot keyname</code></pre>"},{"title":"Redis常用数据结构命令","description":"主要用来记录Redis常用命令的记录，方便查询","date":"2019-10-03T00:32:58.000Z","_content":"\n### key常用操作\n\n```properties\n# 查询指定key是否存在\n$ localhost:6379> EXISTS hash1\n(integer) 1\n$ localhost:6379> EXISTS jjj\n(integer) 0\n\n# 删除指定key\n$ localhost:6379> DEL hash1\n(integer) 1\n$ localhost:6379> EXISTS hash1\n(integer) 0\n\n# 对指定key设置过期时间\n$ localhost:6379> set t1 value ex 5\nOK\n\n# 查询指定key的过期时间\n$ localhost:6379> TTL t1\n(integer) 7\n\n# 查询指定key的类型\n$ localhost:6379> type t1\nstring\n```\n<!--more-->\n### kv结构\n\n```properties\n# 设置key 对应的value\n$ localhost:6379> set key1 value1\nOK\n\n# 获取key对应的value\n$ localhost:6379> get key1\n\"value1\"\n\n# Redis Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。\n$ localhost:6379> SETEX mykey 60 redis\nOK\n\n# 命令在指定的 key 不存在时，为 key 设置指定的值。\n$ localhost:6379> setnx key3 vlaue3\nOK\n$ localhost:6379> setnx key3 value3\n(nil)\n```\n\n### list结构\n\n```properties\n# 从左侧插入元素\n$ localhost:6379> LPUSH list1 1\n(integer) 1\n\n# 从右侧插入元素\n$ localhost:6379> RPUSH list1 2\n(integer) 2\n\n# 查看集合内的元素，-1 表示查看所有元素\n$ localhost:6379> LRANGE list1 0 -1\n1) \"1\"\n2) \"2\"\n\n# 查看list的元素个数\n$ localhost:6379> LLEN list1\n(integer) 2\n\n# 根据索引查询对应的元素，如果指定的索引不存在，则返回'nil'\n$ localhost:6379> LINDEX list1 0\n\"2\"\n\n# 从列表左侧移除一个元素\n$ 127.0.0.1:6379> LPOP list1\n\"5\"\n\n# 从列表右侧移除一个元素\n$ 127.0.0.1:6379> RPOP list1\n\"1\"\n\n# 从列表右侧移除一个元素添加到左侧\n$ localhost:6379> LRANGE list1 0 -1\n1) \"three\"\n2) \"two\"\n3) \"one\"\n$ localhost:6379> RPOPLPUSH list1 list2\n\"one\"\n$ localhost:6379> LRANGE list2 0 -1\n1) \"one\"\n```\n\n### set结构\n\n```properties\n# 向set中添加一个元素\n$ localhost:6379> SADD set1 'one' 'two' 'three'\n(integer) 3\n\n# 获取set集合中的元素\n$ localhost:6379> SMEMBERS set1\n1) \"one\"\n2) \"three\"\n3) \"two\n\n# 从set集合中移除一个或多个元素\n$ localhost:6379> SREM set1 'one'\n(integer) 1\n\n# 从set集合中移除一个或多个元素并返回被删除元素\n$ localhost:6379> SPOP set1 1\n1) \"three\"\n\n# 获取当前set集合元素个数\n$ localhost:6379> SCARD set1\n(integer) 3\n\n# 从set集合随机获取元素但不删除\n$ localhost:6379> SRANDMEMBER set1 1\n1) \"one\"\n$ localhost:6379> SMEMBERS set1\n1) \"three\"\n2) \"two\"\n3) \"one\"\n\n# 判断set集合中是否存在指定元素，如果存在则返回1，不存在返回0\n$ localhost:6379> SISMEMBER set1 'one'\n(integer) 1\n$ localhost:6379> SISMEMBER set1 '4'\n(integer) 0\n```\n\n### sorted set  结构\n\n```properties\n# 向有序集合中添加元素\n$ localhost:6379> ZADD zset1 1 'one'\n(integer) 1\n\n# 获取有序集合中指定分数范围的元素\n$ localhost:6379> ZRANGE zset1 0 -1\n1) \"one\"\n2) \"two\"\n3) \"three\"\n\n# 删除有序集合中的元素\n$ localhost:6379> ZREM zset1 'one'\n(integer) 1\n\n# 获取有序集合元素个数\n$ localhost:6379> ZCARD zset1\n(integer) 2\n\n# 为有序集合中指定成员增加指定个数\n$ localhost:6379> ZINCRBY zset1 2 \"one\"\n\"4\"\n$ localhost:6379> ZRANGE zset1 0 -1 WITHSCORES\n1) \"two\"\n2) \"2\"\n3) \"three\"\n4) \"3\"\n5) \"one\"\n6) \"4\"\n\n# 获取有序集合指定分数范围内的元素数量\n$ localhost:6379> ZCOUNT zset1 0 2\n(integer) 1\n\n# 获取元素在有序集合中的排名，分数越大，排名值越大\n$ localhost:6379> ZRANK zset1 'one'\n(integer) 2\n\n# 获取元素在有序集合中的排名。分数越大，排名值越小\n$ localhost:6379> ZREVRANK zset1 'one'\n(integer) 0\n\n# 获取指定元素的分值\n$ localhost:6379> ZSCORE zset1 'one'\n\"4\"\n```\n\n### hash结构\n\n```properties\n# 向hash集合中添加一个元素\n$ localhost:6379> HSET hash1 field1 1\n(integer) 1\n\n# 向hash集合中添加多个元素\n$ localhost:6379> HMSET hash1 field2 2 field3 3\nOK\n\n# 获取指定field对应的value\n$ localhost:6379> HGET hash1 field1\n\"1\"\n\n# 批量获取指定field下的value\n$ localhost:6379> HMGET hash1 field1 field2 field3\n1) \"1\"\n2) \"2\"\n3) \"3\"\n\n# 获取hash结合里面所有元素\n$ localhost:6379> HGETALL hash1\n1) \"filed1\"\n2) \"1\"\n3) \"filed2\"\n4) \"2\"\n5) \"filed3\"\n6) \"3\"\n7) \"field3\"\n8) \"3\"\n\n# 判断指定filed是否在Hash结构中存在\n$ localhost:6379> HEXISTS hash1 field1\n(integer) 1\n$ localhost:6379> HEXISTS hash1 field5\n(integer) 0\n\n# 从hash结构中删除一个或多个field\n$ localhost:6379> HDEL hash1 field1 field2\n(integer) 2\n\n# 对hash集合中指定field的value增加值\n$ localhost:6379> HINCRBY hash1 field1 2\n(integer) 3\n$ localhost:6379> HGET hash1 field1\n\"3\"\n\n# 获取hash结构中所有的key\n$ localhost:6379> HKEYS hash1\n1) \"filed1\"\n2) \"filed2\"\n3) \"filed3\"\n4) \"field3\"\n5) \"field1\"\n\n$ 获取hash集合中所有的value\n$ localhost:6379> HVALS hash1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n4) \"3\"\n5) \"3\"\n\n# 获取hash集合中的元素个数\n$ localhost:6379> HLEN hash1\n(integer) 5\n```\n\n### 总结\n\n具体命令地址 : http://redis.cn/commands.html","source":"_posts/redis-commons.md","raw":"---\ntitle: Redis常用数据结构命令\ntags:\n  - redis\ncategories: redis\ndescription : 主要用来记录Redis常用命令的记录，方便查询\ndate: 2019-10-03 08:32:58\n---\n\n### key常用操作\n\n```properties\n# 查询指定key是否存在\n$ localhost:6379> EXISTS hash1\n(integer) 1\n$ localhost:6379> EXISTS jjj\n(integer) 0\n\n# 删除指定key\n$ localhost:6379> DEL hash1\n(integer) 1\n$ localhost:6379> EXISTS hash1\n(integer) 0\n\n# 对指定key设置过期时间\n$ localhost:6379> set t1 value ex 5\nOK\n\n# 查询指定key的过期时间\n$ localhost:6379> TTL t1\n(integer) 7\n\n# 查询指定key的类型\n$ localhost:6379> type t1\nstring\n```\n<!--more-->\n### kv结构\n\n```properties\n# 设置key 对应的value\n$ localhost:6379> set key1 value1\nOK\n\n# 获取key对应的value\n$ localhost:6379> get key1\n\"value1\"\n\n# Redis Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。\n$ localhost:6379> SETEX mykey 60 redis\nOK\n\n# 命令在指定的 key 不存在时，为 key 设置指定的值。\n$ localhost:6379> setnx key3 vlaue3\nOK\n$ localhost:6379> setnx key3 value3\n(nil)\n```\n\n### list结构\n\n```properties\n# 从左侧插入元素\n$ localhost:6379> LPUSH list1 1\n(integer) 1\n\n# 从右侧插入元素\n$ localhost:6379> RPUSH list1 2\n(integer) 2\n\n# 查看集合内的元素，-1 表示查看所有元素\n$ localhost:6379> LRANGE list1 0 -1\n1) \"1\"\n2) \"2\"\n\n# 查看list的元素个数\n$ localhost:6379> LLEN list1\n(integer) 2\n\n# 根据索引查询对应的元素，如果指定的索引不存在，则返回'nil'\n$ localhost:6379> LINDEX list1 0\n\"2\"\n\n# 从列表左侧移除一个元素\n$ 127.0.0.1:6379> LPOP list1\n\"5\"\n\n# 从列表右侧移除一个元素\n$ 127.0.0.1:6379> RPOP list1\n\"1\"\n\n# 从列表右侧移除一个元素添加到左侧\n$ localhost:6379> LRANGE list1 0 -1\n1) \"three\"\n2) \"two\"\n3) \"one\"\n$ localhost:6379> RPOPLPUSH list1 list2\n\"one\"\n$ localhost:6379> LRANGE list2 0 -1\n1) \"one\"\n```\n\n### set结构\n\n```properties\n# 向set中添加一个元素\n$ localhost:6379> SADD set1 'one' 'two' 'three'\n(integer) 3\n\n# 获取set集合中的元素\n$ localhost:6379> SMEMBERS set1\n1) \"one\"\n2) \"three\"\n3) \"two\n\n# 从set集合中移除一个或多个元素\n$ localhost:6379> SREM set1 'one'\n(integer) 1\n\n# 从set集合中移除一个或多个元素并返回被删除元素\n$ localhost:6379> SPOP set1 1\n1) \"three\"\n\n# 获取当前set集合元素个数\n$ localhost:6379> SCARD set1\n(integer) 3\n\n# 从set集合随机获取元素但不删除\n$ localhost:6379> SRANDMEMBER set1 1\n1) \"one\"\n$ localhost:6379> SMEMBERS set1\n1) \"three\"\n2) \"two\"\n3) \"one\"\n\n# 判断set集合中是否存在指定元素，如果存在则返回1，不存在返回0\n$ localhost:6379> SISMEMBER set1 'one'\n(integer) 1\n$ localhost:6379> SISMEMBER set1 '4'\n(integer) 0\n```\n\n### sorted set  结构\n\n```properties\n# 向有序集合中添加元素\n$ localhost:6379> ZADD zset1 1 'one'\n(integer) 1\n\n# 获取有序集合中指定分数范围的元素\n$ localhost:6379> ZRANGE zset1 0 -1\n1) \"one\"\n2) \"two\"\n3) \"three\"\n\n# 删除有序集合中的元素\n$ localhost:6379> ZREM zset1 'one'\n(integer) 1\n\n# 获取有序集合元素个数\n$ localhost:6379> ZCARD zset1\n(integer) 2\n\n# 为有序集合中指定成员增加指定个数\n$ localhost:6379> ZINCRBY zset1 2 \"one\"\n\"4\"\n$ localhost:6379> ZRANGE zset1 0 -1 WITHSCORES\n1) \"two\"\n2) \"2\"\n3) \"three\"\n4) \"3\"\n5) \"one\"\n6) \"4\"\n\n# 获取有序集合指定分数范围内的元素数量\n$ localhost:6379> ZCOUNT zset1 0 2\n(integer) 1\n\n# 获取元素在有序集合中的排名，分数越大，排名值越大\n$ localhost:6379> ZRANK zset1 'one'\n(integer) 2\n\n# 获取元素在有序集合中的排名。分数越大，排名值越小\n$ localhost:6379> ZREVRANK zset1 'one'\n(integer) 0\n\n# 获取指定元素的分值\n$ localhost:6379> ZSCORE zset1 'one'\n\"4\"\n```\n\n### hash结构\n\n```properties\n# 向hash集合中添加一个元素\n$ localhost:6379> HSET hash1 field1 1\n(integer) 1\n\n# 向hash集合中添加多个元素\n$ localhost:6379> HMSET hash1 field2 2 field3 3\nOK\n\n# 获取指定field对应的value\n$ localhost:6379> HGET hash1 field1\n\"1\"\n\n# 批量获取指定field下的value\n$ localhost:6379> HMGET hash1 field1 field2 field3\n1) \"1\"\n2) \"2\"\n3) \"3\"\n\n# 获取hash结合里面所有元素\n$ localhost:6379> HGETALL hash1\n1) \"filed1\"\n2) \"1\"\n3) \"filed2\"\n4) \"2\"\n5) \"filed3\"\n6) \"3\"\n7) \"field3\"\n8) \"3\"\n\n# 判断指定filed是否在Hash结构中存在\n$ localhost:6379> HEXISTS hash1 field1\n(integer) 1\n$ localhost:6379> HEXISTS hash1 field5\n(integer) 0\n\n# 从hash结构中删除一个或多个field\n$ localhost:6379> HDEL hash1 field1 field2\n(integer) 2\n\n# 对hash集合中指定field的value增加值\n$ localhost:6379> HINCRBY hash1 field1 2\n(integer) 3\n$ localhost:6379> HGET hash1 field1\n\"3\"\n\n# 获取hash结构中所有的key\n$ localhost:6379> HKEYS hash1\n1) \"filed1\"\n2) \"filed2\"\n3) \"filed3\"\n4) \"field3\"\n5) \"field1\"\n\n$ 获取hash集合中所有的value\n$ localhost:6379> HVALS hash1\n1) \"1\"\n2) \"2\"\n3) \"3\"\n4) \"3\"\n5) \"3\"\n\n# 获取hash集合中的元素个数\n$ localhost:6379> HLEN hash1\n(integer) 5\n```\n\n### 总结\n\n具体命令地址 : http://redis.cn/commands.html","slug":"redis-commons","published":1,"updated":"2021-04-08T00:47:06.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvl002sqwv2gc3fal4k","content":"<h3 id=\"key常用操作\"><a href=\"#key常用操作\" class=\"headerlink\" title=\"key常用操作\"></a>key常用操作</h3><pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\"># 查询指定key是否存在</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> EXISTS hash1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> EXISTS jjj</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">0</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 删除指定key</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> DEL hash1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> EXISTS hash1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">0</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 对指定key设置过期时间</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> set t1 value ex 5</span>\nOK\n\n<span class=\"token comment\" spellcheck=\"true\"># 查询指定key的过期时间</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> TTL t1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">7</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 查询指定key的类型</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> type t1</span>\nstring</code></pre>\n<a id=\"more\"></a>\n<h3 id=\"kv结构\"><a href=\"#kv结构\" class=\"headerlink\" title=\"kv结构\"></a>kv结构</h3><pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\"># 设置key 对应的value</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> set key1 value1</span>\nOK\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取key对应的value</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> get key1</span>\n\"value1\"\n\n<span class=\"token comment\" spellcheck=\"true\"># Redis Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SETEX mykey 60 redis</span>\nOK\n\n<span class=\"token comment\" spellcheck=\"true\"># 命令在指定的 key 不存在时，为 key 设置指定的值。</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> setnx key3 vlaue3</span>\nOK\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> setnx key3 value3</span>\n(nil)</code></pre>\n<h3 id=\"list结构\"><a href=\"#list结构\" class=\"headerlink\" title=\"list结构\"></a>list结构</h3><pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\"># 从左侧插入元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> LPUSH list1 1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 从右侧插入元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> RPUSH list1 2</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">2</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 查看集合内的元素，-1 表示查看所有元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> LRANGE list1 0 -1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"1\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"2\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 查看list的元素个数</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> LLEN list1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">2</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 根据索引查询对应的元素，如果指定的索引不存在，则返回'nil'</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> LINDEX list1 0</span>\n\"2\"\n\n<span class=\"token comment\" spellcheck=\"true\"># 从列表左侧移除一个元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">127.0.0.1:6379> LPOP list1</span>\n\"5\"\n\n<span class=\"token comment\" spellcheck=\"true\"># 从列表右侧移除一个元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">127.0.0.1:6379> RPOP list1</span>\n\"1\"\n\n<span class=\"token comment\" spellcheck=\"true\"># 从列表右侧移除一个元素添加到左侧</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> LRANGE list1 0 -1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"three\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"two\"</span>\n<span class=\"token attr-name\">3)</span> <span class=\"token attr-value\">\"one\"</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> RPOPLPUSH list1 list2</span>\n\"one\"\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> LRANGE list2 0 -1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"one\"</span></code></pre>\n<h3 id=\"set结构\"><a href=\"#set结构\" class=\"headerlink\" title=\"set结构\"></a>set结构</h3><pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\"># 向set中添加一个元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SADD set1 'one' 'two' 'three'</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">3</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取set集合中的元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SMEMBERS set1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"one\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"three\"</span>\n<span class=\"token attr-name\">3)</span> <span class=\"token attr-value\">\"two</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 从set集合中移除一个或多个元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SREM set1 'one'</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 从set集合中移除一个或多个元素并返回被删除元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SPOP set1 1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"three\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取当前set集合元素个数</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SCARD set1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">3</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 从set集合随机获取元素但不删除</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SRANDMEMBER set1 1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"one\"</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SMEMBERS set1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"three\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"two\"</span>\n<span class=\"token attr-name\">3)</span> <span class=\"token attr-value\">\"one\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 判断set集合中是否存在指定元素，如果存在则返回1，不存在返回0</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SISMEMBER set1 'one'</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> SISMEMBER set1 '4'</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">0</span></code></pre>\n<h3 id=\"sorted-set-结构\"><a href=\"#sorted-set-结构\" class=\"headerlink\" title=\"sorted set  结构\"></a>sorted set  结构</h3><pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\"># 向有序集合中添加元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZADD zset1 1 'one'</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取有序集合中指定分数范围的元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZRANGE zset1 0 -1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"one\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"two\"</span>\n<span class=\"token attr-name\">3)</span> <span class=\"token attr-value\">\"three\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 删除有序集合中的元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZREM zset1 'one'</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取有序集合元素个数</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZCARD zset1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">2</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 为有序集合中指定成员增加指定个数</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZINCRBY zset1 2 \"one\"</span>\n\"4\"\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZRANGE zset1 0 -1 WITHSCORES</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"two\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"2\"</span>\n<span class=\"token attr-name\">3)</span> <span class=\"token attr-value\">\"three\"</span>\n<span class=\"token attr-name\">4)</span> <span class=\"token attr-value\">\"3\"</span>\n<span class=\"token attr-name\">5)</span> <span class=\"token attr-value\">\"one\"</span>\n<span class=\"token attr-name\">6)</span> <span class=\"token attr-value\">\"4\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取有序集合指定分数范围内的元素数量</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZCOUNT zset1 0 2</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取元素在有序集合中的排名，分数越大，排名值越大</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZRANK zset1 'one'</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">2</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取元素在有序集合中的排名。分数越大，排名值越小</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZREVRANK zset1 'one'</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">0</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取指定元素的分值</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> ZSCORE zset1 'one'</span>\n\"4\"</code></pre>\n<h3 id=\"hash结构\"><a href=\"#hash结构\" class=\"headerlink\" title=\"hash结构\"></a>hash结构</h3><pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\"># 向hash集合中添加一个元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HSET hash1 field1 1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 向hash集合中添加多个元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HMSET hash1 field2 2 field3 3</span>\nOK\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取指定field对应的value</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HGET hash1 field1</span>\n\"1\"\n\n<span class=\"token comment\" spellcheck=\"true\"># 批量获取指定field下的value</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HMGET hash1 field1 field2 field3</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"1\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"2\"</span>\n<span class=\"token attr-name\">3)</span> <span class=\"token attr-value\">\"3\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取hash结合里面所有元素</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HGETALL hash1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"filed1\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"1\"</span>\n<span class=\"token attr-name\">3)</span> <span class=\"token attr-value\">\"filed2\"</span>\n<span class=\"token attr-name\">4)</span> <span class=\"token attr-value\">\"2\"</span>\n<span class=\"token attr-name\">5)</span> <span class=\"token attr-value\">\"filed3\"</span>\n<span class=\"token attr-name\">6)</span> <span class=\"token attr-value\">\"3\"</span>\n<span class=\"token attr-name\">7)</span> <span class=\"token attr-value\">\"field3\"</span>\n<span class=\"token attr-name\">8)</span> <span class=\"token attr-value\">\"3\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 判断指定filed是否在Hash结构中存在</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HEXISTS hash1 field1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">1</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HEXISTS hash1 field5</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">0</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 从hash结构中删除一个或多个field</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HDEL hash1 field1 field2</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">2</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 对hash集合中指定field的value增加值</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HINCRBY hash1 field1 2</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">3</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HGET hash1 field1</span>\n\"3\"\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取hash结构中所有的key</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HKEYS hash1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"filed1\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"filed2\"</span>\n<span class=\"token attr-name\">3)</span> <span class=\"token attr-value\">\"filed3\"</span>\n<span class=\"token attr-name\">4)</span> <span class=\"token attr-value\">\"field3\"</span>\n<span class=\"token attr-name\">5)</span> <span class=\"token attr-value\">\"field1\"</span>\n\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">获取hash集合中所有的value</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HVALS hash1</span>\n<span class=\"token attr-name\">1)</span> <span class=\"token attr-value\">\"1\"</span>\n<span class=\"token attr-name\">2)</span> <span class=\"token attr-value\">\"2\"</span>\n<span class=\"token attr-name\">3)</span> <span class=\"token attr-value\">\"3\"</span>\n<span class=\"token attr-name\">4)</span> <span class=\"token attr-value\">\"3\"</span>\n<span class=\"token attr-name\">5)</span> <span class=\"token attr-value\">\"3\"</span>\n\n<span class=\"token comment\" spellcheck=\"true\"># 获取hash集合中的元素个数</span>\n<span class=\"token attr-name\">$</span> <span class=\"token attr-value\">localhost:6379> HLEN hash1</span>\n<span class=\"token attr-name\">(integer)</span> <span class=\"token attr-value\">5</span></code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>具体命令地址 : <a href=\"http://redis.cn/commands.html\" target=\"_blank\" rel=\"noopener\">http://redis.cn/commands.html</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"key常用操作\"><a href=\"#key常用操作\" class=\"headerlink\" title=\"key常用操作\"></a>key常用操作</h3><pre><code class=\"properties\"># 查询指定key是否存在\n$ localhost:6379&gt; EXISTS hash1\n(integer) 1\n$ localhost:6379&gt; EXISTS jjj\n(integer) 0\n\n# 删除指定key\n$ localhost:6379&gt; DEL hash1\n(integer) 1\n$ localhost:6379&gt; EXISTS hash1\n(integer) 0\n\n# 对指定key设置过期时间\n$ localhost:6379&gt; set t1 value ex 5\nOK\n\n# 查询指定key的过期时间\n$ localhost:6379&gt; TTL t1\n(integer) 7\n\n# 查询指定key的类型\n$ localhost:6379&gt; type t1\nstring</code></pre>","more":"<h3 id=\"kv结构\"><a href=\"#kv结构\" class=\"headerlink\" title=\"kv结构\"></a>kv结构</h3><pre><code class=\"properties\"># 设置key 对应的value\n$ localhost:6379&gt; set key1 value1\nOK\n\n# 获取key对应的value\n$ localhost:6379&gt; get key1\n&quot;value1&quot;\n\n# Redis Setex 命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。\n$ localhost:6379&gt; SETEX mykey 60 redis\nOK\n\n# 命令在指定的 key 不存在时，为 key 设置指定的值。\n$ localhost:6379&gt; setnx key3 vlaue3\nOK\n$ localhost:6379&gt; setnx key3 value3\n(nil)</code></pre>\n<h3 id=\"list结构\"><a href=\"#list结构\" class=\"headerlink\" title=\"list结构\"></a>list结构</h3><pre><code class=\"properties\"># 从左侧插入元素\n$ localhost:6379&gt; LPUSH list1 1\n(integer) 1\n\n# 从右侧插入元素\n$ localhost:6379&gt; RPUSH list1 2\n(integer) 2\n\n# 查看集合内的元素，-1 表示查看所有元素\n$ localhost:6379&gt; LRANGE list1 0 -1\n1) &quot;1&quot;\n2) &quot;2&quot;\n\n# 查看list的元素个数\n$ localhost:6379&gt; LLEN list1\n(integer) 2\n\n# 根据索引查询对应的元素，如果指定的索引不存在，则返回&#39;nil&#39;\n$ localhost:6379&gt; LINDEX list1 0\n&quot;2&quot;\n\n# 从列表左侧移除一个元素\n$ 127.0.0.1:6379&gt; LPOP list1\n&quot;5&quot;\n\n# 从列表右侧移除一个元素\n$ 127.0.0.1:6379&gt; RPOP list1\n&quot;1&quot;\n\n# 从列表右侧移除一个元素添加到左侧\n$ localhost:6379&gt; LRANGE list1 0 -1\n1) &quot;three&quot;\n2) &quot;two&quot;\n3) &quot;one&quot;\n$ localhost:6379&gt; RPOPLPUSH list1 list2\n&quot;one&quot;\n$ localhost:6379&gt; LRANGE list2 0 -1\n1) &quot;one&quot;</code></pre>\n<h3 id=\"set结构\"><a href=\"#set结构\" class=\"headerlink\" title=\"set结构\"></a>set结构</h3><pre><code class=\"properties\"># 向set中添加一个元素\n$ localhost:6379&gt; SADD set1 &#39;one&#39; &#39;two&#39; &#39;three&#39;\n(integer) 3\n\n# 获取set集合中的元素\n$ localhost:6379&gt; SMEMBERS set1\n1) &quot;one&quot;\n2) &quot;three&quot;\n3) &quot;two\n\n# 从set集合中移除一个或多个元素\n$ localhost:6379&gt; SREM set1 &#39;one&#39;\n(integer) 1\n\n# 从set集合中移除一个或多个元素并返回被删除元素\n$ localhost:6379&gt; SPOP set1 1\n1) &quot;three&quot;\n\n# 获取当前set集合元素个数\n$ localhost:6379&gt; SCARD set1\n(integer) 3\n\n# 从set集合随机获取元素但不删除\n$ localhost:6379&gt; SRANDMEMBER set1 1\n1) &quot;one&quot;\n$ localhost:6379&gt; SMEMBERS set1\n1) &quot;three&quot;\n2) &quot;two&quot;\n3) &quot;one&quot;\n\n# 判断set集合中是否存在指定元素，如果存在则返回1，不存在返回0\n$ localhost:6379&gt; SISMEMBER set1 &#39;one&#39;\n(integer) 1\n$ localhost:6379&gt; SISMEMBER set1 &#39;4&#39;\n(integer) 0</code></pre>\n<h3 id=\"sorted-set-结构\"><a href=\"#sorted-set-结构\" class=\"headerlink\" title=\"sorted set  结构\"></a>sorted set  结构</h3><pre><code class=\"properties\"># 向有序集合中添加元素\n$ localhost:6379&gt; ZADD zset1 1 &#39;one&#39;\n(integer) 1\n\n# 获取有序集合中指定分数范围的元素\n$ localhost:6379&gt; ZRANGE zset1 0 -1\n1) &quot;one&quot;\n2) &quot;two&quot;\n3) &quot;three&quot;\n\n# 删除有序集合中的元素\n$ localhost:6379&gt; ZREM zset1 &#39;one&#39;\n(integer) 1\n\n# 获取有序集合元素个数\n$ localhost:6379&gt; ZCARD zset1\n(integer) 2\n\n# 为有序集合中指定成员增加指定个数\n$ localhost:6379&gt; ZINCRBY zset1 2 &quot;one&quot;\n&quot;4&quot;\n$ localhost:6379&gt; ZRANGE zset1 0 -1 WITHSCORES\n1) &quot;two&quot;\n2) &quot;2&quot;\n3) &quot;three&quot;\n4) &quot;3&quot;\n5) &quot;one&quot;\n6) &quot;4&quot;\n\n# 获取有序集合指定分数范围内的元素数量\n$ localhost:6379&gt; ZCOUNT zset1 0 2\n(integer) 1\n\n# 获取元素在有序集合中的排名，分数越大，排名值越大\n$ localhost:6379&gt; ZRANK zset1 &#39;one&#39;\n(integer) 2\n\n# 获取元素在有序集合中的排名。分数越大，排名值越小\n$ localhost:6379&gt; ZREVRANK zset1 &#39;one&#39;\n(integer) 0\n\n# 获取指定元素的分值\n$ localhost:6379&gt; ZSCORE zset1 &#39;one&#39;\n&quot;4&quot;</code></pre>\n<h3 id=\"hash结构\"><a href=\"#hash结构\" class=\"headerlink\" title=\"hash结构\"></a>hash结构</h3><pre><code class=\"properties\"># 向hash集合中添加一个元素\n$ localhost:6379&gt; HSET hash1 field1 1\n(integer) 1\n\n# 向hash集合中添加多个元素\n$ localhost:6379&gt; HMSET hash1 field2 2 field3 3\nOK\n\n# 获取指定field对应的value\n$ localhost:6379&gt; HGET hash1 field1\n&quot;1&quot;\n\n# 批量获取指定field下的value\n$ localhost:6379&gt; HMGET hash1 field1 field2 field3\n1) &quot;1&quot;\n2) &quot;2&quot;\n3) &quot;3&quot;\n\n# 获取hash结合里面所有元素\n$ localhost:6379&gt; HGETALL hash1\n1) &quot;filed1&quot;\n2) &quot;1&quot;\n3) &quot;filed2&quot;\n4) &quot;2&quot;\n5) &quot;filed3&quot;\n6) &quot;3&quot;\n7) &quot;field3&quot;\n8) &quot;3&quot;\n\n# 判断指定filed是否在Hash结构中存在\n$ localhost:6379&gt; HEXISTS hash1 field1\n(integer) 1\n$ localhost:6379&gt; HEXISTS hash1 field5\n(integer) 0\n\n# 从hash结构中删除一个或多个field\n$ localhost:6379&gt; HDEL hash1 field1 field2\n(integer) 2\n\n# 对hash集合中指定field的value增加值\n$ localhost:6379&gt; HINCRBY hash1 field1 2\n(integer) 3\n$ localhost:6379&gt; HGET hash1 field1\n&quot;3&quot;\n\n# 获取hash结构中所有的key\n$ localhost:6379&gt; HKEYS hash1\n1) &quot;filed1&quot;\n2) &quot;filed2&quot;\n3) &quot;filed3&quot;\n4) &quot;field3&quot;\n5) &quot;field1&quot;\n\n$ 获取hash集合中所有的value\n$ localhost:6379&gt; HVALS hash1\n1) &quot;1&quot;\n2) &quot;2&quot;\n3) &quot;3&quot;\n4) &quot;3&quot;\n5) &quot;3&quot;\n\n# 获取hash集合中的元素个数\n$ localhost:6379&gt; HLEN hash1\n(integer) 5</code></pre>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>具体命令地址 : <a href=\"http://redis.cn/commands.html\" target=\"_blank\" rel=\"noopener\">http://redis.cn/commands.html</a></p>"},{"title":"Redis数据结构总结","description":"Redis数据结构总结","date":"2020-10-03T00:32:58.000Z","_content":"### 概述\n\n本文主要总结Redis几种数据结构的特点，Redis由于单线程和纯内存的特点，所以在数据结构上也做了很多优化，了解Redis的数据结构有利于我们更好的根据实际场景使用正确的数据结构。\n\n### 基础数据结构\n\n#### 概述\n\nRedis在内部定义了6种基础的数据结构，包括：<font color=red>简单动态字符串，链表，字典，跳跃表，整数集合，压缩列表</font>。Redis使用这几种基础的数据结构创建了一个对象系统，这个系统包含了字符串对象，列表对象，哈希对象，集合对象，有序集合对象。\n\n举个例子，对于命令`SET msg \"helloWorld\"`。msg使用的是字符串对象（对于Redis来说保存的键总是一个字符串对象），而helloWorld使用的是`简单动态字符串`。了解这6种基础数据接口才能进一步了解Redis种的字符串，列表，哈希，集合，有序集合。\n<!--more-->\n#### 简单动态字符串\n\n```c\nstruct sdshdr{\n    //记录buf数组中已使用字节的数量，SDS所保存字符串的长度\n\tint len;\n    //记录buf数组中未使用字节数量\n    int free;\n    //字节数组\n    char buf[];\n}\n```\n\n![简单动态字符串](redis-data-type/2.png)\n\n通过上面我们知道Redis简单动态字符串的接口，通过len记录已使用字节数量，free记录未使用字节数量，buf数组记录数据。那为啥要这样设计呢，为啥不直接使用C语言提供的字符串？\n\n**获取字符串长度复杂度超级低**\n\n由于len存储了已使用字节数量，可以直接通过len获取数组长度，而无须去遍历字节数组获取长度，获取字符串长度为常数复杂度。所以我们使用`strlen`命令获取key的长度时速度很快。\n\n这也是为什么Redis不用C语言内置的字符串了。例如C语言中要知道一个字符串的长度可以用函数strlen(str)，而这个函数需要对每个字符计数直到遇到代表字符串结束的空字符才结束，时间负责度O(N)。而 SDS 由于 `len` 记录当前字符串的长度，所以直接读取即可，时间复杂度仅为 **O(1)**。\n\n```reStructuredText\n127.0.0.1:6379> strlen msg\n(integer) 11\n```\n\n**减少修改字符串时带来的内存重分配次数**\n\n由于C字符串在底层时间时一个N+1数组，每次增长或缩小C字符串都要进行内存重分配。由于Redis作为数据库字符串经常被频繁修改，如果每次修改都进行重分配则会对性能有很大影响。\n\n然而SDS的buf数组不是单纯的N+1，而是可以预分配更多空间，未使用的长度用free记录。通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。而当字符串减少时，程序也不会立即使用内存重分配来回收缩短多出来的字节，而是使用free属性记录下来（惰性空间释放）。\n\n总结：SDS通过`空间预分配` 和 `惰性空间释放`减少修改字符串时带来的内存重分配次数，提高了性能。\n\n#### 字典\n\n字典使用哈希表作为底层实现。数据结构如下\n\n```c\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n    //哈希表\n    dictht ht[2];\n    int trehashidx;\n}\ntypedef struct dictht {\n    //哈希表数组\n\tdictEntry **table;\n    //哈希表大小\n    unsigned long size;\n    //哈希表大小掩码，用于计算索引值 总是等于size - 1\n    unsigned long sizemask;\n    //哈希表已有节点的数量\n    unsigned long used;\n} dictht;\n\n//哈希节点\ntypedef struct dictEntry{\n    void *key;\n    union {\n        void *val;\n        uint64_tu64;\n        int64_ts64;\n    } v;\n    //指向下一个节点\n    struct dictEntry *next;\n}\n\n```\n\n![字典结构](redis-data-type/1.png)\n\n- 字典采用哈希表的结构。初始化大小为4的哈希数组。使用<font color=red>链地址</font>法来解决冲突，被分配到同一个索引的多个键值会连接成一个单向链表。\n- 每个字典带有两个哈希表（ht[0]、ht[1]）。一个平时使用，一个在进行rehash使用。\n- Redis字典的rehash并不是一次性完成的，试想一下一个哈希表中有上百万个键值，如果一次性rehash会拖慢Redis的速度，所以是**渐进式**完成的。\n\n总结 ：字典采用了哈希数组+链表的结构，并且扩容时采用了渐进式的扩容方式提高了性能。\n\n#### 整数集合\n\n整数集合用于保存**整数值**的集合抽象数据结构，并且保证**集合中不会出现重复元素**。底层采用数组，有序且无重复的方式保存集合元素，使用整数集合主要是为了节约内存。例如Redis的集合对象里面保存的全是整数时，底层就是使用的整数集合，这样可以**减少内存使用**。\n\n```c\ntypedef struct intset{\n    uint32_t encoding;\n    //集合包含的元素数量\n    uint32_t length;\n    //保存元素的数组\n    int8_t contents[];\n}\n```\n\n#### 跳跃表\n\n 跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。\n\n#### 压缩列表\n\n压缩列表是Redis为了`节约内存`而开发的数据结构，由一系列特殊编码的`连续内存`块组成的顺序型数据结构。压缩列表节点可以保存`字节数组`或`整数值`。**压缩列表有点类似数组，也是通过一篇连续的内存空间来存储数据，不过他跟数组不同的是：允许存储的数据大小不同。**\n\n使用压缩列表的好处是节约内存，将内存存储与连续的内存区域，且减少了内存碎片的产生。\n\n那为什么例如列表当元素到达512就不用压缩列表了？**因为压缩列表的新增、删除的操作平均时间复杂度为O(N)，随着N的增大，时间必然会增加。**\n\n![压缩列表](redis-data-type/3.png)\n\n| 属性                  | 说明                                      |\n| --------------------- | ----------------------------------------- |\n| zlbytes               | 记录整个压缩列表占用的内存字节数          |\n| zltail                | 记录压缩列表表尾距离表头起始地址的字节数  |\n| zllen                 | 记录压缩列表包含的节点数量                |\n| entryN                | 节点                                      |\n| zlend                 | 用来标记压缩列表的末端                    |\n| previous_entry_length | 记录前一个节点的长度                      |\n| encoding              | 记录节点content属性所保存数据的类型和长度 |\n| content               | 保存节点值，可以是字节数组或者整数值      |\n\n\n\n#### 链表\n\n![链表](redis-data-type/4.png)\n\n链表结构是我们经常用的结构，如图所示。Redis的链表结构是一个`双端链表`。value的值为一指针，可以用来存储不同类型的值。\n\n### Redis基础对象\n\nRedis提供了5种对象，这5种对象是通过上面的6种基础结构来实现的。分别是字符串对象，列表对象，哈希对象，集合对象，有序集合对象。Redis的每一种对象都有一个redisObject结构表示。\n\n```c\ntypedef struct redisObject{\n    //对象的类型，用来表示是字符串对象，列表对象，哈希对象，集合对象，有序集合对象\n    //可以通过type key 命令返回数据库键对应的值对象的类型\n    unsigned type:4;\n    //对象所是由的编码，也就是使用的是哪个基础结构\n    //可以通过object encoding key 命令返回数据库值对象的编码\n    unsigned encoding:4;\n    //指针指向底层数据结构\n    void *ptr;\n}\n```\n\n#### 字符串对象\n\n字符串对象的编码有三种：int，rwa，embstr。\n\n- 如果value存的是整数值，那么会使用int编码，且类型是long类型。\n- 如果value是一个字符串值且长度大于39字节，则使用SDS(简单动态字符串)，编码为raw。\n- 如果value是一个字符串值且长度小于等于39字节，则使用SDS(简单动态字符串)，编码为embstr（专门用于保存短字符串的一种优化编码方式）。\n\n#### 列表对象\n\n列表对象的编码使用的是`压缩列表`或`链表`。当列表满足以下两点时采用压缩列表。\n\n- 列表对象保存的所有字符串元素长度都小于64字节。\n- 列表对象保存的元素数量小于512个。\n\n为啥要转成链表呢，压缩列表本身是为了节约内存设计的，当元素长度太长时会导致压缩列表的连锁更新问题；当元素数量太大时，由于压缩列表结构是连续的内存块组成，对于插入缩小元素没有链表来得性能高。所以当不满足上面两个条件时会使用链表。\n\n#### 哈希对象\n\n哈希对象的编码可以是`压缩列表`或`字典`。当满足如下条件时采用压缩链表结构。\n\n- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节。\n- 哈希对象保存的键值对数量小于512个。\n\n![哈希对象使用ziplist存储结构](redis-data-type/5.png)\n\n如果哈希存储的键值对字符串长度小且数量少的情况下使用压缩链表会节约内存空间，但当超过一定量以后，由于压缩列表自身结构的问题会导致性能下降，所以转成用字典结构。\n\n#### 集合对象\n\n集合对象的编码可以是`整数集合`或`字典`。当满足如下条件时使用整数集合。\n\n- 集合对象内的所有元素都是整数。\n- 集合对象保存的元素个数不超过512个。\n\n#### 有序集合列表\n\n有序集合编码可以是`压缩列表`或`跳跃表`。当满足如下条件时使用压缩列表\n\n- 有序集合保存的元素数量小于128个。\n- 有序集合保存的所有元素的长度小于64字节。\n\n### 查看redis数据类型\n\n```\n127.0.0.1:6379> lpush list1 1\n(integer) 1\n127.0.0.1:6379> object encoding list1\n\"quicklist\"\n127.0.0.1:6379> sadd set1 one two three\n(integer) 3\n127.0.0.1:6379> object encoding set1\n\"hashtable\"\n127.0.0.1:6379> hset hash1 field1 1\n(integer) 1\n127.0.0.1:6379> object encoding hash1\n\"ziplist\"\n127.0.0.1:6379> set name xuzy\nOK\n127.0.0.1:6379> object encoding name\n\"embstr\"\n```\n\n\n\n### 总结\n\n**Redis的数据对象由多种数据结构来实现，主要是出于时间和空间的考虑。由于Redis是单线程和纯内存，当数据量小的时候使用更简单的数据结构，有利于节省内存，提高性能。**\n\n在开发过程我们需要选择合适的数据结构。举个例子。\n\n**例子1**\n\n例如上面分析了字符串的结构，虽然Redis字符串使用SDS提高了性能，但是SDS相比于C语言字符串占用更多空间。SDS结构本身就占用比C语言字符串更多内存，且由于空间预分配，还有可能有没使用的空间浪费。所以我们一定要基于合适场景使用合适的数据结构。所以在使用上，如果我们业务上能用哈希对象的话那会比字符串占用内存更低。\n\n****\n\n### 参考\n\n- 《Redis设计与实现》\n- 一篇完善的Redis结构博客：[一文回顾Redis五大对象(数据类型)](https://www.cnblogs.com/hunternet/p/12742390.html)","source":"_posts/redis-data-type.md","raw":"---\ntitle: Redis数据结构总结\ntags:\n  - redis\ncategories: redis\ndescription : Redis数据结构总结\ndate: 2020-10-03 08:32:58\n---\n### 概述\n\n本文主要总结Redis几种数据结构的特点，Redis由于单线程和纯内存的特点，所以在数据结构上也做了很多优化，了解Redis的数据结构有利于我们更好的根据实际场景使用正确的数据结构。\n\n### 基础数据结构\n\n#### 概述\n\nRedis在内部定义了6种基础的数据结构，包括：<font color=red>简单动态字符串，链表，字典，跳跃表，整数集合，压缩列表</font>。Redis使用这几种基础的数据结构创建了一个对象系统，这个系统包含了字符串对象，列表对象，哈希对象，集合对象，有序集合对象。\n\n举个例子，对于命令`SET msg \"helloWorld\"`。msg使用的是字符串对象（对于Redis来说保存的键总是一个字符串对象），而helloWorld使用的是`简单动态字符串`。了解这6种基础数据接口才能进一步了解Redis种的字符串，列表，哈希，集合，有序集合。\n<!--more-->\n#### 简单动态字符串\n\n```c\nstruct sdshdr{\n    //记录buf数组中已使用字节的数量，SDS所保存字符串的长度\n\tint len;\n    //记录buf数组中未使用字节数量\n    int free;\n    //字节数组\n    char buf[];\n}\n```\n\n![简单动态字符串](redis-data-type/2.png)\n\n通过上面我们知道Redis简单动态字符串的接口，通过len记录已使用字节数量，free记录未使用字节数量，buf数组记录数据。那为啥要这样设计呢，为啥不直接使用C语言提供的字符串？\n\n**获取字符串长度复杂度超级低**\n\n由于len存储了已使用字节数量，可以直接通过len获取数组长度，而无须去遍历字节数组获取长度，获取字符串长度为常数复杂度。所以我们使用`strlen`命令获取key的长度时速度很快。\n\n这也是为什么Redis不用C语言内置的字符串了。例如C语言中要知道一个字符串的长度可以用函数strlen(str)，而这个函数需要对每个字符计数直到遇到代表字符串结束的空字符才结束，时间负责度O(N)。而 SDS 由于 `len` 记录当前字符串的长度，所以直接读取即可，时间复杂度仅为 **O(1)**。\n\n```reStructuredText\n127.0.0.1:6379> strlen msg\n(integer) 11\n```\n\n**减少修改字符串时带来的内存重分配次数**\n\n由于C字符串在底层时间时一个N+1数组，每次增长或缩小C字符串都要进行内存重分配。由于Redis作为数据库字符串经常被频繁修改，如果每次修改都进行重分配则会对性能有很大影响。\n\n然而SDS的buf数组不是单纯的N+1，而是可以预分配更多空间，未使用的长度用free记录。通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。而当字符串减少时，程序也不会立即使用内存重分配来回收缩短多出来的字节，而是使用free属性记录下来（惰性空间释放）。\n\n总结：SDS通过`空间预分配` 和 `惰性空间释放`减少修改字符串时带来的内存重分配次数，提高了性能。\n\n#### 字典\n\n字典使用哈希表作为底层实现。数据结构如下\n\n```c\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n    //哈希表\n    dictht ht[2];\n    int trehashidx;\n}\ntypedef struct dictht {\n    //哈希表数组\n\tdictEntry **table;\n    //哈希表大小\n    unsigned long size;\n    //哈希表大小掩码，用于计算索引值 总是等于size - 1\n    unsigned long sizemask;\n    //哈希表已有节点的数量\n    unsigned long used;\n} dictht;\n\n//哈希节点\ntypedef struct dictEntry{\n    void *key;\n    union {\n        void *val;\n        uint64_tu64;\n        int64_ts64;\n    } v;\n    //指向下一个节点\n    struct dictEntry *next;\n}\n\n```\n\n![字典结构](redis-data-type/1.png)\n\n- 字典采用哈希表的结构。初始化大小为4的哈希数组。使用<font color=red>链地址</font>法来解决冲突，被分配到同一个索引的多个键值会连接成一个单向链表。\n- 每个字典带有两个哈希表（ht[0]、ht[1]）。一个平时使用，一个在进行rehash使用。\n- Redis字典的rehash并不是一次性完成的，试想一下一个哈希表中有上百万个键值，如果一次性rehash会拖慢Redis的速度，所以是**渐进式**完成的。\n\n总结 ：字典采用了哈希数组+链表的结构，并且扩容时采用了渐进式的扩容方式提高了性能。\n\n#### 整数集合\n\n整数集合用于保存**整数值**的集合抽象数据结构，并且保证**集合中不会出现重复元素**。底层采用数组，有序且无重复的方式保存集合元素，使用整数集合主要是为了节约内存。例如Redis的集合对象里面保存的全是整数时，底层就是使用的整数集合，这样可以**减少内存使用**。\n\n```c\ntypedef struct intset{\n    uint32_t encoding;\n    //集合包含的元素数量\n    uint32_t length;\n    //保存元素的数组\n    int8_t contents[];\n}\n```\n\n#### 跳跃表\n\n 跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。\n\n#### 压缩列表\n\n压缩列表是Redis为了`节约内存`而开发的数据结构，由一系列特殊编码的`连续内存`块组成的顺序型数据结构。压缩列表节点可以保存`字节数组`或`整数值`。**压缩列表有点类似数组，也是通过一篇连续的内存空间来存储数据，不过他跟数组不同的是：允许存储的数据大小不同。**\n\n使用压缩列表的好处是节约内存，将内存存储与连续的内存区域，且减少了内存碎片的产生。\n\n那为什么例如列表当元素到达512就不用压缩列表了？**因为压缩列表的新增、删除的操作平均时间复杂度为O(N)，随着N的增大，时间必然会增加。**\n\n![压缩列表](redis-data-type/3.png)\n\n| 属性                  | 说明                                      |\n| --------------------- | ----------------------------------------- |\n| zlbytes               | 记录整个压缩列表占用的内存字节数          |\n| zltail                | 记录压缩列表表尾距离表头起始地址的字节数  |\n| zllen                 | 记录压缩列表包含的节点数量                |\n| entryN                | 节点                                      |\n| zlend                 | 用来标记压缩列表的末端                    |\n| previous_entry_length | 记录前一个节点的长度                      |\n| encoding              | 记录节点content属性所保存数据的类型和长度 |\n| content               | 保存节点值，可以是字节数组或者整数值      |\n\n\n\n#### 链表\n\n![链表](redis-data-type/4.png)\n\n链表结构是我们经常用的结构，如图所示。Redis的链表结构是一个`双端链表`。value的值为一指针，可以用来存储不同类型的值。\n\n### Redis基础对象\n\nRedis提供了5种对象，这5种对象是通过上面的6种基础结构来实现的。分别是字符串对象，列表对象，哈希对象，集合对象，有序集合对象。Redis的每一种对象都有一个redisObject结构表示。\n\n```c\ntypedef struct redisObject{\n    //对象的类型，用来表示是字符串对象，列表对象，哈希对象，集合对象，有序集合对象\n    //可以通过type key 命令返回数据库键对应的值对象的类型\n    unsigned type:4;\n    //对象所是由的编码，也就是使用的是哪个基础结构\n    //可以通过object encoding key 命令返回数据库值对象的编码\n    unsigned encoding:4;\n    //指针指向底层数据结构\n    void *ptr;\n}\n```\n\n#### 字符串对象\n\n字符串对象的编码有三种：int，rwa，embstr。\n\n- 如果value存的是整数值，那么会使用int编码，且类型是long类型。\n- 如果value是一个字符串值且长度大于39字节，则使用SDS(简单动态字符串)，编码为raw。\n- 如果value是一个字符串值且长度小于等于39字节，则使用SDS(简单动态字符串)，编码为embstr（专门用于保存短字符串的一种优化编码方式）。\n\n#### 列表对象\n\n列表对象的编码使用的是`压缩列表`或`链表`。当列表满足以下两点时采用压缩列表。\n\n- 列表对象保存的所有字符串元素长度都小于64字节。\n- 列表对象保存的元素数量小于512个。\n\n为啥要转成链表呢，压缩列表本身是为了节约内存设计的，当元素长度太长时会导致压缩列表的连锁更新问题；当元素数量太大时，由于压缩列表结构是连续的内存块组成，对于插入缩小元素没有链表来得性能高。所以当不满足上面两个条件时会使用链表。\n\n#### 哈希对象\n\n哈希对象的编码可以是`压缩列表`或`字典`。当满足如下条件时采用压缩链表结构。\n\n- 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节。\n- 哈希对象保存的键值对数量小于512个。\n\n![哈希对象使用ziplist存储结构](redis-data-type/5.png)\n\n如果哈希存储的键值对字符串长度小且数量少的情况下使用压缩链表会节约内存空间，但当超过一定量以后，由于压缩列表自身结构的问题会导致性能下降，所以转成用字典结构。\n\n#### 集合对象\n\n集合对象的编码可以是`整数集合`或`字典`。当满足如下条件时使用整数集合。\n\n- 集合对象内的所有元素都是整数。\n- 集合对象保存的元素个数不超过512个。\n\n#### 有序集合列表\n\n有序集合编码可以是`压缩列表`或`跳跃表`。当满足如下条件时使用压缩列表\n\n- 有序集合保存的元素数量小于128个。\n- 有序集合保存的所有元素的长度小于64字节。\n\n### 查看redis数据类型\n\n```\n127.0.0.1:6379> lpush list1 1\n(integer) 1\n127.0.0.1:6379> object encoding list1\n\"quicklist\"\n127.0.0.1:6379> sadd set1 one two three\n(integer) 3\n127.0.0.1:6379> object encoding set1\n\"hashtable\"\n127.0.0.1:6379> hset hash1 field1 1\n(integer) 1\n127.0.0.1:6379> object encoding hash1\n\"ziplist\"\n127.0.0.1:6379> set name xuzy\nOK\n127.0.0.1:6379> object encoding name\n\"embstr\"\n```\n\n\n\n### 总结\n\n**Redis的数据对象由多种数据结构来实现，主要是出于时间和空间的考虑。由于Redis是单线程和纯内存，当数据量小的时候使用更简单的数据结构，有利于节省内存，提高性能。**\n\n在开发过程我们需要选择合适的数据结构。举个例子。\n\n**例子1**\n\n例如上面分析了字符串的结构，虽然Redis字符串使用SDS提高了性能，但是SDS相比于C语言字符串占用更多空间。SDS结构本身就占用比C语言字符串更多内存，且由于空间预分配，还有可能有没使用的空间浪费。所以我们一定要基于合适场景使用合适的数据结构。所以在使用上，如果我们业务上能用哈希对象的话那会比字符串占用内存更低。\n\n****\n\n### 参考\n\n- 《Redis设计与实现》\n- 一篇完善的Redis结构博客：[一文回顾Redis五大对象(数据类型)](https://www.cnblogs.com/hunternet/p/12742390.html)","slug":"redis-data-type","published":1,"updated":"2021-04-08T00:47:06.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvl002vqwv232lkay5s","content":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>本文主要总结Redis几种数据结构的特点，Redis由于单线程和纯内存的特点，所以在数据结构上也做了很多优化，了解Redis的数据结构有利于我们更好的根据实际场景使用正确的数据结构。</p>\n<h3 id=\"基础数据结构\"><a href=\"#基础数据结构\" class=\"headerlink\" title=\"基础数据结构\"></a>基础数据结构</h3><h4 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Redis在内部定义了6种基础的数据结构，包括：<font color=\"red\">简单动态字符串，链表，字典，跳跃表，整数集合，压缩列表</font>。Redis使用这几种基础的数据结构创建了一个对象系统，这个系统包含了字符串对象，列表对象，哈希对象，集合对象，有序集合对象。</p>\n<p>举个例子，对于命令<code>SET msg &quot;helloWorld&quot;</code>。msg使用的是字符串对象（对于Redis来说保存的键总是一个字符串对象），而helloWorld使用的是<code>简单动态字符串</code>。了解这6种基础数据接口才能进一步了解Redis种的字符串，列表，哈希，集合，有序集合。</p>\n<a id=\"more\"></a>\n<h4 id=\"简单动态字符串\"><a href=\"#简单动态字符串\" class=\"headerlink\" title=\"简单动态字符串\"></a>简单动态字符串</h4><pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> sdshdr<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//记录buf数组中已使用字节的数量，SDS所保存字符串的长度</span>\n    <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//记录buf数组中未使用字节数量</span>\n    <span class=\"token keyword\">int</span> free<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//字节数组</span>\n    <span class=\"token keyword\">char</span> buf<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><img src=\"/2020/10/03/redis-data-type/2.png\" alt=\"简单动态字符串\"></p>\n<p>通过上面我们知道Redis简单动态字符串的接口，通过len记录已使用字节数量，free记录未使用字节数量，buf数组记录数据。那为啥要这样设计呢，为啥不直接使用C语言提供的字符串？</p>\n<p><strong>获取字符串长度复杂度超级低</strong></p>\n<p>由于len存储了已使用字节数量，可以直接通过len获取数组长度，而无须去遍历字节数组获取长度，获取字符串长度为常数复杂度。所以我们使用<code>strlen</code>命令获取key的长度时速度很快。</p>\n<p>这也是为什么Redis不用C语言内置的字符串了。例如C语言中要知道一个字符串的长度可以用函数strlen(str)，而这个函数需要对每个字符计数直到遇到代表字符串结束的空字符才结束，时间负责度O(N)。而 SDS 由于 <code>len</code> 记录当前字符串的长度，所以直接读取即可，时间复杂度仅为 <strong>O(1)</strong>。</p>\n<pre class=\" language-reStructuredText\"><code class=\"language-reStructuredText\">127.0.0.1:6379> strlen msg\n(integer) 11</code></pre>\n<p><strong>减少修改字符串时带来的内存重分配次数</strong></p>\n<p>由于C字符串在底层时间时一个N+1数组，每次增长或缩小C字符串都要进行内存重分配。由于Redis作为数据库字符串经常被频繁修改，如果每次修改都进行重分配则会对性能有很大影响。</p>\n<p>然而SDS的buf数组不是单纯的N+1，而是可以预分配更多空间，未使用的长度用free记录。通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。而当字符串减少时，程序也不会立即使用内存重分配来回收缩短多出来的字节，而是使用free属性记录下来（惰性空间释放）。</p>\n<p>总结：SDS通过<code>空间预分配</code> 和 <code>惰性空间释放</code>减少修改字符串时带来的内存重分配次数，提高了性能。</p>\n<h4 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h4><p>字典使用哈希表作为底层实现。数据结构如下</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> dict <span class=\"token punctuation\">{</span>\n    dictType <span class=\"token operator\">*</span>type<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>privdata<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//哈希表</span>\n    dictht ht<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> trehashidx<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> dictht <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//哈希表数组</span>\n    dictEntry <span class=\"token operator\">*</span><span class=\"token operator\">*</span>table<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//哈希表大小</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> size<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//哈希表大小掩码，用于计算索引值 总是等于size - 1</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> sizemask<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//哈希表已有节点的数量</span>\n    <span class=\"token keyword\">unsigned</span> <span class=\"token keyword\">long</span> used<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> dictht<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//哈希节点</span>\n<span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> dictEntry<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>key<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">union</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>val<span class=\"token punctuation\">;</span>\n        uint64_tu64<span class=\"token punctuation\">;</span>\n        int64_ts64<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> v<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//指向下一个节点</span>\n    <span class=\"token keyword\">struct</span> dictEntry <span class=\"token operator\">*</span>next<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><img src=\"/2020/10/03/redis-data-type/1.png\" alt=\"字典结构\"></p>\n<ul>\n<li>字典采用哈希表的结构。初始化大小为4的哈希数组。使用<font color=\"red\">链地址</font>法来解决冲突，被分配到同一个索引的多个键值会连接成一个单向链表。</li>\n<li>每个字典带有两个哈希表（ht[0]、ht[1]）。一个平时使用，一个在进行rehash使用。</li>\n<li>Redis字典的rehash并不是一次性完成的，试想一下一个哈希表中有上百万个键值，如果一次性rehash会拖慢Redis的速度，所以是<strong>渐进式</strong>完成的。</li>\n</ul>\n<p>总结 ：字典采用了哈希数组+链表的结构，并且扩容时采用了渐进式的扩容方式提高了性能。</p>\n<h4 id=\"整数集合\"><a href=\"#整数集合\" class=\"headerlink\" title=\"整数集合\"></a>整数集合</h4><p>整数集合用于保存<strong>整数值</strong>的集合抽象数据结构，并且保证<strong>集合中不会出现重复元素</strong>。底层采用数组，有序且无重复的方式保存集合元素，使用整数集合主要是为了节约内存。例如Redis的集合对象里面保存的全是整数时，底层就是使用的整数集合，这样可以<strong>减少内存使用</strong>。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> intset<span class=\"token punctuation\">{</span>\n    uint32_t encoding<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//集合包含的元素数量</span>\n    uint32_t length<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//保存元素的数组</span>\n    int8_t contents<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h4><p> 跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>\n<h4 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h4><p>压缩列表是Redis为了<code>节约内存</code>而开发的数据结构，由一系列特殊编码的<code>连续内存</code>块组成的顺序型数据结构。压缩列表节点可以保存<code>字节数组</code>或<code>整数值</code>。<strong>压缩列表有点类似数组，也是通过一篇连续的内存空间来存储数据，不过他跟数组不同的是：允许存储的数据大小不同。</strong></p>\n<p>使用压缩列表的好处是节约内存，将内存存储与连续的内存区域，且减少了内存碎片的产生。</p>\n<p>那为什么例如列表当元素到达512就不用压缩列表了？<strong>因为压缩列表的新增、删除的操作平均时间复杂度为O(N)，随着N的增大，时间必然会增加。</strong></p>\n<p><img src=\"/2020/10/03/redis-data-type/3.png\" alt=\"压缩列表\"></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>zlbytes</td>\n<td>记录整个压缩列表占用的内存字节数</td>\n</tr>\n<tr>\n<td>zltail</td>\n<td>记录压缩列表表尾距离表头起始地址的字节数</td>\n</tr>\n<tr>\n<td>zllen</td>\n<td>记录压缩列表包含的节点数量</td>\n</tr>\n<tr>\n<td>entryN</td>\n<td>节点</td>\n</tr>\n<tr>\n<td>zlend</td>\n<td>用来标记压缩列表的末端</td>\n</tr>\n<tr>\n<td>previous_entry_length</td>\n<td>记录前一个节点的长度</td>\n</tr>\n<tr>\n<td>encoding</td>\n<td>记录节点content属性所保存数据的类型和长度</td>\n</tr>\n<tr>\n<td>content</td>\n<td>保存节点值，可以是字节数组或者整数值</td>\n</tr>\n</tbody></table>\n<h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><p><img src=\"/2020/10/03/redis-data-type/4.png\" alt=\"链表\"></p>\n<p>链表结构是我们经常用的结构，如图所示。Redis的链表结构是一个<code>双端链表</code>。value的值为一指针，可以用来存储不同类型的值。</p>\n<h3 id=\"Redis基础对象\"><a href=\"#Redis基础对象\" class=\"headerlink\" title=\"Redis基础对象\"></a>Redis基础对象</h3><p>Redis提供了5种对象，这5种对象是通过上面的6种基础结构来实现的。分别是字符串对象，列表对象，哈希对象，集合对象，有序集合对象。Redis的每一种对象都有一个redisObject结构表示。</p>\n<pre class=\" language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> redisObject<span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//对象的类型，用来表示是字符串对象，列表对象，哈希对象，集合对象，有序集合对象</span>\n    <span class=\"token comment\" spellcheck=\"true\">//可以通过type key 命令返回数据库键对应的值对象的类型</span>\n    <span class=\"token keyword\">unsigned</span> type<span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//对象所是由的编码，也就是使用的是哪个基础结构</span>\n    <span class=\"token comment\" spellcheck=\"true\">//可以通过object encoding key 命令返回数据库值对象的编码</span>\n    <span class=\"token keyword\">unsigned</span> encoding<span class=\"token punctuation\">:</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//指针指向底层数据结构</span>\n    <span class=\"token keyword\">void</span> <span class=\"token operator\">*</span>ptr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"字符串对象\"><a href=\"#字符串对象\" class=\"headerlink\" title=\"字符串对象\"></a>字符串对象</h4><p>字符串对象的编码有三种：int，rwa，embstr。</p>\n<ul>\n<li>如果value存的是整数值，那么会使用int编码，且类型是long类型。</li>\n<li>如果value是一个字符串值且长度大于39字节，则使用SDS(简单动态字符串)，编码为raw。</li>\n<li>如果value是一个字符串值且长度小于等于39字节，则使用SDS(简单动态字符串)，编码为embstr（专门用于保存短字符串的一种优化编码方式）。</li>\n</ul>\n<h4 id=\"列表对象\"><a href=\"#列表对象\" class=\"headerlink\" title=\"列表对象\"></a>列表对象</h4><p>列表对象的编码使用的是<code>压缩列表</code>或<code>链表</code>。当列表满足以下两点时采用压缩列表。</p>\n<ul>\n<li>列表对象保存的所有字符串元素长度都小于64字节。</li>\n<li>列表对象保存的元素数量小于512个。</li>\n</ul>\n<p>为啥要转成链表呢，压缩列表本身是为了节约内存设计的，当元素长度太长时会导致压缩列表的连锁更新问题；当元素数量太大时，由于压缩列表结构是连续的内存块组成，对于插入缩小元素没有链表来得性能高。所以当不满足上面两个条件时会使用链表。</p>\n<h4 id=\"哈希对象\"><a href=\"#哈希对象\" class=\"headerlink\" title=\"哈希对象\"></a>哈希对象</h4><p>哈希对象的编码可以是<code>压缩列表</code>或<code>字典</code>。当满足如下条件时采用压缩链表结构。</p>\n<ul>\n<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节。</li>\n<li>哈希对象保存的键值对数量小于512个。</li>\n</ul>\n<p><img src=\"/2020/10/03/redis-data-type/5.png\" alt=\"哈希对象使用ziplist存储结构\"></p>\n<p>如果哈希存储的键值对字符串长度小且数量少的情况下使用压缩链表会节约内存空间，但当超过一定量以后，由于压缩列表自身结构的问题会导致性能下降，所以转成用字典结构。</p>\n<h4 id=\"集合对象\"><a href=\"#集合对象\" class=\"headerlink\" title=\"集合对象\"></a>集合对象</h4><p>集合对象的编码可以是<code>整数集合</code>或<code>字典</code>。当满足如下条件时使用整数集合。</p>\n<ul>\n<li>集合对象内的所有元素都是整数。</li>\n<li>集合对象保存的元素个数不超过512个。</li>\n</ul>\n<h4 id=\"有序集合列表\"><a href=\"#有序集合列表\" class=\"headerlink\" title=\"有序集合列表\"></a>有序集合列表</h4><p>有序集合编码可以是<code>压缩列表</code>或<code>跳跃表</code>。当满足如下条件时使用压缩列表</p>\n<ul>\n<li>有序集合保存的元素数量小于128个。</li>\n<li>有序集合保存的所有元素的长度小于64字节。</li>\n</ul>\n<h3 id=\"查看redis数据类型\"><a href=\"#查看redis数据类型\" class=\"headerlink\" title=\"查看redis数据类型\"></a>查看redis数据类型</h3><pre><code>127.0.0.1:6379&gt; lpush list1 1\n(integer) 1\n127.0.0.1:6379&gt; object encoding list1\n&quot;quicklist&quot;\n127.0.0.1:6379&gt; sadd set1 one two three\n(integer) 3\n127.0.0.1:6379&gt; object encoding set1\n&quot;hashtable&quot;\n127.0.0.1:6379&gt; hset hash1 field1 1\n(integer) 1\n127.0.0.1:6379&gt; object encoding hash1\n&quot;ziplist&quot;\n127.0.0.1:6379&gt; set name xuzy\nOK\n127.0.0.1:6379&gt; object encoding name\n&quot;embstr&quot;</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Redis的数据对象由多种数据结构来实现，主要是出于时间和空间的考虑。由于Redis是单线程和纯内存，当数据量小的时候使用更简单的数据结构，有利于节省内存，提高性能。</strong></p>\n<p>在开发过程我们需要选择合适的数据结构。举个例子。</p>\n<p><strong>例子1</strong></p>\n<p>例如上面分析了字符串的结构，虽然Redis字符串使用SDS提高了性能，但是SDS相比于C语言字符串占用更多空间。SDS结构本身就占用比C语言字符串更多内存，且由于空间预分配，还有可能有没使用的空间浪费。所以我们一定要基于合适场景使用合适的数据结构。所以在使用上，如果我们业务上能用哈希对象的话那会比字符串占用内存更低。</p>\n<hr>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li>《Redis设计与实现》</li>\n<li>一篇完善的Redis结构博客：<a href=\"https://www.cnblogs.com/hunternet/p/12742390.html\" target=\"_blank\" rel=\"noopener\">一文回顾Redis五大对象(数据类型)</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>本文主要总结Redis几种数据结构的特点，Redis由于单线程和纯内存的特点，所以在数据结构上也做了很多优化，了解Redis的数据结构有利于我们更好的根据实际场景使用正确的数据结构。</p>\n<h3 id=\"基础数据结构\"><a href=\"#基础数据结构\" class=\"headerlink\" title=\"基础数据结构\"></a>基础数据结构</h3><h4 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h4><p>Redis在内部定义了6种基础的数据结构，包括：<font color=\"red\">简单动态字符串，链表，字典，跳跃表，整数集合，压缩列表</font>。Redis使用这几种基础的数据结构创建了一个对象系统，这个系统包含了字符串对象，列表对象，哈希对象，集合对象，有序集合对象。</p>\n<p>举个例子，对于命令<code>SET msg &quot;helloWorld&quot;</code>。msg使用的是字符串对象（对于Redis来说保存的键总是一个字符串对象），而helloWorld使用的是<code>简单动态字符串</code>。了解这6种基础数据接口才能进一步了解Redis种的字符串，列表，哈希，集合，有序集合。</p>","more":"<h4 id=\"简单动态字符串\"><a href=\"#简单动态字符串\" class=\"headerlink\" title=\"简单动态字符串\"></a>简单动态字符串</h4><pre><code class=\"c\">struct sdshdr{\n    //记录buf数组中已使用字节的数量，SDS所保存字符串的长度\n    int len;\n    //记录buf数组中未使用字节数量\n    int free;\n    //字节数组\n    char buf[];\n}</code></pre>\n<p><img src=\"/2020/10/03/redis-data-type/2.png\" alt=\"简单动态字符串\"></p>\n<p>通过上面我们知道Redis简单动态字符串的接口，通过len记录已使用字节数量，free记录未使用字节数量，buf数组记录数据。那为啥要这样设计呢，为啥不直接使用C语言提供的字符串？</p>\n<p><strong>获取字符串长度复杂度超级低</strong></p>\n<p>由于len存储了已使用字节数量，可以直接通过len获取数组长度，而无须去遍历字节数组获取长度，获取字符串长度为常数复杂度。所以我们使用<code>strlen</code>命令获取key的长度时速度很快。</p>\n<p>这也是为什么Redis不用C语言内置的字符串了。例如C语言中要知道一个字符串的长度可以用函数strlen(str)，而这个函数需要对每个字符计数直到遇到代表字符串结束的空字符才结束，时间负责度O(N)。而 SDS 由于 <code>len</code> 记录当前字符串的长度，所以直接读取即可，时间复杂度仅为 <strong>O(1)</strong>。</p>\n<pre><code class=\"reStructuredText\">127.0.0.1:6379&gt; strlen msg\n(integer) 11</code></pre>\n<p><strong>减少修改字符串时带来的内存重分配次数</strong></p>\n<p>由于C字符串在底层时间时一个N+1数组，每次增长或缩小C字符串都要进行内存重分配。由于Redis作为数据库字符串经常被频繁修改，如果每次修改都进行重分配则会对性能有很大影响。</p>\n<p>然而SDS的buf数组不是单纯的N+1，而是可以预分配更多空间，未使用的长度用free记录。通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。而当字符串减少时，程序也不会立即使用内存重分配来回收缩短多出来的字节，而是使用free属性记录下来（惰性空间释放）。</p>\n<p>总结：SDS通过<code>空间预分配</code> 和 <code>惰性空间释放</code>减少修改字符串时带来的内存重分配次数，提高了性能。</p>\n<h4 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h4><p>字典使用哈希表作为底层实现。数据结构如下</p>\n<pre><code class=\"c\">typedef struct dict {\n    dictType *type;\n    void *privdata;\n    //哈希表\n    dictht ht[2];\n    int trehashidx;\n}\ntypedef struct dictht {\n    //哈希表数组\n    dictEntry **table;\n    //哈希表大小\n    unsigned long size;\n    //哈希表大小掩码，用于计算索引值 总是等于size - 1\n    unsigned long sizemask;\n    //哈希表已有节点的数量\n    unsigned long used;\n} dictht;\n\n//哈希节点\ntypedef struct dictEntry{\n    void *key;\n    union {\n        void *val;\n        uint64_tu64;\n        int64_ts64;\n    } v;\n    //指向下一个节点\n    struct dictEntry *next;\n}\n</code></pre>\n<p><img src=\"/2020/10/03/redis-data-type/1.png\" alt=\"字典结构\"></p>\n<ul>\n<li>字典采用哈希表的结构。初始化大小为4的哈希数组。使用<font color=\"red\">链地址</font>法来解决冲突，被分配到同一个索引的多个键值会连接成一个单向链表。</li>\n<li>每个字典带有两个哈希表（ht[0]、ht[1]）。一个平时使用，一个在进行rehash使用。</li>\n<li>Redis字典的rehash并不是一次性完成的，试想一下一个哈希表中有上百万个键值，如果一次性rehash会拖慢Redis的速度，所以是<strong>渐进式</strong>完成的。</li>\n</ul>\n<p>总结 ：字典采用了哈希数组+链表的结构，并且扩容时采用了渐进式的扩容方式提高了性能。</p>\n<h4 id=\"整数集合\"><a href=\"#整数集合\" class=\"headerlink\" title=\"整数集合\"></a>整数集合</h4><p>整数集合用于保存<strong>整数值</strong>的集合抽象数据结构，并且保证<strong>集合中不会出现重复元素</strong>。底层采用数组，有序且无重复的方式保存集合元素，使用整数集合主要是为了节约内存。例如Redis的集合对象里面保存的全是整数时，底层就是使用的整数集合，这样可以<strong>减少内存使用</strong>。</p>\n<pre><code class=\"c\">typedef struct intset{\n    uint32_t encoding;\n    //集合包含的元素数量\n    uint32_t length;\n    //保存元素的数组\n    int8_t contents[];\n}</code></pre>\n<h4 id=\"跳跃表\"><a href=\"#跳跃表\" class=\"headerlink\" title=\"跳跃表\"></a>跳跃表</h4><p> 跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>\n<h4 id=\"压缩列表\"><a href=\"#压缩列表\" class=\"headerlink\" title=\"压缩列表\"></a>压缩列表</h4><p>压缩列表是Redis为了<code>节约内存</code>而开发的数据结构，由一系列特殊编码的<code>连续内存</code>块组成的顺序型数据结构。压缩列表节点可以保存<code>字节数组</code>或<code>整数值</code>。<strong>压缩列表有点类似数组，也是通过一篇连续的内存空间来存储数据，不过他跟数组不同的是：允许存储的数据大小不同。</strong></p>\n<p>使用压缩列表的好处是节约内存，将内存存储与连续的内存区域，且减少了内存碎片的产生。</p>\n<p>那为什么例如列表当元素到达512就不用压缩列表了？<strong>因为压缩列表的新增、删除的操作平均时间复杂度为O(N)，随着N的增大，时间必然会增加。</strong></p>\n<p><img src=\"/2020/10/03/redis-data-type/3.png\" alt=\"压缩列表\"></p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>zlbytes</td>\n<td>记录整个压缩列表占用的内存字节数</td>\n</tr>\n<tr>\n<td>zltail</td>\n<td>记录压缩列表表尾距离表头起始地址的字节数</td>\n</tr>\n<tr>\n<td>zllen</td>\n<td>记录压缩列表包含的节点数量</td>\n</tr>\n<tr>\n<td>entryN</td>\n<td>节点</td>\n</tr>\n<tr>\n<td>zlend</td>\n<td>用来标记压缩列表的末端</td>\n</tr>\n<tr>\n<td>previous_entry_length</td>\n<td>记录前一个节点的长度</td>\n</tr>\n<tr>\n<td>encoding</td>\n<td>记录节点content属性所保存数据的类型和长度</td>\n</tr>\n<tr>\n<td>content</td>\n<td>保存节点值，可以是字节数组或者整数值</td>\n</tr>\n</tbody></table>\n<h4 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h4><p><img src=\"/2020/10/03/redis-data-type/4.png\" alt=\"链表\"></p>\n<p>链表结构是我们经常用的结构，如图所示。Redis的链表结构是一个<code>双端链表</code>。value的值为一指针，可以用来存储不同类型的值。</p>\n<h3 id=\"Redis基础对象\"><a href=\"#Redis基础对象\" class=\"headerlink\" title=\"Redis基础对象\"></a>Redis基础对象</h3><p>Redis提供了5种对象，这5种对象是通过上面的6种基础结构来实现的。分别是字符串对象，列表对象，哈希对象，集合对象，有序集合对象。Redis的每一种对象都有一个redisObject结构表示。</p>\n<pre><code class=\"c\">typedef struct redisObject{\n    //对象的类型，用来表示是字符串对象，列表对象，哈希对象，集合对象，有序集合对象\n    //可以通过type key 命令返回数据库键对应的值对象的类型\n    unsigned type:4;\n    //对象所是由的编码，也就是使用的是哪个基础结构\n    //可以通过object encoding key 命令返回数据库值对象的编码\n    unsigned encoding:4;\n    //指针指向底层数据结构\n    void *ptr;\n}</code></pre>\n<h4 id=\"字符串对象\"><a href=\"#字符串对象\" class=\"headerlink\" title=\"字符串对象\"></a>字符串对象</h4><p>字符串对象的编码有三种：int，rwa，embstr。</p>\n<ul>\n<li>如果value存的是整数值，那么会使用int编码，且类型是long类型。</li>\n<li>如果value是一个字符串值且长度大于39字节，则使用SDS(简单动态字符串)，编码为raw。</li>\n<li>如果value是一个字符串值且长度小于等于39字节，则使用SDS(简单动态字符串)，编码为embstr（专门用于保存短字符串的一种优化编码方式）。</li>\n</ul>\n<h4 id=\"列表对象\"><a href=\"#列表对象\" class=\"headerlink\" title=\"列表对象\"></a>列表对象</h4><p>列表对象的编码使用的是<code>压缩列表</code>或<code>链表</code>。当列表满足以下两点时采用压缩列表。</p>\n<ul>\n<li>列表对象保存的所有字符串元素长度都小于64字节。</li>\n<li>列表对象保存的元素数量小于512个。</li>\n</ul>\n<p>为啥要转成链表呢，压缩列表本身是为了节约内存设计的，当元素长度太长时会导致压缩列表的连锁更新问题；当元素数量太大时，由于压缩列表结构是连续的内存块组成，对于插入缩小元素没有链表来得性能高。所以当不满足上面两个条件时会使用链表。</p>\n<h4 id=\"哈希对象\"><a href=\"#哈希对象\" class=\"headerlink\" title=\"哈希对象\"></a>哈希对象</h4><p>哈希对象的编码可以是<code>压缩列表</code>或<code>字典</code>。当满足如下条件时采用压缩链表结构。</p>\n<ul>\n<li>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节。</li>\n<li>哈希对象保存的键值对数量小于512个。</li>\n</ul>\n<p><img src=\"/2020/10/03/redis-data-type/5.png\" alt=\"哈希对象使用ziplist存储结构\"></p>\n<p>如果哈希存储的键值对字符串长度小且数量少的情况下使用压缩链表会节约内存空间，但当超过一定量以后，由于压缩列表自身结构的问题会导致性能下降，所以转成用字典结构。</p>\n<h4 id=\"集合对象\"><a href=\"#集合对象\" class=\"headerlink\" title=\"集合对象\"></a>集合对象</h4><p>集合对象的编码可以是<code>整数集合</code>或<code>字典</code>。当满足如下条件时使用整数集合。</p>\n<ul>\n<li>集合对象内的所有元素都是整数。</li>\n<li>集合对象保存的元素个数不超过512个。</li>\n</ul>\n<h4 id=\"有序集合列表\"><a href=\"#有序集合列表\" class=\"headerlink\" title=\"有序集合列表\"></a>有序集合列表</h4><p>有序集合编码可以是<code>压缩列表</code>或<code>跳跃表</code>。当满足如下条件时使用压缩列表</p>\n<ul>\n<li>有序集合保存的元素数量小于128个。</li>\n<li>有序集合保存的所有元素的长度小于64字节。</li>\n</ul>\n<h3 id=\"查看redis数据类型\"><a href=\"#查看redis数据类型\" class=\"headerlink\" title=\"查看redis数据类型\"></a>查看redis数据类型</h3><pre><code>127.0.0.1:6379&gt; lpush list1 1\n(integer) 1\n127.0.0.1:6379&gt; object encoding list1\n&quot;quicklist&quot;\n127.0.0.1:6379&gt; sadd set1 one two three\n(integer) 3\n127.0.0.1:6379&gt; object encoding set1\n&quot;hashtable&quot;\n127.0.0.1:6379&gt; hset hash1 field1 1\n(integer) 1\n127.0.0.1:6379&gt; object encoding hash1\n&quot;ziplist&quot;\n127.0.0.1:6379&gt; set name xuzy\nOK\n127.0.0.1:6379&gt; object encoding name\n&quot;embstr&quot;</code></pre><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p><strong>Redis的数据对象由多种数据结构来实现，主要是出于时间和空间的考虑。由于Redis是单线程和纯内存，当数据量小的时候使用更简单的数据结构，有利于节省内存，提高性能。</strong></p>\n<p>在开发过程我们需要选择合适的数据结构。举个例子。</p>\n<p><strong>例子1</strong></p>\n<p>例如上面分析了字符串的结构，虽然Redis字符串使用SDS提高了性能，但是SDS相比于C语言字符串占用更多空间。SDS结构本身就占用比C语言字符串更多内存，且由于空间预分配，还有可能有没使用的空间浪费。所以我们一定要基于合适场景使用合适的数据结构。所以在使用上，如果我们业务上能用哈希对象的话那会比字符串占用内存更低。</p>\n<hr>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li>《Redis设计与实现》</li>\n<li>一篇完善的Redis结构博客：<a href=\"https://www.cnblogs.com/hunternet/p/12742390.html\" target=\"_blank\" rel=\"noopener\">一文回顾Redis五大对象(数据类型)</a></li>\n</ul>"},{"title":"redis主从复制原理","description":"redis主从复制原理","date":"2020-08-20T01:09:59.000Z","_content":"## Redis主从复制配置\n```\n127.0.0.1:6380> SLAVEOF 127.0.0.1 6379\n#主从心跳ping的时间间隔。默认10\nrepl-ping-replica-period\n#从节点超时时间，默认60\n#三种情况认为复制超时：\n#1）slave角度，如果在repl-timeout时间内没有收到master SYNC传输的rdb snapshot数据，\n#2）slave角度，在repl-timeout没有收到master发送的数据包或者ping。\n#3）master角度，在repl-timeout时间没有收到REPCONF ACK确认信息。\nrepl-timeout\n#主节点保存操作日志的大小。默认1M \nrepl-backlog-size\n#主节点保存操作日志的时间。默认3600秒\nrepl-backlog-ttl\n#这个参数分为3部分，第二部分涉及slave。表示主节点输出给从节点的缓存(output-buffer)大小。默认是：256M 64M 60秒。意思是：如果output-buffer>256M则从节点需要重新全同步，如果256>output-buffer>64且持续时间60秒，则从节点需要重新全同步。\nclient-output-buffer-limit\n```\n\n## 原理详解\n\nredis的复制功能分为**完整重同步**和**部分重同步**两个操作。\n- 完整重同步操作，将从服务器的数据库状态更新至主服务器当前所处的数据库状态，后续进行命令传播。\n- 部分重同步操作，用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，**如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。**\n<!--more-->\n### 完整同步\n\n同步的过程包括如下：\n\n1. 从服务器向主服务器发送PSYNC命令。\n2. 收到SYNC后主服务器执行BGSAVE命令生成RDB文件，期间并使用一个缓冲区记录从现在开始执行的所有写命令。\n3. BGSAVE命令执行完毕后，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器。\n4. 从服务器接收并载入RDB文件，将状态更新与主服务器一致。\n5. 之后正常运行就是将缓冲区记录通过命令传播传播给从服务器。\n\n![完整同步过程](redis-master-slave/2.png)\n\n上面提到的缓冲区（**replication buffer**）用来存放三个时间内所有的master数据更新操作，分别是：\n\n- master生成RDB文件期间内产生的更新操作\n- master发送RDB文件给slave网络传输时间的更新操作\n- slave load rdb文件把数据恢复到内存的时间的更新操作\n\nreplication buffer<font color=red>对应于每个slave</font>，大小由`client-output-buffer-limit slave 256mb 64mb 60`确定。意思是如果该缓冲区的大小超过256M，或该缓冲区的大小超过64M，且持续了60s，主节点会马上断开从节点的连接。<font color=red>所以对于这个值不能设置太小，太小会导致主从复制断开</font>。\n\n### 部分重同步\n\n部分同步用于处理断线后的重新复制。功能由以下三个部分构成：\n\n- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量\n- 主服务器的复制积压缓冲区（replication backlog）\n- 服务器的运行ID（run ID）\n\n![部分重同步](redis-master-slave/3.png)\n\n主从服务器各自维护着一个**复制偏移量**，主服务器每次向从服务器传播N个字节时，都会将自己的复制偏移量加N，从服务器每次接收到N个字节数据后，也会自己的复制偏移量加N。同时主服务器维护着一个**复制积压缓冲区**。当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：\n\n- 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行<font color=red>部分重同步</font>操作。\n- 如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行<font color=red>完整重同步</font>操作，也就是发送SYNC命令，重头到尾生成快照然后发送给从服务器。\n\n### 知识点\n\n#### SYNC命令\n\nSYNC命令是一个非常耗费资源的操作。每次执行SYNC主从服务器需要执行的操作如下：\n\n- 主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。\n- 主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量）\n- 接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从**服务器会因为阻塞而没办法处理命令请求**\n\n<font color=red>SYNC是一个如此消耗资源的命令，所以Redis最好在真需要的时候才需要执行SYNC命令。</font>\n\n#### 复制积压缓冲区\n\n复制积压缓冲区是由主服务器维护的一个<font color=red>固定长度（fixed-size）先进先出（FIFO）队列</font>，默认大小为1MB。当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器（其实是写入到每个slave对应的replication buffer），还会将写命令入队到复制积压缓冲区里面。\n\n| 偏移量 | ...  | 13512 | 13513 | 13514 | 13515 | 13516 | ...  |\n| ------ | ---- | ----- | ----- | ----- | ----- | ----- | ---- |\n| 字节值 | ...  | \\r    | \\n    | $     | S     | E     | ...  |\n\n复制积压缓冲区大小可以通过**repl-backlog-size**进行配置。\n\n```properties\n//支持单位：b、k、kb、m、mb、g、gb，单位不区分大小写，其中k、m、g间的计算倍数是1000，\n//而kb、mb和gb的计算倍数是1024\nrepl-backlog-size 1mb\n//环形缓冲复制队列存活时长（所有slaves不可用时，保留repl_backlog多长时间，单位：秒）\nrepl-backlog-ttl 3600\n```\n\n由于复制积压缓冲区存的是字节，所以当你key-value很大值会占用这个队列。所以一般当key-value较大时需要更改这个默认值。\n\n复制积压缓冲区的最小大小可以根据公式second * write_size_per_second来估算。\n\n- second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）\n- write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）\n\n#### 服务器运行ID\n\n实现部分重同步还需要用到服务器运行ID（run ID）。每个Redis服务器，**不论主服务器还是从服务，都会有自己的运行ID**。\n\n当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来（注意哦，是**从服务器保存了主服务器的ID**）。\n\n当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：\n\n- 如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作；\n- 相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。\n\n#### 复制运维方法\n\n**如何判断主从同步是否正常**\n\n如果`master_repl_offset`减`offset`差不多，则表示主从复制正常。\n\n```\n192.168.1.110:9852> info replication\n# Replication\nrole:master\nconnected_slaves:1\n#offset 表示 salve0的复制偏移量\nslave0:ip=192.168.1.120,port=9853,state=online,offset=375168999754,lag=1\n# master启动时生成的40位16进制的随机字符串，用来标识master节点\nmaster_replid:0ef80af291afbbb7e2f2d6fdbf150281ab1baa6f \nmaster_replid2:0000000000000000000000000000000000000000\n#当前master复制偏移量\nmaster_repl_offset:375168999754      \nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:67108864\nrepl_backlog_first_byte_offset:375101890891\nrepl_backlog_histlen:67108864\n```\n\n#### 两个重要的缓冲区\n\nreplication buffer，master<font color=red>为每个slave建立</font>的缓冲区，用来缓存master执行的命令。例如主库生成RDB和从库加载RDB这段时间增量的命令。他的特点是每个slave都有一个。<font color=red>所以，如果我们是一主多从的话，对内存的损耗也越大，所以控制从节点的数量，也可以控制缓存区对内存的开销</font>。\n\nreplication backlog，复制积压缓冲区。master<font color=red>唯一一份</font>记录最近执行命令和命令对应的偏移量。结构是一个环形队列，后面的命令覆盖前面的命令。当slave由于网络抖动重新连接上master时，会传递自己的offset与replication backlog进行对比来确定执行全部同步还是部分同步。这个值默认是1M，我们需要根据主库写入的速率和主从同步传输的速率差值来适当调大replication backlog的配置。\n\n## 参考\n\n- 《Redis设计与实现》\n- https://www.cnblogs.com/lukexwang/p/4711977.html\n- https://www.cnblogs.com/vansky/p/9293980.html\n- https://blog.csdn.net/a1076067274/article/details/109294208\n- https://www.cnblogs.com/any-way/p/10411567.html\n\n","source":"_posts/redis-master-slave.md","raw":"---\ntitle: redis主从复制原理\ntags:\n  - redis\ncategories: redis\ndescription : redis主从复制原理\ndate: 2020-08-20 09:09:59\n---\n## Redis主从复制配置\n```\n127.0.0.1:6380> SLAVEOF 127.0.0.1 6379\n#主从心跳ping的时间间隔。默认10\nrepl-ping-replica-period\n#从节点超时时间，默认60\n#三种情况认为复制超时：\n#1）slave角度，如果在repl-timeout时间内没有收到master SYNC传输的rdb snapshot数据，\n#2）slave角度，在repl-timeout没有收到master发送的数据包或者ping。\n#3）master角度，在repl-timeout时间没有收到REPCONF ACK确认信息。\nrepl-timeout\n#主节点保存操作日志的大小。默认1M \nrepl-backlog-size\n#主节点保存操作日志的时间。默认3600秒\nrepl-backlog-ttl\n#这个参数分为3部分，第二部分涉及slave。表示主节点输出给从节点的缓存(output-buffer)大小。默认是：256M 64M 60秒。意思是：如果output-buffer>256M则从节点需要重新全同步，如果256>output-buffer>64且持续时间60秒，则从节点需要重新全同步。\nclient-output-buffer-limit\n```\n\n## 原理详解\n\nredis的复制功能分为**完整重同步**和**部分重同步**两个操作。\n- 完整重同步操作，将从服务器的数据库状态更新至主服务器当前所处的数据库状态，后续进行命令传播。\n- 部分重同步操作，用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，**如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。**\n<!--more-->\n### 完整同步\n\n同步的过程包括如下：\n\n1. 从服务器向主服务器发送PSYNC命令。\n2. 收到SYNC后主服务器执行BGSAVE命令生成RDB文件，期间并使用一个缓冲区记录从现在开始执行的所有写命令。\n3. BGSAVE命令执行完毕后，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器。\n4. 从服务器接收并载入RDB文件，将状态更新与主服务器一致。\n5. 之后正常运行就是将缓冲区记录通过命令传播传播给从服务器。\n\n![完整同步过程](redis-master-slave/2.png)\n\n上面提到的缓冲区（**replication buffer**）用来存放三个时间内所有的master数据更新操作，分别是：\n\n- master生成RDB文件期间内产生的更新操作\n- master发送RDB文件给slave网络传输时间的更新操作\n- slave load rdb文件把数据恢复到内存的时间的更新操作\n\nreplication buffer<font color=red>对应于每个slave</font>，大小由`client-output-buffer-limit slave 256mb 64mb 60`确定。意思是如果该缓冲区的大小超过256M，或该缓冲区的大小超过64M，且持续了60s，主节点会马上断开从节点的连接。<font color=red>所以对于这个值不能设置太小，太小会导致主从复制断开</font>。\n\n### 部分重同步\n\n部分同步用于处理断线后的重新复制。功能由以下三个部分构成：\n\n- 主服务器的复制偏移量（replication offset）和从服务器的复制偏移量\n- 主服务器的复制积压缓冲区（replication backlog）\n- 服务器的运行ID（run ID）\n\n![部分重同步](redis-master-slave/3.png)\n\n主从服务器各自维护着一个**复制偏移量**，主服务器每次向从服务器传播N个字节时，都会将自己的复制偏移量加N，从服务器每次接收到N个字节数据后，也会自己的复制偏移量加N。同时主服务器维护着一个**复制积压缓冲区**。当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：\n\n- 如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行<font color=red>部分重同步</font>操作。\n- 如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行<font color=red>完整重同步</font>操作，也就是发送SYNC命令，重头到尾生成快照然后发送给从服务器。\n\n### 知识点\n\n#### SYNC命令\n\nSYNC命令是一个非常耗费资源的操作。每次执行SYNC主从服务器需要执行的操作如下：\n\n- 主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。\n- 主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量）\n- 接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从**服务器会因为阻塞而没办法处理命令请求**\n\n<font color=red>SYNC是一个如此消耗资源的命令，所以Redis最好在真需要的时候才需要执行SYNC命令。</font>\n\n#### 复制积压缓冲区\n\n复制积压缓冲区是由主服务器维护的一个<font color=red>固定长度（fixed-size）先进先出（FIFO）队列</font>，默认大小为1MB。当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器（其实是写入到每个slave对应的replication buffer），还会将写命令入队到复制积压缓冲区里面。\n\n| 偏移量 | ...  | 13512 | 13513 | 13514 | 13515 | 13516 | ...  |\n| ------ | ---- | ----- | ----- | ----- | ----- | ----- | ---- |\n| 字节值 | ...  | \\r    | \\n    | $     | S     | E     | ...  |\n\n复制积压缓冲区大小可以通过**repl-backlog-size**进行配置。\n\n```properties\n//支持单位：b、k、kb、m、mb、g、gb，单位不区分大小写，其中k、m、g间的计算倍数是1000，\n//而kb、mb和gb的计算倍数是1024\nrepl-backlog-size 1mb\n//环形缓冲复制队列存活时长（所有slaves不可用时，保留repl_backlog多长时间，单位：秒）\nrepl-backlog-ttl 3600\n```\n\n由于复制积压缓冲区存的是字节，所以当你key-value很大值会占用这个队列。所以一般当key-value较大时需要更改这个默认值。\n\n复制积压缓冲区的最小大小可以根据公式second * write_size_per_second来估算。\n\n- second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）\n- write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）\n\n#### 服务器运行ID\n\n实现部分重同步还需要用到服务器运行ID（run ID）。每个Redis服务器，**不论主服务器还是从服务，都会有自己的运行ID**。\n\n当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来（注意哦，是**从服务器保存了主服务器的ID**）。\n\n当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：\n\n- 如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作；\n- 相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。\n\n#### 复制运维方法\n\n**如何判断主从同步是否正常**\n\n如果`master_repl_offset`减`offset`差不多，则表示主从复制正常。\n\n```\n192.168.1.110:9852> info replication\n# Replication\nrole:master\nconnected_slaves:1\n#offset 表示 salve0的复制偏移量\nslave0:ip=192.168.1.120,port=9853,state=online,offset=375168999754,lag=1\n# master启动时生成的40位16进制的随机字符串，用来标识master节点\nmaster_replid:0ef80af291afbbb7e2f2d6fdbf150281ab1baa6f \nmaster_replid2:0000000000000000000000000000000000000000\n#当前master复制偏移量\nmaster_repl_offset:375168999754      \nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:67108864\nrepl_backlog_first_byte_offset:375101890891\nrepl_backlog_histlen:67108864\n```\n\n#### 两个重要的缓冲区\n\nreplication buffer，master<font color=red>为每个slave建立</font>的缓冲区，用来缓存master执行的命令。例如主库生成RDB和从库加载RDB这段时间增量的命令。他的特点是每个slave都有一个。<font color=red>所以，如果我们是一主多从的话，对内存的损耗也越大，所以控制从节点的数量，也可以控制缓存区对内存的开销</font>。\n\nreplication backlog，复制积压缓冲区。master<font color=red>唯一一份</font>记录最近执行命令和命令对应的偏移量。结构是一个环形队列，后面的命令覆盖前面的命令。当slave由于网络抖动重新连接上master时，会传递自己的offset与replication backlog进行对比来确定执行全部同步还是部分同步。这个值默认是1M，我们需要根据主库写入的速率和主从同步传输的速率差值来适当调大replication backlog的配置。\n\n## 参考\n\n- 《Redis设计与实现》\n- https://www.cnblogs.com/lukexwang/p/4711977.html\n- https://www.cnblogs.com/vansky/p/9293980.html\n- https://blog.csdn.net/a1076067274/article/details/109294208\n- https://www.cnblogs.com/any-way/p/10411567.html\n\n","slug":"redis-master-slave","published":1,"updated":"2021-04-08T00:47:06.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvn002zqwv28sr9g006","content":"<h2 id=\"Redis主从复制配置\"><a href=\"#Redis主从复制配置\" class=\"headerlink\" title=\"Redis主从复制配置\"></a>Redis主从复制配置</h2><pre><code>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379\n#主从心跳ping的时间间隔。默认10\nrepl-ping-replica-period\n#从节点超时时间，默认60\n#三种情况认为复制超时：\n#1）slave角度，如果在repl-timeout时间内没有收到master SYNC传输的rdb snapshot数据，\n#2）slave角度，在repl-timeout没有收到master发送的数据包或者ping。\n#3）master角度，在repl-timeout时间没有收到REPCONF ACK确认信息。\nrepl-timeout\n#主节点保存操作日志的大小。默认1M \nrepl-backlog-size\n#主节点保存操作日志的时间。默认3600秒\nrepl-backlog-ttl\n#这个参数分为3部分，第二部分涉及slave。表示主节点输出给从节点的缓存(output-buffer)大小。默认是：256M 64M 60秒。意思是：如果output-buffer&gt;256M则从节点需要重新全同步，如果256&gt;output-buffer&gt;64且持续时间60秒，则从节点需要重新全同步。\nclient-output-buffer-limit</code></pre><h2 id=\"原理详解\"><a href=\"#原理详解\" class=\"headerlink\" title=\"原理详解\"></a>原理详解</h2><p>redis的复制功能分为<strong>完整重同步</strong>和<strong>部分重同步</strong>两个操作。</p>\n<ul>\n<li>完整重同步操作，将从服务器的数据库状态更新至主服务器当前所处的数据库状态，后续进行命令传播。</li>\n<li>部分重同步操作，用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，<strong>如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</strong><a id=\"more\"></a>\n<h3 id=\"完整同步\"><a href=\"#完整同步\" class=\"headerlink\" title=\"完整同步\"></a>完整同步</h3></li>\n</ul>\n<p>同步的过程包括如下：</p>\n<ol>\n<li>从服务器向主服务器发送PSYNC命令。</li>\n<li>收到SYNC后主服务器执行BGSAVE命令生成RDB文件，期间并使用一个缓冲区记录从现在开始执行的所有写命令。</li>\n<li>BGSAVE命令执行完毕后，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器。</li>\n<li>从服务器接收并载入RDB文件，将状态更新与主服务器一致。</li>\n<li>之后正常运行就是将缓冲区记录通过命令传播传播给从服务器。</li>\n</ol>\n<p><img src=\"/2020/08/20/redis-master-slave/2.png\" alt=\"完整同步过程\"></p>\n<p>上面提到的缓冲区（<strong>replication buffer</strong>）用来存放三个时间内所有的master数据更新操作，分别是：</p>\n<ul>\n<li>master生成RDB文件期间内产生的更新操作</li>\n<li>master发送RDB文件给slave网络传输时间的更新操作</li>\n<li>slave load rdb文件把数据恢复到内存的时间的更新操作</li>\n</ul>\n<p>replication buffer<font color=\"red\">对应于每个slave</font>，大小由<code>client-output-buffer-limit slave 256mb 64mb 60</code>确定。意思是如果该缓冲区的大小超过256M，或该缓冲区的大小超过64M，且持续了60s，主节点会马上断开从节点的连接。<font color=\"red\">所以对于这个值不能设置太小，太小会导致主从复制断开</font>。</p>\n<h3 id=\"部分重同步\"><a href=\"#部分重同步\" class=\"headerlink\" title=\"部分重同步\"></a>部分重同步</h3><p>部分同步用于处理断线后的重新复制。功能由以下三个部分构成：</p>\n<ul>\n<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li>\n<li>主服务器的复制积压缓冲区（replication backlog）</li>\n<li>服务器的运行ID（run ID）</li>\n</ul>\n<p><img src=\"/2020/08/20/redis-master-slave/3.png\" alt=\"部分重同步\"></p>\n<p>主从服务器各自维护着一个<strong>复制偏移量</strong>，主服务器每次向从服务器传播N个字节时，都会将自己的复制偏移量加N，从服务器每次接收到N个字节数据后，也会自己的复制偏移量加N。同时主服务器维护着一个<strong>复制积压缓冲区</strong>。当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p>\n<ul>\n<li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行<font color=\"red\">部分重同步</font>操作。</li>\n<li>如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行<font color=\"red\">完整重同步</font>操作，也就是发送SYNC命令，重头到尾生成快照然后发送给从服务器。</li>\n</ul>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><h4 id=\"SYNC命令\"><a href=\"#SYNC命令\" class=\"headerlink\" title=\"SYNC命令\"></a>SYNC命令</h4><p>SYNC命令是一个非常耗费资源的操作。每次执行SYNC主从服务器需要执行的操作如下：</p>\n<ul>\n<li>主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。</li>\n<li>主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量）</li>\n<li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从<strong>服务器会因为阻塞而没办法处理命令请求</strong></li>\n</ul>\n<p><font color=\"red\">SYNC是一个如此消耗资源的命令，所以Redis最好在真需要的时候才需要执行SYNC命令。</font></p>\n<h4 id=\"复制积压缓冲区\"><a href=\"#复制积压缓冲区\" class=\"headerlink\" title=\"复制积压缓冲区\"></a>复制积压缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个<font color=\"red\">固定长度（fixed-size）先进先出（FIFO）队列</font>，默认大小为1MB。当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器（其实是写入到每个slave对应的replication buffer），还会将写命令入队到复制积压缓冲区里面。</p>\n<table>\n<thead>\n<tr>\n<th>偏移量</th>\n<th>…</th>\n<th>13512</th>\n<th>13513</th>\n<th>13514</th>\n<th>13515</th>\n<th>13516</th>\n<th>…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>字节值</td>\n<td>…</td>\n<td>\\r</td>\n<td>\\n</td>\n<td>$</td>\n<td>S</td>\n<td>E</td>\n<td>…</td>\n</tr>\n</tbody></table>\n<p>复制积压缓冲区大小可以通过<strong>repl-backlog-size</strong>进行配置。</p>\n<pre class=\" language-properties\"><code class=\"language-properties\">//支持单位：b、k、kb、m、mb、g、gb，单位不区分大小写，其中k、m、g间的计算倍数是1000，\n//而kb、mb和gb的计算倍数是1024\n<span class=\"token attr-name\">repl-backlog-size</span> <span class=\"token attr-value\">1mb</span>\n//环形缓冲复制队列存活时长（所有slaves不可用时，保留repl_backlog多长时间，单位：秒）\n<span class=\"token attr-name\">repl-backlog-ttl</span> <span class=\"token attr-value\">3600</span></code></pre>\n<p>由于复制积压缓冲区存的是字节，所以当你key-value很大值会占用这个队列。所以一般当key-value较大时需要更改这个默认值。</p>\n<p>复制积压缓冲区的最小大小可以根据公式second * write_size_per_second来估算。</p>\n<ul>\n<li>second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）</li>\n<li>write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）</li>\n</ul>\n<h4 id=\"服务器运行ID\"><a href=\"#服务器运行ID\" class=\"headerlink\" title=\"服务器运行ID\"></a>服务器运行ID</h4><p>实现部分重同步还需要用到服务器运行ID（run ID）。每个Redis服务器，<strong>不论主服务器还是从服务，都会有自己的运行ID</strong>。</p>\n<p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来（注意哦，是<strong>从服务器保存了主服务器的ID</strong>）。</p>\n<p>当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：</p>\n<ul>\n<li>如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作；</li>\n<li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。</li>\n</ul>\n<h4 id=\"复制运维方法\"><a href=\"#复制运维方法\" class=\"headerlink\" title=\"复制运维方法\"></a>复制运维方法</h4><p><strong>如何判断主从同步是否正常</strong></p>\n<p>如果<code>master_repl_offset</code>减<code>offset</code>差不多，则表示主从复制正常。</p>\n<pre><code>192.168.1.110:9852&gt; info replication\n# Replication\nrole:master\nconnected_slaves:1\n#offset 表示 salve0的复制偏移量\nslave0:ip=192.168.1.120,port=9853,state=online,offset=375168999754,lag=1\n# master启动时生成的40位16进制的随机字符串，用来标识master节点\nmaster_replid:0ef80af291afbbb7e2f2d6fdbf150281ab1baa6f \nmaster_replid2:0000000000000000000000000000000000000000\n#当前master复制偏移量\nmaster_repl_offset:375168999754      \nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:67108864\nrepl_backlog_first_byte_offset:375101890891\nrepl_backlog_histlen:67108864</code></pre><h4 id=\"两个重要的缓冲区\"><a href=\"#两个重要的缓冲区\" class=\"headerlink\" title=\"两个重要的缓冲区\"></a>两个重要的缓冲区</h4><p>replication buffer，master<font color=\"red\">为每个slave建立</font>的缓冲区，用来缓存master执行的命令。例如主库生成RDB和从库加载RDB这段时间增量的命令。他的特点是每个slave都有一个。<font color=\"red\">所以，如果我们是一主多从的话，对内存的损耗也越大，所以控制从节点的数量，也可以控制缓存区对内存的开销</font>。</p>\n<p>replication backlog，复制积压缓冲区。master<font color=\"red\">唯一一份</font>记录最近执行命令和命令对应的偏移量。结构是一个环形队列，后面的命令覆盖前面的命令。当slave由于网络抖动重新连接上master时，会传递自己的offset与replication backlog进行对比来确定执行全部同步还是部分同步。这个值默认是1M，我们需要根据主库写入的速率和主从同步传输的速率差值来适当调大replication backlog的配置。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《Redis设计与实现》</li>\n<li><a href=\"https://www.cnblogs.com/lukexwang/p/4711977.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lukexwang/p/4711977.html</a></li>\n<li><a href=\"https://www.cnblogs.com/vansky/p/9293980.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/vansky/p/9293980.html</a></li>\n<li><a href=\"https://blog.csdn.net/a1076067274/article/details/109294208\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/a1076067274/article/details/109294208</a></li>\n<li><a href=\"https://www.cnblogs.com/any-way/p/10411567.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/any-way/p/10411567.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Redis主从复制配置\"><a href=\"#Redis主从复制配置\" class=\"headerlink\" title=\"Redis主从复制配置\"></a>Redis主从复制配置</h2><pre><code>127.0.0.1:6380&gt; SLAVEOF 127.0.0.1 6379\n#主从心跳ping的时间间隔。默认10\nrepl-ping-replica-period\n#从节点超时时间，默认60\n#三种情况认为复制超时：\n#1）slave角度，如果在repl-timeout时间内没有收到master SYNC传输的rdb snapshot数据，\n#2）slave角度，在repl-timeout没有收到master发送的数据包或者ping。\n#3）master角度，在repl-timeout时间没有收到REPCONF ACK确认信息。\nrepl-timeout\n#主节点保存操作日志的大小。默认1M \nrepl-backlog-size\n#主节点保存操作日志的时间。默认3600秒\nrepl-backlog-ttl\n#这个参数分为3部分，第二部分涉及slave。表示主节点输出给从节点的缓存(output-buffer)大小。默认是：256M 64M 60秒。意思是：如果output-buffer&gt;256M则从节点需要重新全同步，如果256&gt;output-buffer&gt;64且持续时间60秒，则从节点需要重新全同步。\nclient-output-buffer-limit</code></pre><h2 id=\"原理详解\"><a href=\"#原理详解\" class=\"headerlink\" title=\"原理详解\"></a>原理详解</h2><p>redis的复制功能分为<strong>完整重同步</strong>和<strong>部分重同步</strong>两个操作。</p>\n<ul>\n<li>完整重同步操作，将从服务器的数据库状态更新至主服务器当前所处的数据库状态，后续进行命令传播。</li>\n<li>部分重同步操作，用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，<strong>如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</strong></li></ul>","more":"<h3 id=\"完整同步\"><a href=\"#完整同步\" class=\"headerlink\" title=\"完整同步\"></a>完整同步</h3>\n\n<p>同步的过程包括如下：</p>\n<ol>\n<li>从服务器向主服务器发送PSYNC命令。</li>\n<li>收到SYNC后主服务器执行BGSAVE命令生成RDB文件，期间并使用一个缓冲区记录从现在开始执行的所有写命令。</li>\n<li>BGSAVE命令执行完毕后，主服务器会将BGSAVE命令生成的RDB文件发送给从服务器。</li>\n<li>从服务器接收并载入RDB文件，将状态更新与主服务器一致。</li>\n<li>之后正常运行就是将缓冲区记录通过命令传播传播给从服务器。</li>\n</ol>\n<p><img src=\"/2020/08/20/redis-master-slave/2.png\" alt=\"完整同步过程\"></p>\n<p>上面提到的缓冲区（<strong>replication buffer</strong>）用来存放三个时间内所有的master数据更新操作，分别是：</p>\n<ul>\n<li>master生成RDB文件期间内产生的更新操作</li>\n<li>master发送RDB文件给slave网络传输时间的更新操作</li>\n<li>slave load rdb文件把数据恢复到内存的时间的更新操作</li>\n</ul>\n<p>replication buffer<font color=\"red\">对应于每个slave</font>，大小由<code>client-output-buffer-limit slave 256mb 64mb 60</code>确定。意思是如果该缓冲区的大小超过256M，或该缓冲区的大小超过64M，且持续了60s，主节点会马上断开从节点的连接。<font color=\"red\">所以对于这个值不能设置太小，太小会导致主从复制断开</font>。</p>\n<h3 id=\"部分重同步\"><a href=\"#部分重同步\" class=\"headerlink\" title=\"部分重同步\"></a>部分重同步</h3><p>部分同步用于处理断线后的重新复制。功能由以下三个部分构成：</p>\n<ul>\n<li>主服务器的复制偏移量（replication offset）和从服务器的复制偏移量</li>\n<li>主服务器的复制积压缓冲区（replication backlog）</li>\n<li>服务器的运行ID（run ID）</li>\n</ul>\n<p><img src=\"/2020/08/20/redis-master-slave/3.png\" alt=\"部分重同步\"></p>\n<p>主从服务器各自维护着一个<strong>复制偏移量</strong>，主服务器每次向从服务器传播N个字节时，都会将自己的复制偏移量加N，从服务器每次接收到N个字节数据后，也会自己的复制偏移量加N。同时主服务器维护着一个<strong>复制积压缓冲区</strong>。当从服务器重新连上主服务器时，从服务器会通过PSYNC命令将自己的复制偏移量offset发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作：</p>\n<ul>\n<li>如果offset偏移量之后的数据（也即是偏移量offset+1开始的数据）仍然存在于复制积压缓冲区里面，那么主服务器将对从服务器执行<font color=\"red\">部分重同步</font>操作。</li>\n<li>如果offset偏移量之后的数据已经不存在于复制积压缓冲区，那么主服务器将对从服务器执行<font color=\"red\">完整重同步</font>操作，也就是发送SYNC命令，重头到尾生成快照然后发送给从服务器。</li>\n</ul>\n<h3 id=\"知识点\"><a href=\"#知识点\" class=\"headerlink\" title=\"知识点\"></a>知识点</h3><h4 id=\"SYNC命令\"><a href=\"#SYNC命令\" class=\"headerlink\" title=\"SYNC命令\"></a>SYNC命令</h4><p>SYNC命令是一个非常耗费资源的操作。每次执行SYNC主从服务器需要执行的操作如下：</p>\n<ul>\n<li>主服务器需要执行BGSAVE命令来生成RDB文件，这个生成操作会耗费主服务器大量的CPU、内存和磁盘I/O资源。</li>\n<li>主服务器需要将自己生成的RDB文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源（带宽和流量）</li>\n<li>接收到RDB文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从<strong>服务器会因为阻塞而没办法处理命令请求</strong></li>\n</ul>\n<p><font color=\"red\">SYNC是一个如此消耗资源的命令，所以Redis最好在真需要的时候才需要执行SYNC命令。</font></p>\n<h4 id=\"复制积压缓冲区\"><a href=\"#复制积压缓冲区\" class=\"headerlink\" title=\"复制积压缓冲区\"></a>复制积压缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个<font color=\"red\">固定长度（fixed-size）先进先出（FIFO）队列</font>，默认大小为1MB。当入队元素的数量大于队列长度时，最先入队的元素会被弹出，而新元素会被放入队列。当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器（其实是写入到每个slave对应的replication buffer），还会将写命令入队到复制积压缓冲区里面。</p>\n<table>\n<thead>\n<tr>\n<th>偏移量</th>\n<th>…</th>\n<th>13512</th>\n<th>13513</th>\n<th>13514</th>\n<th>13515</th>\n<th>13516</th>\n<th>…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>字节值</td>\n<td>…</td>\n<td>\\r</td>\n<td>\\n</td>\n<td>$</td>\n<td>S</td>\n<td>E</td>\n<td>…</td>\n</tr>\n</tbody></table>\n<p>复制积压缓冲区大小可以通过<strong>repl-backlog-size</strong>进行配置。</p>\n<pre><code class=\"properties\">//支持单位：b、k、kb、m、mb、g、gb，单位不区分大小写，其中k、m、g间的计算倍数是1000，\n//而kb、mb和gb的计算倍数是1024\nrepl-backlog-size 1mb\n//环形缓冲复制队列存活时长（所有slaves不可用时，保留repl_backlog多长时间，单位：秒）\nrepl-backlog-ttl 3600</code></pre>\n<p>由于复制积压缓冲区存的是字节，所以当你key-value很大值会占用这个队列。所以一般当key-value较大时需要更改这个默认值。</p>\n<p>复制积压缓冲区的最小大小可以根据公式second * write_size_per_second来估算。</p>\n<ul>\n<li>second为从服务器断线后重新连接上主服务器所需的平均时间（以秒计算）</li>\n<li>write_size_per_second则是主服务器平均每秒产生的写命令数据量（协议格式的写命令的长度总和）</li>\n</ul>\n<h4 id=\"服务器运行ID\"><a href=\"#服务器运行ID\" class=\"headerlink\" title=\"服务器运行ID\"></a>服务器运行ID</h4><p>实现部分重同步还需要用到服务器运行ID（run ID）。每个Redis服务器，<strong>不论主服务器还是从服务，都会有自己的运行ID</strong>。</p>\n<p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器，而从服务器则会将这个运行ID保存起来（注意哦，是<strong>从服务器保存了主服务器的ID</strong>）。</p>\n<p>当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行ID：</p>\n<ul>\n<li>如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作；</li>\n<li>相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作。</li>\n</ul>\n<h4 id=\"复制运维方法\"><a href=\"#复制运维方法\" class=\"headerlink\" title=\"复制运维方法\"></a>复制运维方法</h4><p><strong>如何判断主从同步是否正常</strong></p>\n<p>如果<code>master_repl_offset</code>减<code>offset</code>差不多，则表示主从复制正常。</p>\n<pre><code>192.168.1.110:9852&gt; info replication\n# Replication\nrole:master\nconnected_slaves:1\n#offset 表示 salve0的复制偏移量\nslave0:ip=192.168.1.120,port=9853,state=online,offset=375168999754,lag=1\n# master启动时生成的40位16进制的随机字符串，用来标识master节点\nmaster_replid:0ef80af291afbbb7e2f2d6fdbf150281ab1baa6f \nmaster_replid2:0000000000000000000000000000000000000000\n#当前master复制偏移量\nmaster_repl_offset:375168999754      \nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:67108864\nrepl_backlog_first_byte_offset:375101890891\nrepl_backlog_histlen:67108864</code></pre><h4 id=\"两个重要的缓冲区\"><a href=\"#两个重要的缓冲区\" class=\"headerlink\" title=\"两个重要的缓冲区\"></a>两个重要的缓冲区</h4><p>replication buffer，master<font color=\"red\">为每个slave建立</font>的缓冲区，用来缓存master执行的命令。例如主库生成RDB和从库加载RDB这段时间增量的命令。他的特点是每个slave都有一个。<font color=\"red\">所以，如果我们是一主多从的话，对内存的损耗也越大，所以控制从节点的数量，也可以控制缓存区对内存的开销</font>。</p>\n<p>replication backlog，复制积压缓冲区。master<font color=\"red\">唯一一份</font>记录最近执行命令和命令对应的偏移量。结构是一个环形队列，后面的命令覆盖前面的命令。当slave由于网络抖动重新连接上master时，会传递自己的offset与replication backlog进行对比来确定执行全部同步还是部分同步。这个值默认是1M，我们需要根据主库写入的速率和主从同步传输的速率差值来适当调大replication backlog的配置。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li>《Redis设计与实现》</li>\n<li><a href=\"https://www.cnblogs.com/lukexwang/p/4711977.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/lukexwang/p/4711977.html</a></li>\n<li><a href=\"https://www.cnblogs.com/vansky/p/9293980.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/vansky/p/9293980.html</a></li>\n<li><a href=\"https://blog.csdn.net/a1076067274/article/details/109294208\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/a1076067274/article/details/109294208</a></li>\n<li><a href=\"https://www.cnblogs.com/any-way/p/10411567.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/any-way/p/10411567.html</a></li>\n</ul>"},{"title":"Redis知识点扫盲","description":"Redis知识点扫盲","date":"2020-12-17T11:54:37.000Z","_content":"### Redis内存划分\n\n直接上图\n\n![Redis内存划划分](redis-known/1.png)\n\n### Redis过期策略和内存淘汰\n\n#### 过期策略\n\n你Redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的？这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?\n\nRedis采用的是**定期删除** + **惰性删除策略**。\n\n**定期删除**指的是，Redis默认每个100ms检查是否有过期的Key，有过期Key则删除。需要说明的是，Redis不是每个100ms将所有的Key检查一次，而是随机抽取进行检查（如果每隔100ms，全部Key进行检查，Redis岂不是卡死）。因此，如果只采用定期删除策略，会导致很多Key到时间没有删除。\n\n**惰性删除**指的是你获取某个Key的时候，Redis会检查一下，这个Key如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。\n\n#### 淘汰策略\n\n如果定期删除没删除Key。然后你也没及时去请求Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高，那么就应该采用内存淘汰机制。\n\n```\nmaxmemory-policy volatile-lru\n```\n\n- Noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人使用吧；\n- Allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除<font color=red>最近最少使用</font>的Key。推荐使用，目前项目在用这种；\n- Allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，应该也没人使用吧；\n- Volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的Key。这种情况一般是把Redis既当缓存又做持久化存储的时候才用。不推荐；\n- Volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<font color=red>随机</font>移除某个Key。依然不推荐；\n- Volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的Key优先移除。不推荐。\n- volatite-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 （Redis4.0新加的）\n- allkeys-lfu：从所有键中驱逐使用频率最少的键（Redis4.0新加的）\n\n### Redis缓存问题\n\n![](redis-known/2.png)","source":"_posts/redis-known.md","raw":"---\ntitle: Redis知识点扫盲\ntags:\n  - redis\ncategories: redis\ndescription : Redis知识点扫盲\ndate: 2020-12-17 19:54:37\n---\n### Redis内存划分\n\n直接上图\n\n![Redis内存划划分](redis-known/1.png)\n\n### Redis过期策略和内存淘汰\n\n#### 过期策略\n\n你Redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的？这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?\n\nRedis采用的是**定期删除** + **惰性删除策略**。\n\n**定期删除**指的是，Redis默认每个100ms检查是否有过期的Key，有过期Key则删除。需要说明的是，Redis不是每个100ms将所有的Key检查一次，而是随机抽取进行检查（如果每隔100ms，全部Key进行检查，Redis岂不是卡死）。因此，如果只采用定期删除策略，会导致很多Key到时间没有删除。\n\n**惰性删除**指的是你获取某个Key的时候，Redis会检查一下，这个Key如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。\n\n#### 淘汰策略\n\n如果定期删除没删除Key。然后你也没及时去请求Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高，那么就应该采用内存淘汰机制。\n\n```\nmaxmemory-policy volatile-lru\n```\n\n- Noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人使用吧；\n- Allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除<font color=red>最近最少使用</font>的Key。推荐使用，目前项目在用这种；\n- Allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，应该也没人使用吧；\n- Volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的Key。这种情况一般是把Redis既当缓存又做持久化存储的时候才用。不推荐；\n- Volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<font color=red>随机</font>移除某个Key。依然不推荐；\n- Volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的Key优先移除。不推荐。\n- volatite-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 （Redis4.0新加的）\n- allkeys-lfu：从所有键中驱逐使用频率最少的键（Redis4.0新加的）\n\n### Redis缓存问题\n\n![](redis-known/2.png)","slug":"redis-known","published":1,"updated":"2021-04-08T00:47:06.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvp0033qwv2cm36d9tz","content":"<h3 id=\"Redis内存划分\"><a href=\"#Redis内存划分\" class=\"headerlink\" title=\"Redis内存划分\"></a>Redis内存划分</h3><p>直接上图</p>\n<p><img src=\"/2020/12/17/redis-known/1.png\" alt=\"Redis内存划划分\"></p>\n<h3 id=\"Redis过期策略和内存淘汰\"><a href=\"#Redis过期策略和内存淘汰\" class=\"headerlink\" title=\"Redis过期策略和内存淘汰\"></a>Redis过期策略和内存淘汰</h3><h4 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h4><p>你Redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的？这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p>\n<p>Redis采用的是<strong>定期删除</strong> + <strong>惰性删除策略</strong>。</p>\n<p><strong>定期删除</strong>指的是，Redis默认每个100ms检查是否有过期的Key，有过期Key则删除。需要说明的是，Redis不是每个100ms将所有的Key检查一次，而是随机抽取进行检查（如果每隔100ms，全部Key进行检查，Redis岂不是卡死）。因此，如果只采用定期删除策略，会导致很多Key到时间没有删除。</p>\n<p><strong>惰性删除</strong>指的是你获取某个Key的时候，Redis会检查一下，这个Key如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。</p>\n<h4 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h4><p>如果定期删除没删除Key。然后你也没及时去请求Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高，那么就应该采用内存淘汰机制。</p>\n<pre><code>maxmemory-policy volatile-lru</code></pre><ul>\n<li>Noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人使用吧；</li>\n<li>Allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除<font color=\"red\">最近最少使用</font>的Key。推荐使用，目前项目在用这种；</li>\n<li>Allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，应该也没人使用吧；</li>\n<li>Volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的Key。这种情况一般是把Redis既当缓存又做持久化存储的时候才用。不推荐；</li>\n<li>Volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<font color=\"red\">随机</font>移除某个Key。依然不推荐；</li>\n<li>Volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的Key优先移除。不推荐。</li>\n<li>volatite-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 （Redis4.0新加的）</li>\n<li>allkeys-lfu：从所有键中驱逐使用频率最少的键（Redis4.0新加的）</li>\n</ul>\n<h3 id=\"Redis缓存问题\"><a href=\"#Redis缓存问题\" class=\"headerlink\" title=\"Redis缓存问题\"></a>Redis缓存问题</h3><p><img src=\"/2020/12/17/redis-known/2.png\" alt></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Redis内存划分\"><a href=\"#Redis内存划分\" class=\"headerlink\" title=\"Redis内存划分\"></a>Redis内存划分</h3><p>直接上图</p>\n<p><img src=\"/2020/12/17/redis-known/1.png\" alt=\"Redis内存划划分\"></p>\n<h3 id=\"Redis过期策略和内存淘汰\"><a href=\"#Redis过期策略和内存淘汰\" class=\"headerlink\" title=\"Redis过期策略和内存淘汰\"></a>Redis过期策略和内存淘汰</h3><h4 id=\"过期策略\"><a href=\"#过期策略\" class=\"headerlink\" title=\"过期策略\"></a>过期策略</h4><p>你Redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的？这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?</p>\n<p>Redis采用的是<strong>定期删除</strong> + <strong>惰性删除策略</strong>。</p>\n<p><strong>定期删除</strong>指的是，Redis默认每个100ms检查是否有过期的Key，有过期Key则删除。需要说明的是，Redis不是每个100ms将所有的Key检查一次，而是随机抽取进行检查（如果每隔100ms，全部Key进行检查，Redis岂不是卡死）。因此，如果只采用定期删除策略，会导致很多Key到时间没有删除。</p>\n<p><strong>惰性删除</strong>指的是你获取某个Key的时候，Redis会检查一下，这个Key如果设置了过期时间，那么是否过期了？如果过期了此时就会删除。</p>\n<h4 id=\"淘汰策略\"><a href=\"#淘汰策略\" class=\"headerlink\" title=\"淘汰策略\"></a>淘汰策略</h4><p>如果定期删除没删除Key。然后你也没及时去请求Key，也就是说惰性删除也没生效。这样，Redis的内存会越来越高，那么就应该采用内存淘汰机制。</p>\n<pre><code>maxmemory-policy volatile-lru</code></pre><ul>\n<li>Noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人使用吧；</li>\n<li>Allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除<font color=\"red\">最近最少使用</font>的Key。推荐使用，目前项目在用这种；</li>\n<li>Allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key，应该也没人使用吧；</li>\n<li>Volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的Key。这种情况一般是把Redis既当缓存又做持久化存储的时候才用。不推荐；</li>\n<li>Volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，<font color=\"red\">随机</font>移除某个Key。依然不推荐；</li>\n<li>Volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的Key优先移除。不推荐。</li>\n<li>volatite-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键 （Redis4.0新加的）</li>\n<li>allkeys-lfu：从所有键中驱逐使用频率最少的键（Redis4.0新加的）</li>\n</ul>\n<h3 id=\"Redis缓存问题\"><a href=\"#Redis缓存问题\" class=\"headerlink\" title=\"Redis缓存问题\"></a>Redis缓存问题</h3><p><img src=\"/2020/12/17/redis-known/2.png\" alt></p>\n"},{"title":"redis持久化详解RDB,AOP","description":"redis持久化详解RDB,AOP","date":"2020-08-26T06:43:31.000Z","_content":"\n## Redis两种持久化方案\n\n- RDB方式，生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dumpr.rdb。\n- AOF方式，记录 Redis 除了查询以外的所有写命令，即对内存中数据进行修改的指令记录。\n<!--more-->\n## RDB持久化\n\n### RDB介绍和使用\n- RDB是一种<font color=red>快照模式</font>。保存的是 key-value数据内容。\n- RDB有两种持久化方式即**同步save模式**和**异步bgsave模式**。\n  - 同步模式下阻塞其他命令执行持久化生成rdb文件，不会有一致性问题。\n  - 异步模式下fork一个子进程执行持久化生成rdb文件，不会阻塞其他命令，会有一致性问题。\n- 默认执行 shutdown 时，如果没有开启 AOF，则自动执行 bgsave。\n- 每次的 RDB 文件都是替换的。所以在实际应用上可以通过shell脚本定时备份这个RDB文件。\n\nRedis默认开启RDB持久化方式，通过配置redis.conf\n\n```properties\nsave 900 1\nsave 300 10\nsave 60 10000\n#900秒之内，如果超过1个key被修改，则发起快照保存；\n#300秒之内，如果超过10个key被修改，则发起快照保存；\n#60秒之内，如果1万个key被修改，则发起快照保存；\n```\n\n### bgsave方式持久化\n\n![](redis-master-slave/1.png)\n\n1. Redis 调用 fork() ，同时拥有父进程和子进程。\n2. 子进程将数据集写入到一个临时RDB文件中。\n3. 当子进程完成对新 RDB 文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。\n\n引出问题 ：<font color=red>在bgsave期间子进程正在持久化一个很大的数据结构K时，这时候父进程收到了删除这个数据结构K的命令，这时候redis该怎么办？</font>\n\nredis使用操作系统的多进程<font color=red>COW机制(Copy On Write)</font>机制来实现快照的持久化。子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，这是Linux操作系统的机制，为了节约内存资源，所以尽可能让父子进程共享内存，这样在进程分离的一瞬间，内存的增长几乎没有明显变化。\n\n当子进程进行持久化时父进程收到了写请求，那么会把需要处理的一部分复制一份到内存，对复制后的数据进行修改，所以即使对某个数据进行了修改，redis持久化到RDB中的数据也是未修改的数据。实际上，内存中的全量数据由一个个的\"数据段页面\"组成，每个数据段页面的大小为4K，客户端要修改的数据在哪个页面中，就会复制一份这个页面到内存中。在持久化过程中，随着分离出的页面越来越多，内存就会持续增长，但是不会超过原内存的2倍，因为在一次持久化的过程中，几乎不会出现所有的页面都会分离的情况，读写请求针对的只是原数据中的小部分，大部分redis数据还是\"冷数据\"。<font color=red>所以在执行持久化时就已经快照好了那一瞬间的数据，以后的更改并不会影响持久化</font>。\n\n### 优缺点\n\n**优点**\n\n- 文件紧凑，适合备份，全量复制场景。\n- Redis 加载 RDB 恢复数据远远快于 AOF。\n\n**缺点**\n\n- 无法秒级持久化。\n- 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。\n\n### 问题\n\n**一道面试题 ：假设服务器的内存8g，redis父进程占用了6g，子进程fork父进程后，子父进程总共占用内存12g，如何解决内存不足的问题？**\n\n首先正常来说fork的子线程是不会使得内存翻倍的。因为Redis的RDB方式是采用COW(Copy On Write)机制的，子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，所以fork进程出来的时候内存几乎不变。如果此时有操作命令进来更新数据，此时只会将存这个要更新的数据对应的4K页面复制一份出来进行修改，那此时内存确实增加了一点。但正常情况下不会每个4K页面都复制一份出来更改，所以fork进程后内存只会增加一点但不会很多。\n\n## AOF持久化\n\n### AOF介绍和使用\n\n- AOF持久化时记录的是命令，每一个写命令都通过write函数追加到appendonly.aof文件中。\n- AOF默认是关闭的，需要通过appendfsync配置开启\n- AOF 每次保存的写命令都放在一个缓冲区，根据不同的策略（下面详细说）同步到磁盘\n- AOF 由于每次都会记录写命令，文件会很大，因此需要进行优化，称之为“重写机制”\n- AOF可以通过命令bgrewriteaof进行重写\n\nAOF配置：\n\n```\n# 是否开启AOF持久化\nappendonly yes\n# 由系统决定什么时候写入AOF\nappendfsync no \n#每次有数据修改发生时都会写入AOF文件。原理是每次来操作命令都执行 fsync 函数，直到同步到硬盘返回\nappendfsync always \n#每秒钟同步一次，该策略为AOF的缺省策略。先调用 OS write 函数， 写到缓冲区，然后 redis 每秒执行一次 OS fsync 函数\nappendfsync everysec \n```\n\n### aof过程\n\n当redis收到客户端操作指令后，先进行参数校验。如果校验通过则将操作指令写到操作系统的内存缓存中并执行该指令。到了一定时间后操作系统内核会异步地把内存缓存中的redis操作指令刷写到AOF文件中。也可以通过glibc函数库提供的fsync()函数将指定文件的内容强制从内存缓存中刷写到磁盘上。\n\n### bgrewriteaof重写\n\n![](redis-rdb-aop/2.png)\n\n1. 开始bgrewriteaof，判断当前有没有bgsave命令(RDB持久化)/bgrewriteaof在执行，倘若有，则这些命令执行完成以后再执行。\n2. 主进程fork出子进程，在这一个短暂的时间内，redis是阻塞的。\n3. 主进程fork完子进程继续接受客户端请求，所有写命令依然写入AOF文件缓冲区并根据appendfsync策略同步到磁盘，保证原有AOF文件完整和正确。由于fork的子进程仅仅只共享主进程fork时的内存，因此Redis使用采用重写缓冲区(aof_rewrite_buf)机制保存fork之后的客户端的写请求，防止新AOF文件生成期间丢失这部分数据。此时，客户端的写请求不仅仅写入原来aof_buf缓冲，还写入重写缓冲区(aof_rewrite_buf)。\n4. 子进程通过内存快照，按照命令重写策略写入到新的AOF文件。\n   - 子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。\n   - 主进程把aof_rewrite_buf中的数据写入到新的AOF文件。\n5. 使用新的AOF文件覆盖旧的AOF文件，标志AOF重写完成。\n\n可以看出整个重写过程是安全的。因为 Redis 重写是创建新AOF文件，重写的过程中会继续将命令追加到现有旧的 AOF 文件里面，即使重写过程中发生停机，现有旧的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。\n\n**AOF重写机制的触发条件**：\n\n- 手动触发：客户端执行bgrewriteaof命令。\n- 自动触发：自动触发通过以下两个配置协作生效，auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage\n\n```properties\n#AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写，4.0默认配置64mb\nauto-aof-rewrite-min-size 64mb\n#当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，\n#如100代表当前AOF文件是上次重写的两倍时候才重写\nauto-aof-rewrite-percentage 100\n```\n\n### 优缺点\n\n- 速度快，秒级持久化。恢复数据时能实现全部数据恢复。\n- AOF 文件的体积通常要大于 RDB 文件的体积。\n- 恢复速速慢。\n\n### 启动时优先使用AOF恢复\n\n![](redis-rdb-aop/3.png)\n\n## 混合持久化\n\n混合持久化是Redis 4.0才有的功能。混合持久化同样也是通过bgrewriteaof完成的。\n\n**混合持久化过程**：\n\n1. fork出的子进程先将共享的内存副本以RDB方式写入AOF文件。\n2. 然后在将重写缓冲区的增量命令以AOF方式写入到文件。\n3. 写入完成后通知主进程更新统计信息，并将新的AOF文件替换旧的的AOF文件。\n\n使用混合持久化后，Redis<font color=red>依然优先加载AOF文件</font>。可能有两种情况：\n\n- AOF文件开头是RDB的格式，先加载RDB部分的内容，再加载剩余的AOF\n- AOF文件开头不是RDB的格式，直接加载整个AOF文件\n\n混合持久化需要配置上确认是否开启\n\n```properties\n#yes表示开启混合持久化，默认是开启的\naof-use-rdb-preamble yes\n```\n\n## 参考\n\n- https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452965797&idx=1&sn=dc1cc6dad0d589148d5d6147705cfc38&chksm=88ede4cdbf9a6ddb775e3861ce6fc9a50eefe2d00eed69877e5ecf9cef94a6342fecaa3979c2&scene=21#wechat_redirect\n- https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452965876&idx=1&sn=8e652ab31b628af89b275cf8f25544ef&chksm=88ede49cbf9a6d8a10231e1dde14976a6cfdfd08778783bfede076c935158895fa99159ec754&scene=21#wechat_redirect","source":"_posts/redis-rdb-aop.md","raw":"---\ntitle: redis持久化详解RDB,AOP\ntags:\n  - redis\ncategories: redis\ndescription : redis持久化详解RDB,AOP\ndate: 2020-08-26 14:43:31\n---\n\n## Redis两种持久化方案\n\n- RDB方式，生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dumpr.rdb。\n- AOF方式，记录 Redis 除了查询以外的所有写命令，即对内存中数据进行修改的指令记录。\n<!--more-->\n## RDB持久化\n\n### RDB介绍和使用\n- RDB是一种<font color=red>快照模式</font>。保存的是 key-value数据内容。\n- RDB有两种持久化方式即**同步save模式**和**异步bgsave模式**。\n  - 同步模式下阻塞其他命令执行持久化生成rdb文件，不会有一致性问题。\n  - 异步模式下fork一个子进程执行持久化生成rdb文件，不会阻塞其他命令，会有一致性问题。\n- 默认执行 shutdown 时，如果没有开启 AOF，则自动执行 bgsave。\n- 每次的 RDB 文件都是替换的。所以在实际应用上可以通过shell脚本定时备份这个RDB文件。\n\nRedis默认开启RDB持久化方式，通过配置redis.conf\n\n```properties\nsave 900 1\nsave 300 10\nsave 60 10000\n#900秒之内，如果超过1个key被修改，则发起快照保存；\n#300秒之内，如果超过10个key被修改，则发起快照保存；\n#60秒之内，如果1万个key被修改，则发起快照保存；\n```\n\n### bgsave方式持久化\n\n![](redis-master-slave/1.png)\n\n1. Redis 调用 fork() ，同时拥有父进程和子进程。\n2. 子进程将数据集写入到一个临时RDB文件中。\n3. 当子进程完成对新 RDB 文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。\n\n引出问题 ：<font color=red>在bgsave期间子进程正在持久化一个很大的数据结构K时，这时候父进程收到了删除这个数据结构K的命令，这时候redis该怎么办？</font>\n\nredis使用操作系统的多进程<font color=red>COW机制(Copy On Write)</font>机制来实现快照的持久化。子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，这是Linux操作系统的机制，为了节约内存资源，所以尽可能让父子进程共享内存，这样在进程分离的一瞬间，内存的增长几乎没有明显变化。\n\n当子进程进行持久化时父进程收到了写请求，那么会把需要处理的一部分复制一份到内存，对复制后的数据进行修改，所以即使对某个数据进行了修改，redis持久化到RDB中的数据也是未修改的数据。实际上，内存中的全量数据由一个个的\"数据段页面\"组成，每个数据段页面的大小为4K，客户端要修改的数据在哪个页面中，就会复制一份这个页面到内存中。在持久化过程中，随着分离出的页面越来越多，内存就会持续增长，但是不会超过原内存的2倍，因为在一次持久化的过程中，几乎不会出现所有的页面都会分离的情况，读写请求针对的只是原数据中的小部分，大部分redis数据还是\"冷数据\"。<font color=red>所以在执行持久化时就已经快照好了那一瞬间的数据，以后的更改并不会影响持久化</font>。\n\n### 优缺点\n\n**优点**\n\n- 文件紧凑，适合备份，全量复制场景。\n- Redis 加载 RDB 恢复数据远远快于 AOF。\n\n**缺点**\n\n- 无法秒级持久化。\n- 每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。\n\n### 问题\n\n**一道面试题 ：假设服务器的内存8g，redis父进程占用了6g，子进程fork父进程后，子父进程总共占用内存12g，如何解决内存不足的问题？**\n\n首先正常来说fork的子线程是不会使得内存翻倍的。因为Redis的RDB方式是采用COW(Copy On Write)机制的，子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，所以fork进程出来的时候内存几乎不变。如果此时有操作命令进来更新数据，此时只会将存这个要更新的数据对应的4K页面复制一份出来进行修改，那此时内存确实增加了一点。但正常情况下不会每个4K页面都复制一份出来更改，所以fork进程后内存只会增加一点但不会很多。\n\n## AOF持久化\n\n### AOF介绍和使用\n\n- AOF持久化时记录的是命令，每一个写命令都通过write函数追加到appendonly.aof文件中。\n- AOF默认是关闭的，需要通过appendfsync配置开启\n- AOF 每次保存的写命令都放在一个缓冲区，根据不同的策略（下面详细说）同步到磁盘\n- AOF 由于每次都会记录写命令，文件会很大，因此需要进行优化，称之为“重写机制”\n- AOF可以通过命令bgrewriteaof进行重写\n\nAOF配置：\n\n```\n# 是否开启AOF持久化\nappendonly yes\n# 由系统决定什么时候写入AOF\nappendfsync no \n#每次有数据修改发生时都会写入AOF文件。原理是每次来操作命令都执行 fsync 函数，直到同步到硬盘返回\nappendfsync always \n#每秒钟同步一次，该策略为AOF的缺省策略。先调用 OS write 函数， 写到缓冲区，然后 redis 每秒执行一次 OS fsync 函数\nappendfsync everysec \n```\n\n### aof过程\n\n当redis收到客户端操作指令后，先进行参数校验。如果校验通过则将操作指令写到操作系统的内存缓存中并执行该指令。到了一定时间后操作系统内核会异步地把内存缓存中的redis操作指令刷写到AOF文件中。也可以通过glibc函数库提供的fsync()函数将指定文件的内容强制从内存缓存中刷写到磁盘上。\n\n### bgrewriteaof重写\n\n![](redis-rdb-aop/2.png)\n\n1. 开始bgrewriteaof，判断当前有没有bgsave命令(RDB持久化)/bgrewriteaof在执行，倘若有，则这些命令执行完成以后再执行。\n2. 主进程fork出子进程，在这一个短暂的时间内，redis是阻塞的。\n3. 主进程fork完子进程继续接受客户端请求，所有写命令依然写入AOF文件缓冲区并根据appendfsync策略同步到磁盘，保证原有AOF文件完整和正确。由于fork的子进程仅仅只共享主进程fork时的内存，因此Redis使用采用重写缓冲区(aof_rewrite_buf)机制保存fork之后的客户端的写请求，防止新AOF文件生成期间丢失这部分数据。此时，客户端的写请求不仅仅写入原来aof_buf缓冲，还写入重写缓冲区(aof_rewrite_buf)。\n4. 子进程通过内存快照，按照命令重写策略写入到新的AOF文件。\n   - 子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。\n   - 主进程把aof_rewrite_buf中的数据写入到新的AOF文件。\n5. 使用新的AOF文件覆盖旧的AOF文件，标志AOF重写完成。\n\n可以看出整个重写过程是安全的。因为 Redis 重写是创建新AOF文件，重写的过程中会继续将命令追加到现有旧的 AOF 文件里面，即使重写过程中发生停机，现有旧的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。\n\n**AOF重写机制的触发条件**：\n\n- 手动触发：客户端执行bgrewriteaof命令。\n- 自动触发：自动触发通过以下两个配置协作生效，auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage\n\n```properties\n#AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写，4.0默认配置64mb\nauto-aof-rewrite-min-size 64mb\n#当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，\n#如100代表当前AOF文件是上次重写的两倍时候才重写\nauto-aof-rewrite-percentage 100\n```\n\n### 优缺点\n\n- 速度快，秒级持久化。恢复数据时能实现全部数据恢复。\n- AOF 文件的体积通常要大于 RDB 文件的体积。\n- 恢复速速慢。\n\n### 启动时优先使用AOF恢复\n\n![](redis-rdb-aop/3.png)\n\n## 混合持久化\n\n混合持久化是Redis 4.0才有的功能。混合持久化同样也是通过bgrewriteaof完成的。\n\n**混合持久化过程**：\n\n1. fork出的子进程先将共享的内存副本以RDB方式写入AOF文件。\n2. 然后在将重写缓冲区的增量命令以AOF方式写入到文件。\n3. 写入完成后通知主进程更新统计信息，并将新的AOF文件替换旧的的AOF文件。\n\n使用混合持久化后，Redis<font color=red>依然优先加载AOF文件</font>。可能有两种情况：\n\n- AOF文件开头是RDB的格式，先加载RDB部分的内容，再加载剩余的AOF\n- AOF文件开头不是RDB的格式，直接加载整个AOF文件\n\n混合持久化需要配置上确认是否开启\n\n```properties\n#yes表示开启混合持久化，默认是开启的\naof-use-rdb-preamble yes\n```\n\n## 参考\n\n- https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452965797&idx=1&sn=dc1cc6dad0d589148d5d6147705cfc38&chksm=88ede4cdbf9a6ddb775e3861ce6fc9a50eefe2d00eed69877e5ecf9cef94a6342fecaa3979c2&scene=21#wechat_redirect\n- https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452965876&idx=1&sn=8e652ab31b628af89b275cf8f25544ef&chksm=88ede49cbf9a6d8a10231e1dde14976a6cfdfd08778783bfede076c935158895fa99159ec754&scene=21#wechat_redirect","slug":"redis-rdb-aop","published":1,"updated":"2021-04-08T00:47:06.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvq0037qwv2e2q19khp","content":"<h2 id=\"Redis两种持久化方案\"><a href=\"#Redis两种持久化方案\" class=\"headerlink\" title=\"Redis两种持久化方案\"></a>Redis两种持久化方案</h2><ul>\n<li>RDB方式，生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dumpr.rdb。</li>\n<li>AOF方式，记录 Redis 除了查询以外的所有写命令，即对内存中数据进行修改的指令记录。<a id=\"more\"></a>\n<h2 id=\"RDB持久化\"><a href=\"#RDB持久化\" class=\"headerlink\" title=\"RDB持久化\"></a>RDB持久化</h2></li>\n</ul>\n<h3 id=\"RDB介绍和使用\"><a href=\"#RDB介绍和使用\" class=\"headerlink\" title=\"RDB介绍和使用\"></a>RDB介绍和使用</h3><ul>\n<li>RDB是一种<font color=\"red\">快照模式</font>。保存的是 key-value数据内容。</li>\n<li>RDB有两种持久化方式即<strong>同步save模式</strong>和<strong>异步bgsave模式</strong>。<ul>\n<li>同步模式下阻塞其他命令执行持久化生成rdb文件，不会有一致性问题。</li>\n<li>异步模式下fork一个子进程执行持久化生成rdb文件，不会阻塞其他命令，会有一致性问题。</li>\n</ul>\n</li>\n<li>默认执行 shutdown 时，如果没有开启 AOF，则自动执行 bgsave。</li>\n<li>每次的 RDB 文件都是替换的。所以在实际应用上可以通过shell脚本定时备份这个RDB文件。</li>\n</ul>\n<p>Redis默认开启RDB持久化方式，通过配置redis.conf</p>\n<pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token attr-name\">save</span> <span class=\"token attr-value\">900 1</span>\n<span class=\"token attr-name\">save</span> <span class=\"token attr-value\">300 10</span>\n<span class=\"token attr-name\">save</span> <span class=\"token attr-value\">60 10000</span>\n<span class=\"token comment\" spellcheck=\"true\">#900秒之内，如果超过1个key被修改，则发起快照保存；</span>\n<span class=\"token comment\" spellcheck=\"true\">#300秒之内，如果超过10个key被修改，则发起快照保存；</span>\n<span class=\"token comment\" spellcheck=\"true\">#60秒之内，如果1万个key被修改，则发起快照保存；</span></code></pre>\n<h3 id=\"bgsave方式持久化\"><a href=\"#bgsave方式持久化\" class=\"headerlink\" title=\"bgsave方式持久化\"></a>bgsave方式持久化</h3><p><img src=\"/2020/08/26/redis-rdb-aop/1.png\" alt></p>\n<ol>\n<li>Redis 调用 fork() ，同时拥有父进程和子进程。</li>\n<li>子进程将数据集写入到一个临时RDB文件中。</li>\n<li>当子进程完成对新 RDB 文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。</li>\n</ol>\n<p>引出问题 ：<font color=\"red\">在bgsave期间子进程正在持久化一个很大的数据结构K时，这时候父进程收到了删除这个数据结构K的命令，这时候redis该怎么办？</font></p>\n<p>redis使用操作系统的多进程<font color=\"red\">COW机制(Copy On Write)</font>机制来实现快照的持久化。子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，这是Linux操作系统的机制，为了节约内存资源，所以尽可能让父子进程共享内存，这样在进程分离的一瞬间，内存的增长几乎没有明显变化。</p>\n<p>当子进程进行持久化时父进程收到了写请求，那么会把需要处理的一部分复制一份到内存，对复制后的数据进行修改，所以即使对某个数据进行了修改，redis持久化到RDB中的数据也是未修改的数据。实际上，内存中的全量数据由一个个的”数据段页面”组成，每个数据段页面的大小为4K，客户端要修改的数据在哪个页面中，就会复制一份这个页面到内存中。在持久化过程中，随着分离出的页面越来越多，内存就会持续增长，但是不会超过原内存的2倍，因为在一次持久化的过程中，几乎不会出现所有的页面都会分离的情况，读写请求针对的只是原数据中的小部分，大部分redis数据还是”冷数据”。<font color=\"red\">所以在执行持久化时就已经快照好了那一瞬间的数据，以后的更改并不会影响持久化</font>。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p><strong>优点</strong></p>\n<ul>\n<li>文件紧凑，适合备份，全量复制场景。</li>\n<li>Redis 加载 RDB 恢复数据远远快于 AOF。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>无法秒级持久化。</li>\n<li>每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li>\n</ul>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p><strong>一道面试题 ：假设服务器的内存8g，redis父进程占用了6g，子进程fork父进程后，子父进程总共占用内存12g，如何解决内存不足的问题？</strong></p>\n<p>首先正常来说fork的子线程是不会使得内存翻倍的。因为Redis的RDB方式是采用COW(Copy On Write)机制的，子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，所以fork进程出来的时候内存几乎不变。如果此时有操作命令进来更新数据，此时只会将存这个要更新的数据对应的4K页面复制一份出来进行修改，那此时内存确实增加了一点。但正常情况下不会每个4K页面都复制一份出来更改，所以fork进程后内存只会增加一点但不会很多。</p>\n<h2 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h2><h3 id=\"AOF介绍和使用\"><a href=\"#AOF介绍和使用\" class=\"headerlink\" title=\"AOF介绍和使用\"></a>AOF介绍和使用</h3><ul>\n<li>AOF持久化时记录的是命令，每一个写命令都通过write函数追加到appendonly.aof文件中。</li>\n<li>AOF默认是关闭的，需要通过appendfsync配置开启</li>\n<li>AOF 每次保存的写命令都放在一个缓冲区，根据不同的策略（下面详细说）同步到磁盘</li>\n<li>AOF 由于每次都会记录写命令，文件会很大，因此需要进行优化，称之为“重写机制”</li>\n<li>AOF可以通过命令bgrewriteaof进行重写</li>\n</ul>\n<p>AOF配置：</p>\n<pre><code># 是否开启AOF持久化\nappendonly yes\n# 由系统决定什么时候写入AOF\nappendfsync no \n#每次有数据修改发生时都会写入AOF文件。原理是每次来操作命令都执行 fsync 函数，直到同步到硬盘返回\nappendfsync always \n#每秒钟同步一次，该策略为AOF的缺省策略。先调用 OS write 函数， 写到缓冲区，然后 redis 每秒执行一次 OS fsync 函数\nappendfsync everysec </code></pre><h3 id=\"aof过程\"><a href=\"#aof过程\" class=\"headerlink\" title=\"aof过程\"></a>aof过程</h3><p>当redis收到客户端操作指令后，先进行参数校验。如果校验通过则将操作指令写到操作系统的内存缓存中并执行该指令。到了一定时间后操作系统内核会异步地把内存缓存中的redis操作指令刷写到AOF文件中。也可以通过glibc函数库提供的fsync()函数将指定文件的内容强制从内存缓存中刷写到磁盘上。</p>\n<h3 id=\"bgrewriteaof重写\"><a href=\"#bgrewriteaof重写\" class=\"headerlink\" title=\"bgrewriteaof重写\"></a>bgrewriteaof重写</h3><p><img src=\"/2020/08/26/redis-rdb-aop/2.png\" alt></p>\n<ol>\n<li>开始bgrewriteaof，判断当前有没有bgsave命令(RDB持久化)/bgrewriteaof在执行，倘若有，则这些命令执行完成以后再执行。</li>\n<li>主进程fork出子进程，在这一个短暂的时间内，redis是阻塞的。</li>\n<li>主进程fork完子进程继续接受客户端请求，所有写命令依然写入AOF文件缓冲区并根据appendfsync策略同步到磁盘，保证原有AOF文件完整和正确。由于fork的子进程仅仅只共享主进程fork时的内存，因此Redis使用采用重写缓冲区(aof_rewrite_buf)机制保存fork之后的客户端的写请求，防止新AOF文件生成期间丢失这部分数据。此时，客户端的写请求不仅仅写入原来aof_buf缓冲，还写入重写缓冲区(aof_rewrite_buf)。</li>\n<li>子进程通过内存快照，按照命令重写策略写入到新的AOF文件。<ul>\n<li>子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。</li>\n<li>主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li>\n</ul>\n</li>\n<li>使用新的AOF文件覆盖旧的AOF文件，标志AOF重写完成。</li>\n</ol>\n<p>可以看出整个重写过程是安全的。因为 Redis 重写是创建新AOF文件，重写的过程中会继续将命令追加到现有旧的 AOF 文件里面，即使重写过程中发生停机，现有旧的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>\n<p><strong>AOF重写机制的触发条件</strong>：</p>\n<ul>\n<li>手动触发：客户端执行bgrewriteaof命令。</li>\n<li>自动触发：自动触发通过以下两个配置协作生效，auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage</li>\n</ul>\n<pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\">#AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写，4.0默认配置64mb</span>\n<span class=\"token attr-name\">auto-aof-rewrite-min-size</span> <span class=\"token attr-value\">64mb</span>\n<span class=\"token comment\" spellcheck=\"true\">#当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，</span>\n<span class=\"token comment\" spellcheck=\"true\">#如100代表当前AOF文件是上次重写的两倍时候才重写</span>\n<span class=\"token attr-name\">auto-aof-rewrite-percentage</span> <span class=\"token attr-value\">100</span></code></pre>\n<h3 id=\"优缺点-1\"><a href=\"#优缺点-1\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>速度快，秒级持久化。恢复数据时能实现全部数据恢复。</li>\n<li>AOF 文件的体积通常要大于 RDB 文件的体积。</li>\n<li>恢复速速慢。</li>\n</ul>\n<h3 id=\"启动时优先使用AOF恢复\"><a href=\"#启动时优先使用AOF恢复\" class=\"headerlink\" title=\"启动时优先使用AOF恢复\"></a>启动时优先使用AOF恢复</h3><p><img src=\"/2020/08/26/redis-rdb-aop/3.png\" alt></p>\n<h2 id=\"混合持久化\"><a href=\"#混合持久化\" class=\"headerlink\" title=\"混合持久化\"></a>混合持久化</h2><p>混合持久化是Redis 4.0才有的功能。混合持久化同样也是通过bgrewriteaof完成的。</p>\n<p><strong>混合持久化过程</strong>：</p>\n<ol>\n<li>fork出的子进程先将共享的内存副本以RDB方式写入AOF文件。</li>\n<li>然后在将重写缓冲区的增量命令以AOF方式写入到文件。</li>\n<li>写入完成后通知主进程更新统计信息，并将新的AOF文件替换旧的的AOF文件。</li>\n</ol>\n<p>使用混合持久化后，Redis<font color=\"red\">依然优先加载AOF文件</font>。可能有两种情况：</p>\n<ul>\n<li>AOF文件开头是RDB的格式，先加载RDB部分的内容，再加载剩余的AOF</li>\n<li>AOF文件开头不是RDB的格式，直接加载整个AOF文件</li>\n</ul>\n<p>混合持久化需要配置上确认是否开启</p>\n<pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\">#yes表示开启混合持久化，默认是开启的</span>\n<span class=\"token attr-name\">aof-use-rdb-preamble</span> <span class=\"token attr-value\">yes</span></code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452965797&amp;idx=1&amp;sn=dc1cc6dad0d589148d5d6147705cfc38&amp;chksm=88ede4cdbf9a6ddb775e3861ce6fc9a50eefe2d00eed69877e5ecf9cef94a6342fecaa3979c2&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452965797&amp;idx=1&amp;sn=dc1cc6dad0d589148d5d6147705cfc38&amp;chksm=88ede4cdbf9a6ddb775e3861ce6fc9a50eefe2d00eed69877e5ecf9cef94a6342fecaa3979c2&amp;scene=21#wechat_redirect</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452965876&amp;idx=1&amp;sn=8e652ab31b628af89b275cf8f25544ef&amp;chksm=88ede49cbf9a6d8a10231e1dde14976a6cfdfd08778783bfede076c935158895fa99159ec754&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452965876&amp;idx=1&amp;sn=8e652ab31b628af89b275cf8f25544ef&amp;chksm=88ede49cbf9a6d8a10231e1dde14976a6cfdfd08778783bfede076c935158895fa99159ec754&amp;scene=21#wechat_redirect</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Redis两种持久化方案\"><a href=\"#Redis两种持久化方案\" class=\"headerlink\" title=\"Redis两种持久化方案\"></a>Redis两种持久化方案</h2><ul>\n<li>RDB方式，生成指定时间间隔内的 Redis 内存中数据快照，是一个二进制文件 dumpr.rdb。</li>\n<li>AOF方式，记录 Redis 除了查询以外的所有写命令，即对内存中数据进行修改的指令记录。</li></ul>","more":"<h2 id=\"RDB持久化\"><a href=\"#RDB持久化\" class=\"headerlink\" title=\"RDB持久化\"></a>RDB持久化</h2>\n\n<h3 id=\"RDB介绍和使用\"><a href=\"#RDB介绍和使用\" class=\"headerlink\" title=\"RDB介绍和使用\"></a>RDB介绍和使用</h3><ul>\n<li>RDB是一种<font color=\"red\">快照模式</font>。保存的是 key-value数据内容。</li>\n<li>RDB有两种持久化方式即<strong>同步save模式</strong>和<strong>异步bgsave模式</strong>。<ul>\n<li>同步模式下阻塞其他命令执行持久化生成rdb文件，不会有一致性问题。</li>\n<li>异步模式下fork一个子进程执行持久化生成rdb文件，不会阻塞其他命令，会有一致性问题。</li>\n</ul>\n</li>\n<li>默认执行 shutdown 时，如果没有开启 AOF，则自动执行 bgsave。</li>\n<li>每次的 RDB 文件都是替换的。所以在实际应用上可以通过shell脚本定时备份这个RDB文件。</li>\n</ul>\n<p>Redis默认开启RDB持久化方式，通过配置redis.conf</p>\n<pre><code class=\"properties\">save 900 1\nsave 300 10\nsave 60 10000\n#900秒之内，如果超过1个key被修改，则发起快照保存；\n#300秒之内，如果超过10个key被修改，则发起快照保存；\n#60秒之内，如果1万个key被修改，则发起快照保存；</code></pre>\n<h3 id=\"bgsave方式持久化\"><a href=\"#bgsave方式持久化\" class=\"headerlink\" title=\"bgsave方式持久化\"></a>bgsave方式持久化</h3><p><img src=\"/2020/08/26/redis-rdb-aop/1.png\" alt></p>\n<ol>\n<li>Redis 调用 fork() ，同时拥有父进程和子进程。</li>\n<li>子进程将数据集写入到一个临时RDB文件中。</li>\n<li>当子进程完成对新 RDB 文件的写入时，Redis用新RDB文件替换原来的RDB文件，并删除旧的RDB文件。</li>\n</ol>\n<p>引出问题 ：<font color=\"red\">在bgsave期间子进程正在持久化一个很大的数据结构K时，这时候父进程收到了删除这个数据结构K的命令，这时候redis该怎么办？</font></p>\n<p>redis使用操作系统的多进程<font color=\"red\">COW机制(Copy On Write)</font>机制来实现快照的持久化。子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，这是Linux操作系统的机制，为了节约内存资源，所以尽可能让父子进程共享内存，这样在进程分离的一瞬间，内存的增长几乎没有明显变化。</p>\n<p>当子进程进行持久化时父进程收到了写请求，那么会把需要处理的一部分复制一份到内存，对复制后的数据进行修改，所以即使对某个数据进行了修改，redis持久化到RDB中的数据也是未修改的数据。实际上，内存中的全量数据由一个个的”数据段页面”组成，每个数据段页面的大小为4K，客户端要修改的数据在哪个页面中，就会复制一份这个页面到内存中。在持久化过程中，随着分离出的页面越来越多，内存就会持续增长，但是不会超过原内存的2倍，因为在一次持久化的过程中，几乎不会出现所有的页面都会分离的情况，读写请求针对的只是原数据中的小部分，大部分redis数据还是”冷数据”。<font color=\"red\">所以在执行持久化时就已经快照好了那一瞬间的数据，以后的更改并不会影响持久化</font>。</p>\n<h3 id=\"优缺点\"><a href=\"#优缺点\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><p><strong>优点</strong></p>\n<ul>\n<li>文件紧凑，适合备份，全量复制场景。</li>\n<li>Redis 加载 RDB 恢复数据远远快于 AOF。</li>\n</ul>\n<p><strong>缺点</strong></p>\n<ul>\n<li>无法秒级持久化。</li>\n<li>每次在 fork 子进程来执行 RDB 快照数据文件生成的时候，如果数据文件特别大，可能会导致对客户端提供的服务暂停数毫秒，或者甚至数秒。</li>\n</ul>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p><strong>一道面试题 ：假设服务器的内存8g，redis父进程占用了6g，子进程fork父进程后，子父进程总共占用内存12g，如何解决内存不足的问题？</strong></p>\n<p>首先正常来说fork的子线程是不会使得内存翻倍的。因为Redis的RDB方式是采用COW(Copy On Write)机制的，子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，所以fork进程出来的时候内存几乎不变。如果此时有操作命令进来更新数据，此时只会将存这个要更新的数据对应的4K页面复制一份出来进行修改，那此时内存确实增加了一点。但正常情况下不会每个4K页面都复制一份出来更改，所以fork进程后内存只会增加一点但不会很多。</p>\n<h2 id=\"AOF持久化\"><a href=\"#AOF持久化\" class=\"headerlink\" title=\"AOF持久化\"></a>AOF持久化</h2><h3 id=\"AOF介绍和使用\"><a href=\"#AOF介绍和使用\" class=\"headerlink\" title=\"AOF介绍和使用\"></a>AOF介绍和使用</h3><ul>\n<li>AOF持久化时记录的是命令，每一个写命令都通过write函数追加到appendonly.aof文件中。</li>\n<li>AOF默认是关闭的，需要通过appendfsync配置开启</li>\n<li>AOF 每次保存的写命令都放在一个缓冲区，根据不同的策略（下面详细说）同步到磁盘</li>\n<li>AOF 由于每次都会记录写命令，文件会很大，因此需要进行优化，称之为“重写机制”</li>\n<li>AOF可以通过命令bgrewriteaof进行重写</li>\n</ul>\n<p>AOF配置：</p>\n<pre><code># 是否开启AOF持久化\nappendonly yes\n# 由系统决定什么时候写入AOF\nappendfsync no \n#每次有数据修改发生时都会写入AOF文件。原理是每次来操作命令都执行 fsync 函数，直到同步到硬盘返回\nappendfsync always \n#每秒钟同步一次，该策略为AOF的缺省策略。先调用 OS write 函数， 写到缓冲区，然后 redis 每秒执行一次 OS fsync 函数\nappendfsync everysec </code></pre><h3 id=\"aof过程\"><a href=\"#aof过程\" class=\"headerlink\" title=\"aof过程\"></a>aof过程</h3><p>当redis收到客户端操作指令后，先进行参数校验。如果校验通过则将操作指令写到操作系统的内存缓存中并执行该指令。到了一定时间后操作系统内核会异步地把内存缓存中的redis操作指令刷写到AOF文件中。也可以通过glibc函数库提供的fsync()函数将指定文件的内容强制从内存缓存中刷写到磁盘上。</p>\n<h3 id=\"bgrewriteaof重写\"><a href=\"#bgrewriteaof重写\" class=\"headerlink\" title=\"bgrewriteaof重写\"></a>bgrewriteaof重写</h3><p><img src=\"/2020/08/26/redis-rdb-aop/2.png\" alt></p>\n<ol>\n<li>开始bgrewriteaof，判断当前有没有bgsave命令(RDB持久化)/bgrewriteaof在执行，倘若有，则这些命令执行完成以后再执行。</li>\n<li>主进程fork出子进程，在这一个短暂的时间内，redis是阻塞的。</li>\n<li>主进程fork完子进程继续接受客户端请求，所有写命令依然写入AOF文件缓冲区并根据appendfsync策略同步到磁盘，保证原有AOF文件完整和正确。由于fork的子进程仅仅只共享主进程fork时的内存，因此Redis使用采用重写缓冲区(aof_rewrite_buf)机制保存fork之后的客户端的写请求，防止新AOF文件生成期间丢失这部分数据。此时，客户端的写请求不仅仅写入原来aof_buf缓冲，还写入重写缓冲区(aof_rewrite_buf)。</li>\n<li>子进程通过内存快照，按照命令重写策略写入到新的AOF文件。<ul>\n<li>子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。</li>\n<li>主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</li>\n</ul>\n</li>\n<li>使用新的AOF文件覆盖旧的AOF文件，标志AOF重写完成。</li>\n</ol>\n<p>可以看出整个重写过程是安全的。因为 Redis 重写是创建新AOF文件，重写的过程中会继续将命令追加到现有旧的 AOF 文件里面，即使重写过程中发生停机，现有旧的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。</p>\n<p><strong>AOF重写机制的触发条件</strong>：</p>\n<ul>\n<li>手动触发：客户端执行bgrewriteaof命令。</li>\n<li>自动触发：自动触发通过以下两个配置协作生效，auto-aof-rewrite-min-size 和 auto-aof-rewrite-percentage</li>\n</ul>\n<pre><code class=\"properties\">#AOF文件最小重写大小，只有当AOF文件大小大于该值时候才可能重写，4.0默认配置64mb\nauto-aof-rewrite-min-size 64mb\n#当前AOF文件大小和最后一次重写后的大小之间的比率等于或者等于指定的增长百分比，\n#如100代表当前AOF文件是上次重写的两倍时候才重写\nauto-aof-rewrite-percentage 100</code></pre>\n<h3 id=\"优缺点-1\"><a href=\"#优缺点-1\" class=\"headerlink\" title=\"优缺点\"></a>优缺点</h3><ul>\n<li>速度快，秒级持久化。恢复数据时能实现全部数据恢复。</li>\n<li>AOF 文件的体积通常要大于 RDB 文件的体积。</li>\n<li>恢复速速慢。</li>\n</ul>\n<h3 id=\"启动时优先使用AOF恢复\"><a href=\"#启动时优先使用AOF恢复\" class=\"headerlink\" title=\"启动时优先使用AOF恢复\"></a>启动时优先使用AOF恢复</h3><p><img src=\"/2020/08/26/redis-rdb-aop/3.png\" alt></p>\n<h2 id=\"混合持久化\"><a href=\"#混合持久化\" class=\"headerlink\" title=\"混合持久化\"></a>混合持久化</h2><p>混合持久化是Redis 4.0才有的功能。混合持久化同样也是通过bgrewriteaof完成的。</p>\n<p><strong>混合持久化过程</strong>：</p>\n<ol>\n<li>fork出的子进程先将共享的内存副本以RDB方式写入AOF文件。</li>\n<li>然后在将重写缓冲区的增量命令以AOF方式写入到文件。</li>\n<li>写入完成后通知主进程更新统计信息，并将新的AOF文件替换旧的的AOF文件。</li>\n</ol>\n<p>使用混合持久化后，Redis<font color=\"red\">依然优先加载AOF文件</font>。可能有两种情况：</p>\n<ul>\n<li>AOF文件开头是RDB的格式，先加载RDB部分的内容，再加载剩余的AOF</li>\n<li>AOF文件开头不是RDB的格式，直接加载整个AOF文件</li>\n</ul>\n<p>混合持久化需要配置上确认是否开启</p>\n<pre><code class=\"properties\">#yes表示开启混合持久化，默认是开启的\naof-use-rdb-preamble yes</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452965797&amp;idx=1&amp;sn=dc1cc6dad0d589148d5d6147705cfc38&amp;chksm=88ede4cdbf9a6ddb775e3861ce6fc9a50eefe2d00eed69877e5ecf9cef94a6342fecaa3979c2&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452965797&amp;idx=1&amp;sn=dc1cc6dad0d589148d5d6147705cfc38&amp;chksm=88ede4cdbf9a6ddb775e3861ce6fc9a50eefe2d00eed69877e5ecf9cef94a6342fecaa3979c2&amp;scene=21#wechat_redirect</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452965876&amp;idx=1&amp;sn=8e652ab31b628af89b275cf8f25544ef&amp;chksm=88ede49cbf9a6d8a10231e1dde14976a6cfdfd08778783bfede076c935158895fa99159ec754&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452965876&amp;idx=1&amp;sn=8e652ab31b628af89b275cf8f25544ef&amp;chksm=88ede49cbf9a6d8a10231e1dde14976a6cfdfd08778783bfede076c935158895fa99159ec754&amp;scene=21#wechat_redirect</a></li>\n</ul>"},{"title":"redis哨兵原理解析","description":"redis哨兵原理解析","date":"2020-08-14T08:58:58.000Z","_content":"## Redis哨兵概述\n\nRedis Sentinel是一个分布式系统，为Redis提供<font color=red>高可用性</font>解决方案，通过监控各个Redis节点(主从服务器)实现<font color=red>自动障迁移</font>。\n\nRedis Sentinel功能包括 ：\n\n- 监控。Sentinel 会不断地定期检查你的主服务器和从服务器是否运作正常。\n- 提醒。当被监控的某个 Redis 服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。\n- 自动故障迁移。当主服务器发生故障时，执行自动故障转移，将从服务器升级为新的主服务器，并让其他从服务器复制新的主服务器数据。\n  - 从服务器宕机时没什么，但当从服务器重新启动后会自动加入到主从架构中，自动完成同步数据。\n  - 主服务器宕机时在从服务器中选出一台从服务器提升为主服务器，其他从服务器复制新的主服务器，原来的主服务器恢复后自动加入到主从架构中成为从服务器。\n\n![redis哨兵架构图](redis-sentinel/1.png)\n\n所以说，本身redis哨兵也是一个<font color=red>分布式集群系统</font>。\n<!--more-->\n\n## Redis哨兵配置\n\n```properties\n# sentinel monitor mymaster 127.0.0.1 6379 2\n# 哨兵节点定期监控 名字叫做 <master-name>  并且 IP 为 <ip> 端口号为 <port> 的主节点\n#quorum表示哨兵判断节点是否发生故障的票数，设置成2表示要两个哨兵认为主节点故障了才会客户下线\n#一般这个值是number(sentinel)/2 + 1\nsentinel monitor <master-name> <ip> <port> <quorum>\n\n#sentinel down-after-milliseconds mymaster 2000\n#哨兵定期发送ping命令判断Redis节点和哨兵节点是否可达，如果超过了这个值没有回复pong，\n#主观判断节点是不可达的，单位是毫秒\nsentinel down-after-milliseconds <master-name> <times>\n\n#sentinel parallel-syncs mymaster 2\n#当哨兵选出新的Redis主节点时，其他的从节点会从这个新主节点复制数据，这个值用来控制\n#每次可以向新的主节点复制的节点个数。\n#为啥要这样控制?可以看下主从复制的原理，防止过多从节点同一时间复制造成主节点阻塞\nsentinel parallel-syncs <master-name> <nums>\n\n#sentinel failover-timeout mymaster 2000\n#哨兵进行故障转移时如果超过了配置的<times>时间就表示故障转移超时失败\nsentinel failover-timeout <master-name>  <times>\n\n#sentinel auth-pass mymaster 123456\n#如果主节点有设置密码，这里也要设置，没啥好说的\nsentinel auth-pass <master-name> <password>\n```\n\n主观下线和客观下线的区别\n\n- 主观下线就是<font color=red>单个</font>sentinel认为某个服务下线。例如ping节点时没有按时回复pong就会被认为主观下线，但是这时候并不是这个这个主节点下线了，必须多个sentinel认为主观下线了，超过了quorum才会认为下线(客观下线)\n- 大部分哨兵节点都同意下线操作，也就说是客观下线\n\n## Redis哨兵工作原理\n\n### 哨兵Leader的选举过程\n\n当主节点被认为客观下线时候，这时候需要有一个哨兵来执行故障转移，那是由集群中的哪个哨兵来执行呢？这时候就需要选出一个Leader来做这个事。哨兵Leader的选举主要采用<font color=red>Raft协议</font>。当完成故障转移后，所有哨兵又恢复平等。\n\n### 自动故障转移机制\n\nsentinel状态数据结构中保存了主服务的所有从服务信息，leander sentinel按照如下的规则从从服务列表中挑选出新的主服务。\n\n1. 过滤掉主观下线的节点 \n2. 选择slave-priority最高的节点，如果有则返回没有就继续选择\n3. 选择出复制偏移量最大的系节点，因为复制便宜量越大则数据复制的越完整，如果由就返回了，没有就继续\n4. 选择run_id最小的节点\n\n更新主从状态。通过slaveof no one命令，让选出来的从节点成为主节点。并通过slaveof命令让其他节点成为其从节点。\n\n### 哨兵的定时监控\n\n- 每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到\n- 每个哨兵节点每隔2秒会向redis数据节点的指定频道（\\_\\_sentinel\\_\\_:hello）上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断\n- 每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测\n\n### 工作原理总结\n\n- 每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。\n- 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。\n- 如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 \n- 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。\n- 在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。\n- 当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。\n- 若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 \n\n## Redis集群脑裂\n\nredis的集群脑裂是指因为网络问题，导致redis master节点跟redis slave节点和sentinel集群处于不同的网络分区，此时因为sentinel集群无法感知到master的存在，所以将slave节点提升为master节点。集群的脑裂会导致<font color=red>数据丢失</font>。\n\n![redis脑裂](redis-sentinel/2.png)\n\n**解决方案** ： 在redis配置文件中添加如下配置\n\n```properties\n#连接到master的最少slave数量,如果少于这个数，master会拒绝写请求\nmin-replicas-to-write 3\n#slave连接到master的最大延迟时间\nmin-replicas-max-lag 10\n```\n\n\n\n## Jedis不支持实现哨兵的读写分离\n\n#### Jedis哨兵不支持读写分离分析\n\n通过上面的分析我们知道哨兵解决了Redis主从的高可用性。我们一般在使用中是通过Jedis连接哨兵节点，这样当主服务器挂时我们代码上也不需要做任何改动，因为我们连的是哨兵节点。\n\n我们接下来分析下<font color=red>Jedis连接哨兵源码，了解下为什么Jedis没法实现连接哨兵时的读写分离，还有我们需要如何改造</font>。\n\n**Jedis连接哨兵示例**\n\n```java\n@Test\npublic void test02(){\n    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n    jedisPoolConfig.setMaxTotal(10);\n    jedisPoolConfig.setMaxIdle(5);\n    jedisPoolConfig.setMinIdle(5);\n    // 哨兵信息\n    Set<String> sentinels = \n        new HashSet<>(Arrays.asList(\"192.168.135.131:26379\",\"192.168.135.131:26380\",\"192.168.135.131:26381\"));\n    JedisSentinelPool pool = new JedisSentinelPool(\"mymaster\", sentinels,jedisPoolConfig);\n    Jedis jedis = pool.getResource();\n    jedis.set(\"mykey\", \"myvalue\");\n    String value = jedis.get(\"mykey\");\n    System.out.println(value);\n}\n```\n\n**跟踪JedisSentinelPool初始化源码**\n\n从下面代码我们可以知道，\n\n- 当我们链接哨兵时，哨兵获取到主节点并用主节点做资源池。\n- 每个哨兵设置一个MasterListener，订阅+switch-master，当出现主服务器挂时自动故障转移时，会收到新的主节点，然后就客户端就可以重新initPool(master)，这样就实现了自动转移后客户端自动更变主节点的链接。\n\n但是这样有一个缺点，<font color=red>如果通过Jedis链接哨兵，所有命令只会发送到主节点处理，这样其实从节点只是做一个热备份的作用，当我们需要读写分离来分担主节点压力时就没办法了。</font>\n\n```java\npublic JedisSentinelPool(String masterName, Set<String> sentinels,\n    final GenericObjectPoolConfig poolConfig, final int connectionTimeout, final int soTimeout,\n    final String password, final int database, final String clientName) {\n  this.poolConfig = poolConfig;\n  this.connectionTimeout = connectionTimeout;\n  this.soTimeout = soTimeout;\n  this.password = password;\n  this.database = database;\n  this.clientName = clientName;\n  //获取主节点\n  HostAndPort master = initSentinels(sentinels, masterName);\n  //通过master初始化资源池，后面我们使用就是链接这个资源池\n  initPool(master);\n}\n\n//通过哨兵获取到主节点返回，并设置对主节点的监控\nprivate HostAndPort initSentinels(Set<String> sentinels, final String masterName) {\n  HostAndPort master = null;\n  boolean sentinelAvailable = false;\n  log.info(\"Trying to find master from available Sentinels...\");\n  //遍历设置的哨兵节点  \n  for (String sentinel : sentinels) {\n    final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel.split(\":\")));\n    log.fine(\"Connecting to Sentinel \" + hap);\n    Jedis jedis = null;\n    try {\n      //链接哨兵节点\n      jedis = new Jedis(hap.getHost(), hap.getPort());\n      //通过第一个哨兵节点获取到监控的主节点的Ip和端口，传入的是masterName\n      List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n      //到这一步表示链接哨兵没问题，并获取到了数据  \n      sentinelAvailable = true;\n      //如果这个哨兵获取不到，就循环继续获取\n      if (masterAddr == null || masterAddr.size() != 2) {\n        log.warning(\"Can not get master addr, master name: \" + masterName + \". Sentinel: \" + hap\n            + \".\");\n        continue;\n      }\n\t //转成HostAndPort对象\n      master = toHostAndPort(masterAddr);\n      log.fine(\"Found Redis master at \" + master);\n      break;\n    } catch (JedisConnectionException e) {\n      log.warning(\"Cannot connect to sentinel running @ \" + hap + \". Trying next one.\");\n    } finally {\n      if (jedis != null) {\n        jedis.close();\n      }\n    }\n  }\n\n  //没有获取到主节点就报错\n  if (master == null) {\n    if (sentinelAvailable) {\n      throw new JedisException(\"Can connect to sentinel, but \" + masterName\n          + \" seems to be not monitored...\");\n    } else {\n      throw new JedisConnectionException(\"All sentinels down, cannot determine where is \"\n          + masterName + \" master is running...\");\n    }\n  }\n    \n  log.info(\"Redis master running at \" + master + \", starting Sentinel listeners...\");\n    \n  for (String sentinel : sentinels) {\n    //获取哨兵节点的Ip和端口\n    final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel.split(\":\")));\n    //启动监听自动故障转移并重新初始化主节点\n    MasterListener masterListener = new MasterListener(masterName, hap.getHost(), hap.getPort());\n    masterListener.setDaemon(true);\n    masterListeners.add(masterListener);\n    masterListener.start();\n  }\n  return master;\n}\n```\n\n```java\nprotected class MasterListener extends Thread {\n   //... 省略非关键代码\n    public void run() {\n      running.set(true);\n      while (running.get()) {\n        j = new Jedis(host, port);\n        try {\n          if (!running.get()) {\n            break;\n          }\n          //通过订阅+switch-master频道来感知新的主节点\n          j.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              log.fine(\"Sentinel \" + host + \":\" + port + \" published: \" + message + \".\");\n              String[] switchMasterMsg = message.split(\" \");\n\n              if (switchMasterMsg.length > 3) {\n                if (masterName.equals(switchMasterMsg[0])) {\n                  //重新初始化新的主节点\n                  initPool(toHostAndPort(Arrays.asList(switchMasterMsg[3], switchMasterMsg[4])));\n                } else {\n                  log.fine(\"Ignoring message on +switch-master for master name \"\n                      + switchMasterMsg[0] + \", our master name is \" + masterName);\n                }\n\n              } else {\n                log.severe(\"Invalid message received on Sentinel \" + host + \":\" + port\n                    + \" on channel +switch-master: \" + message);\n              }\n            }\n          }, \"+switch-master\");\n\n        } catch (JedisConnectionException e) {\n\t\t\t//... 省略非关键代码\n        } finally {\n             //... 省略非关键代码\n        }\n      }\n    }\n  }\n```\n\n#### 解决无法读写分离方案\n\nJedisSentinelPool底层使用的是commons.pool2对象池。分析对应的initPool方法，通过传入Master节点到Jedis工厂(JedisFactory)然后链接主节点对象池。\n\n```java\n//通过主节点初始化Jedis对象池  \nprivate void initPool(HostAndPort master) {\n    if (!master.equals(currentHostMaster)) {\n      currentHostMaster = master;\n      if (factory == null) {\n        //传入Master节点\n        factory = new JedisFactory(master.getHost(), master.getPort(), connectionTimeout,\n            soTimeout, password, database, clientName);\n        initPool(poolConfig, factory);\n      } else {\n        factory.setHostAndPort(currentHostMaster);\n        internalPool.clear();\n      }\n      log.info(\"Created JedisPool to master at \" + master);\n    }\n  }\n```\n\n```java\n//redis/clients/jedis/JedisFactory/class  \n@Override\n  public PooledObject<Jedis> makeObject() throws Exception {\n    final HostAndPort hostAndPort = this.hostAndPort.get();\n    //根据主节点来建立资源池\n    final Jedis jedis = new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout,\n        soTimeout);\n\n    jedis.connect();\n    if (null != this.password) {\n      jedis.auth(this.password);\n    }\n    if (database != 0) {\n      jedis.select(database);\n    }\n    if (clientName != null) {\n      jedis.clientSetname(clientName);\n    }\n    return new DefaultPooledObject<Jedis>(jedis);\n  }\n```\n\n所以我们的改造方案：\n\n- 新建一个JedisSlaveSentinelPool类，方法全部照抄JedisSentinelPool类的，其中initPool方法使用JedisFactory替换成JedisSlaveFactory(第二步新建的类)。并去掉MasterListener监听器，因为原来JedisSentinelPool类的MasterListener监听器的功能是当主节点挂时重新选一个从节点，我们这里并不适用。\n- 新建JedisSlaveFactory类，方法全部照抄JedisFactory类，重写makeObject类，通过获取从节点来建立资源池。\n- 新建一个JedisUtils工具类，写操作用主节点对应的资源池，读节点用从节点对应的资源池。\n\n\n\n","source":"_posts/redis-sentinel.md","raw":"---\ntitle: redis哨兵原理解析\ntags:\n  - redis\ncategories: redis\ndescription : redis哨兵原理解析\ndate: 2020-08-14 16:58:58\n---\n## Redis哨兵概述\n\nRedis Sentinel是一个分布式系统，为Redis提供<font color=red>高可用性</font>解决方案，通过监控各个Redis节点(主从服务器)实现<font color=red>自动障迁移</font>。\n\nRedis Sentinel功能包括 ：\n\n- 监控。Sentinel 会不断地定期检查你的主服务器和从服务器是否运作正常。\n- 提醒。当被监控的某个 Redis 服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。\n- 自动故障迁移。当主服务器发生故障时，执行自动故障转移，将从服务器升级为新的主服务器，并让其他从服务器复制新的主服务器数据。\n  - 从服务器宕机时没什么，但当从服务器重新启动后会自动加入到主从架构中，自动完成同步数据。\n  - 主服务器宕机时在从服务器中选出一台从服务器提升为主服务器，其他从服务器复制新的主服务器，原来的主服务器恢复后自动加入到主从架构中成为从服务器。\n\n![redis哨兵架构图](redis-sentinel/1.png)\n\n所以说，本身redis哨兵也是一个<font color=red>分布式集群系统</font>。\n<!--more-->\n\n## Redis哨兵配置\n\n```properties\n# sentinel monitor mymaster 127.0.0.1 6379 2\n# 哨兵节点定期监控 名字叫做 <master-name>  并且 IP 为 <ip> 端口号为 <port> 的主节点\n#quorum表示哨兵判断节点是否发生故障的票数，设置成2表示要两个哨兵认为主节点故障了才会客户下线\n#一般这个值是number(sentinel)/2 + 1\nsentinel monitor <master-name> <ip> <port> <quorum>\n\n#sentinel down-after-milliseconds mymaster 2000\n#哨兵定期发送ping命令判断Redis节点和哨兵节点是否可达，如果超过了这个值没有回复pong，\n#主观判断节点是不可达的，单位是毫秒\nsentinel down-after-milliseconds <master-name> <times>\n\n#sentinel parallel-syncs mymaster 2\n#当哨兵选出新的Redis主节点时，其他的从节点会从这个新主节点复制数据，这个值用来控制\n#每次可以向新的主节点复制的节点个数。\n#为啥要这样控制?可以看下主从复制的原理，防止过多从节点同一时间复制造成主节点阻塞\nsentinel parallel-syncs <master-name> <nums>\n\n#sentinel failover-timeout mymaster 2000\n#哨兵进行故障转移时如果超过了配置的<times>时间就表示故障转移超时失败\nsentinel failover-timeout <master-name>  <times>\n\n#sentinel auth-pass mymaster 123456\n#如果主节点有设置密码，这里也要设置，没啥好说的\nsentinel auth-pass <master-name> <password>\n```\n\n主观下线和客观下线的区别\n\n- 主观下线就是<font color=red>单个</font>sentinel认为某个服务下线。例如ping节点时没有按时回复pong就会被认为主观下线，但是这时候并不是这个这个主节点下线了，必须多个sentinel认为主观下线了，超过了quorum才会认为下线(客观下线)\n- 大部分哨兵节点都同意下线操作，也就说是客观下线\n\n## Redis哨兵工作原理\n\n### 哨兵Leader的选举过程\n\n当主节点被认为客观下线时候，这时候需要有一个哨兵来执行故障转移，那是由集群中的哪个哨兵来执行呢？这时候就需要选出一个Leader来做这个事。哨兵Leader的选举主要采用<font color=red>Raft协议</font>。当完成故障转移后，所有哨兵又恢复平等。\n\n### 自动故障转移机制\n\nsentinel状态数据结构中保存了主服务的所有从服务信息，leander sentinel按照如下的规则从从服务列表中挑选出新的主服务。\n\n1. 过滤掉主观下线的节点 \n2. 选择slave-priority最高的节点，如果有则返回没有就继续选择\n3. 选择出复制偏移量最大的系节点，因为复制便宜量越大则数据复制的越完整，如果由就返回了，没有就继续\n4. 选择run_id最小的节点\n\n更新主从状态。通过slaveof no one命令，让选出来的从节点成为主节点。并通过slaveof命令让其他节点成为其从节点。\n\n### 哨兵的定时监控\n\n- 每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到\n- 每个哨兵节点每隔2秒会向redis数据节点的指定频道（\\_\\_sentinel\\_\\_:hello）上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断\n- 每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测\n\n### 工作原理总结\n\n- 每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。\n- 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。\n- 如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 \n- 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。\n- 在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。\n- 当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。\n- 若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 \n\n## Redis集群脑裂\n\nredis的集群脑裂是指因为网络问题，导致redis master节点跟redis slave节点和sentinel集群处于不同的网络分区，此时因为sentinel集群无法感知到master的存在，所以将slave节点提升为master节点。集群的脑裂会导致<font color=red>数据丢失</font>。\n\n![redis脑裂](redis-sentinel/2.png)\n\n**解决方案** ： 在redis配置文件中添加如下配置\n\n```properties\n#连接到master的最少slave数量,如果少于这个数，master会拒绝写请求\nmin-replicas-to-write 3\n#slave连接到master的最大延迟时间\nmin-replicas-max-lag 10\n```\n\n\n\n## Jedis不支持实现哨兵的读写分离\n\n#### Jedis哨兵不支持读写分离分析\n\n通过上面的分析我们知道哨兵解决了Redis主从的高可用性。我们一般在使用中是通过Jedis连接哨兵节点，这样当主服务器挂时我们代码上也不需要做任何改动，因为我们连的是哨兵节点。\n\n我们接下来分析下<font color=red>Jedis连接哨兵源码，了解下为什么Jedis没法实现连接哨兵时的读写分离，还有我们需要如何改造</font>。\n\n**Jedis连接哨兵示例**\n\n```java\n@Test\npublic void test02(){\n    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n    jedisPoolConfig.setMaxTotal(10);\n    jedisPoolConfig.setMaxIdle(5);\n    jedisPoolConfig.setMinIdle(5);\n    // 哨兵信息\n    Set<String> sentinels = \n        new HashSet<>(Arrays.asList(\"192.168.135.131:26379\",\"192.168.135.131:26380\",\"192.168.135.131:26381\"));\n    JedisSentinelPool pool = new JedisSentinelPool(\"mymaster\", sentinels,jedisPoolConfig);\n    Jedis jedis = pool.getResource();\n    jedis.set(\"mykey\", \"myvalue\");\n    String value = jedis.get(\"mykey\");\n    System.out.println(value);\n}\n```\n\n**跟踪JedisSentinelPool初始化源码**\n\n从下面代码我们可以知道，\n\n- 当我们链接哨兵时，哨兵获取到主节点并用主节点做资源池。\n- 每个哨兵设置一个MasterListener，订阅+switch-master，当出现主服务器挂时自动故障转移时，会收到新的主节点，然后就客户端就可以重新initPool(master)，这样就实现了自动转移后客户端自动更变主节点的链接。\n\n但是这样有一个缺点，<font color=red>如果通过Jedis链接哨兵，所有命令只会发送到主节点处理，这样其实从节点只是做一个热备份的作用，当我们需要读写分离来分担主节点压力时就没办法了。</font>\n\n```java\npublic JedisSentinelPool(String masterName, Set<String> sentinels,\n    final GenericObjectPoolConfig poolConfig, final int connectionTimeout, final int soTimeout,\n    final String password, final int database, final String clientName) {\n  this.poolConfig = poolConfig;\n  this.connectionTimeout = connectionTimeout;\n  this.soTimeout = soTimeout;\n  this.password = password;\n  this.database = database;\n  this.clientName = clientName;\n  //获取主节点\n  HostAndPort master = initSentinels(sentinels, masterName);\n  //通过master初始化资源池，后面我们使用就是链接这个资源池\n  initPool(master);\n}\n\n//通过哨兵获取到主节点返回，并设置对主节点的监控\nprivate HostAndPort initSentinels(Set<String> sentinels, final String masterName) {\n  HostAndPort master = null;\n  boolean sentinelAvailable = false;\n  log.info(\"Trying to find master from available Sentinels...\");\n  //遍历设置的哨兵节点  \n  for (String sentinel : sentinels) {\n    final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel.split(\":\")));\n    log.fine(\"Connecting to Sentinel \" + hap);\n    Jedis jedis = null;\n    try {\n      //链接哨兵节点\n      jedis = new Jedis(hap.getHost(), hap.getPort());\n      //通过第一个哨兵节点获取到监控的主节点的Ip和端口，传入的是masterName\n      List<String> masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n      //到这一步表示链接哨兵没问题，并获取到了数据  \n      sentinelAvailable = true;\n      //如果这个哨兵获取不到，就循环继续获取\n      if (masterAddr == null || masterAddr.size() != 2) {\n        log.warning(\"Can not get master addr, master name: \" + masterName + \". Sentinel: \" + hap\n            + \".\");\n        continue;\n      }\n\t //转成HostAndPort对象\n      master = toHostAndPort(masterAddr);\n      log.fine(\"Found Redis master at \" + master);\n      break;\n    } catch (JedisConnectionException e) {\n      log.warning(\"Cannot connect to sentinel running @ \" + hap + \". Trying next one.\");\n    } finally {\n      if (jedis != null) {\n        jedis.close();\n      }\n    }\n  }\n\n  //没有获取到主节点就报错\n  if (master == null) {\n    if (sentinelAvailable) {\n      throw new JedisException(\"Can connect to sentinel, but \" + masterName\n          + \" seems to be not monitored...\");\n    } else {\n      throw new JedisConnectionException(\"All sentinels down, cannot determine where is \"\n          + masterName + \" master is running...\");\n    }\n  }\n    \n  log.info(\"Redis master running at \" + master + \", starting Sentinel listeners...\");\n    \n  for (String sentinel : sentinels) {\n    //获取哨兵节点的Ip和端口\n    final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel.split(\":\")));\n    //启动监听自动故障转移并重新初始化主节点\n    MasterListener masterListener = new MasterListener(masterName, hap.getHost(), hap.getPort());\n    masterListener.setDaemon(true);\n    masterListeners.add(masterListener);\n    masterListener.start();\n  }\n  return master;\n}\n```\n\n```java\nprotected class MasterListener extends Thread {\n   //... 省略非关键代码\n    public void run() {\n      running.set(true);\n      while (running.get()) {\n        j = new Jedis(host, port);\n        try {\n          if (!running.get()) {\n            break;\n          }\n          //通过订阅+switch-master频道来感知新的主节点\n          j.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              log.fine(\"Sentinel \" + host + \":\" + port + \" published: \" + message + \".\");\n              String[] switchMasterMsg = message.split(\" \");\n\n              if (switchMasterMsg.length > 3) {\n                if (masterName.equals(switchMasterMsg[0])) {\n                  //重新初始化新的主节点\n                  initPool(toHostAndPort(Arrays.asList(switchMasterMsg[3], switchMasterMsg[4])));\n                } else {\n                  log.fine(\"Ignoring message on +switch-master for master name \"\n                      + switchMasterMsg[0] + \", our master name is \" + masterName);\n                }\n\n              } else {\n                log.severe(\"Invalid message received on Sentinel \" + host + \":\" + port\n                    + \" on channel +switch-master: \" + message);\n              }\n            }\n          }, \"+switch-master\");\n\n        } catch (JedisConnectionException e) {\n\t\t\t//... 省略非关键代码\n        } finally {\n             //... 省略非关键代码\n        }\n      }\n    }\n  }\n```\n\n#### 解决无法读写分离方案\n\nJedisSentinelPool底层使用的是commons.pool2对象池。分析对应的initPool方法，通过传入Master节点到Jedis工厂(JedisFactory)然后链接主节点对象池。\n\n```java\n//通过主节点初始化Jedis对象池  \nprivate void initPool(HostAndPort master) {\n    if (!master.equals(currentHostMaster)) {\n      currentHostMaster = master;\n      if (factory == null) {\n        //传入Master节点\n        factory = new JedisFactory(master.getHost(), master.getPort(), connectionTimeout,\n            soTimeout, password, database, clientName);\n        initPool(poolConfig, factory);\n      } else {\n        factory.setHostAndPort(currentHostMaster);\n        internalPool.clear();\n      }\n      log.info(\"Created JedisPool to master at \" + master);\n    }\n  }\n```\n\n```java\n//redis/clients/jedis/JedisFactory/class  \n@Override\n  public PooledObject<Jedis> makeObject() throws Exception {\n    final HostAndPort hostAndPort = this.hostAndPort.get();\n    //根据主节点来建立资源池\n    final Jedis jedis = new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout,\n        soTimeout);\n\n    jedis.connect();\n    if (null != this.password) {\n      jedis.auth(this.password);\n    }\n    if (database != 0) {\n      jedis.select(database);\n    }\n    if (clientName != null) {\n      jedis.clientSetname(clientName);\n    }\n    return new DefaultPooledObject<Jedis>(jedis);\n  }\n```\n\n所以我们的改造方案：\n\n- 新建一个JedisSlaveSentinelPool类，方法全部照抄JedisSentinelPool类的，其中initPool方法使用JedisFactory替换成JedisSlaveFactory(第二步新建的类)。并去掉MasterListener监听器，因为原来JedisSentinelPool类的MasterListener监听器的功能是当主节点挂时重新选一个从节点，我们这里并不适用。\n- 新建JedisSlaveFactory类，方法全部照抄JedisFactory类，重写makeObject类，通过获取从节点来建立资源池。\n- 新建一个JedisUtils工具类，写操作用主节点对应的资源池，读节点用从节点对应的资源池。\n\n\n\n","slug":"redis-sentinel","published":1,"updated":"2021-04-08T00:47:06.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvr003bqwv25nzk0l95","content":"<h2 id=\"Redis哨兵概述\"><a href=\"#Redis哨兵概述\" class=\"headerlink\" title=\"Redis哨兵概述\"></a>Redis哨兵概述</h2><p>Redis Sentinel是一个分布式系统，为Redis提供<font color=\"red\">高可用性</font>解决方案，通过监控各个Redis节点(主从服务器)实现<font color=\"red\">自动障迁移</font>。</p>\n<p>Redis Sentinel功能包括 ：</p>\n<ul>\n<li>监控。Sentinel 会不断地定期检查你的主服务器和从服务器是否运作正常。</li>\n<li>提醒。当被监控的某个 Redis 服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。</li>\n<li>自动故障迁移。当主服务器发生故障时，执行自动故障转移，将从服务器升级为新的主服务器，并让其他从服务器复制新的主服务器数据。<ul>\n<li>从服务器宕机时没什么，但当从服务器重新启动后会自动加入到主从架构中，自动完成同步数据。</li>\n<li>主服务器宕机时在从服务器中选出一台从服务器提升为主服务器，其他从服务器复制新的主服务器，原来的主服务器恢复后自动加入到主从架构中成为从服务器。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2020/08/14/redis-sentinel/1.png\" alt=\"redis哨兵架构图\"></p>\n<p>所以说，本身redis哨兵也是一个<font color=\"red\">分布式集群系统</font>。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Redis哨兵配置\"><a href=\"#Redis哨兵配置\" class=\"headerlink\" title=\"Redis哨兵配置\"></a>Redis哨兵配置</h2><pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\"># sentinel monitor mymaster 127.0.0.1 6379 2</span>\n<span class=\"token comment\" spellcheck=\"true\"># 哨兵节点定期监控 名字叫做 &lt;master-name>  并且 IP 为 &lt;ip> 端口号为 &lt;port> 的主节点</span>\n<span class=\"token comment\" spellcheck=\"true\">#quorum表示哨兵判断节点是否发生故障的票数，设置成2表示要两个哨兵认为主节点故障了才会客户下线</span>\n<span class=\"token comment\" spellcheck=\"true\">#一般这个值是number(sentinel)/2 + 1</span>\n<span class=\"token attr-name\">sentinel</span> <span class=\"token attr-value\">monitor &lt;master-name> &lt;ip> &lt;port> &lt;quorum></span>\n\n<span class=\"token comment\" spellcheck=\"true\">#sentinel down-after-milliseconds mymaster 2000</span>\n<span class=\"token comment\" spellcheck=\"true\">#哨兵定期发送ping命令判断Redis节点和哨兵节点是否可达，如果超过了这个值没有回复pong，</span>\n<span class=\"token comment\" spellcheck=\"true\">#主观判断节点是不可达的，单位是毫秒</span>\n<span class=\"token attr-name\">sentinel</span> <span class=\"token attr-value\">down-after-milliseconds &lt;master-name> &lt;times></span>\n\n<span class=\"token comment\" spellcheck=\"true\">#sentinel parallel-syncs mymaster 2</span>\n<span class=\"token comment\" spellcheck=\"true\">#当哨兵选出新的Redis主节点时，其他的从节点会从这个新主节点复制数据，这个值用来控制</span>\n<span class=\"token comment\" spellcheck=\"true\">#每次可以向新的主节点复制的节点个数。</span>\n<span class=\"token comment\" spellcheck=\"true\">#为啥要这样控制?可以看下主从复制的原理，防止过多从节点同一时间复制造成主节点阻塞</span>\n<span class=\"token attr-name\">sentinel</span> <span class=\"token attr-value\">parallel-syncs &lt;master-name> &lt;nums></span>\n\n<span class=\"token comment\" spellcheck=\"true\">#sentinel failover-timeout mymaster 2000</span>\n<span class=\"token comment\" spellcheck=\"true\">#哨兵进行故障转移时如果超过了配置的&lt;times>时间就表示故障转移超时失败</span>\n<span class=\"token attr-name\">sentinel</span> <span class=\"token attr-value\">failover-timeout &lt;master-name>  &lt;times></span>\n\n<span class=\"token comment\" spellcheck=\"true\">#sentinel auth-pass mymaster 123456</span>\n<span class=\"token comment\" spellcheck=\"true\">#如果主节点有设置密码，这里也要设置，没啥好说的</span>\n<span class=\"token attr-name\">sentinel</span> <span class=\"token attr-value\">auth-pass &lt;master-name> &lt;password></span></code></pre>\n<p>主观下线和客观下线的区别</p>\n<ul>\n<li>主观下线就是<font color=\"red\">单个</font>sentinel认为某个服务下线。例如ping节点时没有按时回复pong就会被认为主观下线，但是这时候并不是这个这个主节点下线了，必须多个sentinel认为主观下线了，超过了quorum才会认为下线(客观下线)</li>\n<li>大部分哨兵节点都同意下线操作，也就说是客观下线</li>\n</ul>\n<h2 id=\"Redis哨兵工作原理\"><a href=\"#Redis哨兵工作原理\" class=\"headerlink\" title=\"Redis哨兵工作原理\"></a>Redis哨兵工作原理</h2><h3 id=\"哨兵Leader的选举过程\"><a href=\"#哨兵Leader的选举过程\" class=\"headerlink\" title=\"哨兵Leader的选举过程\"></a>哨兵Leader的选举过程</h3><p>当主节点被认为客观下线时候，这时候需要有一个哨兵来执行故障转移，那是由集群中的哪个哨兵来执行呢？这时候就需要选出一个Leader来做这个事。哨兵Leader的选举主要采用<font color=\"red\">Raft协议</font>。当完成故障转移后，所有哨兵又恢复平等。</p>\n<h3 id=\"自动故障转移机制\"><a href=\"#自动故障转移机制\" class=\"headerlink\" title=\"自动故障转移机制\"></a>自动故障转移机制</h3><p>sentinel状态数据结构中保存了主服务的所有从服务信息，leander sentinel按照如下的规则从从服务列表中挑选出新的主服务。</p>\n<ol>\n<li>过滤掉主观下线的节点 </li>\n<li>选择slave-priority最高的节点，如果有则返回没有就继续选择</li>\n<li>选择出复制偏移量最大的系节点，因为复制便宜量越大则数据复制的越完整，如果由就返回了，没有就继续</li>\n<li>选择run_id最小的节点</li>\n</ol>\n<p>更新主从状态。通过slaveof no one命令，让选出来的从节点成为主节点。并通过slaveof命令让其他节点成为其从节点。</p>\n<h3 id=\"哨兵的定时监控\"><a href=\"#哨兵的定时监控\" class=\"headerlink\" title=\"哨兵的定时监控\"></a>哨兵的定时监控</h3><ul>\n<li>每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到</li>\n<li>每个哨兵节点每隔2秒会向redis数据节点的指定频道（__sentinel__:hello）上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断</li>\n<li>每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测</li>\n</ul>\n<h3 id=\"工作原理总结\"><a href=\"#工作原理总结\" class=\"headerlink\" title=\"工作原理总结\"></a>工作原理总结</h3><ul>\n<li>每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。</li>\n<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。</li>\n<li>如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 </li>\n<li>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。</li>\n<li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。</li>\n<li>当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。</li>\n<li>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </li>\n</ul>\n<h2 id=\"Redis集群脑裂\"><a href=\"#Redis集群脑裂\" class=\"headerlink\" title=\"Redis集群脑裂\"></a>Redis集群脑裂</h2><p>redis的集群脑裂是指因为网络问题，导致redis master节点跟redis slave节点和sentinel集群处于不同的网络分区，此时因为sentinel集群无法感知到master的存在，所以将slave节点提升为master节点。集群的脑裂会导致<font color=\"red\">数据丢失</font>。</p>\n<p><img src=\"/2020/08/14/redis-sentinel/2.png\" alt=\"redis脑裂\"></p>\n<p><strong>解决方案</strong> ： 在redis配置文件中添加如下配置</p>\n<pre class=\" language-properties\"><code class=\"language-properties\"><span class=\"token comment\" spellcheck=\"true\">#连接到master的最少slave数量,如果少于这个数，master会拒绝写请求</span>\n<span class=\"token attr-name\">min-replicas-to-write</span> <span class=\"token attr-value\">3</span>\n<span class=\"token comment\" spellcheck=\"true\">#slave连接到master的最大延迟时间</span>\n<span class=\"token attr-name\">min-replicas-max-lag</span> <span class=\"token attr-value\">10</span></code></pre>\n<h2 id=\"Jedis不支持实现哨兵的读写分离\"><a href=\"#Jedis不支持实现哨兵的读写分离\" class=\"headerlink\" title=\"Jedis不支持实现哨兵的读写分离\"></a>Jedis不支持实现哨兵的读写分离</h2><h4 id=\"Jedis哨兵不支持读写分离分析\"><a href=\"#Jedis哨兵不支持读写分离分析\" class=\"headerlink\" title=\"Jedis哨兵不支持读写分离分析\"></a>Jedis哨兵不支持读写分离分析</h4><p>通过上面的分析我们知道哨兵解决了Redis主从的高可用性。我们一般在使用中是通过Jedis连接哨兵节点，这样当主服务器挂时我们代码上也不需要做任何改动，因为我们连的是哨兵节点。</p>\n<p>我们接下来分析下<font color=\"red\">Jedis连接哨兵源码，了解下为什么Jedis没法实现连接哨兵时的读写分离，还有我们需要如何改造</font>。</p>\n<p><strong>Jedis连接哨兵示例</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    JedisPoolConfig jedisPoolConfig <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisPoolConfig</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    jedisPoolConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxTotal</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    jedisPoolConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMaxIdle</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    jedisPoolConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setMinIdle</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 哨兵信息</span>\n    Set<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> sentinels <span class=\"token operator\">=</span> \n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"192.168.135.131:26379\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"192.168.135.131:26380\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"192.168.135.131:26381\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    JedisSentinelPool pool <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisSentinelPool</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mymaster\"</span><span class=\"token punctuation\">,</span> sentinels<span class=\"token punctuation\">,</span>jedisPoolConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Jedis jedis <span class=\"token operator\">=</span> pool<span class=\"token punctuation\">.</span><span class=\"token function\">getResource</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    jedis<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mykey\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"myvalue\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    String value <span class=\"token operator\">=</span> jedis<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mykey\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>跟踪JedisSentinelPool初始化源码</strong></p>\n<p>从下面代码我们可以知道，</p>\n<ul>\n<li>当我们链接哨兵时，哨兵获取到主节点并用主节点做资源池。</li>\n<li>每个哨兵设置一个MasterListener，订阅+switch-master，当出现主服务器挂时自动故障转移时，会收到新的主节点，然后就客户端就可以重新initPool(master)，这样就实现了自动转移后客户端自动更变主节点的链接。</li>\n</ul>\n<p>但是这样有一个缺点，<font color=\"red\">如果通过Jedis链接哨兵，所有命令只会发送到主节点处理，这样其实从节点只是做一个热备份的作用，当我们需要读写分离来分担主节点压力时就没办法了。</font></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">JedisSentinelPool</span><span class=\"token punctuation\">(</span>String masterName<span class=\"token punctuation\">,</span> Set<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> sentinels<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">final</span> GenericObjectPoolConfig poolConfig<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> connectionTimeout<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> soTimeout<span class=\"token punctuation\">,</span>\n    <span class=\"token keyword\">final</span> String password<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> database<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> String clientName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>poolConfig <span class=\"token operator\">=</span> poolConfig<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>connectionTimeout <span class=\"token operator\">=</span> connectionTimeout<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>soTimeout <span class=\"token operator\">=</span> soTimeout<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>password <span class=\"token operator\">=</span> password<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>database <span class=\"token operator\">=</span> database<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>clientName <span class=\"token operator\">=</span> clientName<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">//获取主节点</span>\n  HostAndPort master <span class=\"token operator\">=</span> <span class=\"token function\">initSentinels</span><span class=\"token punctuation\">(</span>sentinels<span class=\"token punctuation\">,</span> masterName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">//通过master初始化资源池，后面我们使用就是链接这个资源池</span>\n  <span class=\"token function\">initPool</span><span class=\"token punctuation\">(</span>master<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//通过哨兵获取到主节点返回，并设置对主节点的监控</span>\n<span class=\"token keyword\">private</span> HostAndPort <span class=\"token function\">initSentinels</span><span class=\"token punctuation\">(</span>Set<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> sentinels<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> String masterName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  HostAndPort master <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">boolean</span> sentinelAvailable <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Trying to find master from available Sentinels...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\" spellcheck=\"true\">//遍历设置的哨兵节点  </span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>String sentinel <span class=\"token operator\">:</span> sentinels<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> HostAndPort hap <span class=\"token operator\">=</span> <span class=\"token function\">toHostAndPort</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>sentinel<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\":\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    log<span class=\"token punctuation\">.</span><span class=\"token function\">fine</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Connecting to Sentinel \"</span> <span class=\"token operator\">+</span> hap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Jedis jedis <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">//链接哨兵节点</span>\n      jedis <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Jedis</span><span class=\"token punctuation\">(</span>hap<span class=\"token punctuation\">.</span><span class=\"token function\">getHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> hap<span class=\"token punctuation\">.</span><span class=\"token function\">getPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">//通过第一个哨兵节点获取到监控的主节点的Ip和端口，传入的是masterName</span>\n      List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> masterAddr <span class=\"token operator\">=</span> jedis<span class=\"token punctuation\">.</span><span class=\"token function\">sentinelGetMasterAddrByName</span><span class=\"token punctuation\">(</span>masterName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">//到这一步表示链接哨兵没问题，并获取到了数据  </span>\n      sentinelAvailable <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">//如果这个哨兵获取不到，就循环继续获取</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>masterAddr <span class=\"token operator\">==</span> null <span class=\"token operator\">||</span> masterAddr<span class=\"token punctuation\">.</span><span class=\"token function\">size</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        log<span class=\"token punctuation\">.</span><span class=\"token function\">warning</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Can not get master addr, master name: \"</span> <span class=\"token operator\">+</span> masterName <span class=\"token operator\">+</span> <span class=\"token string\">\". Sentinel: \"</span> <span class=\"token operator\">+</span> hap\n            <span class=\"token operator\">+</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">continue</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n     <span class=\"token comment\" spellcheck=\"true\">//转成HostAndPort对象</span>\n      master <span class=\"token operator\">=</span> <span class=\"token function\">toHostAndPort</span><span class=\"token punctuation\">(</span>masterAddr<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      log<span class=\"token punctuation\">.</span><span class=\"token function\">fine</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Found Redis master at \"</span> <span class=\"token operator\">+</span> master<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">JedisConnectionException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      log<span class=\"token punctuation\">.</span><span class=\"token function\">warning</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Cannot connect to sentinel running @ \"</span> <span class=\"token operator\">+</span> hap <span class=\"token operator\">+</span> <span class=\"token string\">\". Trying next one.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>jedis <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        jedis<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">//没有获取到主节点就报错</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>master <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>sentinelAvailable<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Can connect to sentinel, but \"</span> <span class=\"token operator\">+</span> masterName\n          <span class=\"token operator\">+</span> <span class=\"token string\">\" seems to be not monitored...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisConnectionException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"All sentinels down, cannot determine where is \"</span>\n          <span class=\"token operator\">+</span> masterName <span class=\"token operator\">+</span> <span class=\"token string\">\" master is running...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Redis master running at \"</span> <span class=\"token operator\">+</span> master <span class=\"token operator\">+</span> <span class=\"token string\">\", starting Sentinel listeners...\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>String sentinel <span class=\"token operator\">:</span> sentinels<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//获取哨兵节点的Ip和端口</span>\n    <span class=\"token keyword\">final</span> HostAndPort hap <span class=\"token operator\">=</span> <span class=\"token function\">toHostAndPort</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>sentinel<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\":\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//启动监听自动故障转移并重新初始化主节点</span>\n    MasterListener masterListener <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MasterListener</span><span class=\"token punctuation\">(</span>masterName<span class=\"token punctuation\">,</span> hap<span class=\"token punctuation\">.</span><span class=\"token function\">getHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> hap<span class=\"token punctuation\">.</span><span class=\"token function\">getPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    masterListener<span class=\"token punctuation\">.</span><span class=\"token function\">setDaemon</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    masterListeners<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>masterListener<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    masterListener<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> master<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MasterListener</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token comment\" spellcheck=\"true\">//... 省略非关键代码</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      running<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>running<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        j <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Jedis</span><span class=\"token punctuation\">(</span>host<span class=\"token punctuation\">,</span> port<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>running<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token comment\" spellcheck=\"true\">//通过订阅+switch-master频道来感知新的主节点</span>\n          j<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisPubSub</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onMessage</span><span class=\"token punctuation\">(</span>String channel<span class=\"token punctuation\">,</span> String message<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              log<span class=\"token punctuation\">.</span><span class=\"token function\">fine</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Sentinel \"</span> <span class=\"token operator\">+</span> host <span class=\"token operator\">+</span> <span class=\"token string\">\":\"</span> <span class=\"token operator\">+</span> port <span class=\"token operator\">+</span> <span class=\"token string\">\" published: \"</span> <span class=\"token operator\">+</span> message <span class=\"token operator\">+</span> <span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> switchMasterMsg <span class=\"token operator\">=</span> message<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n              <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>switchMasterMsg<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>masterName<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>switchMasterMsg<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  <span class=\"token comment\" spellcheck=\"true\">//重新初始化新的主节点</span>\n                  <span class=\"token function\">initPool</span><span class=\"token punctuation\">(</span><span class=\"token function\">toHostAndPort</span><span class=\"token punctuation\">(</span>Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">asList</span><span class=\"token punctuation\">(</span>switchMasterMsg<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> switchMasterMsg<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                  log<span class=\"token punctuation\">.</span><span class=\"token function\">fine</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Ignoring message on +switch-master for master name \"</span>\n                      <span class=\"token operator\">+</span> switchMasterMsg<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> <span class=\"token string\">\", our master name is \"</span> <span class=\"token operator\">+</span> masterName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                log<span class=\"token punctuation\">.</span><span class=\"token function\">severe</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Invalid message received on Sentinel \"</span> <span class=\"token operator\">+</span> host <span class=\"token operator\">+</span> <span class=\"token string\">\":\"</span> <span class=\"token operator\">+</span> port\n                    <span class=\"token operator\">+</span> <span class=\"token string\">\" on channel +switch-master: \"</span> <span class=\"token operator\">+</span> message<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"+switch-master\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">JedisConnectionException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//... 省略非关键代码</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n             <span class=\"token comment\" spellcheck=\"true\">//... 省略非关键代码</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"解决无法读写分离方案\"><a href=\"#解决无法读写分离方案\" class=\"headerlink\" title=\"解决无法读写分离方案\"></a>解决无法读写分离方案</h4><p>JedisSentinelPool底层使用的是commons.pool2对象池。分析对应的initPool方法，通过传入Master节点到Jedis工厂(JedisFactory)然后链接主节点对象池。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//通过主节点初始化Jedis对象池  </span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initPool</span><span class=\"token punctuation\">(</span>HostAndPort master<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>master<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>currentHostMaster<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      currentHostMaster <span class=\"token operator\">=</span> master<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>factory <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//传入Master节点</span>\n        factory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JedisFactory</span><span class=\"token punctuation\">(</span>master<span class=\"token punctuation\">.</span><span class=\"token function\">getHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> master<span class=\"token punctuation\">.</span><span class=\"token function\">getPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> connectionTimeout<span class=\"token punctuation\">,</span>\n            soTimeout<span class=\"token punctuation\">,</span> password<span class=\"token punctuation\">,</span> database<span class=\"token punctuation\">,</span> clientName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">initPool</span><span class=\"token punctuation\">(</span>poolConfig<span class=\"token punctuation\">,</span> factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        factory<span class=\"token punctuation\">.</span><span class=\"token function\">setHostAndPort</span><span class=\"token punctuation\">(</span>currentHostMaster<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        internalPool<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      log<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Created JedisPool to master at \"</span> <span class=\"token operator\">+</span> master<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//redis/clients/jedis/JedisFactory/class  </span>\n<span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> PooledObject<span class=\"token operator\">&lt;</span>Jedis<span class=\"token operator\">></span> <span class=\"token function\">makeObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> HostAndPort hostAndPort <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>hostAndPort<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//根据主节点来建立资源池</span>\n    <span class=\"token keyword\">final</span> Jedis jedis <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Jedis</span><span class=\"token punctuation\">(</span>hostAndPort<span class=\"token punctuation\">.</span><span class=\"token function\">getHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> hostAndPort<span class=\"token punctuation\">.</span><span class=\"token function\">getPort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> connectionTimeout<span class=\"token punctuation\">,</span>\n        soTimeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    jedis<span class=\"token punctuation\">.</span><span class=\"token function\">connect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>null <span class=\"token operator\">!=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>password<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      jedis<span class=\"token punctuation\">.</span><span class=\"token function\">auth</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>password<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>database <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      jedis<span class=\"token punctuation\">.</span><span class=\"token function\">select</span><span class=\"token punctuation\">(</span>database<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>clientName <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      jedis<span class=\"token punctuation\">.</span><span class=\"token function\">clientSetname</span><span class=\"token punctuation\">(</span>clientName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultPooledObject</span><span class=\"token operator\">&lt;</span>Jedis<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>jedis<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n<p>所以我们的改造方案：</p>\n<ul>\n<li>新建一个JedisSlaveSentinelPool类，方法全部照抄JedisSentinelPool类的，其中initPool方法使用JedisFactory替换成JedisSlaveFactory(第二步新建的类)。并去掉MasterListener监听器，因为原来JedisSentinelPool类的MasterListener监听器的功能是当主节点挂时重新选一个从节点，我们这里并不适用。</li>\n<li>新建JedisSlaveFactory类，方法全部照抄JedisFactory类，重写makeObject类，通过获取从节点来建立资源池。</li>\n<li>新建一个JedisUtils工具类，写操作用主节点对应的资源池，读节点用从节点对应的资源池。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Redis哨兵概述\"><a href=\"#Redis哨兵概述\" class=\"headerlink\" title=\"Redis哨兵概述\"></a>Redis哨兵概述</h2><p>Redis Sentinel是一个分布式系统，为Redis提供<font color=\"red\">高可用性</font>解决方案，通过监控各个Redis节点(主从服务器)实现<font color=\"red\">自动障迁移</font>。</p>\n<p>Redis Sentinel功能包括 ：</p>\n<ul>\n<li>监控。Sentinel 会不断地定期检查你的主服务器和从服务器是否运作正常。</li>\n<li>提醒。当被监控的某个 Redis 服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发送通知。</li>\n<li>自动故障迁移。当主服务器发生故障时，执行自动故障转移，将从服务器升级为新的主服务器，并让其他从服务器复制新的主服务器数据。<ul>\n<li>从服务器宕机时没什么，但当从服务器重新启动后会自动加入到主从架构中，自动完成同步数据。</li>\n<li>主服务器宕机时在从服务器中选出一台从服务器提升为主服务器，其他从服务器复制新的主服务器，原来的主服务器恢复后自动加入到主从架构中成为从服务器。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/2020/08/14/redis-sentinel/1.png\" alt=\"redis哨兵架构图\"></p>\n<p>所以说，本身redis哨兵也是一个<font color=\"red\">分布式集群系统</font>。</p>","more":"<h2 id=\"Redis哨兵配置\"><a href=\"#Redis哨兵配置\" class=\"headerlink\" title=\"Redis哨兵配置\"></a>Redis哨兵配置</h2><pre><code class=\"properties\"># sentinel monitor mymaster 127.0.0.1 6379 2\n# 哨兵节点定期监控 名字叫做 &lt;master-name&gt;  并且 IP 为 &lt;ip&gt; 端口号为 &lt;port&gt; 的主节点\n#quorum表示哨兵判断节点是否发生故障的票数，设置成2表示要两个哨兵认为主节点故障了才会客户下线\n#一般这个值是number(sentinel)/2 + 1\nsentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;\n\n#sentinel down-after-milliseconds mymaster 2000\n#哨兵定期发送ping命令判断Redis节点和哨兵节点是否可达，如果超过了这个值没有回复pong，\n#主观判断节点是不可达的，单位是毫秒\nsentinel down-after-milliseconds &lt;master-name&gt; &lt;times&gt;\n\n#sentinel parallel-syncs mymaster 2\n#当哨兵选出新的Redis主节点时，其他的从节点会从这个新主节点复制数据，这个值用来控制\n#每次可以向新的主节点复制的节点个数。\n#为啥要这样控制?可以看下主从复制的原理，防止过多从节点同一时间复制造成主节点阻塞\nsentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt;\n\n#sentinel failover-timeout mymaster 2000\n#哨兵进行故障转移时如果超过了配置的&lt;times&gt;时间就表示故障转移超时失败\nsentinel failover-timeout &lt;master-name&gt;  &lt;times&gt;\n\n#sentinel auth-pass mymaster 123456\n#如果主节点有设置密码，这里也要设置，没啥好说的\nsentinel auth-pass &lt;master-name&gt; &lt;password&gt;</code></pre>\n<p>主观下线和客观下线的区别</p>\n<ul>\n<li>主观下线就是<font color=\"red\">单个</font>sentinel认为某个服务下线。例如ping节点时没有按时回复pong就会被认为主观下线，但是这时候并不是这个这个主节点下线了，必须多个sentinel认为主观下线了，超过了quorum才会认为下线(客观下线)</li>\n<li>大部分哨兵节点都同意下线操作，也就说是客观下线</li>\n</ul>\n<h2 id=\"Redis哨兵工作原理\"><a href=\"#Redis哨兵工作原理\" class=\"headerlink\" title=\"Redis哨兵工作原理\"></a>Redis哨兵工作原理</h2><h3 id=\"哨兵Leader的选举过程\"><a href=\"#哨兵Leader的选举过程\" class=\"headerlink\" title=\"哨兵Leader的选举过程\"></a>哨兵Leader的选举过程</h3><p>当主节点被认为客观下线时候，这时候需要有一个哨兵来执行故障转移，那是由集群中的哪个哨兵来执行呢？这时候就需要选出一个Leader来做这个事。哨兵Leader的选举主要采用<font color=\"red\">Raft协议</font>。当完成故障转移后，所有哨兵又恢复平等。</p>\n<h3 id=\"自动故障转移机制\"><a href=\"#自动故障转移机制\" class=\"headerlink\" title=\"自动故障转移机制\"></a>自动故障转移机制</h3><p>sentinel状态数据结构中保存了主服务的所有从服务信息，leander sentinel按照如下的规则从从服务列表中挑选出新的主服务。</p>\n<ol>\n<li>过滤掉主观下线的节点 </li>\n<li>选择slave-priority最高的节点，如果有则返回没有就继续选择</li>\n<li>选择出复制偏移量最大的系节点，因为复制便宜量越大则数据复制的越完整，如果由就返回了，没有就继续</li>\n<li>选择run_id最小的节点</li>\n</ol>\n<p>更新主从状态。通过slaveof no one命令，让选出来的从节点成为主节点。并通过slaveof命令让其他节点成为其从节点。</p>\n<h3 id=\"哨兵的定时监控\"><a href=\"#哨兵的定时监控\" class=\"headerlink\" title=\"哨兵的定时监控\"></a>哨兵的定时监控</h3><ul>\n<li>每个哨兵节点每10秒会向主节点和从节点发送info命令获取最拓扑结构图，哨兵配置时只要配置对主节点的监控即可，通过向主节点发送info，获取从节点的信息，并当有新的从节点加入时可以马上感知到</li>\n<li>每个哨兵节点每隔2秒会向redis数据节点的指定频道（__sentinel__:hello）上发送该哨兵节点对于主节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对主节点的判断</li>\n<li>每隔1秒每个哨兵会向主节点、从节点及其余哨兵节点发送一次ping命令做一次心跳检测</li>\n</ul>\n<h3 id=\"工作原理总结\"><a href=\"#工作原理总结\" class=\"headerlink\" title=\"工作原理总结\"></a>工作原理总结</h3><ul>\n<li>每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个 PING 命令。</li>\n<li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel 标记为主观下线。</li>\n<li>如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。 </li>\n<li>当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线 。</li>\n<li>在一般情况下， 每个 Sentinel 会以每 10 秒一次的频率向它已知的所有Master，Slave发送 INFO 命令 。</li>\n<li>当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次 。</li>\n<li>若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。 </li>\n</ul>\n<h2 id=\"Redis集群脑裂\"><a href=\"#Redis集群脑裂\" class=\"headerlink\" title=\"Redis集群脑裂\"></a>Redis集群脑裂</h2><p>redis的集群脑裂是指因为网络问题，导致redis master节点跟redis slave节点和sentinel集群处于不同的网络分区，此时因为sentinel集群无法感知到master的存在，所以将slave节点提升为master节点。集群的脑裂会导致<font color=\"red\">数据丢失</font>。</p>\n<p><img src=\"/2020/08/14/redis-sentinel/2.png\" alt=\"redis脑裂\"></p>\n<p><strong>解决方案</strong> ： 在redis配置文件中添加如下配置</p>\n<pre><code class=\"properties\">#连接到master的最少slave数量,如果少于这个数，master会拒绝写请求\nmin-replicas-to-write 3\n#slave连接到master的最大延迟时间\nmin-replicas-max-lag 10</code></pre>\n<h2 id=\"Jedis不支持实现哨兵的读写分离\"><a href=\"#Jedis不支持实现哨兵的读写分离\" class=\"headerlink\" title=\"Jedis不支持实现哨兵的读写分离\"></a>Jedis不支持实现哨兵的读写分离</h2><h4 id=\"Jedis哨兵不支持读写分离分析\"><a href=\"#Jedis哨兵不支持读写分离分析\" class=\"headerlink\" title=\"Jedis哨兵不支持读写分离分析\"></a>Jedis哨兵不支持读写分离分析</h4><p>通过上面的分析我们知道哨兵解决了Redis主从的高可用性。我们一般在使用中是通过Jedis连接哨兵节点，这样当主服务器挂时我们代码上也不需要做任何改动，因为我们连的是哨兵节点。</p>\n<p>我们接下来分析下<font color=\"red\">Jedis连接哨兵源码，了解下为什么Jedis没法实现连接哨兵时的读写分离，还有我们需要如何改造</font>。</p>\n<p><strong>Jedis连接哨兵示例</strong></p>\n<pre><code class=\"java\">@Test\npublic void test02(){\n    JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();\n    jedisPoolConfig.setMaxTotal(10);\n    jedisPoolConfig.setMaxIdle(5);\n    jedisPoolConfig.setMinIdle(5);\n    // 哨兵信息\n    Set&lt;String&gt; sentinels = \n        new HashSet&lt;&gt;(Arrays.asList(&quot;192.168.135.131:26379&quot;,&quot;192.168.135.131:26380&quot;,&quot;192.168.135.131:26381&quot;));\n    JedisSentinelPool pool = new JedisSentinelPool(&quot;mymaster&quot;, sentinels,jedisPoolConfig);\n    Jedis jedis = pool.getResource();\n    jedis.set(&quot;mykey&quot;, &quot;myvalue&quot;);\n    String value = jedis.get(&quot;mykey&quot;);\n    System.out.println(value);\n}</code></pre>\n<p><strong>跟踪JedisSentinelPool初始化源码</strong></p>\n<p>从下面代码我们可以知道，</p>\n<ul>\n<li>当我们链接哨兵时，哨兵获取到主节点并用主节点做资源池。</li>\n<li>每个哨兵设置一个MasterListener，订阅+switch-master，当出现主服务器挂时自动故障转移时，会收到新的主节点，然后就客户端就可以重新initPool(master)，这样就实现了自动转移后客户端自动更变主节点的链接。</li>\n</ul>\n<p>但是这样有一个缺点，<font color=\"red\">如果通过Jedis链接哨兵，所有命令只会发送到主节点处理，这样其实从节点只是做一个热备份的作用，当我们需要读写分离来分担主节点压力时就没办法了。</font></p>\n<pre><code class=\"java\">public JedisSentinelPool(String masterName, Set&lt;String&gt; sentinels,\n    final GenericObjectPoolConfig poolConfig, final int connectionTimeout, final int soTimeout,\n    final String password, final int database, final String clientName) {\n  this.poolConfig = poolConfig;\n  this.connectionTimeout = connectionTimeout;\n  this.soTimeout = soTimeout;\n  this.password = password;\n  this.database = database;\n  this.clientName = clientName;\n  //获取主节点\n  HostAndPort master = initSentinels(sentinels, masterName);\n  //通过master初始化资源池，后面我们使用就是链接这个资源池\n  initPool(master);\n}\n\n//通过哨兵获取到主节点返回，并设置对主节点的监控\nprivate HostAndPort initSentinels(Set&lt;String&gt; sentinels, final String masterName) {\n  HostAndPort master = null;\n  boolean sentinelAvailable = false;\n  log.info(&quot;Trying to find master from available Sentinels...&quot;);\n  //遍历设置的哨兵节点  \n  for (String sentinel : sentinels) {\n    final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel.split(&quot;:&quot;)));\n    log.fine(&quot;Connecting to Sentinel &quot; + hap);\n    Jedis jedis = null;\n    try {\n      //链接哨兵节点\n      jedis = new Jedis(hap.getHost(), hap.getPort());\n      //通过第一个哨兵节点获取到监控的主节点的Ip和端口，传入的是masterName\n      List&lt;String&gt; masterAddr = jedis.sentinelGetMasterAddrByName(masterName);\n      //到这一步表示链接哨兵没问题，并获取到了数据  \n      sentinelAvailable = true;\n      //如果这个哨兵获取不到，就循环继续获取\n      if (masterAddr == null || masterAddr.size() != 2) {\n        log.warning(&quot;Can not get master addr, master name: &quot; + masterName + &quot;. Sentinel: &quot; + hap\n            + &quot;.&quot;);\n        continue;\n      }\n     //转成HostAndPort对象\n      master = toHostAndPort(masterAddr);\n      log.fine(&quot;Found Redis master at &quot; + master);\n      break;\n    } catch (JedisConnectionException e) {\n      log.warning(&quot;Cannot connect to sentinel running @ &quot; + hap + &quot;. Trying next one.&quot;);\n    } finally {\n      if (jedis != null) {\n        jedis.close();\n      }\n    }\n  }\n\n  //没有获取到主节点就报错\n  if (master == null) {\n    if (sentinelAvailable) {\n      throw new JedisException(&quot;Can connect to sentinel, but &quot; + masterName\n          + &quot; seems to be not monitored...&quot;);\n    } else {\n      throw new JedisConnectionException(&quot;All sentinels down, cannot determine where is &quot;\n          + masterName + &quot; master is running...&quot;);\n    }\n  }\n\n  log.info(&quot;Redis master running at &quot; + master + &quot;, starting Sentinel listeners...&quot;);\n\n  for (String sentinel : sentinels) {\n    //获取哨兵节点的Ip和端口\n    final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel.split(&quot;:&quot;)));\n    //启动监听自动故障转移并重新初始化主节点\n    MasterListener masterListener = new MasterListener(masterName, hap.getHost(), hap.getPort());\n    masterListener.setDaemon(true);\n    masterListeners.add(masterListener);\n    masterListener.start();\n  }\n  return master;\n}</code></pre>\n<pre><code class=\"java\">protected class MasterListener extends Thread {\n   //... 省略非关键代码\n    public void run() {\n      running.set(true);\n      while (running.get()) {\n        j = new Jedis(host, port);\n        try {\n          if (!running.get()) {\n            break;\n          }\n          //通过订阅+switch-master频道来感知新的主节点\n          j.subscribe(new JedisPubSub() {\n            @Override\n            public void onMessage(String channel, String message) {\n              log.fine(&quot;Sentinel &quot; + host + &quot;:&quot; + port + &quot; published: &quot; + message + &quot;.&quot;);\n              String[] switchMasterMsg = message.split(&quot; &quot;);\n\n              if (switchMasterMsg.length &gt; 3) {\n                if (masterName.equals(switchMasterMsg[0])) {\n                  //重新初始化新的主节点\n                  initPool(toHostAndPort(Arrays.asList(switchMasterMsg[3], switchMasterMsg[4])));\n                } else {\n                  log.fine(&quot;Ignoring message on +switch-master for master name &quot;\n                      + switchMasterMsg[0] + &quot;, our master name is &quot; + masterName);\n                }\n\n              } else {\n                log.severe(&quot;Invalid message received on Sentinel &quot; + host + &quot;:&quot; + port\n                    + &quot; on channel +switch-master: &quot; + message);\n              }\n            }\n          }, &quot;+switch-master&quot;);\n\n        } catch (JedisConnectionException e) {\n            //... 省略非关键代码\n        } finally {\n             //... 省略非关键代码\n        }\n      }\n    }\n  }</code></pre>\n<h4 id=\"解决无法读写分离方案\"><a href=\"#解决无法读写分离方案\" class=\"headerlink\" title=\"解决无法读写分离方案\"></a>解决无法读写分离方案</h4><p>JedisSentinelPool底层使用的是commons.pool2对象池。分析对应的initPool方法，通过传入Master节点到Jedis工厂(JedisFactory)然后链接主节点对象池。</p>\n<pre><code class=\"java\">//通过主节点初始化Jedis对象池  \nprivate void initPool(HostAndPort master) {\n    if (!master.equals(currentHostMaster)) {\n      currentHostMaster = master;\n      if (factory == null) {\n        //传入Master节点\n        factory = new JedisFactory(master.getHost(), master.getPort(), connectionTimeout,\n            soTimeout, password, database, clientName);\n        initPool(poolConfig, factory);\n      } else {\n        factory.setHostAndPort(currentHostMaster);\n        internalPool.clear();\n      }\n      log.info(&quot;Created JedisPool to master at &quot; + master);\n    }\n  }</code></pre>\n<pre><code class=\"java\">//redis/clients/jedis/JedisFactory/class  \n@Override\n  public PooledObject&lt;Jedis&gt; makeObject() throws Exception {\n    final HostAndPort hostAndPort = this.hostAndPort.get();\n    //根据主节点来建立资源池\n    final Jedis jedis = new Jedis(hostAndPort.getHost(), hostAndPort.getPort(), connectionTimeout,\n        soTimeout);\n\n    jedis.connect();\n    if (null != this.password) {\n      jedis.auth(this.password);\n    }\n    if (database != 0) {\n      jedis.select(database);\n    }\n    if (clientName != null) {\n      jedis.clientSetname(clientName);\n    }\n    return new DefaultPooledObject&lt;Jedis&gt;(jedis);\n  }</code></pre>\n<p>所以我们的改造方案：</p>\n<ul>\n<li>新建一个JedisSlaveSentinelPool类，方法全部照抄JedisSentinelPool类的，其中initPool方法使用JedisFactory替换成JedisSlaveFactory(第二步新建的类)。并去掉MasterListener监听器，因为原来JedisSentinelPool类的MasterListener监听器的功能是当主节点挂时重新选一个从节点，我们这里并不适用。</li>\n<li>新建JedisSlaveFactory类，方法全部照抄JedisFactory类，重写makeObject类，通过获取从节点来建立资源池。</li>\n<li>新建一个JedisUtils工具类，写操作用主节点对应的资源池，读节点用从节点对应的资源池。</li>\n</ul>"},{"title":"ShardingJdbc编排治理详解","description":"ShardingJdbc结合zookeeper做全局配置","date":"2021-02-02T02:25:35.000Z","_content":"## 分布式配置中心\n在分布式系统或者微服务中，我们经常用到分布式配置中心，他可以将配置定义到一个单独的地方以便所有分布式系统从能从中读取配置，对于修改配置也只需要修改一个地方就行。\n## ShardingSphere编排治理\n\n### 为啥需要编排治理？\n\nShardingSphere的编排治理提供了配置中心和注册中心功能。\n在使用ShardingSphere我们经常定义了一堆分库分表规则。传统的ShardingJdcb我们一般将分库分表规则配置在yml文件或者xml文件中。然而在分布式系统中，假设我们有100台机器做负载均衡，由于需求原因分库分表规则需要添加规则，这时候我们的处理如下：\n\n1. 对100台机器上的分库分表配置文件yml文件进行逐一修改\n2. 逐一重启100台机器Tomcat\n\n这其中的复杂程度可想而知。有人会说，可以将配置定义在一个分布式配置中心中。 没错 ！！！\n\n所以ShardingSphere提供了编排治理功能，通俗一点就是通过ShardingSphere + Zookeeper 或者 Etcd  实现 分布式配置功能，并且通过Zookeeper的Watch机制保证每次修改后<font color=red>自动加载无需重启</font>。\n<!--more-->\n### 如何使用？\n\n导入编排治理Maven\n\n```xml\n<dependency>\n            <groupId>io.shardingsphere</groupId>\n            <artifactId>sharding-jdbc-orchestration-spring-namespace</artifactId>\n            <version>3.0.0.M3</version>\n</dependency>\n<dependency>\n            <groupId>io.shardingsphere</groupId>\n            <artifactId>sharding-orchestration-reg-zookeeper-curator</artifactId>\n            <version>3.0.0</version>\n</dependency>\n```\n\n最终测试代码\n\n```java\n@Test\npublic void testOrchestration2() throws Exception {\n\n    //先删除zk上相关的配置\n    deleteZkDataSourceAndRule();\n    //加载DataSource信息到zk\n    initDataSourceZkData();\n    //加载分库分表规则到ZK\n    initRuleZkData();\n\n    ZookeeperConfiguration regConfig = new ZookeeperConfiguration();\n    regConfig.setServerLists(\"localhost:2181\");\n    regConfig.setNamespace(\"sharding-data\");\n    OrchestrationConfiguration orchConcifg = new OrchestrationConfiguration(\"xuzy\",regConfig,false, OrchestrationType.SHARDING);\n    //通过OrchestrationShardingDataSourceFactory创建ShardingDataSource\n    DataSource dataSource = OrchestrationShardingDataSourceFactory.createDataSource(orchConcifg);\n    //查询\n    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n    //查询， 此时如果查询2021年的话会报错\n    List<Map<String, Object>> list = jdbcTemplate.queryForList(\"select * from flow where flowtime in ('20170818','20190205')\");\n\n\n    //修改DataSource信息（新增了dataSource_2021）到ZK\n    updateDataSourceZkData();\n    //修改分库分表规则(flow新增了2021年规则)到ZK\n    updateRuleZkData();\n\n    TimeUnit.SECONDS.sleep(20);\n\n    //查询， 此时如果查询2021年的话不会报错\n    List<Map<String, Object>> listNew = jdbcTemplate.queryForList(\"select * from flow where flowtime in ('20170818','20190205','20210405')\");\n    System.out.println(listNew);\n}\n```\n\n删除zookeeper上的sharding配置\n\n```java\n@Test\npublic void deleteZkDataSourceAndRule() throws Exception {\n    //zookeeper节点名称定义在io.shardingsphere.jdbc.orchestration.internal.config.ConfigurationNode上，会面说明\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    Stat stat = cf.checkExists().forPath(\"/sharding-data/xuzy/config/datasource\");\n    if(stat != null){\n        cf.delete().forPath(\"/sharding-data/xuzy/config/datasource\");\n    }\n    Stat stat2 = cf.checkExists().forPath(\"/sharding-data/xuzy/config/sharding/rule\");\n    if(stat2 != null){\n        cf.delete().forPath(\"/sharding-data/xuzy/config/sharding/rule\");\n    }\n    cf.close();\n}\n```\n\n加加载DataSource信息到zookeeper\n\n```java\n@Test\npublic void initDataSourceZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    //创建datasource信息 orchestration-sharding-data-source为命名空间 ，闯将的datasource是ymal模式的\n    //Map<String, DataSource> result = DataSourceConverter.dataSourceMapFromYaml(this.regCenter.getDirectly(this.configNode.getFullPath(\"config/datasource\")));\n    String dataSource = \"\" +\n            \"  dataSource_default: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2017: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2018: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2019: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2020: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\";\n    cf.create()\n            .creatingParentsIfNeeded() //自动创建父节点\n            .withMode(CreateMode.PERSISTENT) //设置成永久节点\n            .forPath(\"/sharding-data/xuzy/config/datasource\", dataSource.getBytes());\n    cf.close();\n}\n```\n\n加载分库分表规则到Zookeeper\n\n```java\n@Test\npublic void initRuleZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    String rule = \"  tables:\\n\" +\n            \"    flow:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\" +\n            \"    ips:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\" +\n            \"    acca:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        complex:\\n\" +\n            \"          shardingColumns: flowtime,dataType\\n\" +\n            \"          algorithmClassName: com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        complex:\\n\" +\n            \"          shardingColumns: flowtime,dataType\\n\" +\n            \"          algorithmClassName: com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\\n\" +\n            \"  bindingTables:\\n\" +\n            \"    - flow,ips,acca\\n\" +\n            \"  defaultDatabaseStrategy:\\n\" +\n            \"    none:\\n\" +\n            \"  defaultTableStrategy:\\n\" +\n            \"    none:\";\n    cf.create()\n            .creatingParentsIfNeeded() //自动创建父节点\n            .withMode(CreateMode.PERSISTENT) //设置成永久节点\n            .forPath(\"/sharding-data/xuzy/config/sharding/rule\", rule.getBytes());\n    cf.close();\n}\n```\n\n修改DataSource信息（新增了dataSource_2021）到Zookeeper\n\n```java\n@Test\npublic void updateDataSourceZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    String dataSource = \"  dataSource_default: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2017: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2018: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2019: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2020: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2021: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2021?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\";\n    //更新\n    cf.setData().forPath(\"/sharding-data/xuzy/config/datasource\", dataSource.getBytes());\n}\n```\n\n修改分库分表规则(flow新增了2021年规则)到Zookeeper\n\n```java\n@Test\npublic void updateRuleZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    String rule = \"  tables:\\n\" +\n            \"    flow:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2021}.flow_0${1..9},dataSource_${2017..2021}.flow_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\" +\n            \"    ips:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\" +\n            \"    acca:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        complex:\\n\" +\n            \"          shardingColumns: flowtime,dataType\\n\" +\n            \"          algorithmClassName: com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        complex:\\n\" +\n            \"          shardingColumns: flowtime,dataType\\n\" +\n            \"          algorithmClassName: com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\\n\" +\n            \"  bindingTables:\\n\" +\n            \"    - flow,ips,acca\\n\" +\n            \"  defaultDatabaseStrategy:\\n\" +\n            \"    none:\\n\" +\n            \"  defaultTableStrategy:\\n\" +\n            \"    none:\";\n    //更新\n    cf.setData().forPath(\"/sharding-data/xuzy/config/sharding/rule\", rule.getBytes());\n}\n```\n\n### 源码分析\n\n```java\nZookeeperConfiguration regConfig = new ZookeeperConfiguration();\nregConfig.setServerLists(\"localhost:2181\");\n//这里namespace表示命名空间。\nregConfig.setNamespace(\"sharding-data\");\nOrchestrationConfiguration orchConcifg = new OrchestrationConfiguration(\"xuzy\",regConfig,false, OrchestrationType.SHARDING);\n//通过OrchestrationShardingDataSourceFactory创建ShardingDataSource\nDataSource dataSource = OrchestrationShardingDataSourceFactory.createDataSource(orchConcifg);\n```\n\n#### 治理规则配置类OrchestrationConfiguration\n\n```java\n@RequiredArgsConstructor\n@Getter\npublic final class OrchestrationConfiguration {\n    //治理规则名称\n    //这个主要作用是为了可以区分本地环境和测试环境。例如在zk上我们可以定义两套配置，然后使用name = prod表示加载的是生产环境的配置\n    private final String name;\n    //注册（配置）中心配置类接口，目前支持zookeeper和Etcd方式\n    private final RegistryCenterConfiguration regCenterConfig;\n    //本地配置是否覆写服务器配置标志位\n    private final boolean overwrite;\n    //枚举类，用来区别是普通sharding或者主从sharding\n    private final OrchestrationType type;\n}\n```\n\n```java\n//节点配置类，定义了存放到zookeeper的路径\n@RequiredArgsConstructor\npublic final class ConfigurationNode {\n    public static final String ROOT = \"config\";\n    public static final String PROXY_NODE_PATH = ROOT + \"/proxy\";\n    //存放数据源信息的路径，配合namespace + 治理规则名称 最终定义存放到zookeeper的路径\n    //例如namespace = sharding-data name(治理规则名称) = xuzy \n    //所以最终数据源信息存放到/sharding-data/xuzy/config/datasource\n    public static final String DATA_SOURCE_NODE_PATH = ROOT + \"/datasource\";\n    public static final String SHARDING_NODE_PATH = ROOT + \"/sharding\";\n    public static final String MASTER_SLAVE_NODE_PATH = ROOT + \"/masterslave\";\n    public static final String RULE_NODE_PATH = \"/rule\";\n    public static final String CONFIG_MAP_NODE_PATH = \"/configmap\";\n    public static final String SHARDING_RULE_NODE_PATH = SHARDING_NODE_PATH + RULE_NODE_PATH;\n    public static final String SHARDING_CONFIG_MAP_NODE_PATH = SHARDING_NODE_PATH + CONFIG_MAP_NODE_PATH;\n    public static final String SHARDING_PROPS_NODE_PATH = SHARDING_NODE_PATH + \"/props\";\n    public static final String MASTER_SLAVE_RULE_NODE_PATH = MASTER_SLAVE_NODE_PATH + RULE_NODE_PATH;\n    public static final String MASTER_SLAVE_CONFIG_MAP_NODE_PATH = MASTER_SLAVE_NODE_PATH + CONFIG_MAP_NODE_PATH;\n    public static final String MASTER_SLAVE_PROPS_NODE_PATH = MASTER_SLAVE_NODE_PATH + \"/props\";\n    public static final String PROXY_RULE_NODE_PATH = PROXY_NODE_PATH + RULE_NODE_PATH;\n    private final String name;\n    /**\n     * Get node full path.\n     *\n     * @param node node name\n     * @return node full path\n     */\n    public String getFullPath(final String node) {\n        return String.format(\"/%s/%s\", name, node);\n    }\n}\n```\n\n#### 创建shardingDataSource工厂\n\n编排治理提供了两种创建shardingDataSource的工厂。\n\n- OrchestrationShardingDataSourceFactory 普通shardingDataSource创建工厂\n- OrchestrationMasterSlaveDataSourceFactory 主从shardingDataSource创建工厂\n\n```java\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\npublic final class OrchestrationShardingDataSourceFactory {\n    public static DataSource createDataSource(final OrchestrationConfiguration orchestrationConfig) throws SQLException {\n        return new OrchestrationShardingDataSource(orchestrationConfig);\n    }\n}\n```\n\n#### 编排治理ShardingDataSource\n\nOrchestrationShardingDataSource继承关系如下，实现了DataSource接口。这个类是最主要的类，通过从zookeeper获取对应的配置最后初始化成ShardingDataSource。\n\n![](shardingjdbc-reg/1.png)\n\n主流程如下：\n\n1. 初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心\n2. 从配置中心获取分库分表规则，数据库连接信息\n3. 初始化ShardingDataSource\n4. 设置watch机制，当配置发生变化时重新加载ShardingDataSource\n\n```java\npublic OrchestrationShardingDataSource(final OrchestrationConfiguration orchestrationConfig) throws SQLException {\n    //初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心\n    super(new OrchestrationFacade(orchestrationConfig));\n    ConfigurationService configService = getOrchestrationFacade().getConfigService();\n    //从配置中心获取分库分表规则，数据库连接信息\n    ShardingRuleConfiguration shardingRuleConfig = configService.loadShardingRuleConfiguration();\n    Preconditions.checkNotNull(shardingRuleConfig, \"Missing the sharding rule configuration on register center\");\n    //初始化ShardingDataSource\n    dataSource = new ShardingDataSource(configService.loadDataSourceMap(),\n            new ShardingRule(shardingRuleConfig, configService.loadDataSourceMap().keySet()), configService.loadShardingConfigMap(), configService.loadShardingProperties());\n    //设置watch机制，当配置发生变化时重新加载ShardingDataSource\n    initOrchestrationFacade(dataSource);\n}\n```\n\n第一步，初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心\n\n```java\npublic OrchestrationFacade(final OrchestrationConfiguration orchestrationConfig) {\n    //选择配置中心\n    regCenter = createRegistryCenter(orchestrationConfig.getRegCenterConfig());\n    isOverwrite = orchestrationConfig.isOverwrite();\n    //用于获取配置的service类\n    configService = new ConfigurationService(orchestrationConfig.getName(), regCenter);\n    //用于获取实例状态的service类\n    instanceStateService = new InstanceStateService(orchestrationConfig.getName(), regCenter);\n    //用于获取数据源的service类\n    dataSourceService = new DataSourceService(orchestrationConfig.getName(), regCenter);\n    listenerManager = new ListenerFactory(orchestrationConfig.getName(), regCenter);\n}\n\nprivate RegistryCenter createRegistryCenter(final RegistryCenterConfiguration regCenterConfig) {\n    Preconditions.checkNotNull(regCenterConfig, \"Registry center configuration cannot be null.\");\n    //如果是ZookeeperConfiguration则采用zookeeper作为配置中心\n    if (regCenterConfig instanceof ZookeeperConfiguration) {\n        return getZookeeperRegistryCenter((ZookeeperConfiguration) regCenterConfig);\n    }\n    if (regCenterConfig instanceof EtcdConfiguration) {\n        return new EtcdRegistryCenter((EtcdConfiguration) regCenterConfig);\n    }\n    throw new UnsupportedOperationException(regCenterConfig.getClass().getName());\n}\n\nprivate RegistryCenter getZookeeperRegistryCenter(final ZookeeperConfiguration regCenterConfig) {\n    if (regCenterConfig.isUseNative()) {\n        //这个没用过\n        return new NewZookeeperRegistryCenter(regCenterConfig);\n    } else {\n        // Curator作为zookeeper的客户端\n        return new ZookeeperRegistryCenter(regCenterConfig);\n    }\n}\n```\n\n第二步，从配置中心获取分库分表规则，数据库连接信息\n\n以获取分库分表规则为例\n\n```java\npublic ShardingRuleConfiguration loadShardingRuleConfiguration() {\n    try {\n        //从路径 /namespace/name/config/sharding/rule 获取到分库分表规并转换成ShardingRuleConfiguration对象\n        ShardingRuleConfiguration result = ShardingConfigurationConverter.shardingRuleConfigFromYaml(regCenter.getDirectly(configNode.getFullPath(ConfigurationNode.SHARDING_RULE_NODE_PATH)));\n        Preconditions.checkState(null != result && !result.getTableRuleConfigs().isEmpty(), \"No available sharding rule configuration to load.\");\n        return result;\n    } catch (final Exception ex) {\n        throw new ShardingConfigurationException(\"No available sharding rule configuration to load.\");\n    }\n}\n```\n\n第三步，初始化shardingDataSource\n\n```java\ndataSource = new ShardingDataSource(configService.loadDataSourceMap(),\n                new ShardingRule(shardingRuleConfig, configService.loadDataSourceMap().keySet()), configService.loadShardingConfigMap(), configService.loadShardingProperties());\n```\n\n第四步，设置watch机制，当配置发生变化时重新加载ShardingDataSource\n\n```java\npublic void init(final Map<String, DataSource> dataSourceMap, final ShardingRuleConfiguration shardingRuleConfig, \n                 final Map<String, Object> configMap, final Properties props) {\n    //判断是否有主从配置的规则，如果有则做处理\n    if (shardingRuleConfig.getMasterSlaveRuleConfigs().isEmpty()) {\n        reviseShardingRuleConfigurationForMasterSlave(dataSourceMap, shardingRuleConfig);\n    }\n    //通过isOverwrite判断是否需要本地配置是否覆写服务器配置\n    //如果为true，则会使用本地的配置先加载到配置中心里面\n    configService.persistShardingConfiguration(getActualDataSourceMapForMasterSlave(dataSourceMap), shardingRuleConfig, configMap, props, isOverwrite);\n    //更新在线的实例机器，这里sharingjdbc通过在节点  /namespace/name/state/instances上记录当前连接到配置中心的机器\n    //以便以后获取在线机器做铺垫\n    instanceStateService.persistShardingInstanceOnline();\n    dataSourceService.persistDataSourcesNode();\n    //分库分表规则，数据库连接信息，实例等设置Watch\n    listenerManager.initShardingListeners();\n}\n```\n\n```java\npublic void initShardingListeners() {\n    //分库分表规则设置Watch\n    configurationListenerManager.watchSharding();\n    //在线实例设置Watch\n    instanceListenerManager.watchSharding();\n    //数据库连接设置Watch\n    dataSourceListenerManager.watchSharding();\n    //configmap设置Watch\n    configMapListenerManager.watchSharding();\n}\n\n//以分库分表规则为例\nwatchSharding(ConfigurationNode.SHARDING_RULE_NODE_PATH);\nprivate void watchSharding(final String node) {\n    String cachePath = configNode.getFullPath(node);\n    regCenter.watch(cachePath, new EventListener() {\n        \n        @Override\n        public void onChange(final DataChangedEvent event) {\n            //当/sharding-data/xuzy/config/sharding/rule的内容发生变化时\n            if (DataChangedEvent.Type.UPDATED == event.getEventType()) {\n                //获取正常运行的数据源信息\n                Map<String, DataSource> dataSourceMap = dataSourceService.getAvailableDataSources();\n                //重新获取配置中心中最新的配置\n                ShardingConfigurationEventBusEvent shardingEvent = new ShardingConfigurationEventBusEvent(dataSourceMap,\n                        new ShardingRule(dataSourceService.getAvailableShardingRuleConfiguration(), dataSourceMap.keySet()), configService.loadShardingProperties());\n                //采用guava的EventBus进行通知，重新加载shardingDataSource实例。 这里EventBus后面说\n                ShardingEventBusInstance.getInstance().post(shardingEvent);\n            }\n        }\n    });\n}\n```\n\n#### EventBus\n\nEventBus是guava提供的一种观察者模式。具体原理可以自己百度下。笔者也不是很清楚。使用如下\n\n```java\npublic class EventBusTest {\n\n    public static void main(String[] args){\n        final EventBus eventBus = new EventBus();\n        //注册监听者\n        eventBus.register(new SimpleListener());\n        eventBus.register(new SimpleListener2());\n        //执行post时，监听者可以收到通知并执行对应的逻辑\n        eventBus.post(\"Simple Event\");\n    }\n\n    static class SimpleListener {\n        @Subscribe\n        public void doAction(final String event) {\n            System.out.println(event + \"_1\");\n        }\n    }\n\n    static class SimpleListener2{\n        @Subscribe\n        public void doAction(final String event) {\n            System.out.println(event + \"_2\");\n        }\n    }\n}\n```\n\n所以，当配置中心触发Watch机制的时候，我们可以看到在代码上执行了\n\n```java\nShardingEventBusInstance.getInstance().post(shardingEvent);\n```\n\n![](shardingjdbc-reg/2.png)\n\n## 总结\n\n通过将复杂繁多的配置使用zookeeper进行管理，并且通过Watch机制自动重新加载配置。笔者工作中负责一个自动化入库任务，通过定时拉取数据再经过shardingjdbc存入数据库。期间如果需要新增分库分表规则需要重启服务，势必会导致定时任务的失败，所以采用了编排治理的方式实现不用重启重新加载配置。安全高效。","source":"_posts/shardingjdbc-reg.md","raw":"---\ntitle: ShardingJdbc编排治理详解\ntags:\n  - shardingjdbc\ncategories: \n  - shardingjdbc\ndescription : ShardingJdbc结合zookeeper做全局配置\ndate: 2021-02-02 10:25:35\n---\n## 分布式配置中心\n在分布式系统或者微服务中，我们经常用到分布式配置中心，他可以将配置定义到一个单独的地方以便所有分布式系统从能从中读取配置，对于修改配置也只需要修改一个地方就行。\n## ShardingSphere编排治理\n\n### 为啥需要编排治理？\n\nShardingSphere的编排治理提供了配置中心和注册中心功能。\n在使用ShardingSphere我们经常定义了一堆分库分表规则。传统的ShardingJdcb我们一般将分库分表规则配置在yml文件或者xml文件中。然而在分布式系统中，假设我们有100台机器做负载均衡，由于需求原因分库分表规则需要添加规则，这时候我们的处理如下：\n\n1. 对100台机器上的分库分表配置文件yml文件进行逐一修改\n2. 逐一重启100台机器Tomcat\n\n这其中的复杂程度可想而知。有人会说，可以将配置定义在一个分布式配置中心中。 没错 ！！！\n\n所以ShardingSphere提供了编排治理功能，通俗一点就是通过ShardingSphere + Zookeeper 或者 Etcd  实现 分布式配置功能，并且通过Zookeeper的Watch机制保证每次修改后<font color=red>自动加载无需重启</font>。\n<!--more-->\n### 如何使用？\n\n导入编排治理Maven\n\n```xml\n<dependency>\n            <groupId>io.shardingsphere</groupId>\n            <artifactId>sharding-jdbc-orchestration-spring-namespace</artifactId>\n            <version>3.0.0.M3</version>\n</dependency>\n<dependency>\n            <groupId>io.shardingsphere</groupId>\n            <artifactId>sharding-orchestration-reg-zookeeper-curator</artifactId>\n            <version>3.0.0</version>\n</dependency>\n```\n\n最终测试代码\n\n```java\n@Test\npublic void testOrchestration2() throws Exception {\n\n    //先删除zk上相关的配置\n    deleteZkDataSourceAndRule();\n    //加载DataSource信息到zk\n    initDataSourceZkData();\n    //加载分库分表规则到ZK\n    initRuleZkData();\n\n    ZookeeperConfiguration regConfig = new ZookeeperConfiguration();\n    regConfig.setServerLists(\"localhost:2181\");\n    regConfig.setNamespace(\"sharding-data\");\n    OrchestrationConfiguration orchConcifg = new OrchestrationConfiguration(\"xuzy\",regConfig,false, OrchestrationType.SHARDING);\n    //通过OrchestrationShardingDataSourceFactory创建ShardingDataSource\n    DataSource dataSource = OrchestrationShardingDataSourceFactory.createDataSource(orchConcifg);\n    //查询\n    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n    //查询， 此时如果查询2021年的话会报错\n    List<Map<String, Object>> list = jdbcTemplate.queryForList(\"select * from flow where flowtime in ('20170818','20190205')\");\n\n\n    //修改DataSource信息（新增了dataSource_2021）到ZK\n    updateDataSourceZkData();\n    //修改分库分表规则(flow新增了2021年规则)到ZK\n    updateRuleZkData();\n\n    TimeUnit.SECONDS.sleep(20);\n\n    //查询， 此时如果查询2021年的话不会报错\n    List<Map<String, Object>> listNew = jdbcTemplate.queryForList(\"select * from flow where flowtime in ('20170818','20190205','20210405')\");\n    System.out.println(listNew);\n}\n```\n\n删除zookeeper上的sharding配置\n\n```java\n@Test\npublic void deleteZkDataSourceAndRule() throws Exception {\n    //zookeeper节点名称定义在io.shardingsphere.jdbc.orchestration.internal.config.ConfigurationNode上，会面说明\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    Stat stat = cf.checkExists().forPath(\"/sharding-data/xuzy/config/datasource\");\n    if(stat != null){\n        cf.delete().forPath(\"/sharding-data/xuzy/config/datasource\");\n    }\n    Stat stat2 = cf.checkExists().forPath(\"/sharding-data/xuzy/config/sharding/rule\");\n    if(stat2 != null){\n        cf.delete().forPath(\"/sharding-data/xuzy/config/sharding/rule\");\n    }\n    cf.close();\n}\n```\n\n加加载DataSource信息到zookeeper\n\n```java\n@Test\npublic void initDataSourceZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    //创建datasource信息 orchestration-sharding-data-source为命名空间 ，闯将的datasource是ymal模式的\n    //Map<String, DataSource> result = DataSourceConverter.dataSourceMapFromYaml(this.regCenter.getDirectly(this.configNode.getFullPath(\"config/datasource\")));\n    String dataSource = \"\" +\n            \"  dataSource_default: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2017: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2018: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2019: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2020: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\";\n    cf.create()\n            .creatingParentsIfNeeded() //自动创建父节点\n            .withMode(CreateMode.PERSISTENT) //设置成永久节点\n            .forPath(\"/sharding-data/xuzy/config/datasource\", dataSource.getBytes());\n    cf.close();\n}\n```\n\n加载分库分表规则到Zookeeper\n\n```java\n@Test\npublic void initRuleZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    String rule = \"  tables:\\n\" +\n            \"    flow:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\" +\n            \"    ips:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\" +\n            \"    acca:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        complex:\\n\" +\n            \"          shardingColumns: flowtime,dataType\\n\" +\n            \"          algorithmClassName: com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        complex:\\n\" +\n            \"          shardingColumns: flowtime,dataType\\n\" +\n            \"          algorithmClassName: com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\\n\" +\n            \"  bindingTables:\\n\" +\n            \"    - flow,ips,acca\\n\" +\n            \"  defaultDatabaseStrategy:\\n\" +\n            \"    none:\\n\" +\n            \"  defaultTableStrategy:\\n\" +\n            \"    none:\";\n    cf.create()\n            .creatingParentsIfNeeded() //自动创建父节点\n            .withMode(CreateMode.PERSISTENT) //设置成永久节点\n            .forPath(\"/sharding-data/xuzy/config/sharding/rule\", rule.getBytes());\n    cf.close();\n}\n```\n\n修改DataSource信息（新增了dataSource_2021）到Zookeeper\n\n```java\n@Test\npublic void updateDataSourceZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    String dataSource = \"  dataSource_default: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2017: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2018: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2019: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2020: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\\n\" +\n            \"  dataSource_2021: !!org.apache.commons.dbcp.BasicDataSource\\n\" +\n            \"    driverClassName: com.mysql.jdbc.Driver\\n\" +\n            \"    url: jdbc:mysql://localhost:3306/sharding_2021?useUnicode=true&amp;characterEncoding=utf-8\\n\" +\n            \"    username: root\\n\" +\n            \"    password: 123456\\n\" +\n            \"    initialSize : 0\\n\" +\n            \"    maxActive : 200\\n\" +\n            \"    maxIdle : 20\\n\" +\n            \"    minIdle : 1\\n\" +\n            \"    maxWait : 60000\";\n    //更新\n    cf.setData().forPath(\"/sharding-data/xuzy/config/datasource\", dataSource.getBytes());\n}\n```\n\n修改分库分表规则(flow新增了2021年规则)到Zookeeper\n\n```java\n@Test\npublic void updateRuleZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    String rule = \"  tables:\\n\" +\n            \"    flow:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2021}.flow_0${1..9},dataSource_${2017..2021}.flow_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\" +\n            \"    ips:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        standard:\\n\" +\n            \"          shardingColumn: flowtime\\n\" +\n            \"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\" +\n            \"    acca:\\n\" +\n            \"      actualDataNodes: dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\\n\" +\n            \"      tableStrategy:\\n\" +\n            \"        complex:\\n\" +\n            \"          shardingColumns: flowtime,dataType\\n\" +\n            \"          algorithmClassName: com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\\n\" +\n            \"      databaseStrategy:\\n\" +\n            \"        complex:\\n\" +\n            \"          shardingColumns: flowtime,dataType\\n\" +\n            \"          algorithmClassName: com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\\n\" +\n            \"  bindingTables:\\n\" +\n            \"    - flow,ips,acca\\n\" +\n            \"  defaultDatabaseStrategy:\\n\" +\n            \"    none:\\n\" +\n            \"  defaultTableStrategy:\\n\" +\n            \"    none:\";\n    //更新\n    cf.setData().forPath(\"/sharding-data/xuzy/config/sharding/rule\", rule.getBytes());\n}\n```\n\n### 源码分析\n\n```java\nZookeeperConfiguration regConfig = new ZookeeperConfiguration();\nregConfig.setServerLists(\"localhost:2181\");\n//这里namespace表示命名空间。\nregConfig.setNamespace(\"sharding-data\");\nOrchestrationConfiguration orchConcifg = new OrchestrationConfiguration(\"xuzy\",regConfig,false, OrchestrationType.SHARDING);\n//通过OrchestrationShardingDataSourceFactory创建ShardingDataSource\nDataSource dataSource = OrchestrationShardingDataSourceFactory.createDataSource(orchConcifg);\n```\n\n#### 治理规则配置类OrchestrationConfiguration\n\n```java\n@RequiredArgsConstructor\n@Getter\npublic final class OrchestrationConfiguration {\n    //治理规则名称\n    //这个主要作用是为了可以区分本地环境和测试环境。例如在zk上我们可以定义两套配置，然后使用name = prod表示加载的是生产环境的配置\n    private final String name;\n    //注册（配置）中心配置类接口，目前支持zookeeper和Etcd方式\n    private final RegistryCenterConfiguration regCenterConfig;\n    //本地配置是否覆写服务器配置标志位\n    private final boolean overwrite;\n    //枚举类，用来区别是普通sharding或者主从sharding\n    private final OrchestrationType type;\n}\n```\n\n```java\n//节点配置类，定义了存放到zookeeper的路径\n@RequiredArgsConstructor\npublic final class ConfigurationNode {\n    public static final String ROOT = \"config\";\n    public static final String PROXY_NODE_PATH = ROOT + \"/proxy\";\n    //存放数据源信息的路径，配合namespace + 治理规则名称 最终定义存放到zookeeper的路径\n    //例如namespace = sharding-data name(治理规则名称) = xuzy \n    //所以最终数据源信息存放到/sharding-data/xuzy/config/datasource\n    public static final String DATA_SOURCE_NODE_PATH = ROOT + \"/datasource\";\n    public static final String SHARDING_NODE_PATH = ROOT + \"/sharding\";\n    public static final String MASTER_SLAVE_NODE_PATH = ROOT + \"/masterslave\";\n    public static final String RULE_NODE_PATH = \"/rule\";\n    public static final String CONFIG_MAP_NODE_PATH = \"/configmap\";\n    public static final String SHARDING_RULE_NODE_PATH = SHARDING_NODE_PATH + RULE_NODE_PATH;\n    public static final String SHARDING_CONFIG_MAP_NODE_PATH = SHARDING_NODE_PATH + CONFIG_MAP_NODE_PATH;\n    public static final String SHARDING_PROPS_NODE_PATH = SHARDING_NODE_PATH + \"/props\";\n    public static final String MASTER_SLAVE_RULE_NODE_PATH = MASTER_SLAVE_NODE_PATH + RULE_NODE_PATH;\n    public static final String MASTER_SLAVE_CONFIG_MAP_NODE_PATH = MASTER_SLAVE_NODE_PATH + CONFIG_MAP_NODE_PATH;\n    public static final String MASTER_SLAVE_PROPS_NODE_PATH = MASTER_SLAVE_NODE_PATH + \"/props\";\n    public static final String PROXY_RULE_NODE_PATH = PROXY_NODE_PATH + RULE_NODE_PATH;\n    private final String name;\n    /**\n     * Get node full path.\n     *\n     * @param node node name\n     * @return node full path\n     */\n    public String getFullPath(final String node) {\n        return String.format(\"/%s/%s\", name, node);\n    }\n}\n```\n\n#### 创建shardingDataSource工厂\n\n编排治理提供了两种创建shardingDataSource的工厂。\n\n- OrchestrationShardingDataSourceFactory 普通shardingDataSource创建工厂\n- OrchestrationMasterSlaveDataSourceFactory 主从shardingDataSource创建工厂\n\n```java\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\npublic final class OrchestrationShardingDataSourceFactory {\n    public static DataSource createDataSource(final OrchestrationConfiguration orchestrationConfig) throws SQLException {\n        return new OrchestrationShardingDataSource(orchestrationConfig);\n    }\n}\n```\n\n#### 编排治理ShardingDataSource\n\nOrchestrationShardingDataSource继承关系如下，实现了DataSource接口。这个类是最主要的类，通过从zookeeper获取对应的配置最后初始化成ShardingDataSource。\n\n![](shardingjdbc-reg/1.png)\n\n主流程如下：\n\n1. 初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心\n2. 从配置中心获取分库分表规则，数据库连接信息\n3. 初始化ShardingDataSource\n4. 设置watch机制，当配置发生变化时重新加载ShardingDataSource\n\n```java\npublic OrchestrationShardingDataSource(final OrchestrationConfiguration orchestrationConfig) throws SQLException {\n    //初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心\n    super(new OrchestrationFacade(orchestrationConfig));\n    ConfigurationService configService = getOrchestrationFacade().getConfigService();\n    //从配置中心获取分库分表规则，数据库连接信息\n    ShardingRuleConfiguration shardingRuleConfig = configService.loadShardingRuleConfiguration();\n    Preconditions.checkNotNull(shardingRuleConfig, \"Missing the sharding rule configuration on register center\");\n    //初始化ShardingDataSource\n    dataSource = new ShardingDataSource(configService.loadDataSourceMap(),\n            new ShardingRule(shardingRuleConfig, configService.loadDataSourceMap().keySet()), configService.loadShardingConfigMap(), configService.loadShardingProperties());\n    //设置watch机制，当配置发生变化时重新加载ShardingDataSource\n    initOrchestrationFacade(dataSource);\n}\n```\n\n第一步，初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心\n\n```java\npublic OrchestrationFacade(final OrchestrationConfiguration orchestrationConfig) {\n    //选择配置中心\n    regCenter = createRegistryCenter(orchestrationConfig.getRegCenterConfig());\n    isOverwrite = orchestrationConfig.isOverwrite();\n    //用于获取配置的service类\n    configService = new ConfigurationService(orchestrationConfig.getName(), regCenter);\n    //用于获取实例状态的service类\n    instanceStateService = new InstanceStateService(orchestrationConfig.getName(), regCenter);\n    //用于获取数据源的service类\n    dataSourceService = new DataSourceService(orchestrationConfig.getName(), regCenter);\n    listenerManager = new ListenerFactory(orchestrationConfig.getName(), regCenter);\n}\n\nprivate RegistryCenter createRegistryCenter(final RegistryCenterConfiguration regCenterConfig) {\n    Preconditions.checkNotNull(regCenterConfig, \"Registry center configuration cannot be null.\");\n    //如果是ZookeeperConfiguration则采用zookeeper作为配置中心\n    if (regCenterConfig instanceof ZookeeperConfiguration) {\n        return getZookeeperRegistryCenter((ZookeeperConfiguration) regCenterConfig);\n    }\n    if (regCenterConfig instanceof EtcdConfiguration) {\n        return new EtcdRegistryCenter((EtcdConfiguration) regCenterConfig);\n    }\n    throw new UnsupportedOperationException(regCenterConfig.getClass().getName());\n}\n\nprivate RegistryCenter getZookeeperRegistryCenter(final ZookeeperConfiguration regCenterConfig) {\n    if (regCenterConfig.isUseNative()) {\n        //这个没用过\n        return new NewZookeeperRegistryCenter(regCenterConfig);\n    } else {\n        // Curator作为zookeeper的客户端\n        return new ZookeeperRegistryCenter(regCenterConfig);\n    }\n}\n```\n\n第二步，从配置中心获取分库分表规则，数据库连接信息\n\n以获取分库分表规则为例\n\n```java\npublic ShardingRuleConfiguration loadShardingRuleConfiguration() {\n    try {\n        //从路径 /namespace/name/config/sharding/rule 获取到分库分表规并转换成ShardingRuleConfiguration对象\n        ShardingRuleConfiguration result = ShardingConfigurationConverter.shardingRuleConfigFromYaml(regCenter.getDirectly(configNode.getFullPath(ConfigurationNode.SHARDING_RULE_NODE_PATH)));\n        Preconditions.checkState(null != result && !result.getTableRuleConfigs().isEmpty(), \"No available sharding rule configuration to load.\");\n        return result;\n    } catch (final Exception ex) {\n        throw new ShardingConfigurationException(\"No available sharding rule configuration to load.\");\n    }\n}\n```\n\n第三步，初始化shardingDataSource\n\n```java\ndataSource = new ShardingDataSource(configService.loadDataSourceMap(),\n                new ShardingRule(shardingRuleConfig, configService.loadDataSourceMap().keySet()), configService.loadShardingConfigMap(), configService.loadShardingProperties());\n```\n\n第四步，设置watch机制，当配置发生变化时重新加载ShardingDataSource\n\n```java\npublic void init(final Map<String, DataSource> dataSourceMap, final ShardingRuleConfiguration shardingRuleConfig, \n                 final Map<String, Object> configMap, final Properties props) {\n    //判断是否有主从配置的规则，如果有则做处理\n    if (shardingRuleConfig.getMasterSlaveRuleConfigs().isEmpty()) {\n        reviseShardingRuleConfigurationForMasterSlave(dataSourceMap, shardingRuleConfig);\n    }\n    //通过isOverwrite判断是否需要本地配置是否覆写服务器配置\n    //如果为true，则会使用本地的配置先加载到配置中心里面\n    configService.persistShardingConfiguration(getActualDataSourceMapForMasterSlave(dataSourceMap), shardingRuleConfig, configMap, props, isOverwrite);\n    //更新在线的实例机器，这里sharingjdbc通过在节点  /namespace/name/state/instances上记录当前连接到配置中心的机器\n    //以便以后获取在线机器做铺垫\n    instanceStateService.persistShardingInstanceOnline();\n    dataSourceService.persistDataSourcesNode();\n    //分库分表规则，数据库连接信息，实例等设置Watch\n    listenerManager.initShardingListeners();\n}\n```\n\n```java\npublic void initShardingListeners() {\n    //分库分表规则设置Watch\n    configurationListenerManager.watchSharding();\n    //在线实例设置Watch\n    instanceListenerManager.watchSharding();\n    //数据库连接设置Watch\n    dataSourceListenerManager.watchSharding();\n    //configmap设置Watch\n    configMapListenerManager.watchSharding();\n}\n\n//以分库分表规则为例\nwatchSharding(ConfigurationNode.SHARDING_RULE_NODE_PATH);\nprivate void watchSharding(final String node) {\n    String cachePath = configNode.getFullPath(node);\n    regCenter.watch(cachePath, new EventListener() {\n        \n        @Override\n        public void onChange(final DataChangedEvent event) {\n            //当/sharding-data/xuzy/config/sharding/rule的内容发生变化时\n            if (DataChangedEvent.Type.UPDATED == event.getEventType()) {\n                //获取正常运行的数据源信息\n                Map<String, DataSource> dataSourceMap = dataSourceService.getAvailableDataSources();\n                //重新获取配置中心中最新的配置\n                ShardingConfigurationEventBusEvent shardingEvent = new ShardingConfigurationEventBusEvent(dataSourceMap,\n                        new ShardingRule(dataSourceService.getAvailableShardingRuleConfiguration(), dataSourceMap.keySet()), configService.loadShardingProperties());\n                //采用guava的EventBus进行通知，重新加载shardingDataSource实例。 这里EventBus后面说\n                ShardingEventBusInstance.getInstance().post(shardingEvent);\n            }\n        }\n    });\n}\n```\n\n#### EventBus\n\nEventBus是guava提供的一种观察者模式。具体原理可以自己百度下。笔者也不是很清楚。使用如下\n\n```java\npublic class EventBusTest {\n\n    public static void main(String[] args){\n        final EventBus eventBus = new EventBus();\n        //注册监听者\n        eventBus.register(new SimpleListener());\n        eventBus.register(new SimpleListener2());\n        //执行post时，监听者可以收到通知并执行对应的逻辑\n        eventBus.post(\"Simple Event\");\n    }\n\n    static class SimpleListener {\n        @Subscribe\n        public void doAction(final String event) {\n            System.out.println(event + \"_1\");\n        }\n    }\n\n    static class SimpleListener2{\n        @Subscribe\n        public void doAction(final String event) {\n            System.out.println(event + \"_2\");\n        }\n    }\n}\n```\n\n所以，当配置中心触发Watch机制的时候，我们可以看到在代码上执行了\n\n```java\nShardingEventBusInstance.getInstance().post(shardingEvent);\n```\n\n![](shardingjdbc-reg/2.png)\n\n## 总结\n\n通过将复杂繁多的配置使用zookeeper进行管理，并且通过Watch机制自动重新加载配置。笔者工作中负责一个自动化入库任务，通过定时拉取数据再经过shardingjdbc存入数据库。期间如果需要新增分库分表规则需要重启服务，势必会导致定时任务的失败，所以采用了编排治理的方式实现不用重启重新加载配置。安全高效。","slug":"shardingjdbc-reg","published":1,"updated":"2021-04-08T00:47:06.987Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvs003eqwv2b9h426cc","content":"<h2 id=\"分布式配置中心\"><a href=\"#分布式配置中心\" class=\"headerlink\" title=\"分布式配置中心\"></a>分布式配置中心</h2><p>在分布式系统或者微服务中，我们经常用到分布式配置中心，他可以将配置定义到一个单独的地方以便所有分布式系统从能从中读取配置，对于修改配置也只需要修改一个地方就行。</p>\n<h2 id=\"ShardingSphere编排治理\"><a href=\"#ShardingSphere编排治理\" class=\"headerlink\" title=\"ShardingSphere编排治理\"></a>ShardingSphere编排治理</h2><h3 id=\"为啥需要编排治理？\"><a href=\"#为啥需要编排治理？\" class=\"headerlink\" title=\"为啥需要编排治理？\"></a>为啥需要编排治理？</h3><p>ShardingSphere的编排治理提供了配置中心和注册中心功能。<br>在使用ShardingSphere我们经常定义了一堆分库分表规则。传统的ShardingJdcb我们一般将分库分表规则配置在yml文件或者xml文件中。然而在分布式系统中，假设我们有100台机器做负载均衡，由于需求原因分库分表规则需要添加规则，这时候我们的处理如下：</p>\n<ol>\n<li>对100台机器上的分库分表配置文件yml文件进行逐一修改</li>\n<li>逐一重启100台机器Tomcat</li>\n</ol>\n<p>这其中的复杂程度可想而知。有人会说，可以将配置定义在一个分布式配置中心中。 没错 ！！！</p>\n<p>所以ShardingSphere提供了编排治理功能，通俗一点就是通过ShardingSphere + Zookeeper 或者 Etcd  实现 分布式配置功能，并且通过Zookeeper的Watch机制保证每次修改后<font color=\"red\">自动加载无需重启</font>。</p>\n<a id=\"more\"></a>\n<h3 id=\"如何使用？\"><a href=\"#如何使用？\" class=\"headerlink\" title=\"如何使用？\"></a>如何使用？</h3><p>导入编排治理Maven</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>io.shardingsphere<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>sharding-jdbc-orchestration-spring-namespace<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>3.0.0.M3<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>io.shardingsphere<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>sharding-orchestration-reg-zookeeper-curator<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>version</span><span class=\"token punctuation\">></span></span>3.0.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>version</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>最终测试代码</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testOrchestration2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//先删除zk上相关的配置</span>\n    <span class=\"token function\">deleteZkDataSourceAndRule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//加载DataSource信息到zk</span>\n    <span class=\"token function\">initDataSourceZkData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//加载分库分表规则到ZK</span>\n    <span class=\"token function\">initRuleZkData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    ZookeeperConfiguration regConfig <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ZookeeperConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    regConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setServerLists</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"localhost:2181\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    regConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setNamespace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sharding-data\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    OrchestrationConfiguration orchConcifg <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OrchestrationConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"xuzy\"</span><span class=\"token punctuation\">,</span>regConfig<span class=\"token punctuation\">,</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> OrchestrationType<span class=\"token punctuation\">.</span>SHARDING<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//通过OrchestrationShardingDataSourceFactory创建ShardingDataSource</span>\n    DataSource dataSource <span class=\"token operator\">=</span> OrchestrationShardingDataSourceFactory<span class=\"token punctuation\">.</span><span class=\"token function\">createDataSource</span><span class=\"token punctuation\">(</span>orchConcifg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//查询</span>\n    JdbcTemplate jdbcTemplate <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">JdbcTemplate</span><span class=\"token punctuation\">(</span>dataSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//查询， 此时如果查询2021年的话会报错</span>\n    List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>></span> list <span class=\"token operator\">=</span> jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">queryForList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select * from flow where flowtime in ('20170818','20190205')\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token comment\" spellcheck=\"true\">//修改DataSource信息（新增了dataSource_2021）到ZK</span>\n    <span class=\"token function\">updateDataSourceZkData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//修改分库分表规则(flow新增了2021年规则)到ZK</span>\n    <span class=\"token function\">updateRuleZkData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//查询， 此时如果查询2021年的话不会报错</span>\n    List<span class=\"token operator\">&lt;</span>Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">>></span> listNew <span class=\"token operator\">=</span> jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">queryForList</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select * from flow where flowtime in ('20170818','20190205','20210405')\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>listNew<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>删除zookeeper上的sharding配置</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">deleteZkDataSourceAndRule</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//zookeeper节点名称定义在io.shardingsphere.jdbc.orchestration.internal.config.ConfigurationNode上，会面说明</span>\n    CuratorFramework cf <span class=\"token operator\">=</span> <span class=\"token function\">getCuratorFramework</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Stat stat <span class=\"token operator\">=</span> cf<span class=\"token punctuation\">.</span><span class=\"token function\">checkExists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/sharding-data/xuzy/config/datasource\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>stat <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cf<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/sharding-data/xuzy/config/datasource\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Stat stat2 <span class=\"token operator\">=</span> cf<span class=\"token punctuation\">.</span><span class=\"token function\">checkExists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/sharding-data/xuzy/config/sharding/rule\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>stat2 <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        cf<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/sharding-data/xuzy/config/sharding/rule\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>加加载DataSource信息到zookeeper</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initDataSourceZkData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n    CuratorFramework cf <span class=\"token operator\">=</span> <span class=\"token function\">getCuratorFramework</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//创建datasource信息 orchestration-sharding-data-source为命名空间 ，闯将的datasource是ymal模式的</span>\n    <span class=\"token comment\" spellcheck=\"true\">//Map&lt;String, DataSource> result = DataSourceConverter.dataSourceMapFromYaml(this.regCenter.getDirectly(this.configNode.getFullPath(\"config/datasource\")));</span>\n    String dataSource <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_default: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_2017: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_2018: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_2019: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_2020: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\"</span><span class=\"token punctuation\">;</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">creatingParentsIfNeeded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//自动创建父节点</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">withMode</span><span class=\"token punctuation\">(</span>CreateMode<span class=\"token punctuation\">.</span>PERSISTENT<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//设置成永久节点</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/sharding-data/xuzy/config/datasource\"</span><span class=\"token punctuation\">,</span> dataSource<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>加载分库分表规则到Zookeeper</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initRuleZkData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n    CuratorFramework cf <span class=\"token operator\">=</span> <span class=\"token function\">getCuratorFramework</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    String rule <span class=\"token operator\">=</span> <span class=\"token string\">\"  tables:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    flow:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      actualDataNodes: dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      tableStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        standard:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumn: flowtime\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      databaseStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        standard:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumn: flowtime\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    ips:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      actualDataNodes: dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      tableStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        standard:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumn: flowtime\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      databaseStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        standard:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumn: flowtime\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    acca:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      actualDataNodes: dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      tableStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        complex:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumns: flowtime,dataType\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          algorithmClassName: com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      databaseStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        complex:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumns: flowtime,dataType\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          algorithmClassName: com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  bindingTables:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    - flow,ips,acca\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  defaultDatabaseStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    none:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  defaultTableStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    none:\"</span><span class=\"token punctuation\">;</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">creatingParentsIfNeeded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//自动创建父节点</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">withMode</span><span class=\"token punctuation\">(</span>CreateMode<span class=\"token punctuation\">.</span>PERSISTENT<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//设置成永久节点</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/sharding-data/xuzy/config/sharding/rule\"</span><span class=\"token punctuation\">,</span> rule<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>修改DataSource信息（新增了dataSource_2021）到Zookeeper</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">updateDataSourceZkData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n    CuratorFramework cf <span class=\"token operator\">=</span> <span class=\"token function\">getCuratorFramework</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    String dataSource <span class=\"token operator\">=</span> <span class=\"token string\">\"  dataSource_default: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_2017: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_2018: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_2019: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_2020: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  dataSource_2021: !!org.apache.commons.dbcp.BasicDataSource\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    driverClassName: com.mysql.jdbc.Driver\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    url: jdbc:mysql://localhost:3306/sharding_2021?useUnicode=true&amp;amp;characterEncoding=utf-8\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    username: root\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    password: 123456\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    initialSize : 0\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxActive : 200\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxIdle : 20\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    minIdle : 1\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    maxWait : 60000\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//更新</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">setData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/sharding-data/xuzy/config/datasource\"</span><span class=\"token punctuation\">,</span> dataSource<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>修改分库分表规则(flow新增了2021年规则)到Zookeeper</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">updateRuleZkData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n    CuratorFramework cf <span class=\"token operator\">=</span> <span class=\"token function\">getCuratorFramework</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    String rule <span class=\"token operator\">=</span> <span class=\"token string\">\"  tables:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    flow:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      actualDataNodes: dataSource_${2017..2021}.flow_0${1..9},dataSource_${2017..2021}.flow_1${0..2}\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      tableStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        standard:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumn: flowtime\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      databaseStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        standard:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumn: flowtime\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    ips:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      actualDataNodes: dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      tableStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        standard:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumn: flowtime\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      databaseStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        standard:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumn: flowtime\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    acca:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      actualDataNodes: dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      tableStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        complex:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumns: flowtime,dataType\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          algorithmClassName: com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"      databaseStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"        complex:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          shardingColumns: flowtime,dataType\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"          algorithmClassName: com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  bindingTables:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    - flow,ips,acca\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  defaultDatabaseStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    none:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"  defaultTableStrategy:\\n\"</span> <span class=\"token operator\">+</span>\n            <span class=\"token string\">\"    none:\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//更新</span>\n    cf<span class=\"token punctuation\">.</span><span class=\"token function\">setData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/sharding-data/xuzy/config/sharding/rule\"</span><span class=\"token punctuation\">,</span> rule<span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><pre class=\" language-java\"><code class=\"language-java\">ZookeeperConfiguration regConfig <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ZookeeperConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nregConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setServerLists</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"localhost:2181\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//这里namespace表示命名空间。</span>\nregConfig<span class=\"token punctuation\">.</span><span class=\"token function\">setNamespace</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"sharding-data\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nOrchestrationConfiguration orchConcifg <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OrchestrationConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"xuzy\"</span><span class=\"token punctuation\">,</span>regConfig<span class=\"token punctuation\">,</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">,</span> OrchestrationType<span class=\"token punctuation\">.</span>SHARDING<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//通过OrchestrationShardingDataSourceFactory创建ShardingDataSource</span>\nDataSource dataSource <span class=\"token operator\">=</span> OrchestrationShardingDataSourceFactory<span class=\"token punctuation\">.</span><span class=\"token function\">createDataSource</span><span class=\"token punctuation\">(</span>orchConcifg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"治理规则配置类OrchestrationConfiguration\"><a href=\"#治理规则配置类OrchestrationConfiguration\" class=\"headerlink\" title=\"治理规则配置类OrchestrationConfiguration\"></a>治理规则配置类OrchestrationConfiguration</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RequiredArgsConstructor</span>\n<span class=\"token annotation punctuation\">@Getter</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrchestrationConfiguration</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//治理规则名称</span>\n    <span class=\"token comment\" spellcheck=\"true\">//这个主要作用是为了可以区分本地环境和测试环境。例如在zk上我们可以定义两套配置，然后使用name = prod表示加载的是生产环境的配置</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> String name<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//注册（配置）中心配置类接口，目前支持zookeeper和Etcd方式</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> RegistryCenterConfiguration regCenterConfig<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//本地配置是否覆写服务器配置标志位</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> overwrite<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//枚举类，用来区别是普通sharding或者主从sharding</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> OrchestrationType type<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//节点配置类，定义了存放到zookeeper的路径</span>\n<span class=\"token annotation punctuation\">@RequiredArgsConstructor</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ConfigurationNode</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String ROOT <span class=\"token operator\">=</span> <span class=\"token string\">\"config\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String PROXY_NODE_PATH <span class=\"token operator\">=</span> ROOT <span class=\"token operator\">+</span> <span class=\"token string\">\"/proxy\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//存放数据源信息的路径，配合namespace + 治理规则名称 最终定义存放到zookeeper的路径</span>\n    <span class=\"token comment\" spellcheck=\"true\">//例如namespace = sharding-data name(治理规则名称) = xuzy </span>\n    <span class=\"token comment\" spellcheck=\"true\">//所以最终数据源信息存放到/sharding-data/xuzy/config/datasource</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String DATA_SOURCE_NODE_PATH <span class=\"token operator\">=</span> ROOT <span class=\"token operator\">+</span> <span class=\"token string\">\"/datasource\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String SHARDING_NODE_PATH <span class=\"token operator\">=</span> ROOT <span class=\"token operator\">+</span> <span class=\"token string\">\"/sharding\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String MASTER_SLAVE_NODE_PATH <span class=\"token operator\">=</span> ROOT <span class=\"token operator\">+</span> <span class=\"token string\">\"/masterslave\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String RULE_NODE_PATH <span class=\"token operator\">=</span> <span class=\"token string\">\"/rule\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String CONFIG_MAP_NODE_PATH <span class=\"token operator\">=</span> <span class=\"token string\">\"/configmap\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String SHARDING_RULE_NODE_PATH <span class=\"token operator\">=</span> SHARDING_NODE_PATH <span class=\"token operator\">+</span> RULE_NODE_PATH<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String SHARDING_CONFIG_MAP_NODE_PATH <span class=\"token operator\">=</span> SHARDING_NODE_PATH <span class=\"token operator\">+</span> CONFIG_MAP_NODE_PATH<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String SHARDING_PROPS_NODE_PATH <span class=\"token operator\">=</span> SHARDING_NODE_PATH <span class=\"token operator\">+</span> <span class=\"token string\">\"/props\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String MASTER_SLAVE_RULE_NODE_PATH <span class=\"token operator\">=</span> MASTER_SLAVE_NODE_PATH <span class=\"token operator\">+</span> RULE_NODE_PATH<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String MASTER_SLAVE_CONFIG_MAP_NODE_PATH <span class=\"token operator\">=</span> MASTER_SLAVE_NODE_PATH <span class=\"token operator\">+</span> CONFIG_MAP_NODE_PATH<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String MASTER_SLAVE_PROPS_NODE_PATH <span class=\"token operator\">=</span> MASTER_SLAVE_NODE_PATH <span class=\"token operator\">+</span> <span class=\"token string\">\"/props\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> String PROXY_RULE_NODE_PATH <span class=\"token operator\">=</span> PROXY_NODE_PATH <span class=\"token operator\">+</span> RULE_NODE_PATH<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> String name<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * Get node full path.\n     *\n     * @param node node name\n     * @return node full path\n     */</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getFullPath</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> String node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">format</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/%s/%s\"</span><span class=\"token punctuation\">,</span> name<span class=\"token punctuation\">,</span> node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"创建shardingDataSource工厂\"><a href=\"#创建shardingDataSource工厂\" class=\"headerlink\" title=\"创建shardingDataSource工厂\"></a>创建shardingDataSource工厂</h4><p>编排治理提供了两种创建shardingDataSource的工厂。</p>\n<ul>\n<li>OrchestrationShardingDataSourceFactory 普通shardingDataSource创建工厂</li>\n<li>OrchestrationMasterSlaveDataSourceFactory 主从shardingDataSource创建工厂</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@NoArgsConstructor</span><span class=\"token punctuation\">(</span>access <span class=\"token operator\">=</span> AccessLevel<span class=\"token punctuation\">.</span>PRIVATE<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OrchestrationShardingDataSourceFactory</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> DataSource <span class=\"token function\">createDataSource</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> OrchestrationConfiguration orchestrationConfig<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> SQLException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">OrchestrationShardingDataSource</span><span class=\"token punctuation\">(</span>orchestrationConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"编排治理ShardingDataSource\"><a href=\"#编排治理ShardingDataSource\" class=\"headerlink\" title=\"编排治理ShardingDataSource\"></a>编排治理ShardingDataSource</h4><p>OrchestrationShardingDataSource继承关系如下，实现了DataSource接口。这个类是最主要的类，通过从zookeeper获取对应的配置最后初始化成ShardingDataSource。</p>\n<p><img src=\"/2021/02/02/shardingjdbc-reg/1.png\" alt></p>\n<p>主流程如下：</p>\n<ol>\n<li>初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心</li>\n<li>从配置中心获取分库分表规则，数据库连接信息</li>\n<li>初始化ShardingDataSource</li>\n<li>设置watch机制，当配置发生变化时重新加载ShardingDataSource</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">OrchestrationShardingDataSource</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> OrchestrationConfiguration orchestrationConfig<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> SQLException <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">OrchestrationFacade</span><span class=\"token punctuation\">(</span>orchestrationConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ConfigurationService configService <span class=\"token operator\">=</span> <span class=\"token function\">getOrchestrationFacade</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getConfigService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//从配置中心获取分库分表规则，数据库连接信息</span>\n    ShardingRuleConfiguration shardingRuleConfig <span class=\"token operator\">=</span> configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadShardingRuleConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Preconditions<span class=\"token punctuation\">.</span><span class=\"token function\">checkNotNull</span><span class=\"token punctuation\">(</span>shardingRuleConfig<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Missing the sharding rule configuration on register center\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化ShardingDataSource</span>\n    dataSource <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ShardingDataSource</span><span class=\"token punctuation\">(</span>configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadDataSourceMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">ShardingRule</span><span class=\"token punctuation\">(</span>shardingRuleConfig<span class=\"token punctuation\">,</span> configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadDataSourceMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadShardingConfigMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadShardingProperties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//设置watch机制，当配置发生变化时重新加载ShardingDataSource</span>\n    <span class=\"token function\">initOrchestrationFacade</span><span class=\"token punctuation\">(</span>dataSource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>第一步，初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">OrchestrationFacade</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> OrchestrationConfiguration orchestrationConfig<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//选择配置中心</span>\n    regCenter <span class=\"token operator\">=</span> <span class=\"token function\">createRegistryCenter</span><span class=\"token punctuation\">(</span>orchestrationConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getRegCenterConfig</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    isOverwrite <span class=\"token operator\">=</span> orchestrationConfig<span class=\"token punctuation\">.</span><span class=\"token function\">isOverwrite</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//用于获取配置的service类</span>\n    configService <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConfigurationService</span><span class=\"token punctuation\">(</span>orchestrationConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> regCenter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//用于获取实例状态的service类</span>\n    instanceStateService <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InstanceStateService</span><span class=\"token punctuation\">(</span>orchestrationConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> regCenter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//用于获取数据源的service类</span>\n    dataSourceService <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DataSourceService</span><span class=\"token punctuation\">(</span>orchestrationConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> regCenter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    listenerManager <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ListenerFactory</span><span class=\"token punctuation\">(</span>orchestrationConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> regCenter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> RegistryCenter <span class=\"token function\">createRegistryCenter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> RegistryCenterConfiguration regCenterConfig<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Preconditions<span class=\"token punctuation\">.</span><span class=\"token function\">checkNotNull</span><span class=\"token punctuation\">(</span>regCenterConfig<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Registry center configuration cannot be null.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果是ZookeeperConfiguration则采用zookeeper作为配置中心</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>regCenterConfig <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ZookeeperConfiguration</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">getZookeeperRegistryCenter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ZookeeperConfiguration<span class=\"token punctuation\">)</span> regCenterConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>regCenterConfig <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">EtcdConfiguration</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">EtcdRegistryCenter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>EtcdConfiguration<span class=\"token punctuation\">)</span> regCenterConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">UnsupportedOperationException</span><span class=\"token punctuation\">(</span>regCenterConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> RegistryCenter <span class=\"token function\">getZookeeperRegistryCenter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> ZookeeperConfiguration regCenterConfig<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>regCenterConfig<span class=\"token punctuation\">.</span><span class=\"token function\">isUseNative</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//这个没用过</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NewZookeeperRegistryCenter</span><span class=\"token punctuation\">(</span>regCenterConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// Curator作为zookeeper的客户端</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ZookeeperRegistryCenter</span><span class=\"token punctuation\">(</span>regCenterConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>第二步，从配置中心获取分库分表规则，数据库连接信息</p>\n<p>以获取分库分表规则为例</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> ShardingRuleConfiguration <span class=\"token function\">loadShardingRuleConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//从路径 /namespace/name/config/sharding/rule 获取到分库分表规并转换成ShardingRuleConfiguration对象</span>\n        ShardingRuleConfiguration result <span class=\"token operator\">=</span> ShardingConfigurationConverter<span class=\"token punctuation\">.</span><span class=\"token function\">shardingRuleConfigFromYaml</span><span class=\"token punctuation\">(</span>regCenter<span class=\"token punctuation\">.</span><span class=\"token function\">getDirectly</span><span class=\"token punctuation\">(</span>configNode<span class=\"token punctuation\">.</span><span class=\"token function\">getFullPath</span><span class=\"token punctuation\">(</span>ConfigurationNode<span class=\"token punctuation\">.</span>SHARDING_RULE_NODE_PATH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Preconditions<span class=\"token punctuation\">.</span><span class=\"token function\">checkState</span><span class=\"token punctuation\">(</span>null <span class=\"token operator\">!=</span> result <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>result<span class=\"token punctuation\">.</span><span class=\"token function\">getTableRuleConfigs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"No available sharding rule configuration to load.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">final</span> Exception ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ShardingConfigurationException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No available sharding rule configuration to load.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>第三步，初始化shardingDataSource</p>\n<pre class=\" language-java\"><code class=\"language-java\">dataSource <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ShardingDataSource</span><span class=\"token punctuation\">(</span>configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadDataSourceMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                <span class=\"token keyword\">new</span> <span class=\"token class-name\">ShardingRule</span><span class=\"token punctuation\">(</span>shardingRuleConfig<span class=\"token punctuation\">,</span> configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadDataSourceMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadShardingConfigMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadShardingProperties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>第四步，设置watch机制，当配置发生变化时重新加载ShardingDataSource</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> DataSource<span class=\"token operator\">></span> dataSourceMap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> ShardingRuleConfiguration shardingRuleConfig<span class=\"token punctuation\">,</span> \n                 <span class=\"token keyword\">final</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> configMap<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> Properties props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//判断是否有主从配置的规则，如果有则做处理</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>shardingRuleConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getMasterSlaveRuleConfigs</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">reviseShardingRuleConfigurationForMasterSlave</span><span class=\"token punctuation\">(</span>dataSourceMap<span class=\"token punctuation\">,</span> shardingRuleConfig<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//通过isOverwrite判断是否需要本地配置是否覆写服务器配置</span>\n    <span class=\"token comment\" spellcheck=\"true\">//如果为true，则会使用本地的配置先加载到配置中心里面</span>\n    configService<span class=\"token punctuation\">.</span><span class=\"token function\">persistShardingConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token function\">getActualDataSourceMapForMasterSlave</span><span class=\"token punctuation\">(</span>dataSourceMap<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> shardingRuleConfig<span class=\"token punctuation\">,</span> configMap<span class=\"token punctuation\">,</span> props<span class=\"token punctuation\">,</span> isOverwrite<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//更新在线的实例机器，这里sharingjdbc通过在节点  /namespace/name/state/instances上记录当前连接到配置中心的机器</span>\n    <span class=\"token comment\" spellcheck=\"true\">//以便以后获取在线机器做铺垫</span>\n    instanceStateService<span class=\"token punctuation\">.</span><span class=\"token function\">persistShardingInstanceOnline</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    dataSourceService<span class=\"token punctuation\">.</span><span class=\"token function\">persistDataSourcesNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//分库分表规则，数据库连接信息，实例等设置Watch</span>\n    listenerManager<span class=\"token punctuation\">.</span><span class=\"token function\">initShardingListeners</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initShardingListeners</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//分库分表规则设置Watch</span>\n    configurationListenerManager<span class=\"token punctuation\">.</span><span class=\"token function\">watchSharding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//在线实例设置Watch</span>\n    instanceListenerManager<span class=\"token punctuation\">.</span><span class=\"token function\">watchSharding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//数据库连接设置Watch</span>\n    dataSourceListenerManager<span class=\"token punctuation\">.</span><span class=\"token function\">watchSharding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//configmap设置Watch</span>\n    configMapListenerManager<span class=\"token punctuation\">.</span><span class=\"token function\">watchSharding</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//以分库分表规则为例</span>\n<span class=\"token function\">watchSharding</span><span class=\"token punctuation\">(</span>ConfigurationNode<span class=\"token punctuation\">.</span>SHARDING_RULE_NODE_PATH<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">watchSharding</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> String node<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    String cachePath <span class=\"token operator\">=</span> configNode<span class=\"token punctuation\">.</span><span class=\"token function\">getFullPath</span><span class=\"token punctuation\">(</span>node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    regCenter<span class=\"token punctuation\">.</span><span class=\"token function\">watch</span><span class=\"token punctuation\">(</span>cachePath<span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">EventListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onChange</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> DataChangedEvent event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//当/sharding-data/xuzy/config/sharding/rule的内容发生变化时</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>DataChangedEvent<span class=\"token punctuation\">.</span>Type<span class=\"token punctuation\">.</span>UPDATED <span class=\"token operator\">==</span> event<span class=\"token punctuation\">.</span><span class=\"token function\">getEventType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//获取正常运行的数据源信息</span>\n                Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> DataSource<span class=\"token operator\">></span> dataSourceMap <span class=\"token operator\">=</span> dataSourceService<span class=\"token punctuation\">.</span><span class=\"token function\">getAvailableDataSources</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//重新获取配置中心中最新的配置</span>\n                ShardingConfigurationEventBusEvent shardingEvent <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ShardingConfigurationEventBusEvent</span><span class=\"token punctuation\">(</span>dataSourceMap<span class=\"token punctuation\">,</span>\n                        <span class=\"token keyword\">new</span> <span class=\"token class-name\">ShardingRule</span><span class=\"token punctuation\">(</span>dataSourceService<span class=\"token punctuation\">.</span><span class=\"token function\">getAvailableShardingRuleConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> dataSourceMap<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> configService<span class=\"token punctuation\">.</span><span class=\"token function\">loadShardingProperties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token comment\" spellcheck=\"true\">//采用guava的EventBus进行通知，重新加载shardingDataSource实例。 这里EventBus后面说</span>\n                ShardingEventBusInstance<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>shardingEvent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"EventBus\"><a href=\"#EventBus\" class=\"headerlink\" title=\"EventBus\"></a>EventBus</h4><p>EventBus是guava提供的一种观察者模式。具体原理可以自己百度下。笔者也不是很清楚。使用如下</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">EventBusTest</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">final</span> EventBus eventBus <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">EventBus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//注册监听者</span>\n        eventBus<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        eventBus<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">SimpleListener2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//执行post时，监听者可以收到通知并执行对应的逻辑</span>\n        eventBus<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Simple Event\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleListener</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Subscribe</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doAction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> String event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>event <span class=\"token operator\">+</span> <span class=\"token string\">\"_1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SimpleListener2</span><span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Subscribe</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doAction</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> String event<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>event <span class=\"token operator\">+</span> <span class=\"token string\">\"_2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>所以，当配置中心触发Watch机制的时候，我们可以看到在代码上执行了</p>\n<pre class=\" language-java\"><code class=\"language-java\">ShardingEventBusInstance<span class=\"token punctuation\">.</span><span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>shardingEvent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p><img src=\"/2021/02/02/shardingjdbc-reg/2.png\" alt></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过将复杂繁多的配置使用zookeeper进行管理，并且通过Watch机制自动重新加载配置。笔者工作中负责一个自动化入库任务，通过定时拉取数据再经过shardingjdbc存入数据库。期间如果需要新增分库分表规则需要重启服务，势必会导致定时任务的失败，所以采用了编排治理的方式实现不用重启重新加载配置。安全高效。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"分布式配置中心\"><a href=\"#分布式配置中心\" class=\"headerlink\" title=\"分布式配置中心\"></a>分布式配置中心</h2><p>在分布式系统或者微服务中，我们经常用到分布式配置中心，他可以将配置定义到一个单独的地方以便所有分布式系统从能从中读取配置，对于修改配置也只需要修改一个地方就行。</p>\n<h2 id=\"ShardingSphere编排治理\"><a href=\"#ShardingSphere编排治理\" class=\"headerlink\" title=\"ShardingSphere编排治理\"></a>ShardingSphere编排治理</h2><h3 id=\"为啥需要编排治理？\"><a href=\"#为啥需要编排治理？\" class=\"headerlink\" title=\"为啥需要编排治理？\"></a>为啥需要编排治理？</h3><p>ShardingSphere的编排治理提供了配置中心和注册中心功能。<br>在使用ShardingSphere我们经常定义了一堆分库分表规则。传统的ShardingJdcb我们一般将分库分表规则配置在yml文件或者xml文件中。然而在分布式系统中，假设我们有100台机器做负载均衡，由于需求原因分库分表规则需要添加规则，这时候我们的处理如下：</p>\n<ol>\n<li>对100台机器上的分库分表配置文件yml文件进行逐一修改</li>\n<li>逐一重启100台机器Tomcat</li>\n</ol>\n<p>这其中的复杂程度可想而知。有人会说，可以将配置定义在一个分布式配置中心中。 没错 ！！！</p>\n<p>所以ShardingSphere提供了编排治理功能，通俗一点就是通过ShardingSphere + Zookeeper 或者 Etcd  实现 分布式配置功能，并且通过Zookeeper的Watch机制保证每次修改后<font color=\"red\">自动加载无需重启</font>。</p>","more":"<h3 id=\"如何使用？\"><a href=\"#如何使用？\" class=\"headerlink\" title=\"如何使用？\"></a>如何使用？</h3><p>导入编排治理Maven</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n            &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;\n            &lt;artifactId&gt;sharding-jdbc-orchestration-spring-namespace&lt;/artifactId&gt;\n            &lt;version&gt;3.0.0.M3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n            &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;\n            &lt;artifactId&gt;sharding-orchestration-reg-zookeeper-curator&lt;/artifactId&gt;\n            &lt;version&gt;3.0.0&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p>最终测试代码</p>\n<pre><code class=\"java\">@Test\npublic void testOrchestration2() throws Exception {\n\n    //先删除zk上相关的配置\n    deleteZkDataSourceAndRule();\n    //加载DataSource信息到zk\n    initDataSourceZkData();\n    //加载分库分表规则到ZK\n    initRuleZkData();\n\n    ZookeeperConfiguration regConfig = new ZookeeperConfiguration();\n    regConfig.setServerLists(&quot;localhost:2181&quot;);\n    regConfig.setNamespace(&quot;sharding-data&quot;);\n    OrchestrationConfiguration orchConcifg = new OrchestrationConfiguration(&quot;xuzy&quot;,regConfig,false, OrchestrationType.SHARDING);\n    //通过OrchestrationShardingDataSourceFactory创建ShardingDataSource\n    DataSource dataSource = OrchestrationShardingDataSourceFactory.createDataSource(orchConcifg);\n    //查询\n    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n    //查询， 此时如果查询2021年的话会报错\n    List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * from flow where flowtime in (&#39;20170818&#39;,&#39;20190205&#39;)&quot;);\n\n\n    //修改DataSource信息（新增了dataSource_2021）到ZK\n    updateDataSourceZkData();\n    //修改分库分表规则(flow新增了2021年规则)到ZK\n    updateRuleZkData();\n\n    TimeUnit.SECONDS.sleep(20);\n\n    //查询， 此时如果查询2021年的话不会报错\n    List&lt;Map&lt;String, Object&gt;&gt; listNew = jdbcTemplate.queryForList(&quot;select * from flow where flowtime in (&#39;20170818&#39;,&#39;20190205&#39;,&#39;20210405&#39;)&quot;);\n    System.out.println(listNew);\n}</code></pre>\n<p>删除zookeeper上的sharding配置</p>\n<pre><code class=\"java\">@Test\npublic void deleteZkDataSourceAndRule() throws Exception {\n    //zookeeper节点名称定义在io.shardingsphere.jdbc.orchestration.internal.config.ConfigurationNode上，会面说明\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    Stat stat = cf.checkExists().forPath(&quot;/sharding-data/xuzy/config/datasource&quot;);\n    if(stat != null){\n        cf.delete().forPath(&quot;/sharding-data/xuzy/config/datasource&quot;);\n    }\n    Stat stat2 = cf.checkExists().forPath(&quot;/sharding-data/xuzy/config/sharding/rule&quot;);\n    if(stat2 != null){\n        cf.delete().forPath(&quot;/sharding-data/xuzy/config/sharding/rule&quot;);\n    }\n    cf.close();\n}</code></pre>\n<p>加加载DataSource信息到zookeeper</p>\n<pre><code class=\"java\">@Test\npublic void initDataSourceZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    //创建datasource信息 orchestration-sharding-data-source为命名空间 ，闯将的datasource是ymal模式的\n    //Map&lt;String, DataSource&gt; result = DataSourceConverter.dataSourceMapFromYaml(this.regCenter.getDirectly(this.configNode.getFullPath(&quot;config/datasource&quot;)));\n    String dataSource = &quot;&quot; +\n            &quot;  dataSource_default: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000\\n&quot; +\n            &quot;  dataSource_2017: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000\\n&quot; +\n            &quot;  dataSource_2018: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000\\n&quot; +\n            &quot;  dataSource_2019: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000\\n&quot; +\n            &quot;  dataSource_2020: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000&quot;;\n    cf.create()\n            .creatingParentsIfNeeded() //自动创建父节点\n            .withMode(CreateMode.PERSISTENT) //设置成永久节点\n            .forPath(&quot;/sharding-data/xuzy/config/datasource&quot;, dataSource.getBytes());\n    cf.close();\n}</code></pre>\n<p>加载分库分表规则到Zookeeper</p>\n<pre><code class=\"java\">@Test\npublic void initRuleZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    String rule = &quot;  tables:\\n&quot; +\n            &quot;    flow:\\n&quot; +\n            &quot;      actualDataNodes: dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\\n&quot; +\n            &quot;      tableStrategy:\\n&quot; +\n            &quot;        standard:\\n&quot; +\n            &quot;          shardingColumn: flowtime\\n&quot; +\n            &quot;          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n&quot; +\n            &quot;      databaseStrategy:\\n&quot; +\n            &quot;        standard:\\n&quot; +\n            &quot;          shardingColumn: flowtime\\n&quot; +\n            &quot;          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n&quot; +\n            &quot;    ips:\\n&quot; +\n            &quot;      actualDataNodes: dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\\n&quot; +\n            &quot;      tableStrategy:\\n&quot; +\n            &quot;        standard:\\n&quot; +\n            &quot;          shardingColumn: flowtime\\n&quot; +\n            &quot;          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n&quot; +\n            &quot;      databaseStrategy:\\n&quot; +\n            &quot;        standard:\\n&quot; +\n            &quot;          shardingColumn: flowtime\\n&quot; +\n            &quot;          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n&quot; +\n            &quot;    acca:\\n&quot; +\n            &quot;      actualDataNodes: dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\\n&quot; +\n            &quot;      tableStrategy:\\n&quot; +\n            &quot;        complex:\\n&quot; +\n            &quot;          shardingColumns: flowtime,dataType\\n&quot; +\n            &quot;          algorithmClassName: com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\\n&quot; +\n            &quot;      databaseStrategy:\\n&quot; +\n            &quot;        complex:\\n&quot; +\n            &quot;          shardingColumns: flowtime,dataType\\n&quot; +\n            &quot;          algorithmClassName: com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\\n&quot; +\n            &quot;  bindingTables:\\n&quot; +\n            &quot;    - flow,ips,acca\\n&quot; +\n            &quot;  defaultDatabaseStrategy:\\n&quot; +\n            &quot;    none:\\n&quot; +\n            &quot;  defaultTableStrategy:\\n&quot; +\n            &quot;    none:&quot;;\n    cf.create()\n            .creatingParentsIfNeeded() //自动创建父节点\n            .withMode(CreateMode.PERSISTENT) //设置成永久节点\n            .forPath(&quot;/sharding-data/xuzy/config/sharding/rule&quot;, rule.getBytes());\n    cf.close();\n}</code></pre>\n<p>修改DataSource信息（新增了dataSource_2021）到Zookeeper</p>\n<pre><code class=\"java\">@Test\npublic void updateDataSourceZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    String dataSource = &quot;  dataSource_default: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000\\n&quot; +\n            &quot;  dataSource_2017: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000\\n&quot; +\n            &quot;  dataSource_2018: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000\\n&quot; +\n            &quot;  dataSource_2019: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000\\n&quot; +\n            &quot;  dataSource_2020: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000\\n&quot; +\n            &quot;  dataSource_2021: !!org.apache.commons.dbcp.BasicDataSource\\n&quot; +\n            &quot;    driverClassName: com.mysql.jdbc.Driver\\n&quot; +\n            &quot;    url: jdbc:mysql://localhost:3306/sharding_2021?useUnicode=true&amp;amp;characterEncoding=utf-8\\n&quot; +\n            &quot;    username: root\\n&quot; +\n            &quot;    password: 123456\\n&quot; +\n            &quot;    initialSize : 0\\n&quot; +\n            &quot;    maxActive : 200\\n&quot; +\n            &quot;    maxIdle : 20\\n&quot; +\n            &quot;    minIdle : 1\\n&quot; +\n            &quot;    maxWait : 60000&quot;;\n    //更新\n    cf.setData().forPath(&quot;/sharding-data/xuzy/config/datasource&quot;, dataSource.getBytes());\n}</code></pre>\n<p>修改分库分表规则(flow新增了2021年规则)到Zookeeper</p>\n<pre><code class=\"java\">@Test\npublic void updateRuleZkData() throws Exception {\n    CuratorFramework cf = getCuratorFramework();\n    cf.start();\n    String rule = &quot;  tables:\\n&quot; +\n            &quot;    flow:\\n&quot; +\n            &quot;      actualDataNodes: dataSource_${2017..2021}.flow_0${1..9},dataSource_${2017..2021}.flow_1${0..2}\\n&quot; +\n            &quot;      tableStrategy:\\n&quot; +\n            &quot;        standard:\\n&quot; +\n            &quot;          shardingColumn: flowtime\\n&quot; +\n            &quot;          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n&quot; +\n            &quot;      databaseStrategy:\\n&quot; +\n            &quot;        standard:\\n&quot; +\n            &quot;          shardingColumn: flowtime\\n&quot; +\n            &quot;          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n&quot; +\n            &quot;    ips:\\n&quot; +\n            &quot;      actualDataNodes: dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\\n&quot; +\n            &quot;      tableStrategy:\\n&quot; +\n            &quot;        standard:\\n&quot; +\n            &quot;          shardingColumn: flowtime\\n&quot; +\n            &quot;          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\\n&quot; +\n            &quot;      databaseStrategy:\\n&quot; +\n            &quot;        standard:\\n&quot; +\n            &quot;          shardingColumn: flowtime\\n&quot; +\n            &quot;          preciseAlgorithmClassName: com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\\n&quot; +\n            &quot;    acca:\\n&quot; +\n            &quot;      actualDataNodes: dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\\n&quot; +\n            &quot;      tableStrategy:\\n&quot; +\n            &quot;        complex:\\n&quot; +\n            &quot;          shardingColumns: flowtime,dataType\\n&quot; +\n            &quot;          algorithmClassName: com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\\n&quot; +\n            &quot;      databaseStrategy:\\n&quot; +\n            &quot;        complex:\\n&quot; +\n            &quot;          shardingColumns: flowtime,dataType\\n&quot; +\n            &quot;          algorithmClassName: com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\\n&quot; +\n            &quot;  bindingTables:\\n&quot; +\n            &quot;    - flow,ips,acca\\n&quot; +\n            &quot;  defaultDatabaseStrategy:\\n&quot; +\n            &quot;    none:\\n&quot; +\n            &quot;  defaultTableStrategy:\\n&quot; +\n            &quot;    none:&quot;;\n    //更新\n    cf.setData().forPath(&quot;/sharding-data/xuzy/config/sharding/rule&quot;, rule.getBytes());\n}</code></pre>\n<h3 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h3><pre><code class=\"java\">ZookeeperConfiguration regConfig = new ZookeeperConfiguration();\nregConfig.setServerLists(&quot;localhost:2181&quot;);\n//这里namespace表示命名空间。\nregConfig.setNamespace(&quot;sharding-data&quot;);\nOrchestrationConfiguration orchConcifg = new OrchestrationConfiguration(&quot;xuzy&quot;,regConfig,false, OrchestrationType.SHARDING);\n//通过OrchestrationShardingDataSourceFactory创建ShardingDataSource\nDataSource dataSource = OrchestrationShardingDataSourceFactory.createDataSource(orchConcifg);</code></pre>\n<h4 id=\"治理规则配置类OrchestrationConfiguration\"><a href=\"#治理规则配置类OrchestrationConfiguration\" class=\"headerlink\" title=\"治理规则配置类OrchestrationConfiguration\"></a>治理规则配置类OrchestrationConfiguration</h4><pre><code class=\"java\">@RequiredArgsConstructor\n@Getter\npublic final class OrchestrationConfiguration {\n    //治理规则名称\n    //这个主要作用是为了可以区分本地环境和测试环境。例如在zk上我们可以定义两套配置，然后使用name = prod表示加载的是生产环境的配置\n    private final String name;\n    //注册（配置）中心配置类接口，目前支持zookeeper和Etcd方式\n    private final RegistryCenterConfiguration regCenterConfig;\n    //本地配置是否覆写服务器配置标志位\n    private final boolean overwrite;\n    //枚举类，用来区别是普通sharding或者主从sharding\n    private final OrchestrationType type;\n}</code></pre>\n<pre><code class=\"java\">//节点配置类，定义了存放到zookeeper的路径\n@RequiredArgsConstructor\npublic final class ConfigurationNode {\n    public static final String ROOT = &quot;config&quot;;\n    public static final String PROXY_NODE_PATH = ROOT + &quot;/proxy&quot;;\n    //存放数据源信息的路径，配合namespace + 治理规则名称 最终定义存放到zookeeper的路径\n    //例如namespace = sharding-data name(治理规则名称) = xuzy \n    //所以最终数据源信息存放到/sharding-data/xuzy/config/datasource\n    public static final String DATA_SOURCE_NODE_PATH = ROOT + &quot;/datasource&quot;;\n    public static final String SHARDING_NODE_PATH = ROOT + &quot;/sharding&quot;;\n    public static final String MASTER_SLAVE_NODE_PATH = ROOT + &quot;/masterslave&quot;;\n    public static final String RULE_NODE_PATH = &quot;/rule&quot;;\n    public static final String CONFIG_MAP_NODE_PATH = &quot;/configmap&quot;;\n    public static final String SHARDING_RULE_NODE_PATH = SHARDING_NODE_PATH + RULE_NODE_PATH;\n    public static final String SHARDING_CONFIG_MAP_NODE_PATH = SHARDING_NODE_PATH + CONFIG_MAP_NODE_PATH;\n    public static final String SHARDING_PROPS_NODE_PATH = SHARDING_NODE_PATH + &quot;/props&quot;;\n    public static final String MASTER_SLAVE_RULE_NODE_PATH = MASTER_SLAVE_NODE_PATH + RULE_NODE_PATH;\n    public static final String MASTER_SLAVE_CONFIG_MAP_NODE_PATH = MASTER_SLAVE_NODE_PATH + CONFIG_MAP_NODE_PATH;\n    public static final String MASTER_SLAVE_PROPS_NODE_PATH = MASTER_SLAVE_NODE_PATH + &quot;/props&quot;;\n    public static final String PROXY_RULE_NODE_PATH = PROXY_NODE_PATH + RULE_NODE_PATH;\n    private final String name;\n    /**\n     * Get node full path.\n     *\n     * @param node node name\n     * @return node full path\n     */\n    public String getFullPath(final String node) {\n        return String.format(&quot;/%s/%s&quot;, name, node);\n    }\n}</code></pre>\n<h4 id=\"创建shardingDataSource工厂\"><a href=\"#创建shardingDataSource工厂\" class=\"headerlink\" title=\"创建shardingDataSource工厂\"></a>创建shardingDataSource工厂</h4><p>编排治理提供了两种创建shardingDataSource的工厂。</p>\n<ul>\n<li>OrchestrationShardingDataSourceFactory 普通shardingDataSource创建工厂</li>\n<li>OrchestrationMasterSlaveDataSourceFactory 主从shardingDataSource创建工厂</li>\n</ul>\n<pre><code class=\"java\">@NoArgsConstructor(access = AccessLevel.PRIVATE)\npublic final class OrchestrationShardingDataSourceFactory {\n    public static DataSource createDataSource(final OrchestrationConfiguration orchestrationConfig) throws SQLException {\n        return new OrchestrationShardingDataSource(orchestrationConfig);\n    }\n}</code></pre>\n<h4 id=\"编排治理ShardingDataSource\"><a href=\"#编排治理ShardingDataSource\" class=\"headerlink\" title=\"编排治理ShardingDataSource\"></a>编排治理ShardingDataSource</h4><p>OrchestrationShardingDataSource继承关系如下，实现了DataSource接口。这个类是最主要的类，通过从zookeeper获取对应的配置最后初始化成ShardingDataSource。</p>\n<p><img src=\"/2021/02/02/shardingjdbc-reg/1.png\" alt></p>\n<p>主流程如下：</p>\n<ol>\n<li>初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心</li>\n<li>从配置中心获取分库分表规则，数据库连接信息</li>\n<li>初始化ShardingDataSource</li>\n<li>设置watch机制，当配置发生变化时重新加载ShardingDataSource</li>\n</ol>\n<pre><code class=\"java\">public OrchestrationShardingDataSource(final OrchestrationConfiguration orchestrationConfig) throws SQLException {\n    //初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心\n    super(new OrchestrationFacade(orchestrationConfig));\n    ConfigurationService configService = getOrchestrationFacade().getConfigService();\n    //从配置中心获取分库分表规则，数据库连接信息\n    ShardingRuleConfiguration shardingRuleConfig = configService.loadShardingRuleConfiguration();\n    Preconditions.checkNotNull(shardingRuleConfig, &quot;Missing the sharding rule configuration on register center&quot;);\n    //初始化ShardingDataSource\n    dataSource = new ShardingDataSource(configService.loadDataSourceMap(),\n            new ShardingRule(shardingRuleConfig, configService.loadDataSourceMap().keySet()), configService.loadShardingConfigMap(), configService.loadShardingProperties());\n    //设置watch机制，当配置发生变化时重新加载ShardingDataSource\n    initOrchestrationFacade(dataSource);\n}</code></pre>\n<p>第一步，初始化OrchestrationFacade对象，里面通过配置确定是采用zookeeper还是etcd作为配置中心</p>\n<pre><code class=\"java\">public OrchestrationFacade(final OrchestrationConfiguration orchestrationConfig) {\n    //选择配置中心\n    regCenter = createRegistryCenter(orchestrationConfig.getRegCenterConfig());\n    isOverwrite = orchestrationConfig.isOverwrite();\n    //用于获取配置的service类\n    configService = new ConfigurationService(orchestrationConfig.getName(), regCenter);\n    //用于获取实例状态的service类\n    instanceStateService = new InstanceStateService(orchestrationConfig.getName(), regCenter);\n    //用于获取数据源的service类\n    dataSourceService = new DataSourceService(orchestrationConfig.getName(), regCenter);\n    listenerManager = new ListenerFactory(orchestrationConfig.getName(), regCenter);\n}\n\nprivate RegistryCenter createRegistryCenter(final RegistryCenterConfiguration regCenterConfig) {\n    Preconditions.checkNotNull(regCenterConfig, &quot;Registry center configuration cannot be null.&quot;);\n    //如果是ZookeeperConfiguration则采用zookeeper作为配置中心\n    if (regCenterConfig instanceof ZookeeperConfiguration) {\n        return getZookeeperRegistryCenter((ZookeeperConfiguration) regCenterConfig);\n    }\n    if (regCenterConfig instanceof EtcdConfiguration) {\n        return new EtcdRegistryCenter((EtcdConfiguration) regCenterConfig);\n    }\n    throw new UnsupportedOperationException(regCenterConfig.getClass().getName());\n}\n\nprivate RegistryCenter getZookeeperRegistryCenter(final ZookeeperConfiguration regCenterConfig) {\n    if (regCenterConfig.isUseNative()) {\n        //这个没用过\n        return new NewZookeeperRegistryCenter(regCenterConfig);\n    } else {\n        // Curator作为zookeeper的客户端\n        return new ZookeeperRegistryCenter(regCenterConfig);\n    }\n}</code></pre>\n<p>第二步，从配置中心获取分库分表规则，数据库连接信息</p>\n<p>以获取分库分表规则为例</p>\n<pre><code class=\"java\">public ShardingRuleConfiguration loadShardingRuleConfiguration() {\n    try {\n        //从路径 /namespace/name/config/sharding/rule 获取到分库分表规并转换成ShardingRuleConfiguration对象\n        ShardingRuleConfiguration result = ShardingConfigurationConverter.shardingRuleConfigFromYaml(regCenter.getDirectly(configNode.getFullPath(ConfigurationNode.SHARDING_RULE_NODE_PATH)));\n        Preconditions.checkState(null != result &amp;&amp; !result.getTableRuleConfigs().isEmpty(), &quot;No available sharding rule configuration to load.&quot;);\n        return result;\n    } catch (final Exception ex) {\n        throw new ShardingConfigurationException(&quot;No available sharding rule configuration to load.&quot;);\n    }\n}</code></pre>\n<p>第三步，初始化shardingDataSource</p>\n<pre><code class=\"java\">dataSource = new ShardingDataSource(configService.loadDataSourceMap(),\n                new ShardingRule(shardingRuleConfig, configService.loadDataSourceMap().keySet()), configService.loadShardingConfigMap(), configService.loadShardingProperties());</code></pre>\n<p>第四步，设置watch机制，当配置发生变化时重新加载ShardingDataSource</p>\n<pre><code class=\"java\">public void init(final Map&lt;String, DataSource&gt; dataSourceMap, final ShardingRuleConfiguration shardingRuleConfig, \n                 final Map&lt;String, Object&gt; configMap, final Properties props) {\n    //判断是否有主从配置的规则，如果有则做处理\n    if (shardingRuleConfig.getMasterSlaveRuleConfigs().isEmpty()) {\n        reviseShardingRuleConfigurationForMasterSlave(dataSourceMap, shardingRuleConfig);\n    }\n    //通过isOverwrite判断是否需要本地配置是否覆写服务器配置\n    //如果为true，则会使用本地的配置先加载到配置中心里面\n    configService.persistShardingConfiguration(getActualDataSourceMapForMasterSlave(dataSourceMap), shardingRuleConfig, configMap, props, isOverwrite);\n    //更新在线的实例机器，这里sharingjdbc通过在节点  /namespace/name/state/instances上记录当前连接到配置中心的机器\n    //以便以后获取在线机器做铺垫\n    instanceStateService.persistShardingInstanceOnline();\n    dataSourceService.persistDataSourcesNode();\n    //分库分表规则，数据库连接信息，实例等设置Watch\n    listenerManager.initShardingListeners();\n}</code></pre>\n<pre><code class=\"java\">public void initShardingListeners() {\n    //分库分表规则设置Watch\n    configurationListenerManager.watchSharding();\n    //在线实例设置Watch\n    instanceListenerManager.watchSharding();\n    //数据库连接设置Watch\n    dataSourceListenerManager.watchSharding();\n    //configmap设置Watch\n    configMapListenerManager.watchSharding();\n}\n\n//以分库分表规则为例\nwatchSharding(ConfigurationNode.SHARDING_RULE_NODE_PATH);\nprivate void watchSharding(final String node) {\n    String cachePath = configNode.getFullPath(node);\n    regCenter.watch(cachePath, new EventListener() {\n\n        @Override\n        public void onChange(final DataChangedEvent event) {\n            //当/sharding-data/xuzy/config/sharding/rule的内容发生变化时\n            if (DataChangedEvent.Type.UPDATED == event.getEventType()) {\n                //获取正常运行的数据源信息\n                Map&lt;String, DataSource&gt; dataSourceMap = dataSourceService.getAvailableDataSources();\n                //重新获取配置中心中最新的配置\n                ShardingConfigurationEventBusEvent shardingEvent = new ShardingConfigurationEventBusEvent(dataSourceMap,\n                        new ShardingRule(dataSourceService.getAvailableShardingRuleConfiguration(), dataSourceMap.keySet()), configService.loadShardingProperties());\n                //采用guava的EventBus进行通知，重新加载shardingDataSource实例。 这里EventBus后面说\n                ShardingEventBusInstance.getInstance().post(shardingEvent);\n            }\n        }\n    });\n}</code></pre>\n<h4 id=\"EventBus\"><a href=\"#EventBus\" class=\"headerlink\" title=\"EventBus\"></a>EventBus</h4><p>EventBus是guava提供的一种观察者模式。具体原理可以自己百度下。笔者也不是很清楚。使用如下</p>\n<pre><code class=\"java\">public class EventBusTest {\n\n    public static void main(String[] args){\n        final EventBus eventBus = new EventBus();\n        //注册监听者\n        eventBus.register(new SimpleListener());\n        eventBus.register(new SimpleListener2());\n        //执行post时，监听者可以收到通知并执行对应的逻辑\n        eventBus.post(&quot;Simple Event&quot;);\n    }\n\n    static class SimpleListener {\n        @Subscribe\n        public void doAction(final String event) {\n            System.out.println(event + &quot;_1&quot;);\n        }\n    }\n\n    static class SimpleListener2{\n        @Subscribe\n        public void doAction(final String event) {\n            System.out.println(event + &quot;_2&quot;);\n        }\n    }\n}</code></pre>\n<p>所以，当配置中心触发Watch机制的时候，我们可以看到在代码上执行了</p>\n<pre><code class=\"java\">ShardingEventBusInstance.getInstance().post(shardingEvent);</code></pre>\n<p><img src=\"/2021/02/02/shardingjdbc-reg/2.png\" alt></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过将复杂繁多的配置使用zookeeper进行管理，并且通过Watch机制自动重新加载配置。笔者工作中负责一个自动化入库任务，通过定时拉取数据再经过shardingjdbc存入数据库。期间如果需要新增分库分表规则需要重启服务，势必会导致定时任务的失败，所以采用了编排治理的方式实现不用重启重新加载配置。安全高效。</p>"},{"title":"ShardingJdbc学习之按年月分库分表","description":"采用shardingjdbc实现按年分库按月分表","date":"2021-01-09T02:14:00.000Z","_content":"sharding-jdbc官方文档:https://shardingsphere.apache.org/document/current/cn/overview/\n**本文采用当当的shardingjdbc实现按年分库，按月分表**\n\n**最终数据库结果如下**\n\n![](sharding-student/1.png)\n例如有如下sql语句\n```\nselect * from ips where flowtime = '20181202';\n```\n我们规定flowtime是我们的分片键,通过值20181202确定年份为2018，月份为12，所以需要定位到库sharding_2018中的表ips_12查询，\n所以实际发出的查询语句是\n```\nselect * from `sharding_2018`.ips_12 where flowtime = '20181202';\n```\n<!--more-->\n#### 具体实现\n##### maven导出具体sharding需要的包\n```\n<dependency>\n            <groupId>io.shardingsphere</groupId>\n            <artifactId>sharding-jdbc-spring-namespace</artifactId>\n            <version>3.0.0.M3</version>\n</dependency>\n<dependency>\n            <groupId>io.shardingsphere</groupId>\n            <artifactId>sharding-jdbc-orchestration-spring-namespace</artifactId>\n            <version>3.0.0.M3</version>\n</dependency>\n```\n##### 配置数据库连接\n由于我们需要一年一库，所以我们取2017~2020年来建库，这步骤需要手工建立。查了资料好像shardingjdbc不支持自动建库，例如我们如果按照上面一年一库的规则，我们就需要自己手动建立对应的库。一年一库感觉还好，正常来说一个产品最多用10年已经很久了，所以手动预先建立好库没什么太大的工作量。所以我们先在数据库建立好表后，然后配置对应的数据源\n######applicationContext-database.xml\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <bean id=\"dataSource_default\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n    <bean id=\"dataSource_2017\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n    <bean id=\"dataSource_2018\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n    <bean id=\"dataSource_2019\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n    <bean id=\"dataSource_2020\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n</beans>\n```\n**这里解释下dataSource_default这个数据库用来干嘛的。由于在正常项目中并不是所有的数据都需要进行分库分表，例如用户表和用户记录表，一般用户记录表一般是千万级的，需要分库分表，但是用户表不需要。我们这里配置一个默认的数据源，对于不分库分表的数据就存放在这个默认的数据库中**\n###### applicationContext-sharding.xml\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:sharding=\"http://shardingsphere.io/schema/shardingsphere/sharding\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://shardingsphere.io/schema/shardingsphere/sharding\n                        http://shardingsphere.io/schema/shardingsphere/sharding/sharding.xsd\">\n\n    <!--规则定义:一年一库,一月一表-->\n    <!--分片算法(根据flowtime一年一库，一月一表)-->\n    <bean id=\"databaseShardingAlgorithm\" class=\"com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\"></bean>\n    <bean id=\"tableShardingAlgorithm\" class=\"com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\"></bean>\n\n\n    <bean id=\"complexModuloDatabaseShardingAlgorithm\" class=\"com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\"></bean>\n    <bean id=\"complexModuloTableShardingAlgorithm\" class=\"com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\"></bean>\n\n\n    <!--数据库分片-标准-按照time字段分片【坑:不能使用mysql关键词作为分片，不然会不能路由,time就是一个 所以换成了flowtime】-->\n    <sharding:standard-strategy id=\"databaseShardingStrategy\" sharding-column=\"flowtime\" precise-algorithm-ref=\"databaseShardingAlgorithm\"/>\n    <!--表分片-标准-按照time字段分片-->\n    <sharding:standard-strategy id=\"tableShardingStrategy\" sharding-column=\"flowtime\" precise-algorithm-ref=\"tableShardingAlgorithm\"/>\n\n    <!--复合分片-->\n    <sharding:complex-strategy id=\"complexdatabaseShardingStrategy\" sharding-columns=\"flowtime,dataType\" algorithm-ref=\"complexModuloDatabaseShardingAlgorithm\"/>\n    <sharding:complex-strategy id=\"complextableShardingStrategy\" sharding-columns=\"flowtime,dataType\" algorithm-ref=\"complexModuloTableShardingAlgorithm\"/>\n\n\n    <sharding:none-strategy id=\"noShardingStrategy\"/>\n\n    <sharding:data-source id=\"shardingDataSource\">\n        <sharding:sharding-rule data-source-names=\"dataSource_2017,dataSource_2018,dataSource_2019,dataSource_2020,dataSource_default\" default-data-source-name=\"dataSource_default\">\n            <sharding:table-rules>\n                <!--flow表的分片规则-->\n                <sharding:table-rule logic-table=\"flow\" actual-data-nodes=\"dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\" database-strategy-ref=\"databaseShardingStrategy\" table-strategy-ref=\"tableShardingStrategy\" />\n                <sharding:table-rule logic-table=\"ips\" actual-data-nodes=\"dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\" database-strategy-ref=\"databaseShardingStrategy\" table-strategy-ref=\"tableShardingStrategy\" />\n                <sharding:table-rule logic-table=\"acca\" actual-data-nodes=\"dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\" database-strategy-ref=\"complexdatabaseShardingStrategy\" table-strategy-ref=\"complextableShardingStrategy\" />\n                <!--\n                    不路由的数据可以不配置，因为上面指定了默认的dataSource_default\n                    <sharding:table-rule logic-table=\"websocket\" actual-data-nodes=\"dataSource_default.websocket\"/>\n                -->\n            </sharding:table-rules>\n        </sharding:sharding-rule>\n        <sharding:props>\n            <prop key=\"sql.show\">true</prop>\n        </sharding:props>\n    </sharding:data-source>\n\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"shardingDataSource\"></property>\n    </bean>\n\n    <!--普通的数据库连接，不走sharding-->\n    <bean id=\"jdbcTemplate_default\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"dataSource_default\"></property>\n    </bean>\n</beans>\n```\n解释下如上配置的意思:\n```\n    <bean id=\"databaseShardingAlgorithm\" class=\"com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\"></bean>\n    <bean id=\"tableShardingAlgorithm\" class=\"com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\"></bean>\n```\n表示对应的库跟表的分片算法，shardingjdbc支持多种的分片算法，具体可以参考# [sharding-jdbc—分片策略](https://www.cnblogs.com/mr-yang-localhost/p/8313360.html)里的介绍。举个例子，我们需要进行分库分表，肯定需要定义一些规则，例如select * from ips where flowtime = '20181212'查询语句,我是通过flowtime分片，且SQL语句是in或者=的查询，我就需要实现shardingjdbc提供的特定的分片算法接口，在里面通过计算出20181212具体是哪年哪月，shardingjdbc才能帮我们定位到对应的数据库\n```\n<sharding:sharding-rule data-source-names=\"dataSource_2017,dataSource_2018,dataSource_2019,dataSource_2020,dataSource_default\" default-data-source-name=\"dataSource_default\">\n......\n</sharding:sharding-rule>\n```\ndata-source-names 主要列举所有的数据源。default-data-source-name为默认的数据源，通过这两项配置告诉sharding我的数据源列表和默认的数据源\n```\n<sharding:table-rule logic-table=\"flow\" actual-data-nodes=\"dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\" database-strategy-ref=\"databaseShardingStrategy\" table-strategy-ref=\"tableShardingStrategy\" />\n<sharding:table-rule logic-table=\"ips\" actual-data-nodes=\"dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\" database-strategy-ref=\"databaseShardingStrategy\" table-strategy-ref=\"tableShardingStrategy\" />\n<sharding:table-rule logic-table=\"acca\" actual-data-nodes=\"dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\" database-strategy-ref=\"complexdatabaseShardingStrategy\" table-strategy-ref=\"complextableShardingStrategy\" />\n```\n这里我对三个表都配置了分片规则，其实是一样的，我们取其中一个来看。\n```\nactual-data-nodes=\"dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\"\n```\n主要配置实际的库表，格式为 数据库.表 。支持使用inline表达式。上面的配置shardingjdbc将为解析成dataSource_2017.flow_01 ~ dataSource_2020.flow_12。具体参考[行表达式](https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/inline-expression/)\nlogic-table 表示实际表\ndatabase-strategy-ref 表示对应的库分片算法\ntable-strategy-ref 表示对应的表分片算法\n#### 分片算法\n#####库分片算法 PreciseModuloDatabaseShardingAlgorithm\n```\npublic class PreciseModuloDatabaseShardingAlgorithm implements PreciseShardingAlgorithm<String> {\n\n    @Override\n    public String doSharding(Collection<String> collection, PreciseShardingValue<String> preciseShardingValue) {\n        //对于库的分片collection存放的是所有的库的列表，这里代表dataSource_2017~dataSource_2020\n        //配置的分片的sharding-column对应的值\n        String timeValue = preciseShardingValue.getValue();\n        //分库时配置的sharding-column\n        String time = preciseShardingValue.getColumnName();\n        //需要分库的逻辑表\n        String table = preciseShardingValue.getLogicTableName();\n        if(StringUtils.isBlank(timeValue)){\n            throw new UnsupportedOperationException(\"preciseShardingValue is null\");\n        }\n        //按年路由\n        for (String each : collection) {\n            String value = StringUtils.substring(timeValue,0,4); //获取到年份\n            if(each.endsWith(value)){\n               // //这里返回回去的就是最终需要查询的库名\n                return each;\n            }\n        }\n        throw new UnsupportedOperationException();\n    }\n```\n#####表分片算法 PreciseModuloTableShardingAlgorithm\n```\n/**\n * @author xuzhiyong\n * @createDate 2019-01-28-22:30\n * 按表\n */\npublic class PreciseModuloTableShardingAlgorithm implements PreciseShardingAlgorithm<String> {\n    @Override\n    public String doSharding(Collection<String> collection, PreciseShardingValue<String> preciseShardingValue) {\n        //对于库的分片collection存放的是所有的库的列表，这里代表flow_01~flow_12\n        //配置的分片的sharding-column对应的值\n        String timeValue = preciseShardingValue.getValue();\n        //分库时配置的sharding-column\n        String time = preciseShardingValue.getColumnName();\n        //需要分库的逻辑表\n        String table = preciseShardingValue.getLogicTableName();\n        if(StringUtils.isBlank(timeValue)){\n            throw new UnsupportedOperationException(\"preciseShardingValue is null\");\n        }\n        //按月路由\n        for (String each : collection) {\n            String value = StringUtils.substring(timeValue,4,6); //获取到月份\n            if(each.endsWith(value)){\n                //这里返回回去的就是最终需要查询的表名\n                return each;\n            }\n        }\n        return null;\n    }\n}\n```\n#####测试\n```\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\", \"classpath:applicationContext-database.xml\", \"classpath:applicationContext-sharding.xml\"})\npublic class ShardingTest {\n    @Resource(name = \"jdbcTemplate\")\n    private JdbcTemplate jdbcTemplate;\n\n    @Test\n    public void testCreateTable() {\n        jdbcTemplate.update(\"CREATE TABLE IF NOT EXISTS ips (flowtime VARCHAR(50) NOT NULL, value INT NOT NULL)\");\n  }\n}\n```\n查看控制台，已经帮我们创建了对应的表\n![](sharding-student/2.png)\n测试插入数据\n\n```\n@Test\n    public void testInsertOne(){\n        //测试一条记录多条插入\n        jdbcTemplate.update(\"INSERT IGNORE INTO flow(flowtime,value) VALUES ('20190525',1),('20190526',2),('20190527',2)\");\n    }\n```\n根据对应的规则插入到不同的表\n![](sharding-student/3.png)\n\n```\n @Test\n    public void query(){\n        List<Map<String, Object>> list = jdbcTemplate.queryForList(\"select * from flow where flowtime = '20170818'\");\n    }\n```\n![](sharding-student/4.png)\n#### 进行分库分表的思考\n待续","source":"_posts/sharding-student.md","raw":"---\ntitle: ShardingJdbc学习之按年月分库分表\ntags:\n  - shardingjdbc\ncategories: \n  - shardingjdbc\ndescription : 采用shardingjdbc实现按年分库按月分表\ndate: 2021-01-09 10:14:00\n---\nsharding-jdbc官方文档:https://shardingsphere.apache.org/document/current/cn/overview/\n**本文采用当当的shardingjdbc实现按年分库，按月分表**\n\n**最终数据库结果如下**\n\n![](sharding-student/1.png)\n例如有如下sql语句\n```\nselect * from ips where flowtime = '20181202';\n```\n我们规定flowtime是我们的分片键,通过值20181202确定年份为2018，月份为12，所以需要定位到库sharding_2018中的表ips_12查询，\n所以实际发出的查询语句是\n```\nselect * from `sharding_2018`.ips_12 where flowtime = '20181202';\n```\n<!--more-->\n#### 具体实现\n##### maven导出具体sharding需要的包\n```\n<dependency>\n            <groupId>io.shardingsphere</groupId>\n            <artifactId>sharding-jdbc-spring-namespace</artifactId>\n            <version>3.0.0.M3</version>\n</dependency>\n<dependency>\n            <groupId>io.shardingsphere</groupId>\n            <artifactId>sharding-jdbc-orchestration-spring-namespace</artifactId>\n            <version>3.0.0.M3</version>\n</dependency>\n```\n##### 配置数据库连接\n由于我们需要一年一库，所以我们取2017~2020年来建库，这步骤需要手工建立。查了资料好像shardingjdbc不支持自动建库，例如我们如果按照上面一年一库的规则，我们就需要自己手动建立对应的库。一年一库感觉还好，正常来说一个产品最多用10年已经很久了，所以手动预先建立好库没什么太大的工作量。所以我们先在数据库建立好表后，然后配置对应的数据源\n######applicationContext-database.xml\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\">\n    <bean id=\"dataSource_default\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n    <bean id=\"dataSource_2017\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n    <bean id=\"dataSource_2018\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n    <bean id=\"dataSource_2019\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n    <bean id=\"dataSource_2020\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;characterEncoding=utf-8\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"123456\"/>\n        <!-- 初始化连接大小 -->\n        <property name=\"initialSize\" value=\"0\"></property>\n        <!-- 连接池最大数量 -->\n        <property name=\"maxActive\" value=\"200\"></property>\n        <!-- 连接池最大空闲 -->\n        <property name=\"maxIdle\" value=\"20\"></property>\n        <!-- 连接池最小空闲 -->\n        <property name=\"minIdle\" value=\"1\"></property>\n        <!-- 获取连接最大等待时间 -->\n        <property name=\"maxWait\" value=\"60000\"></property>\n    </bean>\n</beans>\n```\n**这里解释下dataSource_default这个数据库用来干嘛的。由于在正常项目中并不是所有的数据都需要进行分库分表，例如用户表和用户记录表，一般用户记录表一般是千万级的，需要分库分表，但是用户表不需要。我们这里配置一个默认的数据源，对于不分库分表的数据就存放在这个默认的数据库中**\n###### applicationContext-sharding.xml\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xmlns:sharding=\"http://shardingsphere.io/schema/shardingsphere/sharding\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://shardingsphere.io/schema/shardingsphere/sharding\n                        http://shardingsphere.io/schema/shardingsphere/sharding/sharding.xsd\">\n\n    <!--规则定义:一年一库,一月一表-->\n    <!--分片算法(根据flowtime一年一库，一月一表)-->\n    <bean id=\"databaseShardingAlgorithm\" class=\"com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\"></bean>\n    <bean id=\"tableShardingAlgorithm\" class=\"com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\"></bean>\n\n\n    <bean id=\"complexModuloDatabaseShardingAlgorithm\" class=\"com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm\"></bean>\n    <bean id=\"complexModuloTableShardingAlgorithm\" class=\"com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm\"></bean>\n\n\n    <!--数据库分片-标准-按照time字段分片【坑:不能使用mysql关键词作为分片，不然会不能路由,time就是一个 所以换成了flowtime】-->\n    <sharding:standard-strategy id=\"databaseShardingStrategy\" sharding-column=\"flowtime\" precise-algorithm-ref=\"databaseShardingAlgorithm\"/>\n    <!--表分片-标准-按照time字段分片-->\n    <sharding:standard-strategy id=\"tableShardingStrategy\" sharding-column=\"flowtime\" precise-algorithm-ref=\"tableShardingAlgorithm\"/>\n\n    <!--复合分片-->\n    <sharding:complex-strategy id=\"complexdatabaseShardingStrategy\" sharding-columns=\"flowtime,dataType\" algorithm-ref=\"complexModuloDatabaseShardingAlgorithm\"/>\n    <sharding:complex-strategy id=\"complextableShardingStrategy\" sharding-columns=\"flowtime,dataType\" algorithm-ref=\"complexModuloTableShardingAlgorithm\"/>\n\n\n    <sharding:none-strategy id=\"noShardingStrategy\"/>\n\n    <sharding:data-source id=\"shardingDataSource\">\n        <sharding:sharding-rule data-source-names=\"dataSource_2017,dataSource_2018,dataSource_2019,dataSource_2020,dataSource_default\" default-data-source-name=\"dataSource_default\">\n            <sharding:table-rules>\n                <!--flow表的分片规则-->\n                <sharding:table-rule logic-table=\"flow\" actual-data-nodes=\"dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\" database-strategy-ref=\"databaseShardingStrategy\" table-strategy-ref=\"tableShardingStrategy\" />\n                <sharding:table-rule logic-table=\"ips\" actual-data-nodes=\"dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\" database-strategy-ref=\"databaseShardingStrategy\" table-strategy-ref=\"tableShardingStrategy\" />\n                <sharding:table-rule logic-table=\"acca\" actual-data-nodes=\"dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\" database-strategy-ref=\"complexdatabaseShardingStrategy\" table-strategy-ref=\"complextableShardingStrategy\" />\n                <!--\n                    不路由的数据可以不配置，因为上面指定了默认的dataSource_default\n                    <sharding:table-rule logic-table=\"websocket\" actual-data-nodes=\"dataSource_default.websocket\"/>\n                -->\n            </sharding:table-rules>\n        </sharding:sharding-rule>\n        <sharding:props>\n            <prop key=\"sql.show\">true</prop>\n        </sharding:props>\n    </sharding:data-source>\n\n    <bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"shardingDataSource\"></property>\n    </bean>\n\n    <!--普通的数据库连接，不走sharding-->\n    <bean id=\"jdbcTemplate_default\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"dataSource_default\"></property>\n    </bean>\n</beans>\n```\n解释下如上配置的意思:\n```\n    <bean id=\"databaseShardingAlgorithm\" class=\"com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm\"></bean>\n    <bean id=\"tableShardingAlgorithm\" class=\"com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm\"></bean>\n```\n表示对应的库跟表的分片算法，shardingjdbc支持多种的分片算法，具体可以参考# [sharding-jdbc—分片策略](https://www.cnblogs.com/mr-yang-localhost/p/8313360.html)里的介绍。举个例子，我们需要进行分库分表，肯定需要定义一些规则，例如select * from ips where flowtime = '20181212'查询语句,我是通过flowtime分片，且SQL语句是in或者=的查询，我就需要实现shardingjdbc提供的特定的分片算法接口，在里面通过计算出20181212具体是哪年哪月，shardingjdbc才能帮我们定位到对应的数据库\n```\n<sharding:sharding-rule data-source-names=\"dataSource_2017,dataSource_2018,dataSource_2019,dataSource_2020,dataSource_default\" default-data-source-name=\"dataSource_default\">\n......\n</sharding:sharding-rule>\n```\ndata-source-names 主要列举所有的数据源。default-data-source-name为默认的数据源，通过这两项配置告诉sharding我的数据源列表和默认的数据源\n```\n<sharding:table-rule logic-table=\"flow\" actual-data-nodes=\"dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\" database-strategy-ref=\"databaseShardingStrategy\" table-strategy-ref=\"tableShardingStrategy\" />\n<sharding:table-rule logic-table=\"ips\" actual-data-nodes=\"dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}\" database-strategy-ref=\"databaseShardingStrategy\" table-strategy-ref=\"tableShardingStrategy\" />\n<sharding:table-rule logic-table=\"acca\" actual-data-nodes=\"dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}\" database-strategy-ref=\"complexdatabaseShardingStrategy\" table-strategy-ref=\"complextableShardingStrategy\" />\n```\n这里我对三个表都配置了分片规则，其实是一样的，我们取其中一个来看。\n```\nactual-data-nodes=\"dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}\"\n```\n主要配置实际的库表，格式为 数据库.表 。支持使用inline表达式。上面的配置shardingjdbc将为解析成dataSource_2017.flow_01 ~ dataSource_2020.flow_12。具体参考[行表达式](https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/inline-expression/)\nlogic-table 表示实际表\ndatabase-strategy-ref 表示对应的库分片算法\ntable-strategy-ref 表示对应的表分片算法\n#### 分片算法\n#####库分片算法 PreciseModuloDatabaseShardingAlgorithm\n```\npublic class PreciseModuloDatabaseShardingAlgorithm implements PreciseShardingAlgorithm<String> {\n\n    @Override\n    public String doSharding(Collection<String> collection, PreciseShardingValue<String> preciseShardingValue) {\n        //对于库的分片collection存放的是所有的库的列表，这里代表dataSource_2017~dataSource_2020\n        //配置的分片的sharding-column对应的值\n        String timeValue = preciseShardingValue.getValue();\n        //分库时配置的sharding-column\n        String time = preciseShardingValue.getColumnName();\n        //需要分库的逻辑表\n        String table = preciseShardingValue.getLogicTableName();\n        if(StringUtils.isBlank(timeValue)){\n            throw new UnsupportedOperationException(\"preciseShardingValue is null\");\n        }\n        //按年路由\n        for (String each : collection) {\n            String value = StringUtils.substring(timeValue,0,4); //获取到年份\n            if(each.endsWith(value)){\n               // //这里返回回去的就是最终需要查询的库名\n                return each;\n            }\n        }\n        throw new UnsupportedOperationException();\n    }\n```\n#####表分片算法 PreciseModuloTableShardingAlgorithm\n```\n/**\n * @author xuzhiyong\n * @createDate 2019-01-28-22:30\n * 按表\n */\npublic class PreciseModuloTableShardingAlgorithm implements PreciseShardingAlgorithm<String> {\n    @Override\n    public String doSharding(Collection<String> collection, PreciseShardingValue<String> preciseShardingValue) {\n        //对于库的分片collection存放的是所有的库的列表，这里代表flow_01~flow_12\n        //配置的分片的sharding-column对应的值\n        String timeValue = preciseShardingValue.getValue();\n        //分库时配置的sharding-column\n        String time = preciseShardingValue.getColumnName();\n        //需要分库的逻辑表\n        String table = preciseShardingValue.getLogicTableName();\n        if(StringUtils.isBlank(timeValue)){\n            throw new UnsupportedOperationException(\"preciseShardingValue is null\");\n        }\n        //按月路由\n        for (String each : collection) {\n            String value = StringUtils.substring(timeValue,4,6); //获取到月份\n            if(each.endsWith(value)){\n                //这里返回回去的就是最终需要查询的表名\n                return each;\n            }\n        }\n        return null;\n    }\n}\n```\n#####测试\n```\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {\"classpath:applicationContext.xml\", \"classpath:applicationContext-database.xml\", \"classpath:applicationContext-sharding.xml\"})\npublic class ShardingTest {\n    @Resource(name = \"jdbcTemplate\")\n    private JdbcTemplate jdbcTemplate;\n\n    @Test\n    public void testCreateTable() {\n        jdbcTemplate.update(\"CREATE TABLE IF NOT EXISTS ips (flowtime VARCHAR(50) NOT NULL, value INT NOT NULL)\");\n  }\n}\n```\n查看控制台，已经帮我们创建了对应的表\n![](sharding-student/2.png)\n测试插入数据\n\n```\n@Test\n    public void testInsertOne(){\n        //测试一条记录多条插入\n        jdbcTemplate.update(\"INSERT IGNORE INTO flow(flowtime,value) VALUES ('20190525',1),('20190526',2),('20190527',2)\");\n    }\n```\n根据对应的规则插入到不同的表\n![](sharding-student/3.png)\n\n```\n @Test\n    public void query(){\n        List<Map<String, Object>> list = jdbcTemplate.queryForList(\"select * from flow where flowtime = '20170818'\");\n    }\n```\n![](sharding-student/4.png)\n#### 进行分库分表的思考\n待续","slug":"sharding-student","published":1,"updated":"2021-04-08T00:47:06.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvt003iqwv21k7k2dns","content":"<p>sharding-jdbc官方文档:<a href=\"https://shardingsphere.apache.org/document/current/cn/overview/\" target=\"_blank\" rel=\"noopener\">https://shardingsphere.apache.org/document/current/cn/overview/</a><br><strong>本文采用当当的shardingjdbc实现按年分库，按月分表</strong></p>\n<p><strong>最终数据库结果如下</strong></p>\n<p><img src=\"/2021/01/09/sharding-student/1.png\" alt><br>例如有如下sql语句</p>\n<pre><code>select * from ips where flowtime = &#39;20181202&#39;;</code></pre><p>我们规定flowtime是我们的分片键,通过值20181202确定年份为2018，月份为12，所以需要定位到库sharding_2018中的表ips_12查询，<br>所以实际发出的查询语句是</p>\n<pre><code>select * from `sharding_2018`.ips_12 where flowtime = &#39;20181202&#39;;</code></pre><a id=\"more\"></a>\n<h4 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h4><h5 id=\"maven导出具体sharding需要的包\"><a href=\"#maven导出具体sharding需要的包\" class=\"headerlink\" title=\"maven导出具体sharding需要的包\"></a>maven导出具体sharding需要的包</h5><pre><code>&lt;dependency&gt;\n            &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;\n            &lt;artifactId&gt;sharding-jdbc-spring-namespace&lt;/artifactId&gt;\n            &lt;version&gt;3.0.0.M3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n            &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;\n            &lt;artifactId&gt;sharding-jdbc-orchestration-spring-namespace&lt;/artifactId&gt;\n            &lt;version&gt;3.0.0.M3&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><h5 id=\"配置数据库连接\"><a href=\"#配置数据库连接\" class=\"headerlink\" title=\"配置数据库连接\"></a>配置数据库连接</h5><p>由于我们需要一年一库，所以我们取2017~2020年来建库，这步骤需要手工建立。查了资料好像shardingjdbc不支持自动建库，例如我们如果按照上面一年一库的规则，我们就需要自己手动建立对应的库。一年一库感觉还好，正常来说一个产品最多用10年已经很久了，所以手动预先建立好库没什么太大的工作量。所以我们先在数据库建立好表后，然后配置对应的数据源<br>######applicationContext-database.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n    &lt;bean id=&quot;dataSource_default&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;dataSource_2017&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;dataSource_2018&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;dataSource_2019&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;dataSource_2020&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre><p><strong>这里解释下dataSource_default这个数据库用来干嘛的。由于在正常项目中并不是所有的数据都需要进行分库分表，例如用户表和用户记录表，一般用户记录表一般是千万级的，需要分库分表，但是用户表不需要。我们这里配置一个默认的数据源，对于不分库分表的数据就存放在这个默认的数据库中</strong></p>\n<h6 id=\"applicationContext-sharding-xml\"><a href=\"#applicationContext-sharding-xml\" class=\"headerlink\" title=\"applicationContext-sharding.xml\"></a>applicationContext-sharding.xml</h6><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n       xmlns:sharding=&quot;http://shardingsphere.io/schema/shardingsphere/sharding&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://shardingsphere.io/schema/shardingsphere/sharding\n                        http://shardingsphere.io/schema/shardingsphere/sharding/sharding.xsd&quot;&gt;\n\n    &lt;!--规则定义:一年一库,一月一表--&gt;\n    &lt;!--分片算法(根据flowtime一年一库，一月一表)--&gt;\n    &lt;bean id=&quot;databaseShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;tableShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n\n\n    &lt;bean id=&quot;complexModuloDatabaseShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;complexModuloTableShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n\n\n    &lt;!--数据库分片-标准-按照time字段分片【坑:不能使用mysql关键词作为分片，不然会不能路由,time就是一个 所以换成了flowtime】--&gt;\n    &lt;sharding:standard-strategy id=&quot;databaseShardingStrategy&quot; sharding-column=&quot;flowtime&quot; precise-algorithm-ref=&quot;databaseShardingAlgorithm&quot;/&gt;\n    &lt;!--表分片-标准-按照time字段分片--&gt;\n    &lt;sharding:standard-strategy id=&quot;tableShardingStrategy&quot; sharding-column=&quot;flowtime&quot; precise-algorithm-ref=&quot;tableShardingAlgorithm&quot;/&gt;\n\n    &lt;!--复合分片--&gt;\n    &lt;sharding:complex-strategy id=&quot;complexdatabaseShardingStrategy&quot; sharding-columns=&quot;flowtime,dataType&quot; algorithm-ref=&quot;complexModuloDatabaseShardingAlgorithm&quot;/&gt;\n    &lt;sharding:complex-strategy id=&quot;complextableShardingStrategy&quot; sharding-columns=&quot;flowtime,dataType&quot; algorithm-ref=&quot;complexModuloTableShardingAlgorithm&quot;/&gt;\n\n\n    &lt;sharding:none-strategy id=&quot;noShardingStrategy&quot;/&gt;\n\n    &lt;sharding:data-source id=&quot;shardingDataSource&quot;&gt;\n        &lt;sharding:sharding-rule data-source-names=&quot;dataSource_2017,dataSource_2018,dataSource_2019,dataSource_2020,dataSource_default&quot; default-data-source-name=&quot;dataSource_default&quot;&gt;\n            &lt;sharding:table-rules&gt;\n                &lt;!--flow表的分片规则--&gt;\n                &lt;sharding:table-rule logic-table=&quot;flow&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}&quot; database-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot; /&gt;\n                &lt;sharding:table-rule logic-table=&quot;ips&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}&quot; database-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot; /&gt;\n                &lt;sharding:table-rule logic-table=&quot;acca&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}&quot; database-strategy-ref=&quot;complexdatabaseShardingStrategy&quot; table-strategy-ref=&quot;complextableShardingStrategy&quot; /&gt;\n                &lt;!--\n                    不路由的数据可以不配置，因为上面指定了默认的dataSource_default\n                    &lt;sharding:table-rule logic-table=&quot;websocket&quot; actual-data-nodes=&quot;dataSource_default.websocket&quot;/&gt;\n                --&gt;\n            &lt;/sharding:table-rules&gt;\n        &lt;/sharding:sharding-rule&gt;\n        &lt;sharding:props&gt;\n            &lt;prop key=&quot;sql.show&quot;&gt;true&lt;/prop&gt;\n        &lt;/sharding:props&gt;\n    &lt;/sharding:data-source&gt;\n\n    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!--普通的数据库连接，不走sharding--&gt;\n    &lt;bean id=&quot;jdbcTemplate_default&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource_default&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre><p>解释下如上配置的意思:</p>\n<pre><code>    &lt;bean id=&quot;databaseShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;tableShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm&quot;&gt;&lt;/bean&gt;</code></pre><p>表示对应的库跟表的分片算法，shardingjdbc支持多种的分片算法，具体可以参考# <a href=\"https://www.cnblogs.com/mr-yang-localhost/p/8313360.html\" target=\"_blank\" rel=\"noopener\">sharding-jdbc—分片策略</a>里的介绍。举个例子，我们需要进行分库分表，肯定需要定义一些规则，例如select * from ips where flowtime = ‘20181212’查询语句,我是通过flowtime分片，且SQL语句是in或者=的查询，我就需要实现shardingjdbc提供的特定的分片算法接口，在里面通过计算出20181212具体是哪年哪月，shardingjdbc才能帮我们定位到对应的数据库</p>\n<pre><code>&lt;sharding:sharding-rule data-source-names=&quot;dataSource_2017,dataSource_2018,dataSource_2019,dataSource_2020,dataSource_default&quot; default-data-source-name=&quot;dataSource_default&quot;&gt;\n......\n&lt;/sharding:sharding-rule&gt;</code></pre><p>data-source-names 主要列举所有的数据源。default-data-source-name为默认的数据源，通过这两项配置告诉sharding我的数据源列表和默认的数据源</p>\n<pre><code>&lt;sharding:table-rule logic-table=&quot;flow&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}&quot; database-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot; /&gt;\n&lt;sharding:table-rule logic-table=&quot;ips&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}&quot; database-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot; /&gt;\n&lt;sharding:table-rule logic-table=&quot;acca&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}&quot; database-strategy-ref=&quot;complexdatabaseShardingStrategy&quot; table-strategy-ref=&quot;complextableShardingStrategy&quot; /&gt;</code></pre><p>这里我对三个表都配置了分片规则，其实是一样的，我们取其中一个来看。</p>\n<pre><code>actual-data-nodes=&quot;dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}&quot;</code></pre><p>主要配置实际的库表，格式为 数据库.表 。支持使用inline表达式。上面的配置shardingjdbc将为解析成dataSource_2017.flow_01 ~ dataSource_2020.flow_12。具体参考<a href=\"https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/inline-expression/\" target=\"_blank\" rel=\"noopener\">行表达式</a><br>logic-table 表示实际表<br>database-strategy-ref 表示对应的库分片算法<br>table-strategy-ref 表示对应的表分片算法</p>\n<h4 id=\"分片算法\"><a href=\"#分片算法\" class=\"headerlink\" title=\"分片算法\"></a>分片算法</h4><p>#####库分片算法 PreciseModuloDatabaseShardingAlgorithm</p>\n<pre><code>public class PreciseModuloDatabaseShardingAlgorithm implements PreciseShardingAlgorithm&lt;String&gt; {\n\n    @Override\n    public String doSharding(Collection&lt;String&gt; collection, PreciseShardingValue&lt;String&gt; preciseShardingValue) {\n        //对于库的分片collection存放的是所有的库的列表，这里代表dataSource_2017~dataSource_2020\n        //配置的分片的sharding-column对应的值\n        String timeValue = preciseShardingValue.getValue();\n        //分库时配置的sharding-column\n        String time = preciseShardingValue.getColumnName();\n        //需要分库的逻辑表\n        String table = preciseShardingValue.getLogicTableName();\n        if(StringUtils.isBlank(timeValue)){\n            throw new UnsupportedOperationException(&quot;preciseShardingValue is null&quot;);\n        }\n        //按年路由\n        for (String each : collection) {\n            String value = StringUtils.substring(timeValue,0,4); //获取到年份\n            if(each.endsWith(value)){\n               // //这里返回回去的就是最终需要查询的库名\n                return each;\n            }\n        }\n        throw new UnsupportedOperationException();\n    }</code></pre><p>#####表分片算法 PreciseModuloTableShardingAlgorithm</p>\n<pre><code>/**\n * @author xuzhiyong\n * @createDate 2019-01-28-22:30\n * 按表\n */\npublic class PreciseModuloTableShardingAlgorithm implements PreciseShardingAlgorithm&lt;String&gt; {\n    @Override\n    public String doSharding(Collection&lt;String&gt; collection, PreciseShardingValue&lt;String&gt; preciseShardingValue) {\n        //对于库的分片collection存放的是所有的库的列表，这里代表flow_01~flow_12\n        //配置的分片的sharding-column对应的值\n        String timeValue = preciseShardingValue.getValue();\n        //分库时配置的sharding-column\n        String time = preciseShardingValue.getColumnName();\n        //需要分库的逻辑表\n        String table = preciseShardingValue.getLogicTableName();\n        if(StringUtils.isBlank(timeValue)){\n            throw new UnsupportedOperationException(&quot;preciseShardingValue is null&quot;);\n        }\n        //按月路由\n        for (String each : collection) {\n            String value = StringUtils.substring(timeValue,4,6); //获取到月份\n            if(each.endsWith(value)){\n                //这里返回回去的就是最终需要查询的表名\n                return each;\n            }\n        }\n        return null;\n    }\n}</code></pre><p>#####测试</p>\n<pre><code>@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {&quot;classpath:applicationContext.xml&quot;, &quot;classpath:applicationContext-database.xml&quot;, &quot;classpath:applicationContext-sharding.xml&quot;})\npublic class ShardingTest {\n    @Resource(name = &quot;jdbcTemplate&quot;)\n    private JdbcTemplate jdbcTemplate;\n\n    @Test\n    public void testCreateTable() {\n        jdbcTemplate.update(&quot;CREATE TABLE IF NOT EXISTS ips (flowtime VARCHAR(50) NOT NULL, value INT NOT NULL)&quot;);\n  }\n}</code></pre><p>查看控制台，已经帮我们创建了对应的表<br><img src=\"/2021/01/09/sharding-student/2.png\" alt><br>测试插入数据</p>\n<pre><code>@Test\n    public void testInsertOne(){\n        //测试一条记录多条插入\n        jdbcTemplate.update(&quot;INSERT IGNORE INTO flow(flowtime,value) VALUES (&#39;20190525&#39;,1),(&#39;20190526&#39;,2),(&#39;20190527&#39;,2)&quot;);\n    }</code></pre><p>根据对应的规则插入到不同的表<br><img src=\"/2021/01/09/sharding-student/3.png\" alt></p>\n<pre><code> @Test\n    public void query(){\n        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * from flow where flowtime = &#39;20170818&#39;&quot;);\n    }</code></pre><p><img src=\"/2021/01/09/sharding-student/4.png\" alt></p>\n<h4 id=\"进行分库分表的思考\"><a href=\"#进行分库分表的思考\" class=\"headerlink\" title=\"进行分库分表的思考\"></a>进行分库分表的思考</h4><p>待续</p>\n","site":{"data":{}},"excerpt":"<p>sharding-jdbc官方文档:<a href=\"https://shardingsphere.apache.org/document/current/cn/overview/\" target=\"_blank\" rel=\"noopener\">https://shardingsphere.apache.org/document/current/cn/overview/</a><br><strong>本文采用当当的shardingjdbc实现按年分库，按月分表</strong></p>\n<p><strong>最终数据库结果如下</strong></p>\n<p><img src=\"/2021/01/09/sharding-student/1.png\" alt><br>例如有如下sql语句</p>\n<pre><code>select * from ips where flowtime = &#39;20181202&#39;;</code></pre><p>我们规定flowtime是我们的分片键,通过值20181202确定年份为2018，月份为12，所以需要定位到库sharding_2018中的表ips_12查询，<br>所以实际发出的查询语句是</p>\n<pre><code>select * from `sharding_2018`.ips_12 where flowtime = &#39;20181202&#39;;</code></pre>","more":"<h4 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h4><h5 id=\"maven导出具体sharding需要的包\"><a href=\"#maven导出具体sharding需要的包\" class=\"headerlink\" title=\"maven导出具体sharding需要的包\"></a>maven导出具体sharding需要的包</h5><pre><code>&lt;dependency&gt;\n            &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;\n            &lt;artifactId&gt;sharding-jdbc-spring-namespace&lt;/artifactId&gt;\n            &lt;version&gt;3.0.0.M3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n            &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;\n            &lt;artifactId&gt;sharding-jdbc-orchestration-spring-namespace&lt;/artifactId&gt;\n            &lt;version&gt;3.0.0.M3&lt;/version&gt;\n&lt;/dependency&gt;</code></pre><h5 id=\"配置数据库连接\"><a href=\"#配置数据库连接\" class=\"headerlink\" title=\"配置数据库连接\"></a>配置数据库连接</h5><p>由于我们需要一年一库，所以我们取2017~2020年来建库，这步骤需要手工建立。查了资料好像shardingjdbc不支持自动建库，例如我们如果按照上面一年一库的规则，我们就需要自己手动建立对应的库。一年一库感觉还好，正常来说一个产品最多用10年已经很久了，所以手动预先建立好库没什么太大的工作量。所以我们先在数据库建立好表后，然后配置对应的数据源<br>######applicationContext-database.xml</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;\n    &lt;bean id=&quot;dataSource_default&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_default?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;dataSource_2017&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_2017?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;dataSource_2018&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_2018?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;dataSource_2019&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_2019?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n    &lt;bean id=&quot;dataSource_2020&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;\n        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/sharding_2020?useUnicode=true&amp;amp;characterEncoding=utf-8&quot;/&gt;\n        &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;\n        &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;\n        &lt;!-- 初始化连接大小 --&gt;\n        &lt;property name=&quot;initialSize&quot; value=&quot;0&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大数量 --&gt;\n        &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最大空闲 --&gt;\n        &lt;property name=&quot;maxIdle&quot; value=&quot;20&quot;&gt;&lt;/property&gt;\n        &lt;!-- 连接池最小空闲 --&gt;\n        &lt;property name=&quot;minIdle&quot; value=&quot;1&quot;&gt;&lt;/property&gt;\n        &lt;!-- 获取连接最大等待时间 --&gt;\n        &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre><p><strong>这里解释下dataSource_default这个数据库用来干嘛的。由于在正常项目中并不是所有的数据都需要进行分库分表，例如用户表和用户记录表，一般用户记录表一般是千万级的，需要分库分表，但是用户表不需要。我们这里配置一个默认的数据源，对于不分库分表的数据就存放在这个默认的数据库中</strong></p>\n<h6 id=\"applicationContext-sharding-xml\"><a href=\"#applicationContext-sharding-xml\" class=\"headerlink\" title=\"applicationContext-sharding.xml\"></a>applicationContext-sharding.xml</h6><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n       xmlns:sharding=&quot;http://shardingsphere.io/schema/shardingsphere/sharding&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n                        http://www.springframework.org/schema/beans/spring-beans.xsd\n                        http://www.springframework.org/schema/tx\n                        http://www.springframework.org/schema/tx/spring-tx.xsd\n                        http://www.springframework.org/schema/context\n                        http://www.springframework.org/schema/context/spring-context.xsd\n                        http://shardingsphere.io/schema/shardingsphere/sharding\n                        http://shardingsphere.io/schema/shardingsphere/sharding/sharding.xsd&quot;&gt;\n\n    &lt;!--规则定义:一年一库,一月一表--&gt;\n    &lt;!--分片算法(根据flowtime一年一库，一月一表)--&gt;\n    &lt;bean id=&quot;databaseShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;tableShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n\n\n    &lt;bean id=&quot;complexModuloDatabaseShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.ComplexModuloDatabaseShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;complexModuloTableShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.ComplexModuloTableShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n\n\n    &lt;!--数据库分片-标准-按照time字段分片【坑:不能使用mysql关键词作为分片，不然会不能路由,time就是一个 所以换成了flowtime】--&gt;\n    &lt;sharding:standard-strategy id=&quot;databaseShardingStrategy&quot; sharding-column=&quot;flowtime&quot; precise-algorithm-ref=&quot;databaseShardingAlgorithm&quot;/&gt;\n    &lt;!--表分片-标准-按照time字段分片--&gt;\n    &lt;sharding:standard-strategy id=&quot;tableShardingStrategy&quot; sharding-column=&quot;flowtime&quot; precise-algorithm-ref=&quot;tableShardingAlgorithm&quot;/&gt;\n\n    &lt;!--复合分片--&gt;\n    &lt;sharding:complex-strategy id=&quot;complexdatabaseShardingStrategy&quot; sharding-columns=&quot;flowtime,dataType&quot; algorithm-ref=&quot;complexModuloDatabaseShardingAlgorithm&quot;/&gt;\n    &lt;sharding:complex-strategy id=&quot;complextableShardingStrategy&quot; sharding-columns=&quot;flowtime,dataType&quot; algorithm-ref=&quot;complexModuloTableShardingAlgorithm&quot;/&gt;\n\n\n    &lt;sharding:none-strategy id=&quot;noShardingStrategy&quot;/&gt;\n\n    &lt;sharding:data-source id=&quot;shardingDataSource&quot;&gt;\n        &lt;sharding:sharding-rule data-source-names=&quot;dataSource_2017,dataSource_2018,dataSource_2019,dataSource_2020,dataSource_default&quot; default-data-source-name=&quot;dataSource_default&quot;&gt;\n            &lt;sharding:table-rules&gt;\n                &lt;!--flow表的分片规则--&gt;\n                &lt;sharding:table-rule logic-table=&quot;flow&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}&quot; database-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot; /&gt;\n                &lt;sharding:table-rule logic-table=&quot;ips&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}&quot; database-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot; /&gt;\n                &lt;sharding:table-rule logic-table=&quot;acca&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}&quot; database-strategy-ref=&quot;complexdatabaseShardingStrategy&quot; table-strategy-ref=&quot;complextableShardingStrategy&quot; /&gt;\n                &lt;!--\n                    不路由的数据可以不配置，因为上面指定了默认的dataSource_default\n                    &lt;sharding:table-rule logic-table=&quot;websocket&quot; actual-data-nodes=&quot;dataSource_default.websocket&quot;/&gt;\n                --&gt;\n            &lt;/sharding:table-rules&gt;\n        &lt;/sharding:sharding-rule&gt;\n        &lt;sharding:props&gt;\n            &lt;prop key=&quot;sql.show&quot;&gt;true&lt;/prop&gt;\n        &lt;/sharding:props&gt;\n    &lt;/sharding:data-source&gt;\n\n    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;shardingDataSource&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n    &lt;!--普通的数据库连接，不走sharding--&gt;\n    &lt;bean id=&quot;jdbcTemplate_default&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;\n        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource_default&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre><p>解释下如上配置的意思:</p>\n<pre><code>    &lt;bean id=&quot;databaseShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.PreciseModuloDatabaseShardingAlgorithm&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;tableShardingAlgorithm&quot; class=&quot;com.shardingAlgorithm.PreciseModuloTableShardingAlgorithm&quot;&gt;&lt;/bean&gt;</code></pre><p>表示对应的库跟表的分片算法，shardingjdbc支持多种的分片算法，具体可以参考# <a href=\"https://www.cnblogs.com/mr-yang-localhost/p/8313360.html\" target=\"_blank\" rel=\"noopener\">sharding-jdbc—分片策略</a>里的介绍。举个例子，我们需要进行分库分表，肯定需要定义一些规则，例如select * from ips where flowtime = ‘20181212’查询语句,我是通过flowtime分片，且SQL语句是in或者=的查询，我就需要实现shardingjdbc提供的特定的分片算法接口，在里面通过计算出20181212具体是哪年哪月，shardingjdbc才能帮我们定位到对应的数据库</p>\n<pre><code>&lt;sharding:sharding-rule data-source-names=&quot;dataSource_2017,dataSource_2018,dataSource_2019,dataSource_2020,dataSource_default&quot; default-data-source-name=&quot;dataSource_default&quot;&gt;\n......\n&lt;/sharding:sharding-rule&gt;</code></pre><p>data-source-names 主要列举所有的数据源。default-data-source-name为默认的数据源，通过这两项配置告诉sharding我的数据源列表和默认的数据源</p>\n<pre><code>&lt;sharding:table-rule logic-table=&quot;flow&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}&quot; database-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot; /&gt;\n&lt;sharding:table-rule logic-table=&quot;ips&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.ips_0${1..9},dataSource_${2017..2020}.ips_1${0..2}&quot; database-strategy-ref=&quot;databaseShardingStrategy&quot; table-strategy-ref=&quot;tableShardingStrategy&quot; /&gt;\n&lt;sharding:table-rule logic-table=&quot;acca&quot; actual-data-nodes=&quot;dataSource_${2017..2020}.acca_0${1..9},dataSource_${2017..2020}.acca_1${0..2}&quot; database-strategy-ref=&quot;complexdatabaseShardingStrategy&quot; table-strategy-ref=&quot;complextableShardingStrategy&quot; /&gt;</code></pre><p>这里我对三个表都配置了分片规则，其实是一样的，我们取其中一个来看。</p>\n<pre><code>actual-data-nodes=&quot;dataSource_${2017..2020}.flow_0${1..9},dataSource_${2017..2020}.flow_1${0..2}&quot;</code></pre><p>主要配置实际的库表，格式为 数据库.表 。支持使用inline表达式。上面的配置shardingjdbc将为解析成dataSource_2017.flow_01 ~ dataSource_2020.flow_12。具体参考<a href=\"https://shardingsphere.apache.org/document/current/cn/features/sharding/other-features/inline-expression/\" target=\"_blank\" rel=\"noopener\">行表达式</a><br>logic-table 表示实际表<br>database-strategy-ref 表示对应的库分片算法<br>table-strategy-ref 表示对应的表分片算法</p>\n<h4 id=\"分片算法\"><a href=\"#分片算法\" class=\"headerlink\" title=\"分片算法\"></a>分片算法</h4><p>#####库分片算法 PreciseModuloDatabaseShardingAlgorithm</p>\n<pre><code>public class PreciseModuloDatabaseShardingAlgorithm implements PreciseShardingAlgorithm&lt;String&gt; {\n\n    @Override\n    public String doSharding(Collection&lt;String&gt; collection, PreciseShardingValue&lt;String&gt; preciseShardingValue) {\n        //对于库的分片collection存放的是所有的库的列表，这里代表dataSource_2017~dataSource_2020\n        //配置的分片的sharding-column对应的值\n        String timeValue = preciseShardingValue.getValue();\n        //分库时配置的sharding-column\n        String time = preciseShardingValue.getColumnName();\n        //需要分库的逻辑表\n        String table = preciseShardingValue.getLogicTableName();\n        if(StringUtils.isBlank(timeValue)){\n            throw new UnsupportedOperationException(&quot;preciseShardingValue is null&quot;);\n        }\n        //按年路由\n        for (String each : collection) {\n            String value = StringUtils.substring(timeValue,0,4); //获取到年份\n            if(each.endsWith(value)){\n               // //这里返回回去的就是最终需要查询的库名\n                return each;\n            }\n        }\n        throw new UnsupportedOperationException();\n    }</code></pre><p>#####表分片算法 PreciseModuloTableShardingAlgorithm</p>\n<pre><code>/**\n * @author xuzhiyong\n * @createDate 2019-01-28-22:30\n * 按表\n */\npublic class PreciseModuloTableShardingAlgorithm implements PreciseShardingAlgorithm&lt;String&gt; {\n    @Override\n    public String doSharding(Collection&lt;String&gt; collection, PreciseShardingValue&lt;String&gt; preciseShardingValue) {\n        //对于库的分片collection存放的是所有的库的列表，这里代表flow_01~flow_12\n        //配置的分片的sharding-column对应的值\n        String timeValue = preciseShardingValue.getValue();\n        //分库时配置的sharding-column\n        String time = preciseShardingValue.getColumnName();\n        //需要分库的逻辑表\n        String table = preciseShardingValue.getLogicTableName();\n        if(StringUtils.isBlank(timeValue)){\n            throw new UnsupportedOperationException(&quot;preciseShardingValue is null&quot;);\n        }\n        //按月路由\n        for (String each : collection) {\n            String value = StringUtils.substring(timeValue,4,6); //获取到月份\n            if(each.endsWith(value)){\n                //这里返回回去的就是最终需要查询的表名\n                return each;\n            }\n        }\n        return null;\n    }\n}</code></pre><p>#####测试</p>\n<pre><code>@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(locations = {&quot;classpath:applicationContext.xml&quot;, &quot;classpath:applicationContext-database.xml&quot;, &quot;classpath:applicationContext-sharding.xml&quot;})\npublic class ShardingTest {\n    @Resource(name = &quot;jdbcTemplate&quot;)\n    private JdbcTemplate jdbcTemplate;\n\n    @Test\n    public void testCreateTable() {\n        jdbcTemplate.update(&quot;CREATE TABLE IF NOT EXISTS ips (flowtime VARCHAR(50) NOT NULL, value INT NOT NULL)&quot;);\n  }\n}</code></pre><p>查看控制台，已经帮我们创建了对应的表<br><img src=\"/2021/01/09/sharding-student/2.png\" alt><br>测试插入数据</p>\n<pre><code>@Test\n    public void testInsertOne(){\n        //测试一条记录多条插入\n        jdbcTemplate.update(&quot;INSERT IGNORE INTO flow(flowtime,value) VALUES (&#39;20190525&#39;,1),(&#39;20190526&#39;,2),(&#39;20190527&#39;,2)&quot;);\n    }</code></pre><p>根据对应的规则插入到不同的表<br><img src=\"/2021/01/09/sharding-student/3.png\" alt></p>\n<pre><code> @Test\n    public void query(){\n        List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList(&quot;select * from flow where flowtime = &#39;20170818&#39;&quot;);\n    }</code></pre><p><img src=\"/2021/01/09/sharding-student/4.png\" alt></p>\n<h4 id=\"进行分库分表的思考\"><a href=\"#进行分库分表的思考\" class=\"headerlink\" title=\"进行分库分表的思考\"></a>进行分库分表的思考</h4><p>待续</p>"},{"title":"Spring扩展点详解","description":"Spring扩展点详解","date":"2020-09-13T03:24:54.000Z","_content":"\n## 正文\n\n### BeanDefinitionRegistryPostProcessor\n\n![](spring-extend/1.png)\n\n这个扩展点主要发生在获取BeanDefinition后，可以在这里动态注册自己的beanDefinition，或者对已注册的BeanDefinition做一些改变，提供了两个方法\n\n- postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry)，该方法用来注册更多的bean到spring容器中。\n- postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)，主要用来对已注册BeanDefinition做一些改变。\n<!--more-->\n具体源码\n\n```java\n//refresh -> #invokeBeanFactoryPostProcessors() -> PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, //getBeanFactoryPostProcessors())\nboolean reiterate = true;\nwhile (reiterate) {\n\treiterate = false;\n\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\tfor (String ppName : postProcessorNames) {\n\t\tif (!processedBeans.contains(ppName)) {\n\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\tprocessedBeans.add(ppName);\n\t\t\treiterate = true;\n\t\t}\n\t}\n\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\tregistryProcessors.addAll(currentRegistryProcessors);\n    //执行postProcessBeanDefinitionRegistry方法\n\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n\tcurrentRegistryProcessors.clear();\n}\n//执行postProcessBeanFactory方法\ninvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\ninvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n```\n\n### BeanFactoryPostProcessor\n\n这个接口是beanFactory的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。是上面说的BeanDefinitionRegistryPostProcessor的父类，提供了postProcessBeanFactory方法。用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。\n\n### InstantiationAwareBeanPostProcessor\n\nInstantiationAwareBeanPostProcessor继承了BeanPostProcess接口。原本BeanPostProcess只有提供了`初始化之前`和`初始化之后`的扩展，它再次基础上增加了`实例化bean之前`，`实例化bean之后`，`属性注入时阶段`这几个过程。\n\n![InstantiationAwareBeanPostProcessor继承图](spring-extend/2.png)\n\n- postProcessBeforeInitialization 初始化之前\n- postProcessAfterInitialization 初始化之后\n- postProcessBeforeInstantiation 实例化之前\n- postProcessAfterInstantiation 实例化之后\n- postProcessProperties 属性赋值时，用来属性赋值时做一些操作，**@Autowired,@Resource等注解原理基于此方法实现**\n\n**感觉这个接口是对Spring生命周期扩展最全的一个接口了。例如依赖注入@Autowired对应的后处理器AutowiredAnnotationBeanPostProcessor就是基于这个实现。**\n\n### SmartInstantiationAwareBeanPostProcessor\n\nSmartInstantiationAwareBeanPostProcessor继承了上面说的`InstantiationAwareBeanPostProcessor`类，并在此基础上新增了三个扩展点。\n\n- predictBeanType，该触发点发生在`postProcessBeforeInstantiation`之前，用于预测Bean的类型。你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。\n- determineCandidateConstructors，该触发点发生在`postProcessBeforeInstantiation`之后。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。\n- getEarlyBeanReference，该触发点发生在`postProcessAfterInstantiation`之后。主要用于**循环依赖**。\n\n### MergedBeanDefinitionPostProcessor\n\n触发时机在实例化之后，属性赋值之前。AutowiredAnnotationBeanPostProcessor使用到了这个接口。\n\nAutowiredAnnotationBeanPostProcessor类把正在被spring实例化的bean进行@Autowired和@Value扫描，扫描到类里面属性和方法上面如果有注解，就会把对应的方法或者属性封装起来，最终封装成InjectionMetadata对象。\n\n![](spring-extend/4.png)\n\n### BeanFactoryAware\n\n**发生在bean的实例化之后，注入属性之前，也就是Setter之前。**\n\n使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。\n\n**作用于单个Bean，例如某个Bean实现了这个接口，就只有这个接口会触发这个接口的方法。其他接口不会触发**\n\n### BeanNameAware\n\n触发点在bean的初始化之前，也就是`postProcessBeforeInitialization`之前。\n\n用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。\n\n### InitializingBean\n\n触发时机在`postProcessAfterInitialization`之前，也就是初始化完成之后。\n\n### DisposableBean\n\n其触发时机为当此对象销毁时。比如说运行applicationContext.registerShutdownHook时，就会触发这个方法。\n\n### NamespaceHandler\n\n翻译过来叫命名空间处理器。他的主要作用是**配合BeanDefinitionParser，通过解析自定义标签来自动注入一些Bean，这些Bean包括了一些关键的后处理器。例如component-scan标签**。\n\n接下去我们来看\\<context:component-scan\\>是如何实现自动注入一些关键后处理器的。\n\n**spring.handlers设置\\<context:这种开头的配置使用的NamespaceHandler**\n\n![](spring-extend/3.png)\n\n当解析application.xml文件时，如果遇到component-scan就会进来ContextNamespaceHandler执行init方法。\n\n```java\npublic class ContextNamespaceHandler extends NamespaceHandlerSupport {\n\t@Override\n\tpublic void init() {\n\t\tregisterBeanDefinitionParser(\"property-placeholder\", new PropertyPlaceholderBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"property-override\", new PropertyOverrideBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"annotation-config\", new AnnotationConfigBeanDefinitionParser());\n         //注册component-scan包含的后处理器\n\t\tregisterBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"load-time-weaver\", new LoadTimeWeaverBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"mbean-export\", new MBeanExportBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"mbean-server\", new MBeanServerBeanDefinitionParser());\n\t}\n}\n```\n\n**利用ComponentScanBeanDefinitionParser完成指定包下所有类的扫描，BeanDefinition创建的过程。**\n\n继续跟代码，在registerComponents方法中。通过下面代码，自动为我们注入了一些关键的后处理器。如下\n\n```java\nSet<BeanDefinitionHolder> processorDefinitions =\n\t\t\t\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source)；\n```\n\n- ConfigurationClassPostProcessor，帮我们处理了@Configuration，@ComponentScan，@Bean等注解的处理，帮我们将注解类注册到spring容器中。\n- AutowiredAnnotationBeanPostProcessor，@Autowried自动装配所需的后处理器\n- CommonAnnotationBeanPostProcessor，解析@Resource、@WebServiceRef、@EJB三个注解\n- EventListenerMethodProcessor\n- DefaultEventListenerFactory\n\n### ApplicationContextAwareProcessor\n\nApplicationContextAwareProcessor是Spring启动后自动加载进去的后处理器。该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前。例如我们常用的ApplicationContextAware（我们经常实现ApplicationContextAware类来编写SpringUtils工具类，用来getBean）。\n\n```java\n//ApplicationContextAwareProcessor类中postProcessBeforeInitialization方法中的执行逻辑\nprivate void invokeAwareInterfaces(Object bean) {\n\tif (bean instanceof EnvironmentAware) {\n\t\t((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\n\t}\n\tif (bean instanceof EmbeddedValueResolverAware) {\n\t\t((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);\n\t}\n\tif (bean instanceof ResourceLoaderAware) {\n\t\t((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);\n\t}\n\tif (bean instanceof ApplicationEventPublisherAware) {\n\t\t((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);\n\t}\n\tif (bean instanceof MessageSourceAware) {\n\t\t((MessageSourceAware) bean).setMessageSource(this.applicationContext);\n\t}\n    //判断Bean中是否有实现ApplicationContextAware接口的类，如果有就将applicationContext赋值进去。\n\tif (bean instanceof ApplicationContextAware) {\n\t\t((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);\n\t}\n}\n```\n\n```java\n@Component\npublic class AppUtil implements ApplicationContextAware {\n    private static ApplicationContext applicationContext;\n    @Override\n    public void setApplicationContext(ApplicationContext arg0) throws BeansException {\n        //将ApplicationContext保存在静态变量中，后面就可以直接获取到spring上下文了。\n        applicationContext = arg0;\n    }\n\n    public static Object getBean(String id) {\n        Object object = null;\n        object = applicationContext.getBean(id);\n        return object;\n    }\n}\n```\n\n- EnvironmentAware，用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。\n- EmbeddedValueResolverAware，用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取。\n- ResourceLoaderAware，用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。\n- ApplicationEventPublisherAware，用于获取ApplicationEventPublisher的一个扩展类。\n- MessageSourceAware，用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。\n- ApplicationContextAware，用来获取ApplicationContext上下文的一个扩展类。\n\n","source":"_posts/spring-extend.md","raw":"---\ntitle: Spring扩展点详解\ntags:\n  - spring\ncategories: \n  - spring\ndescription : Spring扩展点详解\ndate: 2020-09-13 11:24:54\n---\n\n## 正文\n\n### BeanDefinitionRegistryPostProcessor\n\n![](spring-extend/1.png)\n\n这个扩展点主要发生在获取BeanDefinition后，可以在这里动态注册自己的beanDefinition，或者对已注册的BeanDefinition做一些改变，提供了两个方法\n\n- postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry)，该方法用来注册更多的bean到spring容器中。\n- postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)，主要用来对已注册BeanDefinition做一些改变。\n<!--more-->\n具体源码\n\n```java\n//refresh -> #invokeBeanFactoryPostProcessors() -> PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, //getBeanFactoryPostProcessors())\nboolean reiterate = true;\nwhile (reiterate) {\n\treiterate = false;\n\tpostProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n\tfor (String ppName : postProcessorNames) {\n\t\tif (!processedBeans.contains(ppName)) {\n\t\t\tcurrentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n\t\t\tprocessedBeans.add(ppName);\n\t\t\treiterate = true;\n\t\t}\n\t}\n\tsortPostProcessors(currentRegistryProcessors, beanFactory);\n\tregistryProcessors.addAll(currentRegistryProcessors);\n    //执行postProcessBeanDefinitionRegistry方法\n\tinvokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n\tcurrentRegistryProcessors.clear();\n}\n//执行postProcessBeanFactory方法\ninvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\ninvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);\n```\n\n### BeanFactoryPostProcessor\n\n这个接口是beanFactory的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。是上面说的BeanDefinitionRegistryPostProcessor的父类，提供了postProcessBeanFactory方法。用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。\n\n### InstantiationAwareBeanPostProcessor\n\nInstantiationAwareBeanPostProcessor继承了BeanPostProcess接口。原本BeanPostProcess只有提供了`初始化之前`和`初始化之后`的扩展，它再次基础上增加了`实例化bean之前`，`实例化bean之后`，`属性注入时阶段`这几个过程。\n\n![InstantiationAwareBeanPostProcessor继承图](spring-extend/2.png)\n\n- postProcessBeforeInitialization 初始化之前\n- postProcessAfterInitialization 初始化之后\n- postProcessBeforeInstantiation 实例化之前\n- postProcessAfterInstantiation 实例化之后\n- postProcessProperties 属性赋值时，用来属性赋值时做一些操作，**@Autowired,@Resource等注解原理基于此方法实现**\n\n**感觉这个接口是对Spring生命周期扩展最全的一个接口了。例如依赖注入@Autowired对应的后处理器AutowiredAnnotationBeanPostProcessor就是基于这个实现。**\n\n### SmartInstantiationAwareBeanPostProcessor\n\nSmartInstantiationAwareBeanPostProcessor继承了上面说的`InstantiationAwareBeanPostProcessor`类，并在此基础上新增了三个扩展点。\n\n- predictBeanType，该触发点发生在`postProcessBeforeInstantiation`之前，用于预测Bean的类型。你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。\n- determineCandidateConstructors，该触发点发生在`postProcessBeforeInstantiation`之后。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。\n- getEarlyBeanReference，该触发点发生在`postProcessAfterInstantiation`之后。主要用于**循环依赖**。\n\n### MergedBeanDefinitionPostProcessor\n\n触发时机在实例化之后，属性赋值之前。AutowiredAnnotationBeanPostProcessor使用到了这个接口。\n\nAutowiredAnnotationBeanPostProcessor类把正在被spring实例化的bean进行@Autowired和@Value扫描，扫描到类里面属性和方法上面如果有注解，就会把对应的方法或者属性封装起来，最终封装成InjectionMetadata对象。\n\n![](spring-extend/4.png)\n\n### BeanFactoryAware\n\n**发生在bean的实例化之后，注入属性之前，也就是Setter之前。**\n\n使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。\n\n**作用于单个Bean，例如某个Bean实现了这个接口，就只有这个接口会触发这个接口的方法。其他接口不会触发**\n\n### BeanNameAware\n\n触发点在bean的初始化之前，也就是`postProcessBeforeInitialization`之前。\n\n用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。\n\n### InitializingBean\n\n触发时机在`postProcessAfterInitialization`之前，也就是初始化完成之后。\n\n### DisposableBean\n\n其触发时机为当此对象销毁时。比如说运行applicationContext.registerShutdownHook时，就会触发这个方法。\n\n### NamespaceHandler\n\n翻译过来叫命名空间处理器。他的主要作用是**配合BeanDefinitionParser，通过解析自定义标签来自动注入一些Bean，这些Bean包括了一些关键的后处理器。例如component-scan标签**。\n\n接下去我们来看\\<context:component-scan\\>是如何实现自动注入一些关键后处理器的。\n\n**spring.handlers设置\\<context:这种开头的配置使用的NamespaceHandler**\n\n![](spring-extend/3.png)\n\n当解析application.xml文件时，如果遇到component-scan就会进来ContextNamespaceHandler执行init方法。\n\n```java\npublic class ContextNamespaceHandler extends NamespaceHandlerSupport {\n\t@Override\n\tpublic void init() {\n\t\tregisterBeanDefinitionParser(\"property-placeholder\", new PropertyPlaceholderBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"property-override\", new PropertyOverrideBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"annotation-config\", new AnnotationConfigBeanDefinitionParser());\n         //注册component-scan包含的后处理器\n\t\tregisterBeanDefinitionParser(\"component-scan\", new ComponentScanBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"load-time-weaver\", new LoadTimeWeaverBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"mbean-export\", new MBeanExportBeanDefinitionParser());\n\t\tregisterBeanDefinitionParser(\"mbean-server\", new MBeanServerBeanDefinitionParser());\n\t}\n}\n```\n\n**利用ComponentScanBeanDefinitionParser完成指定包下所有类的扫描，BeanDefinition创建的过程。**\n\n继续跟代码，在registerComponents方法中。通过下面代码，自动为我们注入了一些关键的后处理器。如下\n\n```java\nSet<BeanDefinitionHolder> processorDefinitions =\n\t\t\t\t\tAnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source)；\n```\n\n- ConfigurationClassPostProcessor，帮我们处理了@Configuration，@ComponentScan，@Bean等注解的处理，帮我们将注解类注册到spring容器中。\n- AutowiredAnnotationBeanPostProcessor，@Autowried自动装配所需的后处理器\n- CommonAnnotationBeanPostProcessor，解析@Resource、@WebServiceRef、@EJB三个注解\n- EventListenerMethodProcessor\n- DefaultEventListenerFactory\n\n### ApplicationContextAwareProcessor\n\nApplicationContextAwareProcessor是Spring启动后自动加载进去的后处理器。该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前。例如我们常用的ApplicationContextAware（我们经常实现ApplicationContextAware类来编写SpringUtils工具类，用来getBean）。\n\n```java\n//ApplicationContextAwareProcessor类中postProcessBeforeInitialization方法中的执行逻辑\nprivate void invokeAwareInterfaces(Object bean) {\n\tif (bean instanceof EnvironmentAware) {\n\t\t((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\n\t}\n\tif (bean instanceof EmbeddedValueResolverAware) {\n\t\t((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);\n\t}\n\tif (bean instanceof ResourceLoaderAware) {\n\t\t((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);\n\t}\n\tif (bean instanceof ApplicationEventPublisherAware) {\n\t\t((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);\n\t}\n\tif (bean instanceof MessageSourceAware) {\n\t\t((MessageSourceAware) bean).setMessageSource(this.applicationContext);\n\t}\n    //判断Bean中是否有实现ApplicationContextAware接口的类，如果有就将applicationContext赋值进去。\n\tif (bean instanceof ApplicationContextAware) {\n\t\t((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);\n\t}\n}\n```\n\n```java\n@Component\npublic class AppUtil implements ApplicationContextAware {\n    private static ApplicationContext applicationContext;\n    @Override\n    public void setApplicationContext(ApplicationContext arg0) throws BeansException {\n        //将ApplicationContext保存在静态变量中，后面就可以直接获取到spring上下文了。\n        applicationContext = arg0;\n    }\n\n    public static Object getBean(String id) {\n        Object object = null;\n        object = applicationContext.getBean(id);\n        return object;\n    }\n}\n```\n\n- EnvironmentAware，用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。\n- EmbeddedValueResolverAware，用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取。\n- ResourceLoaderAware，用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。\n- ApplicationEventPublisherAware，用于获取ApplicationEventPublisher的一个扩展类。\n- MessageSourceAware，用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。\n- ApplicationContextAware，用来获取ApplicationContext上下文的一个扩展类。\n\n","slug":"spring-extend","published":1,"updated":"2021-04-08T00:47:06.997Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvu003mqwv26ydf4751","content":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"BeanDefinitionRegistryPostProcessor\"><a href=\"#BeanDefinitionRegistryPostProcessor\" class=\"headerlink\" title=\"BeanDefinitionRegistryPostProcessor\"></a>BeanDefinitionRegistryPostProcessor</h3><p><img src=\"/2020/09/13/spring-extend/1.png\" alt></p>\n<p>这个扩展点主要发生在获取BeanDefinition后，可以在这里动态注册自己的beanDefinition，或者对已注册的BeanDefinition做一些改变，提供了两个方法</p>\n<ul>\n<li>postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry)，该方法用来注册更多的bean到spring容器中。</li>\n<li>postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)，主要用来对已注册BeanDefinition做一些改变。<a id=\"more\"></a>\n具体源码</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//refresh -> #invokeBeanFactoryPostProcessors() -> PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, //getBeanFactoryPostProcessors())</span>\n<span class=\"token keyword\">boolean</span> reiterate <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>reiterate<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    reiterate <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    postProcessorNames <span class=\"token operator\">=</span> beanFactory<span class=\"token punctuation\">.</span><span class=\"token function\">getBeanNamesForType</span><span class=\"token punctuation\">(</span>BeanDefinitionRegistryPostProcessor<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>String ppName <span class=\"token operator\">:</span> postProcessorNames<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>processedBeans<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span>ppName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            currentRegistryProcessors<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>beanFactory<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>ppName<span class=\"token punctuation\">,</span> BeanDefinitionRegistryPostProcessor<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            processedBeans<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>ppName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            reiterate <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">sortPostProcessors</span><span class=\"token punctuation\">(</span>currentRegistryProcessors<span class=\"token punctuation\">,</span> beanFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    registryProcessors<span class=\"token punctuation\">.</span><span class=\"token function\">addAll</span><span class=\"token punctuation\">(</span>currentRegistryProcessors<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//执行postProcessBeanDefinitionRegistry方法</span>\n    <span class=\"token function\">invokeBeanDefinitionRegistryPostProcessors</span><span class=\"token punctuation\">(</span>currentRegistryProcessors<span class=\"token punctuation\">,</span> registry<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    currentRegistryProcessors<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//执行postProcessBeanFactory方法</span>\n<span class=\"token function\">invokeBeanFactoryPostProcessors</span><span class=\"token punctuation\">(</span>registryProcessors<span class=\"token punctuation\">,</span> beanFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">invokeBeanFactoryPostProcessors</span><span class=\"token punctuation\">(</span>regularPostProcessors<span class=\"token punctuation\">,</span> beanFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"BeanFactoryPostProcessor\"><a href=\"#BeanFactoryPostProcessor\" class=\"headerlink\" title=\"BeanFactoryPostProcessor\"></a>BeanFactoryPostProcessor</h3><p>这个接口是beanFactory的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。是上面说的BeanDefinitionRegistryPostProcessor的父类，提供了postProcessBeanFactory方法。用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。</p>\n<h3 id=\"InstantiationAwareBeanPostProcessor\"><a href=\"#InstantiationAwareBeanPostProcessor\" class=\"headerlink\" title=\"InstantiationAwareBeanPostProcessor\"></a>InstantiationAwareBeanPostProcessor</h3><p>InstantiationAwareBeanPostProcessor继承了BeanPostProcess接口。原本BeanPostProcess只有提供了<code>初始化之前</code>和<code>初始化之后</code>的扩展，它再次基础上增加了<code>实例化bean之前</code>，<code>实例化bean之后</code>，<code>属性注入时阶段</code>这几个过程。</p>\n<p><img src=\"/2020/09/13/spring-extend/2.png\" alt=\"InstantiationAwareBeanPostProcessor继承图\"></p>\n<ul>\n<li>postProcessBeforeInitialization 初始化之前</li>\n<li>postProcessAfterInitialization 初始化之后</li>\n<li>postProcessBeforeInstantiation 实例化之前</li>\n<li>postProcessAfterInstantiation 实例化之后</li>\n<li>postProcessProperties 属性赋值时，用来属性赋值时做一些操作，<strong>@Autowired,@Resource等注解原理基于此方法实现</strong></li>\n</ul>\n<p><strong>感觉这个接口是对Spring生命周期扩展最全的一个接口了。例如依赖注入@Autowired对应的后处理器AutowiredAnnotationBeanPostProcessor就是基于这个实现。</strong></p>\n<h3 id=\"SmartInstantiationAwareBeanPostProcessor\"><a href=\"#SmartInstantiationAwareBeanPostProcessor\" class=\"headerlink\" title=\"SmartInstantiationAwareBeanPostProcessor\"></a>SmartInstantiationAwareBeanPostProcessor</h3><p>SmartInstantiationAwareBeanPostProcessor继承了上面说的<code>InstantiationAwareBeanPostProcessor</code>类，并在此基础上新增了三个扩展点。</p>\n<ul>\n<li>predictBeanType，该触发点发生在<code>postProcessBeforeInstantiation</code>之前，用于预测Bean的类型。你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</li>\n<li>determineCandidateConstructors，该触发点发生在<code>postProcessBeforeInstantiation</code>之后。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</li>\n<li>getEarlyBeanReference，该触发点发生在<code>postProcessAfterInstantiation</code>之后。主要用于<strong>循环依赖</strong>。</li>\n</ul>\n<h3 id=\"MergedBeanDefinitionPostProcessor\"><a href=\"#MergedBeanDefinitionPostProcessor\" class=\"headerlink\" title=\"MergedBeanDefinitionPostProcessor\"></a>MergedBeanDefinitionPostProcessor</h3><p>触发时机在实例化之后，属性赋值之前。AutowiredAnnotationBeanPostProcessor使用到了这个接口。</p>\n<p>AutowiredAnnotationBeanPostProcessor类把正在被spring实例化的bean进行@Autowired和@Value扫描，扫描到类里面属性和方法上面如果有注解，就会把对应的方法或者属性封装起来，最终封装成InjectionMetadata对象。</p>\n<p><img src=\"/2020/09/13/spring-extend/4.png\" alt></p>\n<h3 id=\"BeanFactoryAware\"><a href=\"#BeanFactoryAware\" class=\"headerlink\" title=\"BeanFactoryAware\"></a>BeanFactoryAware</h3><p><strong>发生在bean的实例化之后，注入属性之前，也就是Setter之前。</strong></p>\n<p>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。</p>\n<p><strong>作用于单个Bean，例如某个Bean实现了这个接口，就只有这个接口会触发这个接口的方法。其他接口不会触发</strong></p>\n<h3 id=\"BeanNameAware\"><a href=\"#BeanNameAware\" class=\"headerlink\" title=\"BeanNameAware\"></a>BeanNameAware</h3><p>触发点在bean的初始化之前，也就是<code>postProcessBeforeInitialization</code>之前。</p>\n<p>用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p>\n<h3 id=\"InitializingBean\"><a href=\"#InitializingBean\" class=\"headerlink\" title=\"InitializingBean\"></a>InitializingBean</h3><p>触发时机在<code>postProcessAfterInitialization</code>之前，也就是初始化完成之后。</p>\n<h3 id=\"DisposableBean\"><a href=\"#DisposableBean\" class=\"headerlink\" title=\"DisposableBean\"></a>DisposableBean</h3><p>其触发时机为当此对象销毁时。比如说运行applicationContext.registerShutdownHook时，就会触发这个方法。</p>\n<h3 id=\"NamespaceHandler\"><a href=\"#NamespaceHandler\" class=\"headerlink\" title=\"NamespaceHandler\"></a>NamespaceHandler</h3><p>翻译过来叫命名空间处理器。他的主要作用是<strong>配合BeanDefinitionParser，通过解析自定义标签来自动注入一些Bean，这些Bean包括了一些关键的后处理器。例如component-scan标签</strong>。</p>\n<p>接下去我们来看&lt;context:component-scan&gt;是如何实现自动注入一些关键后处理器的。</p>\n<p><strong>spring.handlers设置&lt;context:这种开头的配置使用的NamespaceHandler</strong></p>\n<p><img src=\"/2020/09/13/spring-extend/3.png\" alt></p>\n<p>当解析application.xml文件时，如果遇到component-scan就会进来ContextNamespaceHandler执行init方法。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ContextNamespaceHandler</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">NamespaceHandlerSupport</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">registerBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"property-placeholder\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PropertyPlaceholderBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">registerBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"property-override\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">PropertyOverrideBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">registerBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"annotation-config\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AnnotationConfigBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token comment\" spellcheck=\"true\">//注册component-scan包含的后处理器</span>\n        <span class=\"token function\">registerBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"component-scan\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ComponentScanBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">registerBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"load-time-weaver\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">LoadTimeWeaverBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">registerBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"spring-configured\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SpringConfiguredBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">registerBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mbean-export\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MBeanExportBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">registerBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"mbean-server\"</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MBeanServerBeanDefinitionParser</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>利用ComponentScanBeanDefinitionParser完成指定包下所有类的扫描，BeanDefinition创建的过程。</strong></p>\n<p>继续跟代码，在registerComponents方法中。通过下面代码，自动为我们注入了一些关键的后处理器。如下</p>\n<pre class=\" language-java\"><code class=\"language-java\">Set<span class=\"token operator\">&lt;</span>BeanDefinitionHolder<span class=\"token operator\">></span> processorDefinitions <span class=\"token operator\">=</span>\n                    AnnotationConfigUtils<span class=\"token punctuation\">.</span><span class=\"token function\">registerAnnotationConfigProcessors</span><span class=\"token punctuation\">(</span>readerContext<span class=\"token punctuation\">.</span><span class=\"token function\">getRegistry</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">)</span>；</code></pre>\n<ul>\n<li>ConfigurationClassPostProcessor，帮我们处理了@Configuration，@ComponentScan，@Bean等注解的处理，帮我们将注解类注册到spring容器中。</li>\n<li>AutowiredAnnotationBeanPostProcessor，@Autowried自动装配所需的后处理器</li>\n<li>CommonAnnotationBeanPostProcessor，解析@Resource、@WebServiceRef、@EJB三个注解</li>\n<li>EventListenerMethodProcessor</li>\n<li>DefaultEventListenerFactory</li>\n</ul>\n<h3 id=\"ApplicationContextAwareProcessor\"><a href=\"#ApplicationContextAwareProcessor\" class=\"headerlink\" title=\"ApplicationContextAwareProcessor\"></a>ApplicationContextAwareProcessor</h3><p>ApplicationContextAwareProcessor是Spring启动后自动加载进去的后处理器。该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前。例如我们常用的ApplicationContextAware（我们经常实现ApplicationContextAware类来编写SpringUtils工具类，用来getBean）。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//ApplicationContextAwareProcessor类中postProcessBeforeInitialization方法中的执行逻辑</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">invokeAwareInterfaces</span><span class=\"token punctuation\">(</span>Object bean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bean <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">EnvironmentAware</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>EnvironmentAware<span class=\"token punctuation\">)</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setEnvironment</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>applicationContext<span class=\"token punctuation\">.</span><span class=\"token function\">getEnvironment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bean <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">EmbeddedValueResolverAware</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>EmbeddedValueResolverAware<span class=\"token punctuation\">)</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setEmbeddedValueResolver</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>embeddedValueResolver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bean <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ResourceLoaderAware</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ResourceLoaderAware<span class=\"token punctuation\">)</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setResourceLoader</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>applicationContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bean <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ApplicationEventPublisherAware</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ApplicationEventPublisherAware<span class=\"token punctuation\">)</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setApplicationEventPublisher</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>applicationContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bean <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">MessageSourceAware</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>MessageSourceAware<span class=\"token punctuation\">)</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setMessageSource</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>applicationContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//判断Bean中是否有实现ApplicationContextAware接口的类，如果有就将applicationContext赋值进去。</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bean <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">ApplicationContextAware</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>ApplicationContextAware<span class=\"token punctuation\">)</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">setApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>applicationContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Component</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AppUtil</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ApplicationContextAware</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> ApplicationContext applicationContext<span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setApplicationContext</span><span class=\"token punctuation\">(</span>ApplicationContext arg0<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> BeansException <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//将ApplicationContext保存在静态变量中，后面就可以直接获取到spring上下文了。</span>\n        applicationContext <span class=\"token operator\">=</span> arg0<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> Object <span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>String id<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Object object <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        object <span class=\"token operator\">=</span> applicationContext<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> object<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>EnvironmentAware，用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。</li>\n<li>EmbeddedValueResolverAware，用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取。</li>\n<li>ResourceLoaderAware，用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。</li>\n<li>ApplicationEventPublisherAware，用于获取ApplicationEventPublisher的一个扩展类。</li>\n<li>MessageSourceAware，用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。</li>\n<li>ApplicationContextAware，用来获取ApplicationContext上下文的一个扩展类。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"BeanDefinitionRegistryPostProcessor\"><a href=\"#BeanDefinitionRegistryPostProcessor\" class=\"headerlink\" title=\"BeanDefinitionRegistryPostProcessor\"></a>BeanDefinitionRegistryPostProcessor</h3><p><img src=\"/2020/09/13/spring-extend/1.png\" alt></p>\n<p>这个扩展点主要发生在获取BeanDefinition后，可以在这里动态注册自己的beanDefinition，或者对已注册的BeanDefinition做一些改变，提供了两个方法</p>\n<ul>\n<li>postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry)，该方法用来注册更多的bean到spring容器中。</li>\n<li>postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)，主要用来对已注册BeanDefinition做一些改变。</li></ul>","more":"具体源码\n\n<pre><code class=\"java\">//refresh -&gt; #invokeBeanFactoryPostProcessors() -&gt; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, //getBeanFactoryPostProcessors())\nboolean reiterate = true;\nwhile (reiterate) {\n    reiterate = false;\n    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);\n    for (String ppName : postProcessorNames) {\n        if (!processedBeans.contains(ppName)) {\n            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));\n            processedBeans.add(ppName);\n            reiterate = true;\n        }\n    }\n    sortPostProcessors(currentRegistryProcessors, beanFactory);\n    registryProcessors.addAll(currentRegistryProcessors);\n    //执行postProcessBeanDefinitionRegistry方法\n    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);\n    currentRegistryProcessors.clear();\n}\n//执行postProcessBeanFactory方法\ninvokeBeanFactoryPostProcessors(registryProcessors, beanFactory);\ninvokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</code></pre>\n<h3 id=\"BeanFactoryPostProcessor\"><a href=\"#BeanFactoryPostProcessor\" class=\"headerlink\" title=\"BeanFactoryPostProcessor\"></a>BeanFactoryPostProcessor</h3><p>这个接口是beanFactory的扩展接口，调用时机在spring在读取beanDefinition信息之后，实例化bean之前。是上面说的BeanDefinitionRegistryPostProcessor的父类，提供了postProcessBeanFactory方法。用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的beanDefinition的元信息。</p>\n<h3 id=\"InstantiationAwareBeanPostProcessor\"><a href=\"#InstantiationAwareBeanPostProcessor\" class=\"headerlink\" title=\"InstantiationAwareBeanPostProcessor\"></a>InstantiationAwareBeanPostProcessor</h3><p>InstantiationAwareBeanPostProcessor继承了BeanPostProcess接口。原本BeanPostProcess只有提供了<code>初始化之前</code>和<code>初始化之后</code>的扩展，它再次基础上增加了<code>实例化bean之前</code>，<code>实例化bean之后</code>，<code>属性注入时阶段</code>这几个过程。</p>\n<p><img src=\"/2020/09/13/spring-extend/2.png\" alt=\"InstantiationAwareBeanPostProcessor继承图\"></p>\n<ul>\n<li>postProcessBeforeInitialization 初始化之前</li>\n<li>postProcessAfterInitialization 初始化之后</li>\n<li>postProcessBeforeInstantiation 实例化之前</li>\n<li>postProcessAfterInstantiation 实例化之后</li>\n<li>postProcessProperties 属性赋值时，用来属性赋值时做一些操作，<strong>@Autowired,@Resource等注解原理基于此方法实现</strong></li>\n</ul>\n<p><strong>感觉这个接口是对Spring生命周期扩展最全的一个接口了。例如依赖注入@Autowired对应的后处理器AutowiredAnnotationBeanPostProcessor就是基于这个实现。</strong></p>\n<h3 id=\"SmartInstantiationAwareBeanPostProcessor\"><a href=\"#SmartInstantiationAwareBeanPostProcessor\" class=\"headerlink\" title=\"SmartInstantiationAwareBeanPostProcessor\"></a>SmartInstantiationAwareBeanPostProcessor</h3><p>SmartInstantiationAwareBeanPostProcessor继承了上面说的<code>InstantiationAwareBeanPostProcessor</code>类，并在此基础上新增了三个扩展点。</p>\n<ul>\n<li>predictBeanType，该触发点发生在<code>postProcessBeforeInstantiation</code>之前，用于预测Bean的类型。你调用BeanFactory.getType(name)时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</li>\n<li>determineCandidateConstructors，该触发点发生在<code>postProcessBeforeInstantiation</code>之后。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</li>\n<li>getEarlyBeanReference，该触发点发生在<code>postProcessAfterInstantiation</code>之后。主要用于<strong>循环依赖</strong>。</li>\n</ul>\n<h3 id=\"MergedBeanDefinitionPostProcessor\"><a href=\"#MergedBeanDefinitionPostProcessor\" class=\"headerlink\" title=\"MergedBeanDefinitionPostProcessor\"></a>MergedBeanDefinitionPostProcessor</h3><p>触发时机在实例化之后，属性赋值之前。AutowiredAnnotationBeanPostProcessor使用到了这个接口。</p>\n<p>AutowiredAnnotationBeanPostProcessor类把正在被spring实例化的bean进行@Autowired和@Value扫描，扫描到类里面属性和方法上面如果有注解，就会把对应的方法或者属性封装起来，最终封装成InjectionMetadata对象。</p>\n<p><img src=\"/2020/09/13/spring-extend/4.png\" alt></p>\n<h3 id=\"BeanFactoryAware\"><a href=\"#BeanFactoryAware\" class=\"headerlink\" title=\"BeanFactoryAware\"></a>BeanFactoryAware</h3><p><strong>发生在bean的实例化之后，注入属性之前，也就是Setter之前。</strong></p>\n<p>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 BeanFactory，在这个时候，可以对每个bean作特殊化的定制。</p>\n<p><strong>作用于单个Bean，例如某个Bean实现了这个接口，就只有这个接口会触发这个接口的方法。其他接口不会触发</strong></p>\n<h3 id=\"BeanNameAware\"><a href=\"#BeanNameAware\" class=\"headerlink\" title=\"BeanNameAware\"></a>BeanNameAware</h3><p>触发点在bean的初始化之前，也就是<code>postProcessBeforeInitialization</code>之前。</p>\n<p>用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p>\n<h3 id=\"InitializingBean\"><a href=\"#InitializingBean\" class=\"headerlink\" title=\"InitializingBean\"></a>InitializingBean</h3><p>触发时机在<code>postProcessAfterInitialization</code>之前，也就是初始化完成之后。</p>\n<h3 id=\"DisposableBean\"><a href=\"#DisposableBean\" class=\"headerlink\" title=\"DisposableBean\"></a>DisposableBean</h3><p>其触发时机为当此对象销毁时。比如说运行applicationContext.registerShutdownHook时，就会触发这个方法。</p>\n<h3 id=\"NamespaceHandler\"><a href=\"#NamespaceHandler\" class=\"headerlink\" title=\"NamespaceHandler\"></a>NamespaceHandler</h3><p>翻译过来叫命名空间处理器。他的主要作用是<strong>配合BeanDefinitionParser，通过解析自定义标签来自动注入一些Bean，这些Bean包括了一些关键的后处理器。例如component-scan标签</strong>。</p>\n<p>接下去我们来看&lt;context:component-scan&gt;是如何实现自动注入一些关键后处理器的。</p>\n<p><strong>spring.handlers设置&lt;context:这种开头的配置使用的NamespaceHandler</strong></p>\n<p><img src=\"/2020/09/13/spring-extend/3.png\" alt></p>\n<p>当解析application.xml文件时，如果遇到component-scan就会进来ContextNamespaceHandler执行init方法。</p>\n<pre><code class=\"java\">public class ContextNamespaceHandler extends NamespaceHandlerSupport {\n    @Override\n    public void init() {\n        registerBeanDefinitionParser(&quot;property-placeholder&quot;, new PropertyPlaceholderBeanDefinitionParser());\n        registerBeanDefinitionParser(&quot;property-override&quot;, new PropertyOverrideBeanDefinitionParser());\n        registerBeanDefinitionParser(&quot;annotation-config&quot;, new AnnotationConfigBeanDefinitionParser());\n         //注册component-scan包含的后处理器\n        registerBeanDefinitionParser(&quot;component-scan&quot;, new ComponentScanBeanDefinitionParser());\n        registerBeanDefinitionParser(&quot;load-time-weaver&quot;, new LoadTimeWeaverBeanDefinitionParser());\n        registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());\n        registerBeanDefinitionParser(&quot;mbean-export&quot;, new MBeanExportBeanDefinitionParser());\n        registerBeanDefinitionParser(&quot;mbean-server&quot;, new MBeanServerBeanDefinitionParser());\n    }\n}</code></pre>\n<p><strong>利用ComponentScanBeanDefinitionParser完成指定包下所有类的扫描，BeanDefinition创建的过程。</strong></p>\n<p>继续跟代码，在registerComponents方法中。通过下面代码，自动为我们注入了一些关键的后处理器。如下</p>\n<pre><code class=\"java\">Set&lt;BeanDefinitionHolder&gt; processorDefinitions =\n                    AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source)；</code></pre>\n<ul>\n<li>ConfigurationClassPostProcessor，帮我们处理了@Configuration，@ComponentScan，@Bean等注解的处理，帮我们将注解类注册到spring容器中。</li>\n<li>AutowiredAnnotationBeanPostProcessor，@Autowried自动装配所需的后处理器</li>\n<li>CommonAnnotationBeanPostProcessor，解析@Resource、@WebServiceRef、@EJB三个注解</li>\n<li>EventListenerMethodProcessor</li>\n<li>DefaultEventListenerFactory</li>\n</ul>\n<h3 id=\"ApplicationContextAwareProcessor\"><a href=\"#ApplicationContextAwareProcessor\" class=\"headerlink\" title=\"ApplicationContextAwareProcessor\"></a>ApplicationContextAwareProcessor</h3><p>ApplicationContextAwareProcessor是Spring启动后自动加载进去的后处理器。该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前。例如我们常用的ApplicationContextAware（我们经常实现ApplicationContextAware类来编写SpringUtils工具类，用来getBean）。</p>\n<pre><code class=\"java\">//ApplicationContextAwareProcessor类中postProcessBeforeInitialization方法中的执行逻辑\nprivate void invokeAwareInterfaces(Object bean) {\n    if (bean instanceof EnvironmentAware) {\n        ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());\n    }\n    if (bean instanceof EmbeddedValueResolverAware) {\n        ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);\n    }\n    if (bean instanceof ResourceLoaderAware) {\n        ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);\n    }\n    if (bean instanceof ApplicationEventPublisherAware) {\n        ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);\n    }\n    if (bean instanceof MessageSourceAware) {\n        ((MessageSourceAware) bean).setMessageSource(this.applicationContext);\n    }\n    //判断Bean中是否有实现ApplicationContextAware接口的类，如果有就将applicationContext赋值进去。\n    if (bean instanceof ApplicationContextAware) {\n        ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);\n    }\n}</code></pre>\n<pre><code class=\"java\">@Component\npublic class AppUtil implements ApplicationContextAware {\n    private static ApplicationContext applicationContext;\n    @Override\n    public void setApplicationContext(ApplicationContext arg0) throws BeansException {\n        //将ApplicationContext保存在静态变量中，后面就可以直接获取到spring上下文了。\n        applicationContext = arg0;\n    }\n\n    public static Object getBean(String id) {\n        Object object = null;\n        object = applicationContext.getBean(id);\n        return object;\n    }\n}</code></pre>\n<ul>\n<li>EnvironmentAware，用于获取EnviromentAware的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。</li>\n<li>EmbeddedValueResolverAware，用于获取StringValueResolver的一个扩展类， StringValueResolver用于获取基于String类型的properties的变量，一般我们都用@Value的方式去获取。</li>\n<li>ResourceLoaderAware，用于获取ResourceLoader的一个扩展类，ResourceLoader可以用于获取classpath内所有的资源对象，可以扩展此类来拿到ResourceLoader对象。</li>\n<li>ApplicationEventPublisherAware，用于获取ApplicationEventPublisher的一个扩展类。</li>\n<li>MessageSourceAware，用于获取MessageSource的一个扩展类，MessageSource主要用来做国际化。</li>\n<li>ApplicationContextAware，用来获取ApplicationContext上下文的一个扩展类。</li>\n</ul>"},{"title":"Spring循环依赖详解","description":"Spring循环依赖详解","date":"2020-05-10T05:42:51.000Z","_content":"\n### 什么是循环依赖\n\n所谓的循环依赖是指，A 依赖 B，B 又依赖 A，它们之间形成了循环依赖。或者是 A 依赖 B，B 依赖 C，C 又依赖 A，形成了循环依赖。更或者是自己依赖自己。\n\n![](spring-forbean/1.png)\n<!--more-->\n**Spring循环依赖配置和测试类**\n\n```xml\n<!--src\\main\\resources\\applicationContext.xml-->\n<bean id=\"beanB\" class=\"com.xzy.bean.BeanB\">\n    <property name=\"param1\" value=\"param1\"/>\n    <property name=\"param2\" value=\"param2\"/>\n    <property name=\"beanC\" ref=\"beanC\"/>\n</bean>\n<bean id=\"beanC\" class=\"com.xzy.bean.BeanC\">\n    <property name=\"param1\" value=\"param1\"/>\n    <property name=\"param2\" value=\"param2\"/>\n    <property name=\"beanB\" ref=\"beanB\"/>\n</bean>\n```\n\n```java\n@Test\npublic void testFor(){\n    ClassPathResource resource = new ClassPathResource(\"applicationContext.xml\");\n    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\n    //解析资源\n    reader.loadBeanDefinitions(resource);\n    BeanB bean = factory.getBean(BeanB.class);\n    System.out.println(bean);\n}\n```\n\n### 为什么会有循环依赖问题\n\n循环依赖问题主要是由于Spring复杂的生命周期。当我们getBean()获取一个bean时，bean要经历\n\n1. 从Beandefinition对象通过反射实例化bean对象\n2. 对实例化后的bean进行属性赋值\n3. bean初始化\n4. 使用bean\n5. bean销毁\n\n如果存在循环依赖，假设A对象实例化进行属性赋值时候发现B，由于B还没实例化，接着去实例化B，B实例化属性赋值时发现A。如果不做处理的话就会导致无限循环，也就是循环依赖的问题。\n\n### Spring解决循环依赖的思想\n\nSpring 实例化对象分两步，第一步会先创建一个原始对象，只是没有设置属性，可以理解为\"半成品\"，官方叫 A 对象的早期引用（EarlyBeanReference），所以当实例化 B 的时候发现依赖了 A， B就会把这个“半成品”设置进去先完成实例化，既然 B 完成了实例化，所以 A 就可以获得 B 的引用，也完成实例化了。\n\n### 原理解读\n\n#### **获取Bean 流程**\n\nSpring IOC容器中获取bean实例的简化版流程如下\n\n<img src=\"spring-forbean\\2.png\" style=\"zoom:50%;\" />\n\n1. 流程从 `getBean` 方法开始，`getBean` 是个空壳方法，所有逻辑直接到 `doGetBean` 方法中。\n2. `transformedBeanName` 将name转换为真正的 beanName（name可能是 FactoryBean 以 & 字符开头或者有别名的情况，所以需要转化下）。\n3. 然后通过 `getSingleton(beanName)` 方法尝试从缓存中查找是不是有该实例（单例在 Spring 的同一容器只会被创建一次，后续再获取 bean，就直接从缓存获取即可）。\n4. 如果有的话，sharedInstance 可能是完全实例化好的 bean，也可能是一个原始的 bean，所以再经 `getObjectForBeanInstance` 处理即可返回。\n5. 当然sharedInstance也可能是null，这时候就会执行创建 bean 的逻辑，将结果返回。\n\n#### **三级缓存**\n\n从getBean的流程来看，解决循环依赖的关键是**将实例化后的对象放到缓存中去，当需要用到时在从缓存中拿。**spring定义了三级缓存来解决循环依赖。\n\n```java\n//org.springframework.beans.factory.support.DefaultSingletonBeanRegistry\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);\nprivate final Map<String, Object> earlySingletonObjects = new HashMap<>(16);\n```\n\n三级缓存的作用：\n\n- singletonObjects：完成初始化的单例对象的cache，这里的bean经历过**实例化->属性填充->初始化**以及各种后置处理（一级缓存）\n- earlySingletonObjects：存放原始的bean对象（**完成实例化但是尚未填充属性和初始化**），仅仅能作为指针提前曝光，被其他bean所引用，用于解决循环依赖的（二级缓存）\n- singletonFactories：在bean实例化完之后，属性填充以及初始化之前，如果允许提前曝光，Spring会将实例化后的bean提前曝光，也就是把该bean转换成`beanFactory`并加入到`singletonFactories`（三级缓存）。\n\n#### **创建Bean的流程**\n\n![](spring-forbean/3.png)\n\n**主要代码**\n\n```java\n\n//org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean\nsharedInstance = getSingleton(beanName, () -> {\n\ttry {\n\t\treturn createBean(beanName, mbd, args);\n\t}\n\tcatch (BeansException ex) {\n\t\t//异常销毁Bean\n\t\tdestroySingleton(beanName);\n\t\tthrow ex;\n\t}\n});\n\npublic Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n\tAssert.notNull(beanName, \"Bean name must not be null\");\n\tsynchronized (this.singletonObjects) {\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\tif (singletonObject == null) {\n\t\t\t//创建bean 下面的代码执行的是 createBean(beanName, mbd, args)\n\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\tnewSingleton = true;\n\t\t\tif (newSingleton) {\n\t\t\t\t//将bean加入到一级缓存中\n\t\t\t\taddSingleton(beanName, singletonObject);\n\n\t\t\t}\n\t\t}\n\t\treturn singletonObject;\n\t}\n}\n//将Bean加入到一级缓存，上面说过一级缓存里面的Bean是完整的Bean\nprotected void addSingleton(String beanName, Object singletonObject) {\n\tsynchronized (this.singletonObjects) {\n\t\tthis.singletonObjects.put(beanName, singletonObject);\n\t\tthis.singletonFactories.remove(beanName);\n\t\tthis.earlySingletonObjects.remove(beanName);\n\t\tthis.registeredSingletons.add(beanName);\n\t}\n}\n\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\tthrows BeanCreationException {\n\tObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n\treturn beanInstance;\n}\n\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n\t\tthrows BeanCreationException {\n\tBeanWrapper instanceWrapper = null;\n\tif (instanceWrapper == null) {\n\t\t//实例化Bean\n\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\t}\n\tboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n\t\t\tisSingletonCurrentlyInCreation(beanName));\n\tif (earlySingletonExposure) {\n\t\t//将实例化后的值加入到三级缓存中\n\t\taddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\t}\n\tObject exposedObject = bean;\n\t//属性赋值\n\tpopulateBean(beanName, mbd, instanceWrapper);\n\t//初始化\n\texposedObject = initializeBean(beanName, exposedObject, mbd);\n  \t// 循环依赖校验\n\tif (earlySingletonExposure) {\n\t    // 注意此处第二个参数传的false，表示不去三级缓存里再去调用一次getObject()方法了，此时代理对象还在二级缓存，所以这里拿出来的就是个 代理对象\n\t    // 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  \n\t    // 这样就保证了我们容器里 最终实际上是代理对象，而非原始对象\n\t    Object earlySingletonReference = getSingleton(beanName, false);\n\t    if (earlySingletonReference != null) {\n\t        if (exposedObject == bean) { \n\t            exposedObject = earlySingletonReference;\n\t        }\n\t    }\n\t}\n\treturn exposedObject;\n}\n\nprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\tObject exposedObject = bean;\n\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\tif (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n\t\t\t\tSmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;\n\t\t\t\texposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t}\n\treturn exposedObject;\n}\n```\n\n整个创建Bean流程逻辑如下：\n\n1. `getSingleton`方法获取Bean，发现Bean还没创建，则调用`createBean`创建Bean。\n2. `createBeanInstance`实例化Bean，实例化后将`getEarlyBeanReference`创建工厂加入到三级缓存中。\n3. 通过 `populateBean` 方法向原始 bean 对象中填充属性，并解析依赖。**假设这时候创建A之后填充属性时发现依赖B，然后创建依赖对象B的时候又发现依赖A，还是同样的流程，又去getBean(A)，这个时候三级缓存已经有了beanA的“半成品”，这时就可以把A对象的原始引用注入B对象（并将其移动到二级缓存）来解决循环依赖问题。这时候getObject()方法就算执行结束了，返回完全实例化的bean。**\n4. 最后调用 `addSingleton` 把完全实例化好的bean对象放入 singletonObjects 缓存（一级缓存）中。\n\n#### **循环依赖解决**\n\n![](spring-forbean/4.png)\n\n当我们创建beanA的原始对象后，并把它放到三级缓存中，接下来就该填充对象属性了，这时候发现依赖了beanB，接着就又去创建beanB，同样的流程，创建完beanB填充属性时又发现它依赖了beanA，又是同样的流程，不同的是，这时候可以在三级缓存中查到刚放进去的原始对象beanA，所以不需要继续创建，用它注入beanB，完成beanB的创建。\n\n#### **为什么需要用到三级缓存？**\n\n如果按照上面的逻辑，完全可以将缓存放到二级缓存就好，为啥还要三级缓存呢。我们注意到三级缓存放的是bean工厂。具体方法如下。\n\n```java\n//将bean创建存入三级缓存\naddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\nprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\tObject exposedObject = bean;\n\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\tif (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n                 // 这么一大段就这句话是核心，也就是当bean要进行提前曝光时，\n                 // 给一个机会，通过重写后置处理器的getEarlyBeanReference方法，来自定义操作bean\n                 // 值得注意的是，如果提前曝光了，但是没有被提前引用，则该后置处理器并不生效!!!\n                 // 这也正式三级缓存存在的意义，否则二级缓存就可以解决循环依赖的问题\n\t\t\t\tSmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;\n\t\t\t\texposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t}\n\treturn exposedObject;\n}\n```\n\n这个方法就是 Spring 为什么使用三级缓存，而不是二级缓存的原因，它的目的是为了后置处理，如果没有 AOP 后置处理，就不会走进 if 语句，直接返回了 exposedObject。\n\n然后我们看下**SmartInstantiationAwareBeanPostProcessor**这个后处理器，其实是用来做SpringAOP，事务使用代理对象的。我们都知道 **Spring AOP、事务**等都是通过代理对象来实现的，而**事务**的代理对象是由自动代理创建器来自动完成的。\n\n![](spring-forbean/5.png)\n\n所以为啥要用到三级缓存，假设beanA是用AOP代理的，当beanB属性赋值时要获取A时应该获取的是A的代理对象，此时就通过`singletonFactory.getObject()`获取到代理对象然后在存到二级缓存中。\n\n**为什么这么设计呢，即使有代理，在二级缓存代理也可以吧 | 为什么要使用三级缓存呢？**\n\n假设我们现在是二级缓存架构，创建A的时候，我们不知道有没有循环依赖，所以放入二级缓存提前暴露，接着创建B，也是放入二级缓存，这时候发现又循环依赖了A，就去二级缓存找，是有，但是如果此时还有AOP代理呢，我们要的是代理对象可不是原始对象，这怎么办，只能改逻辑，在第一步的时候，不管3721，所有Bean统统去完成AOP代理，如果是这样的话，就不需要三级缓存了，但是这样不仅没有必要，而且违背了Spring在结合AOP跟Bean的生命周期的设计。\n\n所以Spring“多此一举”的将实例先封装到ObjectFactory中（三级缓存），主要关键点在getObject()方法并非直接返回实例，而是对实例又使用SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法对bean进行处理，也就是说，当Spring中存在该后置处理器，所有的单例bean在实例化后都会被进行提前曝光到三级缓存中，但是并不是所有的bean都存在循环依赖，也就是三级缓存到二级缓存的步骤不一定都会被执行，有可能曝光后直接创建完成，没被提前引用过，就直接被加入到一级缓存中。因此可以确保只有提前曝光且被引用的bean才会进行该后置处理。\n\n### 参考\n\n- https://developer.aliyun.com/article/771925?spm=a2c6h.12873581.0.0.322f2fb1GfswWI&groupCode=microservice\n\n\n\n","source":"_posts/spring-forbean.md","raw":"---\ntitle: Spring循环依赖详解\ntags:\n  - spring\ncategories: \n  - spring\ndescription : Spring循环依赖详解\ndate: 2020-05-10 13:42:51\n---\n\n### 什么是循环依赖\n\n所谓的循环依赖是指，A 依赖 B，B 又依赖 A，它们之间形成了循环依赖。或者是 A 依赖 B，B 依赖 C，C 又依赖 A，形成了循环依赖。更或者是自己依赖自己。\n\n![](spring-forbean/1.png)\n<!--more-->\n**Spring循环依赖配置和测试类**\n\n```xml\n<!--src\\main\\resources\\applicationContext.xml-->\n<bean id=\"beanB\" class=\"com.xzy.bean.BeanB\">\n    <property name=\"param1\" value=\"param1\"/>\n    <property name=\"param2\" value=\"param2\"/>\n    <property name=\"beanC\" ref=\"beanC\"/>\n</bean>\n<bean id=\"beanC\" class=\"com.xzy.bean.BeanC\">\n    <property name=\"param1\" value=\"param1\"/>\n    <property name=\"param2\" value=\"param2\"/>\n    <property name=\"beanB\" ref=\"beanB\"/>\n</bean>\n```\n\n```java\n@Test\npublic void testFor(){\n    ClassPathResource resource = new ClassPathResource(\"applicationContext.xml\");\n    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\n    //解析资源\n    reader.loadBeanDefinitions(resource);\n    BeanB bean = factory.getBean(BeanB.class);\n    System.out.println(bean);\n}\n```\n\n### 为什么会有循环依赖问题\n\n循环依赖问题主要是由于Spring复杂的生命周期。当我们getBean()获取一个bean时，bean要经历\n\n1. 从Beandefinition对象通过反射实例化bean对象\n2. 对实例化后的bean进行属性赋值\n3. bean初始化\n4. 使用bean\n5. bean销毁\n\n如果存在循环依赖，假设A对象实例化进行属性赋值时候发现B，由于B还没实例化，接着去实例化B，B实例化属性赋值时发现A。如果不做处理的话就会导致无限循环，也就是循环依赖的问题。\n\n### Spring解决循环依赖的思想\n\nSpring 实例化对象分两步，第一步会先创建一个原始对象，只是没有设置属性，可以理解为\"半成品\"，官方叫 A 对象的早期引用（EarlyBeanReference），所以当实例化 B 的时候发现依赖了 A， B就会把这个“半成品”设置进去先完成实例化，既然 B 完成了实例化，所以 A 就可以获得 B 的引用，也完成实例化了。\n\n### 原理解读\n\n#### **获取Bean 流程**\n\nSpring IOC容器中获取bean实例的简化版流程如下\n\n<img src=\"spring-forbean\\2.png\" style=\"zoom:50%;\" />\n\n1. 流程从 `getBean` 方法开始，`getBean` 是个空壳方法，所有逻辑直接到 `doGetBean` 方法中。\n2. `transformedBeanName` 将name转换为真正的 beanName（name可能是 FactoryBean 以 & 字符开头或者有别名的情况，所以需要转化下）。\n3. 然后通过 `getSingleton(beanName)` 方法尝试从缓存中查找是不是有该实例（单例在 Spring 的同一容器只会被创建一次，后续再获取 bean，就直接从缓存获取即可）。\n4. 如果有的话，sharedInstance 可能是完全实例化好的 bean，也可能是一个原始的 bean，所以再经 `getObjectForBeanInstance` 处理即可返回。\n5. 当然sharedInstance也可能是null，这时候就会执行创建 bean 的逻辑，将结果返回。\n\n#### **三级缓存**\n\n从getBean的流程来看，解决循环依赖的关键是**将实例化后的对象放到缓存中去，当需要用到时在从缓存中拿。**spring定义了三级缓存来解决循环依赖。\n\n```java\n//org.springframework.beans.factory.support.DefaultSingletonBeanRegistry\nprivate final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);\nprivate final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);\nprivate final Map<String, Object> earlySingletonObjects = new HashMap<>(16);\n```\n\n三级缓存的作用：\n\n- singletonObjects：完成初始化的单例对象的cache，这里的bean经历过**实例化->属性填充->初始化**以及各种后置处理（一级缓存）\n- earlySingletonObjects：存放原始的bean对象（**完成实例化但是尚未填充属性和初始化**），仅仅能作为指针提前曝光，被其他bean所引用，用于解决循环依赖的（二级缓存）\n- singletonFactories：在bean实例化完之后，属性填充以及初始化之前，如果允许提前曝光，Spring会将实例化后的bean提前曝光，也就是把该bean转换成`beanFactory`并加入到`singletonFactories`（三级缓存）。\n\n#### **创建Bean的流程**\n\n![](spring-forbean/3.png)\n\n**主要代码**\n\n```java\n\n//org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean\nsharedInstance = getSingleton(beanName, () -> {\n\ttry {\n\t\treturn createBean(beanName, mbd, args);\n\t}\n\tcatch (BeansException ex) {\n\t\t//异常销毁Bean\n\t\tdestroySingleton(beanName);\n\t\tthrow ex;\n\t}\n});\n\npublic Object getSingleton(String beanName, ObjectFactory<?> singletonFactory) {\n\tAssert.notNull(beanName, \"Bean name must not be null\");\n\tsynchronized (this.singletonObjects) {\n\t\tObject singletonObject = this.singletonObjects.get(beanName);\n\t\tif (singletonObject == null) {\n\t\t\t//创建bean 下面的代码执行的是 createBean(beanName, mbd, args)\n\t\t\tsingletonObject = singletonFactory.getObject();\n\t\t\tnewSingleton = true;\n\t\t\tif (newSingleton) {\n\t\t\t\t//将bean加入到一级缓存中\n\t\t\t\taddSingleton(beanName, singletonObject);\n\n\t\t\t}\n\t\t}\n\t\treturn singletonObject;\n\t}\n}\n//将Bean加入到一级缓存，上面说过一级缓存里面的Bean是完整的Bean\nprotected void addSingleton(String beanName, Object singletonObject) {\n\tsynchronized (this.singletonObjects) {\n\t\tthis.singletonObjects.put(beanName, singletonObject);\n\t\tthis.singletonFactories.remove(beanName);\n\t\tthis.earlySingletonObjects.remove(beanName);\n\t\tthis.registeredSingletons.add(beanName);\n\t}\n}\n\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n\t\tthrows BeanCreationException {\n\tObject beanInstance = doCreateBean(beanName, mbdToUse, args);\n\treturn beanInstance;\n}\n\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n\t\tthrows BeanCreationException {\n\tBeanWrapper instanceWrapper = null;\n\tif (instanceWrapper == null) {\n\t\t//实例化Bean\n\t\tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\t}\n\tboolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&\n\t\t\tisSingletonCurrentlyInCreation(beanName));\n\tif (earlySingletonExposure) {\n\t\t//将实例化后的值加入到三级缓存中\n\t\taddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\t}\n\tObject exposedObject = bean;\n\t//属性赋值\n\tpopulateBean(beanName, mbd, instanceWrapper);\n\t//初始化\n\texposedObject = initializeBean(beanName, exposedObject, mbd);\n  \t// 循环依赖校验\n\tif (earlySingletonExposure) {\n\t    // 注意此处第二个参数传的false，表示不去三级缓存里再去调用一次getObject()方法了，此时代理对象还在二级缓存，所以这里拿出来的就是个 代理对象\n\t    // 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  \n\t    // 这样就保证了我们容器里 最终实际上是代理对象，而非原始对象\n\t    Object earlySingletonReference = getSingleton(beanName, false);\n\t    if (earlySingletonReference != null) {\n\t        if (exposedObject == bean) { \n\t            exposedObject = earlySingletonReference;\n\t        }\n\t    }\n\t}\n\treturn exposedObject;\n}\n\nprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\tObject exposedObject = bean;\n\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\tif (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n\t\t\t\tSmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;\n\t\t\t\texposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t}\n\treturn exposedObject;\n}\n```\n\n整个创建Bean流程逻辑如下：\n\n1. `getSingleton`方法获取Bean，发现Bean还没创建，则调用`createBean`创建Bean。\n2. `createBeanInstance`实例化Bean，实例化后将`getEarlyBeanReference`创建工厂加入到三级缓存中。\n3. 通过 `populateBean` 方法向原始 bean 对象中填充属性，并解析依赖。**假设这时候创建A之后填充属性时发现依赖B，然后创建依赖对象B的时候又发现依赖A，还是同样的流程，又去getBean(A)，这个时候三级缓存已经有了beanA的“半成品”，这时就可以把A对象的原始引用注入B对象（并将其移动到二级缓存）来解决循环依赖问题。这时候getObject()方法就算执行结束了，返回完全实例化的bean。**\n4. 最后调用 `addSingleton` 把完全实例化好的bean对象放入 singletonObjects 缓存（一级缓存）中。\n\n#### **循环依赖解决**\n\n![](spring-forbean/4.png)\n\n当我们创建beanA的原始对象后，并把它放到三级缓存中，接下来就该填充对象属性了，这时候发现依赖了beanB，接着就又去创建beanB，同样的流程，创建完beanB填充属性时又发现它依赖了beanA，又是同样的流程，不同的是，这时候可以在三级缓存中查到刚放进去的原始对象beanA，所以不需要继续创建，用它注入beanB，完成beanB的创建。\n\n#### **为什么需要用到三级缓存？**\n\n如果按照上面的逻辑，完全可以将缓存放到二级缓存就好，为啥还要三级缓存呢。我们注意到三级缓存放的是bean工厂。具体方法如下。\n\n```java\n//将bean创建存入三级缓存\naddSingletonFactory(beanName, () -> getEarlyBeanReference(beanName, mbd, bean));\n\nprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n\tObject exposedObject = bean;\n\tif (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {\n\t\tfor (BeanPostProcessor bp : getBeanPostProcessors()) {\n\t\t\tif (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n                 // 这么一大段就这句话是核心，也就是当bean要进行提前曝光时，\n                 // 给一个机会，通过重写后置处理器的getEarlyBeanReference方法，来自定义操作bean\n                 // 值得注意的是，如果提前曝光了，但是没有被提前引用，则该后置处理器并不生效!!!\n                 // 这也正式三级缓存存在的意义，否则二级缓存就可以解决循环依赖的问题\n\t\t\t\tSmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;\n\t\t\t\texposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n\t\t\t}\n\t\t}\n\t}\n\treturn exposedObject;\n}\n```\n\n这个方法就是 Spring 为什么使用三级缓存，而不是二级缓存的原因，它的目的是为了后置处理，如果没有 AOP 后置处理，就不会走进 if 语句，直接返回了 exposedObject。\n\n然后我们看下**SmartInstantiationAwareBeanPostProcessor**这个后处理器，其实是用来做SpringAOP，事务使用代理对象的。我们都知道 **Spring AOP、事务**等都是通过代理对象来实现的，而**事务**的代理对象是由自动代理创建器来自动完成的。\n\n![](spring-forbean/5.png)\n\n所以为啥要用到三级缓存，假设beanA是用AOP代理的，当beanB属性赋值时要获取A时应该获取的是A的代理对象，此时就通过`singletonFactory.getObject()`获取到代理对象然后在存到二级缓存中。\n\n**为什么这么设计呢，即使有代理，在二级缓存代理也可以吧 | 为什么要使用三级缓存呢？**\n\n假设我们现在是二级缓存架构，创建A的时候，我们不知道有没有循环依赖，所以放入二级缓存提前暴露，接着创建B，也是放入二级缓存，这时候发现又循环依赖了A，就去二级缓存找，是有，但是如果此时还有AOP代理呢，我们要的是代理对象可不是原始对象，这怎么办，只能改逻辑，在第一步的时候，不管3721，所有Bean统统去完成AOP代理，如果是这样的话，就不需要三级缓存了，但是这样不仅没有必要，而且违背了Spring在结合AOP跟Bean的生命周期的设计。\n\n所以Spring“多此一举”的将实例先封装到ObjectFactory中（三级缓存），主要关键点在getObject()方法并非直接返回实例，而是对实例又使用SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法对bean进行处理，也就是说，当Spring中存在该后置处理器，所有的单例bean在实例化后都会被进行提前曝光到三级缓存中，但是并不是所有的bean都存在循环依赖，也就是三级缓存到二级缓存的步骤不一定都会被执行，有可能曝光后直接创建完成，没被提前引用过，就直接被加入到一级缓存中。因此可以确保只有提前曝光且被引用的bean才会进行该后置处理。\n\n### 参考\n\n- https://developer.aliyun.com/article/771925?spm=a2c6h.12873581.0.0.322f2fb1GfswWI&groupCode=microservice\n\n\n\n","slug":"spring-forbean","published":1,"updated":"2021-04-08T00:47:07.007Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvv003qqwv2c6353vtk","content":"<h3 id=\"什么是循环依赖\"><a href=\"#什么是循环依赖\" class=\"headerlink\" title=\"什么是循环依赖\"></a>什么是循环依赖</h3><p>所谓的循环依赖是指，A 依赖 B，B 又依赖 A，它们之间形成了循环依赖。或者是 A 依赖 B，B 依赖 C，C 又依赖 A，形成了循环依赖。更或者是自己依赖自己。</p>\n<p><img src=\"/2020/05/10/spring-forbean/1.png\" alt></p>\n<a id=\"more\"></a>\n<p><strong>Spring循环依赖配置和测试类</strong></p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token comment\" spellcheck=\"true\">&lt;!--src\\main\\resources\\applicationContext.xml--></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>beanB<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.xzy.bean.BeanB<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>param1<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>param1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>param2<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>param2<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>beanC<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>beanC<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bean</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>beanC<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.xzy.bean.BeanC<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>param1<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>param1<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>param2<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">value</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>param2<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>beanB<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">ref</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>beanB<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bean</span><span class=\"token punctuation\">></span></span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">testFor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    ClassPathResource resource <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ClassPathResource</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"applicationContext.xml\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    DefaultListableBeanFactory factory <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DefaultListableBeanFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    XmlBeanDefinitionReader reader <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">XmlBeanDefinitionReader</span><span class=\"token punctuation\">(</span>factory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//解析资源</span>\n    reader<span class=\"token punctuation\">.</span><span class=\"token function\">loadBeanDefinitions</span><span class=\"token punctuation\">(</span>resource<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    BeanB bean <span class=\"token operator\">=</span> factory<span class=\"token punctuation\">.</span><span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span>BeanB<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"为什么会有循环依赖问题\"><a href=\"#为什么会有循环依赖问题\" class=\"headerlink\" title=\"为什么会有循环依赖问题\"></a>为什么会有循环依赖问题</h3><p>循环依赖问题主要是由于Spring复杂的生命周期。当我们getBean()获取一个bean时，bean要经历</p>\n<ol>\n<li>从Beandefinition对象通过反射实例化bean对象</li>\n<li>对实例化后的bean进行属性赋值</li>\n<li>bean初始化</li>\n<li>使用bean</li>\n<li>bean销毁</li>\n</ol>\n<p>如果存在循环依赖，假设A对象实例化进行属性赋值时候发现B，由于B还没实例化，接着去实例化B，B实例化属性赋值时发现A。如果不做处理的话就会导致无限循环，也就是循环依赖的问题。</p>\n<h3 id=\"Spring解决循环依赖的思想\"><a href=\"#Spring解决循环依赖的思想\" class=\"headerlink\" title=\"Spring解决循环依赖的思想\"></a>Spring解决循环依赖的思想</h3><p>Spring 实例化对象分两步，第一步会先创建一个原始对象，只是没有设置属性，可以理解为”半成品”，官方叫 A 对象的早期引用（EarlyBeanReference），所以当实例化 B 的时候发现依赖了 A， B就会把这个“半成品”设置进去先完成实例化，既然 B 完成了实例化，所以 A 就可以获得 B 的引用，也完成实例化了。</p>\n<h3 id=\"原理解读\"><a href=\"#原理解读\" class=\"headerlink\" title=\"原理解读\"></a>原理解读</h3><h4 id=\"获取Bean-流程\"><a href=\"#获取Bean-流程\" class=\"headerlink\" title=\"获取Bean 流程\"></a><strong>获取Bean 流程</strong></h4><p>Spring IOC容器中获取bean实例的简化版流程如下</p>\n<img src=\"/2020/05/10/spring-forbean/2.png\" style=\"zoom:50%;\">\n\n<ol>\n<li>流程从 <code>getBean</code> 方法开始，<code>getBean</code> 是个空壳方法，所有逻辑直接到 <code>doGetBean</code> 方法中。</li>\n<li><code>transformedBeanName</code> 将name转换为真正的 beanName（name可能是 FactoryBean 以 &amp; 字符开头或者有别名的情况，所以需要转化下）。</li>\n<li>然后通过 <code>getSingleton(beanName)</code> 方法尝试从缓存中查找是不是有该实例（单例在 Spring 的同一容器只会被创建一次，后续再获取 bean，就直接从缓存获取即可）。</li>\n<li>如果有的话，sharedInstance 可能是完全实例化好的 bean，也可能是一个原始的 bean，所以再经 <code>getObjectForBeanInstance</code> 处理即可返回。</li>\n<li>当然sharedInstance也可能是null，这时候就会执行创建 bean 的逻辑，将结果返回。</li>\n</ol>\n<h4 id=\"三级缓存\"><a href=\"#三级缓存\" class=\"headerlink\" title=\"三级缓存\"></a><strong>三级缓存</strong></h4><p>从getBean的流程来看，解决循环依赖的关键是<strong>将实例化后的对象放到缓存中去，当需要用到时在从缓存中拿。</strong>spring定义了三级缓存来解决循环依赖。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//org.springframework.beans.factory.support.DefaultSingletonBeanRegistry</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> singletonObjects <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">256</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> ObjectFactory<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span> singletonFactories <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> earlySingletonObjects <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>三级缓存的作用：</p>\n<ul>\n<li>singletonObjects：完成初始化的单例对象的cache，这里的bean经历过<strong>实例化-&gt;属性填充-&gt;初始化</strong>以及各种后置处理（一级缓存）</li>\n<li>earlySingletonObjects：存放原始的bean对象（<strong>完成实例化但是尚未填充属性和初始化</strong>），仅仅能作为指针提前曝光，被其他bean所引用，用于解决循环依赖的（二级缓存）</li>\n<li>singletonFactories：在bean实例化完之后，属性填充以及初始化之前，如果允许提前曝光，Spring会将实例化后的bean提前曝光，也就是把该bean转换成<code>beanFactory</code>并加入到<code>singletonFactories</code>（三级缓存）。</li>\n</ul>\n<h4 id=\"创建Bean的流程\"><a href=\"#创建Bean的流程\" class=\"headerlink\" title=\"创建Bean的流程\"></a><strong>创建Bean的流程</strong></h4><p><img src=\"/2020/05/10/spring-forbean/3.png\" alt></p>\n<p><strong>主要代码</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\">\n<span class=\"token comment\" spellcheck=\"true\">//org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</span>\nsharedInstance <span class=\"token operator\">=</span> <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">createBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BeansException</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//异常销毁Bean</span>\n        <span class=\"token function\">destroySingleton</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">throw</span> ex<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> Object <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span>String beanName<span class=\"token punctuation\">,</span> ObjectFactory<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> singletonFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Assert<span class=\"token punctuation\">.</span><span class=\"token function\">notNull</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Bean name must not be null\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonObjects<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Object singletonObject <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonObjects<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>singletonObject <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//创建bean 下面的代码执行的是 createBean(beanName, mbd, args)</span>\n            singletonObject <span class=\"token operator\">=</span> singletonFactory<span class=\"token punctuation\">.</span><span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            newSingleton <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>newSingleton<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//将bean加入到一级缓存中</span>\n                <span class=\"token function\">addSingleton</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> singletonObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> singletonObject<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//将Bean加入到一级缓存，上面说过一级缓存里面的Bean是完整的Bean</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addSingleton</span><span class=\"token punctuation\">(</span>String beanName<span class=\"token punctuation\">,</span> Object singletonObject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonObjects<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonObjects<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> singletonObject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>singletonFactories<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>earlySingletonObjects<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>registeredSingletons<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@Override</span>\n<span class=\"token keyword\">protected</span> Object <span class=\"token function\">createBean</span><span class=\"token punctuation\">(</span>String beanName<span class=\"token punctuation\">,</span> RootBeanDefinition mbd<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@Nullable</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throws</span> BeanCreationException <span class=\"token punctuation\">{</span>\n    Object beanInstance <span class=\"token operator\">=</span> <span class=\"token function\">doCreateBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbdToUse<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> beanInstance<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protected</span> Object <span class=\"token function\">doCreateBean</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> String beanName<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> RootBeanDefinition mbd<span class=\"token punctuation\">,</span> <span class=\"token keyword\">final</span> <span class=\"token annotation punctuation\">@Nullable</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">throws</span> BeanCreationException <span class=\"token punctuation\">{</span>\n    BeanWrapper instanceWrapper <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instanceWrapper <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//实例化Bean</span>\n        instanceWrapper <span class=\"token operator\">=</span> <span class=\"token function\">createBeanInstance</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">boolean</span> earlySingletonExposure <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>mbd<span class=\"token punctuation\">.</span><span class=\"token function\">isSingleton</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>allowCircularReferences <span class=\"token operator\">&amp;&amp;</span>\n            <span class=\"token function\">isSingletonCurrentlyInCreation</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>earlySingletonExposure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//将实例化后的值加入到三级缓存中</span>\n        <span class=\"token function\">addSingletonFactory</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">,</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    Object exposedObject <span class=\"token operator\">=</span> bean<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//属性赋值</span>\n    <span class=\"token function\">populateBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">,</span> instanceWrapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化</span>\n    exposedObject <span class=\"token operator\">=</span> <span class=\"token function\">initializeBean</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> exposedObject<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 循环依赖校验</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>earlySingletonExposure<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 注意此处第二个参数传的false，表示不去三级缓存里再去调用一次getObject()方法了，此时代理对象还在二级缓存，所以这里拿出来的就是个 代理对象</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  </span>\n        <span class=\"token comment\" spellcheck=\"true\">// 这样就保证了我们容器里 最终实际上是代理对象，而非原始对象</span>\n        Object earlySingletonReference <span class=\"token operator\">=</span> <span class=\"token function\">getSingleton</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>earlySingletonReference <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>exposedObject <span class=\"token operator\">==</span> bean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n                exposedObject <span class=\"token operator\">=</span> earlySingletonReference<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> exposedObject<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protected</span> Object <span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span>String beanName<span class=\"token punctuation\">,</span> RootBeanDefinition mbd<span class=\"token punctuation\">,</span> Object bean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Object exposedObject <span class=\"token operator\">=</span> bean<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mbd<span class=\"token punctuation\">.</span><span class=\"token function\">isSynthetic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">hasInstantiationAwareBeanPostProcessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>BeanPostProcessor bp <span class=\"token operator\">:</span> <span class=\"token function\">getBeanPostProcessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bp <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SmartInstantiationAwareBeanPostProcessor</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                SmartInstantiationAwareBeanPostProcessor ibp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>SmartInstantiationAwareBeanPostProcessor<span class=\"token punctuation\">)</span> bp<span class=\"token punctuation\">;</span>\n                exposedObject <span class=\"token operator\">=</span> ibp<span class=\"token punctuation\">.</span><span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span>exposedObject<span class=\"token punctuation\">,</span> beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> exposedObject<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>整个创建Bean流程逻辑如下：</p>\n<ol>\n<li><code>getSingleton</code>方法获取Bean，发现Bean还没创建，则调用<code>createBean</code>创建Bean。</li>\n<li><code>createBeanInstance</code>实例化Bean，实例化后将<code>getEarlyBeanReference</code>创建工厂加入到三级缓存中。</li>\n<li>通过 <code>populateBean</code> 方法向原始 bean 对象中填充属性，并解析依赖。<strong>假设这时候创建A之后填充属性时发现依赖B，然后创建依赖对象B的时候又发现依赖A，还是同样的流程，又去getBean(A)，这个时候三级缓存已经有了beanA的“半成品”，这时就可以把A对象的原始引用注入B对象（并将其移动到二级缓存）来解决循环依赖问题。这时候getObject()方法就算执行结束了，返回完全实例化的bean。</strong></li>\n<li>最后调用 <code>addSingleton</code> 把完全实例化好的bean对象放入 singletonObjects 缓存（一级缓存）中。</li>\n</ol>\n<h4 id=\"循环依赖解决\"><a href=\"#循环依赖解决\" class=\"headerlink\" title=\"循环依赖解决\"></a><strong>循环依赖解决</strong></h4><p><img src=\"/2020/05/10/spring-forbean/4.png\" alt></p>\n<p>当我们创建beanA的原始对象后，并把它放到三级缓存中，接下来就该填充对象属性了，这时候发现依赖了beanB，接着就又去创建beanB，同样的流程，创建完beanB填充属性时又发现它依赖了beanA，又是同样的流程，不同的是，这时候可以在三级缓存中查到刚放进去的原始对象beanA，所以不需要继续创建，用它注入beanB，完成beanB的创建。</p>\n<h4 id=\"为什么需要用到三级缓存？\"><a href=\"#为什么需要用到三级缓存？\" class=\"headerlink\" title=\"为什么需要用到三级缓存？\"></a><strong>为什么需要用到三级缓存？</strong></h4><p>如果按照上面的逻辑，完全可以将缓存放到二级缓存就好，为啥还要三级缓存呢。我们注意到三级缓存放的是bean工厂。具体方法如下。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//将bean创建存入三级缓存</span>\n<span class=\"token function\">addSingletonFactory</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> mbd<span class=\"token punctuation\">,</span> bean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">protected</span> Object <span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span>String beanName<span class=\"token punctuation\">,</span> RootBeanDefinition mbd<span class=\"token punctuation\">,</span> Object bean<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Object exposedObject <span class=\"token operator\">=</span> bean<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mbd<span class=\"token punctuation\">.</span><span class=\"token function\">isSynthetic</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token function\">hasInstantiationAwareBeanPostProcessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>BeanPostProcessor bp <span class=\"token operator\">:</span> <span class=\"token function\">getBeanPostProcessors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>bp <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">SmartInstantiationAwareBeanPostProcessor</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                 <span class=\"token comment\" spellcheck=\"true\">// 这么一大段就这句话是核心，也就是当bean要进行提前曝光时，</span>\n                 <span class=\"token comment\" spellcheck=\"true\">// 给一个机会，通过重写后置处理器的getEarlyBeanReference方法，来自定义操作bean</span>\n                 <span class=\"token comment\" spellcheck=\"true\">// 值得注意的是，如果提前曝光了，但是没有被提前引用，则该后置处理器并不生效!!!</span>\n                 <span class=\"token comment\" spellcheck=\"true\">// 这也正式三级缓存存在的意义，否则二级缓存就可以解决循环依赖的问题</span>\n                SmartInstantiationAwareBeanPostProcessor ibp <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>SmartInstantiationAwareBeanPostProcessor<span class=\"token punctuation\">)</span> bp<span class=\"token punctuation\">;</span>\n                exposedObject <span class=\"token operator\">=</span> ibp<span class=\"token punctuation\">.</span><span class=\"token function\">getEarlyBeanReference</span><span class=\"token punctuation\">(</span>exposedObject<span class=\"token punctuation\">,</span> beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> exposedObject<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这个方法就是 Spring 为什么使用三级缓存，而不是二级缓存的原因，它的目的是为了后置处理，如果没有 AOP 后置处理，就不会走进 if 语句，直接返回了 exposedObject。</p>\n<p>然后我们看下<strong>SmartInstantiationAwareBeanPostProcessor</strong>这个后处理器，其实是用来做SpringAOP，事务使用代理对象的。我们都知道 <strong>Spring AOP、事务</strong>等都是通过代理对象来实现的，而<strong>事务</strong>的代理对象是由自动代理创建器来自动完成的。</p>\n<p><img src=\"/2020/05/10/spring-forbean/5.png\" alt></p>\n<p>所以为啥要用到三级缓存，假设beanA是用AOP代理的，当beanB属性赋值时要获取A时应该获取的是A的代理对象，此时就通过<code>singletonFactory.getObject()</code>获取到代理对象然后在存到二级缓存中。</p>\n<p><strong>为什么这么设计呢，即使有代理，在二级缓存代理也可以吧 | 为什么要使用三级缓存呢？</strong></p>\n<p>假设我们现在是二级缓存架构，创建A的时候，我们不知道有没有循环依赖，所以放入二级缓存提前暴露，接着创建B，也是放入二级缓存，这时候发现又循环依赖了A，就去二级缓存找，是有，但是如果此时还有AOP代理呢，我们要的是代理对象可不是原始对象，这怎么办，只能改逻辑，在第一步的时候，不管3721，所有Bean统统去完成AOP代理，如果是这样的话，就不需要三级缓存了，但是这样不仅没有必要，而且违背了Spring在结合AOP跟Bean的生命周期的设计。</p>\n<p>所以Spring“多此一举”的将实例先封装到ObjectFactory中（三级缓存），主要关键点在getObject()方法并非直接返回实例，而是对实例又使用SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法对bean进行处理，也就是说，当Spring中存在该后置处理器，所有的单例bean在实例化后都会被进行提前曝光到三级缓存中，但是并不是所有的bean都存在循环依赖，也就是三级缓存到二级缓存的步骤不一定都会被执行，有可能曝光后直接创建完成，没被提前引用过，就直接被加入到一级缓存中。因此可以确保只有提前曝光且被引用的bean才会进行该后置处理。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.aliyun.com/article/771925?spm=a2c6h.12873581.0.0.322f2fb1GfswWI&amp;groupCode=microservice\" target=\"_blank\" rel=\"noopener\">https://developer.aliyun.com/article/771925?spm=a2c6h.12873581.0.0.322f2fb1GfswWI&amp;groupCode=microservice</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是循环依赖\"><a href=\"#什么是循环依赖\" class=\"headerlink\" title=\"什么是循环依赖\"></a>什么是循环依赖</h3><p>所谓的循环依赖是指，A 依赖 B，B 又依赖 A，它们之间形成了循环依赖。或者是 A 依赖 B，B 依赖 C，C 又依赖 A，形成了循环依赖。更或者是自己依赖自己。</p>\n<p><img src=\"/2020/05/10/spring-forbean/1.png\" alt></p>","more":"<p><strong>Spring循环依赖配置和测试类</strong></p>\n<pre><code class=\"xml\">&lt;!--src\\main\\resources\\applicationContext.xml--&gt;\n&lt;bean id=&quot;beanB&quot; class=&quot;com.xzy.bean.BeanB&quot;&gt;\n    &lt;property name=&quot;param1&quot; value=&quot;param1&quot;/&gt;\n    &lt;property name=&quot;param2&quot; value=&quot;param2&quot;/&gt;\n    &lt;property name=&quot;beanC&quot; ref=&quot;beanC&quot;/&gt;\n&lt;/bean&gt;\n&lt;bean id=&quot;beanC&quot; class=&quot;com.xzy.bean.BeanC&quot;&gt;\n    &lt;property name=&quot;param1&quot; value=&quot;param1&quot;/&gt;\n    &lt;property name=&quot;param2&quot; value=&quot;param2&quot;/&gt;\n    &lt;property name=&quot;beanB&quot; ref=&quot;beanB&quot;/&gt;\n&lt;/bean&gt;</code></pre>\n<pre><code class=\"java\">@Test\npublic void testFor(){\n    ClassPathResource resource = new ClassPathResource(&quot;applicationContext.xml&quot;);\n    DefaultListableBeanFactory factory = new DefaultListableBeanFactory();\n    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);\n    //解析资源\n    reader.loadBeanDefinitions(resource);\n    BeanB bean = factory.getBean(BeanB.class);\n    System.out.println(bean);\n}</code></pre>\n<h3 id=\"为什么会有循环依赖问题\"><a href=\"#为什么会有循环依赖问题\" class=\"headerlink\" title=\"为什么会有循环依赖问题\"></a>为什么会有循环依赖问题</h3><p>循环依赖问题主要是由于Spring复杂的生命周期。当我们getBean()获取一个bean时，bean要经历</p>\n<ol>\n<li>从Beandefinition对象通过反射实例化bean对象</li>\n<li>对实例化后的bean进行属性赋值</li>\n<li>bean初始化</li>\n<li>使用bean</li>\n<li>bean销毁</li>\n</ol>\n<p>如果存在循环依赖，假设A对象实例化进行属性赋值时候发现B，由于B还没实例化，接着去实例化B，B实例化属性赋值时发现A。如果不做处理的话就会导致无限循环，也就是循环依赖的问题。</p>\n<h3 id=\"Spring解决循环依赖的思想\"><a href=\"#Spring解决循环依赖的思想\" class=\"headerlink\" title=\"Spring解决循环依赖的思想\"></a>Spring解决循环依赖的思想</h3><p>Spring 实例化对象分两步，第一步会先创建一个原始对象，只是没有设置属性，可以理解为”半成品”，官方叫 A 对象的早期引用（EarlyBeanReference），所以当实例化 B 的时候发现依赖了 A， B就会把这个“半成品”设置进去先完成实例化，既然 B 完成了实例化，所以 A 就可以获得 B 的引用，也完成实例化了。</p>\n<h3 id=\"原理解读\"><a href=\"#原理解读\" class=\"headerlink\" title=\"原理解读\"></a>原理解读</h3><h4 id=\"获取Bean-流程\"><a href=\"#获取Bean-流程\" class=\"headerlink\" title=\"获取Bean 流程\"></a><strong>获取Bean 流程</strong></h4><p>Spring IOC容器中获取bean实例的简化版流程如下</p>\n<img src=\"/2020/05/10/spring-forbean/2.png\" style=\"zoom:50%;\">\n\n<ol>\n<li>流程从 <code>getBean</code> 方法开始，<code>getBean</code> 是个空壳方法，所有逻辑直接到 <code>doGetBean</code> 方法中。</li>\n<li><code>transformedBeanName</code> 将name转换为真正的 beanName（name可能是 FactoryBean 以 &amp; 字符开头或者有别名的情况，所以需要转化下）。</li>\n<li>然后通过 <code>getSingleton(beanName)</code> 方法尝试从缓存中查找是不是有该实例（单例在 Spring 的同一容器只会被创建一次，后续再获取 bean，就直接从缓存获取即可）。</li>\n<li>如果有的话，sharedInstance 可能是完全实例化好的 bean，也可能是一个原始的 bean，所以再经 <code>getObjectForBeanInstance</code> 处理即可返回。</li>\n<li>当然sharedInstance也可能是null，这时候就会执行创建 bean 的逻辑，将结果返回。</li>\n</ol>\n<h4 id=\"三级缓存\"><a href=\"#三级缓存\" class=\"headerlink\" title=\"三级缓存\"></a><strong>三级缓存</strong></h4><p>从getBean的流程来看，解决循环依赖的关键是<strong>将实例化后的对象放到缓存中去，当需要用到时在从缓存中拿。</strong>spring定义了三级缓存来解决循环依赖。</p>\n<pre><code class=\"java\">//org.springframework.beans.factory.support.DefaultSingletonBeanRegistry\nprivate final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);\nprivate final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);\nprivate final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16);</code></pre>\n<p>三级缓存的作用：</p>\n<ul>\n<li>singletonObjects：完成初始化的单例对象的cache，这里的bean经历过<strong>实例化-&gt;属性填充-&gt;初始化</strong>以及各种后置处理（一级缓存）</li>\n<li>earlySingletonObjects：存放原始的bean对象（<strong>完成实例化但是尚未填充属性和初始化</strong>），仅仅能作为指针提前曝光，被其他bean所引用，用于解决循环依赖的（二级缓存）</li>\n<li>singletonFactories：在bean实例化完之后，属性填充以及初始化之前，如果允许提前曝光，Spring会将实例化后的bean提前曝光，也就是把该bean转换成<code>beanFactory</code>并加入到<code>singletonFactories</code>（三级缓存）。</li>\n</ul>\n<h4 id=\"创建Bean的流程\"><a href=\"#创建Bean的流程\" class=\"headerlink\" title=\"创建Bean的流程\"></a><strong>创建Bean的流程</strong></h4><p><img src=\"/2020/05/10/spring-forbean/3.png\" alt></p>\n<p><strong>主要代码</strong></p>\n<pre><code class=\"java\">\n//org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean\nsharedInstance = getSingleton(beanName, () -&gt; {\n    try {\n        return createBean(beanName, mbd, args);\n    }\n    catch (BeansException ex) {\n        //异常销毁Bean\n        destroySingleton(beanName);\n        throw ex;\n    }\n});\n\npublic Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {\n    Assert.notNull(beanName, &quot;Bean name must not be null&quot;);\n    synchronized (this.singletonObjects) {\n        Object singletonObject = this.singletonObjects.get(beanName);\n        if (singletonObject == null) {\n            //创建bean 下面的代码执行的是 createBean(beanName, mbd, args)\n            singletonObject = singletonFactory.getObject();\n            newSingleton = true;\n            if (newSingleton) {\n                //将bean加入到一级缓存中\n                addSingleton(beanName, singletonObject);\n\n            }\n        }\n        return singletonObject;\n    }\n}\n//将Bean加入到一级缓存，上面说过一级缓存里面的Bean是完整的Bean\nprotected void addSingleton(String beanName, Object singletonObject) {\n    synchronized (this.singletonObjects) {\n        this.singletonObjects.put(beanName, singletonObject);\n        this.singletonFactories.remove(beanName);\n        this.earlySingletonObjects.remove(beanName);\n        this.registeredSingletons.add(beanName);\n    }\n}\n\n@Override\nprotected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)\n        throws BeanCreationException {\n    Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n    return beanInstance;\n}\n\nprotected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)\n        throws BeanCreationException {\n    BeanWrapper instanceWrapper = null;\n    if (instanceWrapper == null) {\n        //实例化Bean\n        instanceWrapper = createBeanInstance(beanName, mbd, args);\n    }\n    boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp;\n            isSingletonCurrentlyInCreation(beanName));\n    if (earlySingletonExposure) {\n        //将实例化后的值加入到三级缓存中\n        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n    }\n    Object exposedObject = bean;\n    //属性赋值\n    populateBean(beanName, mbd, instanceWrapper);\n    //初始化\n    exposedObject = initializeBean(beanName, exposedObject, mbd);\n      // 循环依赖校验\n    if (earlySingletonExposure) {\n        // 注意此处第二个参数传的false，表示不去三级缓存里再去调用一次getObject()方法了，此时代理对象还在二级缓存，所以这里拿出来的就是个 代理对象\n        // 最后赋值给exposedObject  然后return出去，进而最终被addSingleton()添加进一级缓存里面去  \n        // 这样就保证了我们容器里 最终实际上是代理对象，而非原始对象\n        Object earlySingletonReference = getSingleton(beanName, false);\n        if (earlySingletonReference != null) {\n            if (exposedObject == bean) { \n                exposedObject = earlySingletonReference;\n            }\n        }\n    }\n    return exposedObject;\n}\n\nprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n    Object exposedObject = bean;\n    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;\n                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n            }\n        }\n    }\n    return exposedObject;\n}</code></pre>\n<p>整个创建Bean流程逻辑如下：</p>\n<ol>\n<li><code>getSingleton</code>方法获取Bean，发现Bean还没创建，则调用<code>createBean</code>创建Bean。</li>\n<li><code>createBeanInstance</code>实例化Bean，实例化后将<code>getEarlyBeanReference</code>创建工厂加入到三级缓存中。</li>\n<li>通过 <code>populateBean</code> 方法向原始 bean 对象中填充属性，并解析依赖。<strong>假设这时候创建A之后填充属性时发现依赖B，然后创建依赖对象B的时候又发现依赖A，还是同样的流程，又去getBean(A)，这个时候三级缓存已经有了beanA的“半成品”，这时就可以把A对象的原始引用注入B对象（并将其移动到二级缓存）来解决循环依赖问题。这时候getObject()方法就算执行结束了，返回完全实例化的bean。</strong></li>\n<li>最后调用 <code>addSingleton</code> 把完全实例化好的bean对象放入 singletonObjects 缓存（一级缓存）中。</li>\n</ol>\n<h4 id=\"循环依赖解决\"><a href=\"#循环依赖解决\" class=\"headerlink\" title=\"循环依赖解决\"></a><strong>循环依赖解决</strong></h4><p><img src=\"/2020/05/10/spring-forbean/4.png\" alt></p>\n<p>当我们创建beanA的原始对象后，并把它放到三级缓存中，接下来就该填充对象属性了，这时候发现依赖了beanB，接着就又去创建beanB，同样的流程，创建完beanB填充属性时又发现它依赖了beanA，又是同样的流程，不同的是，这时候可以在三级缓存中查到刚放进去的原始对象beanA，所以不需要继续创建，用它注入beanB，完成beanB的创建。</p>\n<h4 id=\"为什么需要用到三级缓存？\"><a href=\"#为什么需要用到三级缓存？\" class=\"headerlink\" title=\"为什么需要用到三级缓存？\"></a><strong>为什么需要用到三级缓存？</strong></h4><p>如果按照上面的逻辑，完全可以将缓存放到二级缓存就好，为啥还要三级缓存呢。我们注意到三级缓存放的是bean工厂。具体方法如下。</p>\n<pre><code class=\"java\">//将bean创建存入三级缓存\naddSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));\n\nprotected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {\n    Object exposedObject = bean;\n    if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {\n        for (BeanPostProcessor bp : getBeanPostProcessors()) {\n            if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {\n                 // 这么一大段就这句话是核心，也就是当bean要进行提前曝光时，\n                 // 给一个机会，通过重写后置处理器的getEarlyBeanReference方法，来自定义操作bean\n                 // 值得注意的是，如果提前曝光了，但是没有被提前引用，则该后置处理器并不生效!!!\n                 // 这也正式三级缓存存在的意义，否则二级缓存就可以解决循环依赖的问题\n                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;\n                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);\n            }\n        }\n    }\n    return exposedObject;\n}</code></pre>\n<p>这个方法就是 Spring 为什么使用三级缓存，而不是二级缓存的原因，它的目的是为了后置处理，如果没有 AOP 后置处理，就不会走进 if 语句，直接返回了 exposedObject。</p>\n<p>然后我们看下<strong>SmartInstantiationAwareBeanPostProcessor</strong>这个后处理器，其实是用来做SpringAOP，事务使用代理对象的。我们都知道 <strong>Spring AOP、事务</strong>等都是通过代理对象来实现的，而<strong>事务</strong>的代理对象是由自动代理创建器来自动完成的。</p>\n<p><img src=\"/2020/05/10/spring-forbean/5.png\" alt></p>\n<p>所以为啥要用到三级缓存，假设beanA是用AOP代理的，当beanB属性赋值时要获取A时应该获取的是A的代理对象，此时就通过<code>singletonFactory.getObject()</code>获取到代理对象然后在存到二级缓存中。</p>\n<p><strong>为什么这么设计呢，即使有代理，在二级缓存代理也可以吧 | 为什么要使用三级缓存呢？</strong></p>\n<p>假设我们现在是二级缓存架构，创建A的时候，我们不知道有没有循环依赖，所以放入二级缓存提前暴露，接着创建B，也是放入二级缓存，这时候发现又循环依赖了A，就去二级缓存找，是有，但是如果此时还有AOP代理呢，我们要的是代理对象可不是原始对象，这怎么办，只能改逻辑，在第一步的时候，不管3721，所有Bean统统去完成AOP代理，如果是这样的话，就不需要三级缓存了，但是这样不仅没有必要，而且违背了Spring在结合AOP跟Bean的生命周期的设计。</p>\n<p>所以Spring“多此一举”的将实例先封装到ObjectFactory中（三级缓存），主要关键点在getObject()方法并非直接返回实例，而是对实例又使用SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法对bean进行处理，也就是说，当Spring中存在该后置处理器，所有的单例bean在实例化后都会被进行提前曝光到三级缓存中，但是并不是所有的bean都存在循环依赖，也就是三级缓存到二级缓存的步骤不一定都会被执行，有可能曝光后直接创建完成，没被提前引用过，就直接被加入到一级缓存中。因此可以确保只有提前曝光且被引用的bean才会进行该后置处理。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://developer.aliyun.com/article/771925?spm=a2c6h.12873581.0.0.322f2fb1GfswWI&amp;groupCode=microservice\" target=\"_blank\" rel=\"noopener\">https://developer.aliyun.com/article/771925?spm=a2c6h.12873581.0.0.322f2fb1GfswWI&amp;groupCode=microservice</a></li>\n</ul>"},{"title":"ShardingPhere使用中遇到的问题记录","description":"ShardingPhere使用中遇到的问题记录","date":"2021-02-02T08:43:15.000Z","_content":"\n### **问题1：shardingphere启动慢**\n\n项目中使用了shardingphere分库分表，在使用了一段时间后发现项目启动越来越慢，原因定位在加载shardingphere时耗时比较长。但不知道具体是哪一个步骤。\n\n**定位可能原因：一般情况下我们项目会用到数据库连接池，在shardingjdbc启动时会初始化数据库连接池，可能是其中一台机器初始化连接时超时导致整体启动时间慢。**\n\n很遗憾不是这个问题，通过打印连接日志，数据库连接速度很快，不是这个问题导致的。无奈之下，跟了一遍shardingjdbc启动源码，发现问题所在。\n\n**定位原因：在shardingjdbc启动时，会加载分库分表中所有的表结构进行校验，判断是否所有的表结构都是一致的。**\n<!--more-->\n在项目中，使用了分库分表 + 读写分离的方式。假设现在有一个表(user表)采用分库分表读写分离。分库分表规则如下：\n\n- 分库规则：4个库，按照日期%4的方式\n- 分表规则：每个月一个表，一共12个表\n- 读写分离：一主一从\n\n根据上面的规则，在对表结构校验时一共需要加载 4（4个库） * 12（12张表） * 3（三个机房）= 144张表进行校验。 由于我们项目中一共有接近100张这样的表规则，且每个表的都是很长字段数的表，导致了`从数据库加载表结构`和`表结构校验`这两个步骤变得异常慢。具体代码在类\n\n```java\nio.shardingsphere.core.metadata.table.executor.TableMetaDataLoader\n```\n\n ![](shardingphere-problem/1.png)\n\n**解决方案**\n\n由于查了下shardingPhere的开发文档都没有一个配置用来关掉校验的，所以在解放方法上我们采用两种方式：\n\n- 下载shardingphere对应版本的源代码，修改后替换仓库中的jar包\n- 如果你是用tomcat服务器，利用tomcat类加载机制，在项目中重写TableMetaDataLoader类，然后更改源码。\n\n所以，更改源码后，去掉了这个校验。\n\n![](shardingphere-problem/2.png)\n\n### **问题1：普通的查询SQL没有路由**\n\n使用的数据库是MySQL，SQL语句如下。分片键是`time`\n\n```java\nSELECT ID,USERNAME .... FROM USER where time = '20200802'\n```\n\n**定位原因：time是MySQL的特殊字段，sharding在做词法分析时如果使用了特殊字段会出现问题**\n\n**解决方法**\n\n- 不用使用time命名。\n- 更改语句，将time用\\`\\`字符包装起来。\n\n```\nSELECT ID,USERNAME .... FROM USER where `time` = '20200802'\n```\n\n","source":"_posts/shardingphere-problem.md","raw":"---\ntitle: ShardingPhere使用中遇到的问题记录\ntags:\n  - shardingjdbc\ncategories: \n  - shardingjdbc\ndescription : ShardingPhere使用中遇到的问题记录\ndate: 2021-02-02 16:43:15\n---\n\n### **问题1：shardingphere启动慢**\n\n项目中使用了shardingphere分库分表，在使用了一段时间后发现项目启动越来越慢，原因定位在加载shardingphere时耗时比较长。但不知道具体是哪一个步骤。\n\n**定位可能原因：一般情况下我们项目会用到数据库连接池，在shardingjdbc启动时会初始化数据库连接池，可能是其中一台机器初始化连接时超时导致整体启动时间慢。**\n\n很遗憾不是这个问题，通过打印连接日志，数据库连接速度很快，不是这个问题导致的。无奈之下，跟了一遍shardingjdbc启动源码，发现问题所在。\n\n**定位原因：在shardingjdbc启动时，会加载分库分表中所有的表结构进行校验，判断是否所有的表结构都是一致的。**\n<!--more-->\n在项目中，使用了分库分表 + 读写分离的方式。假设现在有一个表(user表)采用分库分表读写分离。分库分表规则如下：\n\n- 分库规则：4个库，按照日期%4的方式\n- 分表规则：每个月一个表，一共12个表\n- 读写分离：一主一从\n\n根据上面的规则，在对表结构校验时一共需要加载 4（4个库） * 12（12张表） * 3（三个机房）= 144张表进行校验。 由于我们项目中一共有接近100张这样的表规则，且每个表的都是很长字段数的表，导致了`从数据库加载表结构`和`表结构校验`这两个步骤变得异常慢。具体代码在类\n\n```java\nio.shardingsphere.core.metadata.table.executor.TableMetaDataLoader\n```\n\n ![](shardingphere-problem/1.png)\n\n**解决方案**\n\n由于查了下shardingPhere的开发文档都没有一个配置用来关掉校验的，所以在解放方法上我们采用两种方式：\n\n- 下载shardingphere对应版本的源代码，修改后替换仓库中的jar包\n- 如果你是用tomcat服务器，利用tomcat类加载机制，在项目中重写TableMetaDataLoader类，然后更改源码。\n\n所以，更改源码后，去掉了这个校验。\n\n![](shardingphere-problem/2.png)\n\n### **问题1：普通的查询SQL没有路由**\n\n使用的数据库是MySQL，SQL语句如下。分片键是`time`\n\n```java\nSELECT ID,USERNAME .... FROM USER where time = '20200802'\n```\n\n**定位原因：time是MySQL的特殊字段，sharding在做词法分析时如果使用了特殊字段会出现问题**\n\n**解决方法**\n\n- 不用使用time命名。\n- 更改语句，将time用\\`\\`字符包装起来。\n\n```\nSELECT ID,USERNAME .... FROM USER where `time` = '20200802'\n```\n\n","slug":"shardingphere-problem","published":1,"updated":"2021-04-08T00:47:06.987Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvw003tqwv2c41fb2zf","content":"<h3 id=\"问题1：shardingphere启动慢\"><a href=\"#问题1：shardingphere启动慢\" class=\"headerlink\" title=\"问题1：shardingphere启动慢\"></a><strong>问题1：shardingphere启动慢</strong></h3><p>项目中使用了shardingphere分库分表，在使用了一段时间后发现项目启动越来越慢，原因定位在加载shardingphere时耗时比较长。但不知道具体是哪一个步骤。</p>\n<p><strong>定位可能原因：一般情况下我们项目会用到数据库连接池，在shardingjdbc启动时会初始化数据库连接池，可能是其中一台机器初始化连接时超时导致整体启动时间慢。</strong></p>\n<p>很遗憾不是这个问题，通过打印连接日志，数据库连接速度很快，不是这个问题导致的。无奈之下，跟了一遍shardingjdbc启动源码，发现问题所在。</p>\n<p><strong>定位原因：在shardingjdbc启动时，会加载分库分表中所有的表结构进行校验，判断是否所有的表结构都是一致的。</strong></p>\n<a id=\"more\"></a>\n<p>在项目中，使用了分库分表 + 读写分离的方式。假设现在有一个表(user表)采用分库分表读写分离。分库分表规则如下：</p>\n<ul>\n<li>分库规则：4个库，按照日期%4的方式</li>\n<li>分表规则：每个月一个表，一共12个表</li>\n<li>读写分离：一主一从</li>\n</ul>\n<p>根据上面的规则，在对表结构校验时一共需要加载 4（4个库） * 12（12张表） * 3（三个机房）= 144张表进行校验。 由于我们项目中一共有接近100张这样的表规则，且每个表的都是很长字段数的表，导致了<code>从数据库加载表结构</code>和<code>表结构校验</code>这两个步骤变得异常慢。具体代码在类</p>\n<pre class=\" language-java\"><code class=\"language-java\">io<span class=\"token punctuation\">.</span>shardingsphere<span class=\"token punctuation\">.</span>core<span class=\"token punctuation\">.</span>metadata<span class=\"token punctuation\">.</span>table<span class=\"token punctuation\">.</span>executor<span class=\"token punctuation\">.</span>TableMetaDataLoader</code></pre>\n<p> <img src=\"/2021/02/02/shardingphere-problem/1.png\" alt></p>\n<p><strong>解决方案</strong></p>\n<p>由于查了下shardingPhere的开发文档都没有一个配置用来关掉校验的，所以在解放方法上我们采用两种方式：</p>\n<ul>\n<li>下载shardingphere对应版本的源代码，修改后替换仓库中的jar包</li>\n<li>如果你是用tomcat服务器，利用tomcat类加载机制，在项目中重写TableMetaDataLoader类，然后更改源码。</li>\n</ul>\n<p>所以，更改源码后，去掉了这个校验。</p>\n<p><img src=\"/2021/02/02/shardingphere-problem/2.png\" alt></p>\n<h3 id=\"问题1：普通的查询SQL没有路由\"><a href=\"#问题1：普通的查询SQL没有路由\" class=\"headerlink\" title=\"问题1：普通的查询SQL没有路由\"></a><strong>问题1：普通的查询SQL没有路由</strong></h3><p>使用的数据库是MySQL，SQL语句如下。分片键是<code>time</code></p>\n<pre class=\" language-java\"><code class=\"language-java\">SELECT ID<span class=\"token punctuation\">,</span>USERNAME <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> FROM USER where time <span class=\"token operator\">=</span> <span class=\"token string\">'20200802'</span></code></pre>\n<p><strong>定位原因：time是MySQL的特殊字段，sharding在做词法分析时如果使用了特殊字段会出现问题</strong></p>\n<p><strong>解决方法</strong></p>\n<ul>\n<li>不用使用time命名。</li>\n<li>更改语句，将time用``字符包装起来。</li>\n</ul>\n<pre><code>SELECT ID,USERNAME .... FROM USER where `time` = &#39;20200802&#39;</code></pre>","site":{"data":{}},"excerpt":"<h3 id=\"问题1：shardingphere启动慢\"><a href=\"#问题1：shardingphere启动慢\" class=\"headerlink\" title=\"问题1：shardingphere启动慢\"></a><strong>问题1：shardingphere启动慢</strong></h3><p>项目中使用了shardingphere分库分表，在使用了一段时间后发现项目启动越来越慢，原因定位在加载shardingphere时耗时比较长。但不知道具体是哪一个步骤。</p>\n<p><strong>定位可能原因：一般情况下我们项目会用到数据库连接池，在shardingjdbc启动时会初始化数据库连接池，可能是其中一台机器初始化连接时超时导致整体启动时间慢。</strong></p>\n<p>很遗憾不是这个问题，通过打印连接日志，数据库连接速度很快，不是这个问题导致的。无奈之下，跟了一遍shardingjdbc启动源码，发现问题所在。</p>\n<p><strong>定位原因：在shardingjdbc启动时，会加载分库分表中所有的表结构进行校验，判断是否所有的表结构都是一致的。</strong></p>","more":"<p>在项目中，使用了分库分表 + 读写分离的方式。假设现在有一个表(user表)采用分库分表读写分离。分库分表规则如下：</p>\n<ul>\n<li>分库规则：4个库，按照日期%4的方式</li>\n<li>分表规则：每个月一个表，一共12个表</li>\n<li>读写分离：一主一从</li>\n</ul>\n<p>根据上面的规则，在对表结构校验时一共需要加载 4（4个库） * 12（12张表） * 3（三个机房）= 144张表进行校验。 由于我们项目中一共有接近100张这样的表规则，且每个表的都是很长字段数的表，导致了<code>从数据库加载表结构</code>和<code>表结构校验</code>这两个步骤变得异常慢。具体代码在类</p>\n<pre><code class=\"java\">io.shardingsphere.core.metadata.table.executor.TableMetaDataLoader</code></pre>\n<p> <img src=\"/2021/02/02/shardingphere-problem/1.png\" alt></p>\n<p><strong>解决方案</strong></p>\n<p>由于查了下shardingPhere的开发文档都没有一个配置用来关掉校验的，所以在解放方法上我们采用两种方式：</p>\n<ul>\n<li>下载shardingphere对应版本的源代码，修改后替换仓库中的jar包</li>\n<li>如果你是用tomcat服务器，利用tomcat类加载机制，在项目中重写TableMetaDataLoader类，然后更改源码。</li>\n</ul>\n<p>所以，更改源码后，去掉了这个校验。</p>\n<p><img src=\"/2021/02/02/shardingphere-problem/2.png\" alt></p>\n<h3 id=\"问题1：普通的查询SQL没有路由\"><a href=\"#问题1：普通的查询SQL没有路由\" class=\"headerlink\" title=\"问题1：普通的查询SQL没有路由\"></a><strong>问题1：普通的查询SQL没有路由</strong></h3><p>使用的数据库是MySQL，SQL语句如下。分片键是<code>time</code></p>\n<pre><code class=\"java\">SELECT ID,USERNAME .... FROM USER where time = &#39;20200802&#39;</code></pre>\n<p><strong>定位原因：time是MySQL的特殊字段，sharding在做词法分析时如果使用了特殊字段会出现问题</strong></p>\n<p><strong>解决方法</strong></p>\n<ul>\n<li>不用使用time命名。</li>\n<li>更改语句，将time用``字符包装起来。</li>\n</ul>\n<pre><code>SELECT ID,USERNAME .... FROM USER where `time` = &#39;20200802&#39;</code></pre>"},{"title":"SpringBoot自动配置原理和自定义起步依赖","description":"SpringBoot自动配置原理和自定义起步依赖","date":"2020-09-27T02:32:09.000Z","_content":"\n## 概述\n\nSpringBoot采用了“习惯优于配置”的理念，没有了繁琐的配置，让我们开发起来变得更加快捷。例如我们需要在项目中使用Redis模块进行开发。只需要引入spring-boot-starter-data-redis包，就会自动加载了Redis所需要的模块。我们只需要在配置文件application.properties上配置redis的相关连接信息，并在代码上使用RedisTemplate.java类就可以操作Redis。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n<!--more-->\n类似的这种起步依赖大大降低了我们的配置成本。在SpringBoot中大概分成两类起步依赖：**SpringBoot自带起步依赖** 和 **开发者自带起步依赖**。\n\n- spring-boot-starter-xxx是官方提供的starter。\n\n- xxx-spring-boot-starter是第三方提供的starter。\n\n## 自动配置原理\n\nSpringBoot的自动配置原理依赖于spring-boot-autoconfigure-xxx包。对应的**@EnableAutoConfiguration**注解。\n\n![](springboot-custom-start/1.png)\n\n在我们SpringBoot启动代码上使用了@SpringBootApplication注解，里面包含了@EnableAutoConfiguration。从字面看上不难猜出这个开启自动配置的意思。\n\n```java\n@SpringBootApplication\npublic class SpringbootprojectApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootprojectApplication.class, args);\n    }\n}\n```\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration //开启自动注解\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n\t//...忽略\n}\n```\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n\t//..忽略\n}\n```\n\n@EnableAutoConfiguration注解通过@Import导入了AutoConfigurationImportSelector.class。\n\n其导入的**AutoConfigurationImportSelector**的selectImports()方法通过**SpringFactoriesLoader.loadFactoryNames()**扫描所有具有**META-INF/spring.factories**的jar包。spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。\n\n![](springboot-custom-start/3.png)\n\n到这一步我们知道了自动配置的其中原理：<font color=red>SpringBoot在启动时通过注解@EnableAutoConfiguration。扫描class路径下的spring.factories文件。将key = org.springframework.boot.autoconfigure.EnableAutoConfiguration 下的配置加载到Bean容器中，这样就自动配置上了相关的类。</font>\n\n到这一步我们知道了SpingBoot是如何通过导入Maven包就能将RedisAutoConfiguration交给spring容器管理。而不用我们自己创建一个Redis配置类去写一大堆的配置。**但我们知道，往往要完成自动配置并能使用是有依赖条件。例如你需要定义Redis的配置信息(IP,端口等)，需要依赖Redis的操作类。**所以SpringBoot提供了一系列的条件依赖注解。\n\n- @ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。\n- @ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。\n- @ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。\n- @ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。\n- @ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。\n- @ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。\n- @AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。\n- @AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。\n- @ConditionalOnProperty，当存在某个配置的时候才加载\n- @EnableConfigurationProperties(xxxProperties.class)，使@ConfigurationProperties注解生效，将yml或properties配置文件转换成bean。\n\n**具体分析下Redis配置类**\n\n```java\n//标明这个类是一个配置类\n@Configuration(proxyBeanMethods = false)\n//当路径下存在RedisOperations.class类时才加载这个配置类\n@ConditionalOnClass(RedisOperations.class)\n//将yml或properties文件的配置映射到RedisProperties.class类上\n@EnableConfigurationProperties(RedisProperties.class)\n//@Import作用就跟<import />标签作用一样，这里是表示在加载RedisAutoConfiguration这个配置类的时候\n//导入LettuceConnectionConfiguration这个配置类，最新的springboot使用lettuce作为redis的客户端\n@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\npublic class RedisAutoConfiguration {\n    //这里就是帮我们自动配置了RedisTemplate类，代码上就可以直接通过RedisTemplate进行代码编写\n\t@Bean\n    //@ConditionalOnMissingBean这个的意思是表示spring容器中没有redisTemplate类的时候才配置，不然不配置。\n\t@ConditionalOnMissingBean(name = \"redisTemplate\")\n\tpublic RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\n\t\t\tthrows UnknownHostException {\n\t\tRedisTemplate<Object, Object> template = new RedisTemplate<>();\n\t\ttemplate.setConnectionFactory(redisConnectionFactory);\n\t\treturn template;\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)\n\t\t\tthrows UnknownHostException {\n\t\tStringRedisTemplate template = new StringRedisTemplate();\n\t\ttemplate.setConnectionFactory(redisConnectionFactory);\n\t\treturn template;\n\t}\n}\n\n@ConfigurationProperties(prefix = \"spring.redis\")\npublic class RedisProperties {\n\tprivate String url;\n    private String host = \"localhost\";\n}\n```\n\n到这里我们知道了**SpringBoot自动配置的原理。**通过一张图做个总结。\n\n![](springboot-custom-start/4.png)\n\n## Mybatis起步依赖\n\nspring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。上面说的Redis是SpringBoot官方提供的起步依赖。对于Mybatis来说，是第三方提供的起步依赖。我们具体来看他是怎么实现的。\n\n```java\n<dependency>\n\t<groupId>org.mybatis.spring.boot</groupId>\n\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t<version>1.3.2</version>\n</dependency>\n```\n\n![](springboot-custom-start/5.png)\n\nMybatis的starter通过注入mybatis-spring-boot-starter包实现。包含了\n\n- mybatis-spring-boot-autoconfigure ， 自动注入相关包\n- mybatis， mybatis核心包\n- mybatis-spring， mybatis-spring包\n- spring-boot-starter-jdbc ，spring的jbdc包，mybatis需要依赖jdbc。\n\n查看mybatis-spring-boot-autoconfigure，同样的也有**spring.factories**。里面也是形如org.springframework.boot.autoconfigure.EnableAutoConfiguration = XXXConfiguration的配置项。\n\n![](springboot-custom-start/6.png)\n\n```java\npackage org.mybatis.spring.boot.autoconfigure;\n//...省略很多\n@Configuration //这个类是个配置类\n//当class路径下有SqlSessionFactory和SqlSessionFactoryBean这个两个class时才加载这个配置类（所以前提是引入mybatis类）\n@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class})\n//当spring上下文存在数据源时才配置。区别与上面的@ConditionalOnClass。mybatis是需要数据源的，如果没有数据源就没意义\n@ConditionalOnBean({DataSource.class})\n//yml或properties映射到MybatisProperties类\n@EnableConfigurationProperties({MybatisProperties.class})\n//当前这个类的配置必须等到DataSourceAutoConfiguration.class先配置完后再配置\n@AutoConfigureAfter({DataSourceAutoConfiguration.class})\npublic class MybatisAutoConfiguration {\n    //...省略很多\n\n    @PostConstruct\n    public void checkConfigFileExists() {\n        if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {\n            Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());\n            Assert.state(resource.exists(), \"Cannot find config location: \" + resource + \" (please add config file or check your Mybatis configuration)\");\n        }\n    }\n\n    //自动注入SqlSessionFactory\n    @Bean\n    @ConditionalOnMissingBean\n    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n        //...省略很多\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n        ExecutorType executorType = this.properties.getExecutorType();\n        return executorType != null ? new SqlSessionTemplate(sqlSessionFactory, executorType) : new SqlSessionTemplate(sqlSessionFactory);\n    }\n\n    //这里MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar应该是自动扫描实现了Mapper的类加入到spring容器\n    @Configuration\n    @Import({MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class})\n    @ConditionalOnMissingBean({MapperFactoryBean.class})\n    public static class MapperScannerRegistrarNotFoundConfiguration {\n        public MapperScannerRegistrarNotFoundConfiguration() {\n        }\n\n        @PostConstruct\n        public void afterPropertiesSet() {\n            MybatisAutoConfiguration.logger.debug(\"No {} found.\", MapperFactoryBean.class.getName());\n        }\n    }\n\n    public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar, ResourceLoaderAware {\n        private BeanFactory beanFactory;\n        private ResourceLoader resourceLoader;\n\n        public AutoConfiguredMapperScannerRegistrar() {\n        }\n\n        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n            //....省略很多\n        }\n\n        public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n            this.beanFactory = beanFactory;\n        }\n\n        public void setResourceLoader(ResourceLoader resourceLoader) {\n            this.resourceLoader = resourceLoader;\n        }\n    }\n}\n```\n\n## 自定义一个起步依赖\n\n在项目上Redis使用频繁，要求将Redis操作的工具类做成一个starter，让其他项目能够复用。\n\n1. 创建一个新项目 **xuzy-spring-redis-starter**\n2. 导入**spring-boot-starter-data-redis**依赖\n3. 创建**META-INF/spring.factories**文件并设置启动配置类。\n4. 创建启动配置类**RedisAutoConfig**\n\n![](springboot-custom-start/7.png)\n\n如果所示，我们参考Mybatis自动配置的方式。我们在配置类上使用了@AutoConfigureAfter(RedisTemplate.class)来保证当RedisTemplate被实例化后才加载工具类。最后我们通过@Bean注入了RedisUtil工具类。\n\n在实际项目上，我们可以根据自动配置条件依赖来更好的定义starter。上面的例子只是大概写一个过程。我们可以根据实际需要做配置。\n\n\n\n","source":"_posts/springboot-custom-start.md","raw":"---\ntitle: SpringBoot自动配置原理和自定义起步依赖\ntags:\n  - spring\ncategories: \n  - spring\ndescription : SpringBoot自动配置原理和自定义起步依赖\ndate: 2020-09-27 10:32:09\n---\n\n## 概述\n\nSpringBoot采用了“习惯优于配置”的理念，没有了繁琐的配置，让我们开发起来变得更加快捷。例如我们需要在项目中使用Redis模块进行开发。只需要引入spring-boot-starter-data-redis包，就会自动加载了Redis所需要的模块。我们只需要在配置文件application.properties上配置redis的相关连接信息，并在代码上使用RedisTemplate.java类就可以操作Redis。\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n<!--more-->\n类似的这种起步依赖大大降低了我们的配置成本。在SpringBoot中大概分成两类起步依赖：**SpringBoot自带起步依赖** 和 **开发者自带起步依赖**。\n\n- spring-boot-starter-xxx是官方提供的starter。\n\n- xxx-spring-boot-starter是第三方提供的starter。\n\n## 自动配置原理\n\nSpringBoot的自动配置原理依赖于spring-boot-autoconfigure-xxx包。对应的**@EnableAutoConfiguration**注解。\n\n![](springboot-custom-start/1.png)\n\n在我们SpringBoot启动代码上使用了@SpringBootApplication注解，里面包含了@EnableAutoConfiguration。从字面看上不难猜出这个开启自动配置的意思。\n\n```java\n@SpringBootApplication\npublic class SpringbootprojectApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootprojectApplication.class, args);\n    }\n}\n```\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration //开启自动注解\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n\t\t@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n\t//...忽略\n}\n```\n\n```java\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n\t//..忽略\n}\n```\n\n@EnableAutoConfiguration注解通过@Import导入了AutoConfigurationImportSelector.class。\n\n其导入的**AutoConfigurationImportSelector**的selectImports()方法通过**SpringFactoriesLoader.loadFactoryNames()**扫描所有具有**META-INF/spring.factories**的jar包。spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。\n\n![](springboot-custom-start/3.png)\n\n到这一步我们知道了自动配置的其中原理：<font color=red>SpringBoot在启动时通过注解@EnableAutoConfiguration。扫描class路径下的spring.factories文件。将key = org.springframework.boot.autoconfigure.EnableAutoConfiguration 下的配置加载到Bean容器中，这样就自动配置上了相关的类。</font>\n\n到这一步我们知道了SpingBoot是如何通过导入Maven包就能将RedisAutoConfiguration交给spring容器管理。而不用我们自己创建一个Redis配置类去写一大堆的配置。**但我们知道，往往要完成自动配置并能使用是有依赖条件。例如你需要定义Redis的配置信息(IP,端口等)，需要依赖Redis的操作类。**所以SpringBoot提供了一系列的条件依赖注解。\n\n- @ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。\n- @ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。\n- @ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。\n- @ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。\n- @ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。\n- @ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。\n- @AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。\n- @AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。\n- @ConditionalOnProperty，当存在某个配置的时候才加载\n- @EnableConfigurationProperties(xxxProperties.class)，使@ConfigurationProperties注解生效，将yml或properties配置文件转换成bean。\n\n**具体分析下Redis配置类**\n\n```java\n//标明这个类是一个配置类\n@Configuration(proxyBeanMethods = false)\n//当路径下存在RedisOperations.class类时才加载这个配置类\n@ConditionalOnClass(RedisOperations.class)\n//将yml或properties文件的配置映射到RedisProperties.class类上\n@EnableConfigurationProperties(RedisProperties.class)\n//@Import作用就跟<import />标签作用一样，这里是表示在加载RedisAutoConfiguration这个配置类的时候\n//导入LettuceConnectionConfiguration这个配置类，最新的springboot使用lettuce作为redis的客户端\n@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\npublic class RedisAutoConfiguration {\n    //这里就是帮我们自动配置了RedisTemplate类，代码上就可以直接通过RedisTemplate进行代码编写\n\t@Bean\n    //@ConditionalOnMissingBean这个的意思是表示spring容器中没有redisTemplate类的时候才配置，不然不配置。\n\t@ConditionalOnMissingBean(name = \"redisTemplate\")\n\tpublic RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\n\t\t\tthrows UnknownHostException {\n\t\tRedisTemplate<Object, Object> template = new RedisTemplate<>();\n\t\ttemplate.setConnectionFactory(redisConnectionFactory);\n\t\treturn template;\n\t}\n\n\t@Bean\n\t@ConditionalOnMissingBean\n\tpublic StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)\n\t\t\tthrows UnknownHostException {\n\t\tStringRedisTemplate template = new StringRedisTemplate();\n\t\ttemplate.setConnectionFactory(redisConnectionFactory);\n\t\treturn template;\n\t}\n}\n\n@ConfigurationProperties(prefix = \"spring.redis\")\npublic class RedisProperties {\n\tprivate String url;\n    private String host = \"localhost\";\n}\n```\n\n到这里我们知道了**SpringBoot自动配置的原理。**通过一张图做个总结。\n\n![](springboot-custom-start/4.png)\n\n## Mybatis起步依赖\n\nspring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。上面说的Redis是SpringBoot官方提供的起步依赖。对于Mybatis来说，是第三方提供的起步依赖。我们具体来看他是怎么实现的。\n\n```java\n<dependency>\n\t<groupId>org.mybatis.spring.boot</groupId>\n\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t<version>1.3.2</version>\n</dependency>\n```\n\n![](springboot-custom-start/5.png)\n\nMybatis的starter通过注入mybatis-spring-boot-starter包实现。包含了\n\n- mybatis-spring-boot-autoconfigure ， 自动注入相关包\n- mybatis， mybatis核心包\n- mybatis-spring， mybatis-spring包\n- spring-boot-starter-jdbc ，spring的jbdc包，mybatis需要依赖jdbc。\n\n查看mybatis-spring-boot-autoconfigure，同样的也有**spring.factories**。里面也是形如org.springframework.boot.autoconfigure.EnableAutoConfiguration = XXXConfiguration的配置项。\n\n![](springboot-custom-start/6.png)\n\n```java\npackage org.mybatis.spring.boot.autoconfigure;\n//...省略很多\n@Configuration //这个类是个配置类\n//当class路径下有SqlSessionFactory和SqlSessionFactoryBean这个两个class时才加载这个配置类（所以前提是引入mybatis类）\n@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class})\n//当spring上下文存在数据源时才配置。区别与上面的@ConditionalOnClass。mybatis是需要数据源的，如果没有数据源就没意义\n@ConditionalOnBean({DataSource.class})\n//yml或properties映射到MybatisProperties类\n@EnableConfigurationProperties({MybatisProperties.class})\n//当前这个类的配置必须等到DataSourceAutoConfiguration.class先配置完后再配置\n@AutoConfigureAfter({DataSourceAutoConfiguration.class})\npublic class MybatisAutoConfiguration {\n    //...省略很多\n\n    @PostConstruct\n    public void checkConfigFileExists() {\n        if (this.properties.isCheckConfigLocation() && StringUtils.hasText(this.properties.getConfigLocation())) {\n            Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());\n            Assert.state(resource.exists(), \"Cannot find config location: \" + resource + \" (please add config file or check your Mybatis configuration)\");\n        }\n    }\n\n    //自动注入SqlSessionFactory\n    @Bean\n    @ConditionalOnMissingBean\n    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n        //...省略很多\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n        ExecutorType executorType = this.properties.getExecutorType();\n        return executorType != null ? new SqlSessionTemplate(sqlSessionFactory, executorType) : new SqlSessionTemplate(sqlSessionFactory);\n    }\n\n    //这里MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar应该是自动扫描实现了Mapper的类加入到spring容器\n    @Configuration\n    @Import({MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class})\n    @ConditionalOnMissingBean({MapperFactoryBean.class})\n    public static class MapperScannerRegistrarNotFoundConfiguration {\n        public MapperScannerRegistrarNotFoundConfiguration() {\n        }\n\n        @PostConstruct\n        public void afterPropertiesSet() {\n            MybatisAutoConfiguration.logger.debug(\"No {} found.\", MapperFactoryBean.class.getName());\n        }\n    }\n\n    public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar, ResourceLoaderAware {\n        private BeanFactory beanFactory;\n        private ResourceLoader resourceLoader;\n\n        public AutoConfiguredMapperScannerRegistrar() {\n        }\n\n        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n            //....省略很多\n        }\n\n        public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n            this.beanFactory = beanFactory;\n        }\n\n        public void setResourceLoader(ResourceLoader resourceLoader) {\n            this.resourceLoader = resourceLoader;\n        }\n    }\n}\n```\n\n## 自定义一个起步依赖\n\n在项目上Redis使用频繁，要求将Redis操作的工具类做成一个starter，让其他项目能够复用。\n\n1. 创建一个新项目 **xuzy-spring-redis-starter**\n2. 导入**spring-boot-starter-data-redis**依赖\n3. 创建**META-INF/spring.factories**文件并设置启动配置类。\n4. 创建启动配置类**RedisAutoConfig**\n\n![](springboot-custom-start/7.png)\n\n如果所示，我们参考Mybatis自动配置的方式。我们在配置类上使用了@AutoConfigureAfter(RedisTemplate.class)来保证当RedisTemplate被实例化后才加载工具类。最后我们通过@Bean注入了RedisUtil工具类。\n\n在实际项目上，我们可以根据自动配置条件依赖来更好的定义starter。上面的例子只是大概写一个过程。我们可以根据实际需要做配置。\n\n\n\n","slug":"springboot-custom-start","published":1,"updated":"2021-04-08T00:47:07.017Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvx003yqwv2626945nt","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>SpringBoot采用了“习惯优于配置”的理念，没有了繁琐的配置，让我们开发起来变得更加快捷。例如我们需要在项目中使用Redis模块进行开发。只需要引入spring-boot-starter-data-redis包，就会自动加载了Redis所需要的模块。我们只需要在配置文件application.properties上配置redis的相关连接信息，并在代码上使用RedisTemplate.java类就可以操作Redis。</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dependency</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>groupId</span><span class=\"token punctuation\">></span></span>org.springframework.boot<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>groupId</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>artifactId</span><span class=\"token punctuation\">></span></span>spring-boot-starter-data-redis<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>artifactId</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dependency</span><span class=\"token punctuation\">></span></span></code></pre>\n<a id=\"more\"></a>\n<p>类似的这种起步依赖大大降低了我们的配置成本。在SpringBoot中大概分成两类起步依赖：<strong>SpringBoot自带起步依赖</strong> 和 <strong>开发者自带起步依赖</strong>。</p>\n<ul>\n<li><p>spring-boot-starter-xxx是官方提供的starter。</p>\n</li>\n<li><p>xxx-spring-boot-starter是第三方提供的starter。</p>\n</li>\n</ul>\n<h2 id=\"自动配置原理\"><a href=\"#自动配置原理\" class=\"headerlink\" title=\"自动配置原理\"></a>自动配置原理</h2><p>SpringBoot的自动配置原理依赖于spring-boot-autoconfigure-xxx包。对应的<strong>@EnableAutoConfiguration</strong>注解。</p>\n<p><img src=\"/2020/09/27/springboot-custom-start/1.png\" alt></p>\n<p>在我们SpringBoot启动代码上使用了@SpringBootApplication注解，里面包含了@EnableAutoConfiguration。从字面看上不难猜出这个开启自动配置的意思。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@SpringBootApplication</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpringbootprojectApplication</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        SpringApplication<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span>SpringbootprojectApplication<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span>ElementType<span class=\"token punctuation\">.</span>TYPE<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span>RetentionPolicy<span class=\"token punctuation\">.</span>RUNTIME<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Documented</span>\n<span class=\"token annotation punctuation\">@Inherited</span>\n<span class=\"token annotation punctuation\">@SpringBootConfiguration</span>\n<span class=\"token annotation punctuation\">@EnableAutoConfiguration</span> <span class=\"token comment\" spellcheck=\"true\">//开启自动注解</span>\n<span class=\"token annotation punctuation\">@ComponentScan</span><span class=\"token punctuation\">(</span>excludeFilters <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token annotation punctuation\">@Filter</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">=</span> FilterType<span class=\"token punctuation\">.</span>CUSTOM<span class=\"token punctuation\">,</span> classes <span class=\"token operator\">=</span> TypeExcludeFilter<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token annotation punctuation\">@Filter</span><span class=\"token punctuation\">(</span>type <span class=\"token operator\">=</span> FilterType<span class=\"token punctuation\">.</span>CUSTOM<span class=\"token punctuation\">,</span> classes <span class=\"token operator\">=</span> AutoConfigurationExcludeFilter<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> @<span class=\"token keyword\">interface</span> <span class=\"token class-name\">SpringBootApplication</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//...忽略</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span>ElementType<span class=\"token punctuation\">.</span>TYPE<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span>RetentionPolicy<span class=\"token punctuation\">.</span>RUNTIME<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Documented</span>\n<span class=\"token annotation punctuation\">@Inherited</span>\n<span class=\"token annotation punctuation\">@AutoConfigurationPackage</span>\n<span class=\"token annotation punctuation\">@Import</span><span class=\"token punctuation\">(</span>AutoConfigurationImportSelector<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> @<span class=\"token keyword\">interface</span> <span class=\"token class-name\">EnableAutoConfiguration</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//..忽略</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>@EnableAutoConfiguration注解通过@Import导入了AutoConfigurationImportSelector.class。</p>\n<p>其导入的<strong>AutoConfigurationImportSelector</strong>的selectImports()方法通过<strong>SpringFactoriesLoader.loadFactoryNames()</strong>扫描所有具有<strong>META-INF/spring.factories</strong>的jar包。spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。</p>\n<p><img src=\"/2020/09/27/springboot-custom-start/3.png\" alt></p>\n<p>到这一步我们知道了自动配置的其中原理：<font color=\"red\">SpringBoot在启动时通过注解@EnableAutoConfiguration。扫描class路径下的spring.factories文件。将key = org.springframework.boot.autoconfigure.EnableAutoConfiguration 下的配置加载到Bean容器中，这样就自动配置上了相关的类。</font></p>\n<p>到这一步我们知道了SpingBoot是如何通过导入Maven包就能将RedisAutoConfiguration交给spring容器管理。而不用我们自己创建一个Redis配置类去写一大堆的配置。<strong>但我们知道，往往要完成自动配置并能使用是有依赖条件。例如你需要定义Redis的配置信息(IP,端口等)，需要依赖Redis的操作类。</strong>所以SpringBoot提供了一系列的条件依赖注解。</p>\n<ul>\n<li>@ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。</li>\n<li>@ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。</li>\n<li>@ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。</li>\n<li>@ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。</li>\n<li>@ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。</li>\n<li>@ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。</li>\n<li>@AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。</li>\n<li>@AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。</li>\n<li>@ConditionalOnProperty，当存在某个配置的时候才加载</li>\n<li>@EnableConfigurationProperties(xxxProperties.class)，使@ConfigurationProperties注解生效，将yml或properties配置文件转换成bean。</li>\n</ul>\n<p><strong>具体分析下Redis配置类</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//标明这个类是一个配置类</span>\n<span class=\"token annotation punctuation\">@Configuration</span><span class=\"token punctuation\">(</span>proxyBeanMethods <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//当路径下存在RedisOperations.class类时才加载这个配置类</span>\n<span class=\"token annotation punctuation\">@ConditionalOnClass</span><span class=\"token punctuation\">(</span>RedisOperations<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//将yml或properties文件的配置映射到RedisProperties.class类上</span>\n<span class=\"token annotation punctuation\">@EnableConfigurationProperties</span><span class=\"token punctuation\">(</span>RedisProperties<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//@Import作用就跟&lt;import />标签作用一样，这里是表示在加载RedisAutoConfiguration这个配置类的时候</span>\n<span class=\"token comment\" spellcheck=\"true\">//导入LettuceConnectionConfiguration这个配置类，最新的springboot使用lettuce作为redis的客户端</span>\n<span class=\"token annotation punctuation\">@Import</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> LettuceConnectionConfiguration<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> JedisConnectionConfiguration<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RedisAutoConfiguration</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//这里就是帮我们自动配置了RedisTemplate类，代码上就可以直接通过RedisTemplate进行代码编写</span>\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token comment\" spellcheck=\"true\">//@ConditionalOnMissingBean这个的意思是表示spring容器中没有redisTemplate类的时候才配置，不然不配置。</span>\n    <span class=\"token annotation punctuation\">@ConditionalOnMissingBean</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"redisTemplate\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> RedisTemplate<span class=\"token operator\">&lt;</span>Object<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> <span class=\"token function\">redisTemplate</span><span class=\"token punctuation\">(</span>RedisConnectionFactory redisConnectionFactory<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throws</span> UnknownHostException <span class=\"token punctuation\">{</span>\n        RedisTemplate<span class=\"token operator\">&lt;</span>Object<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> template <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RedisTemplate</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        template<span class=\"token punctuation\">.</span><span class=\"token function\">setConnectionFactory</span><span class=\"token punctuation\">(</span>redisConnectionFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> template<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token annotation punctuation\">@ConditionalOnMissingBean</span>\n    <span class=\"token keyword\">public</span> StringRedisTemplate <span class=\"token function\">stringRedisTemplate</span><span class=\"token punctuation\">(</span>RedisConnectionFactory redisConnectionFactory<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throws</span> UnknownHostException <span class=\"token punctuation\">{</span>\n        StringRedisTemplate template <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringRedisTemplate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        template<span class=\"token punctuation\">.</span><span class=\"token function\">setConnectionFactory</span><span class=\"token punctuation\">(</span>redisConnectionFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> template<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token annotation punctuation\">@ConfigurationProperties</span><span class=\"token punctuation\">(</span>prefix <span class=\"token operator\">=</span> <span class=\"token string\">\"spring.redis\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">RedisProperties</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> String url<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> String host <span class=\"token operator\">=</span> <span class=\"token string\">\"localhost\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>到这里我们知道了<strong>SpringBoot自动配置的原理。</strong>通过一张图做个总结。</p>\n<p><img src=\"/2020/09/27/springboot-custom-start/4.png\" alt></p>\n<h2 id=\"Mybatis起步依赖\"><a href=\"#Mybatis起步依赖\" class=\"headerlink\" title=\"Mybatis起步依赖\"></a>Mybatis起步依赖</h2><p>spring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。上面说的Redis是SpringBoot官方提供的起步依赖。对于Mybatis来说，是第三方提供的起步依赖。我们具体来看他是怎么实现的。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span>dependency<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>groupId<span class=\"token operator\">></span>org<span class=\"token punctuation\">.</span>mybatis<span class=\"token punctuation\">.</span>spring<span class=\"token punctuation\">.</span>boot<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>groupId<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>artifactId<span class=\"token operator\">></span>mybatis<span class=\"token operator\">-</span>spring<span class=\"token operator\">-</span>boot<span class=\"token operator\">-</span>starter<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>artifactId<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>version<span class=\"token operator\">></span><span class=\"token number\">1.3</span><span class=\"token punctuation\">.</span><span class=\"token number\">2</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>version<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dependency<span class=\"token operator\">></span></code></pre>\n<p><img src=\"/2020/09/27/springboot-custom-start/5.png\" alt></p>\n<p>Mybatis的starter通过注入mybatis-spring-boot-starter包实现。包含了</p>\n<ul>\n<li>mybatis-spring-boot-autoconfigure ， 自动注入相关包</li>\n<li>mybatis， mybatis核心包</li>\n<li>mybatis-spring， mybatis-spring包</li>\n<li>spring-boot-starter-jdbc ，spring的jbdc包，mybatis需要依赖jdbc。</li>\n</ul>\n<p>查看mybatis-spring-boot-autoconfigure，同样的也有<strong>spring.factories</strong>。里面也是形如org.springframework.boot.autoconfigure.EnableAutoConfiguration = XXXConfiguration的配置项。</p>\n<p><img src=\"/2020/09/27/springboot-custom-start/6.png\" alt></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> org<span class=\"token punctuation\">.</span>mybatis<span class=\"token punctuation\">.</span>spring<span class=\"token punctuation\">.</span>boot<span class=\"token punctuation\">.</span>autoconfigure<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//...省略很多</span>\n<span class=\"token annotation punctuation\">@Configuration</span> <span class=\"token comment\" spellcheck=\"true\">//这个类是个配置类</span>\n<span class=\"token comment\" spellcheck=\"true\">//当class路径下有SqlSessionFactory和SqlSessionFactoryBean这个两个class时才加载这个配置类（所以前提是引入mybatis类）</span>\n<span class=\"token annotation punctuation\">@ConditionalOnClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>SqlSessionFactory<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> SqlSessionFactoryBean<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//当spring上下文存在数据源时才配置。区别与上面的@ConditionalOnClass。mybatis是需要数据源的，如果没有数据源就没意义</span>\n<span class=\"token annotation punctuation\">@ConditionalOnBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>DataSource<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//yml或properties映射到MybatisProperties类</span>\n<span class=\"token annotation punctuation\">@EnableConfigurationProperties</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>MybatisProperties<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\" spellcheck=\"true\">//当前这个类的配置必须等到DataSourceAutoConfiguration.class先配置完后再配置</span>\n<span class=\"token annotation punctuation\">@AutoConfigureAfter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>DataSourceAutoConfiguration<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MybatisAutoConfiguration</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//...省略很多</span>\n\n    <span class=\"token annotation punctuation\">@PostConstruct</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">checkConfigFileExists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">.</span><span class=\"token function\">isCheckConfigLocation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> StringUtils<span class=\"token punctuation\">.</span><span class=\"token function\">hasText</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">.</span><span class=\"token function\">getConfigLocation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            Resource resource <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resourceLoader<span class=\"token punctuation\">.</span><span class=\"token function\">getResource</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">.</span><span class=\"token function\">getConfigLocation</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Assert<span class=\"token punctuation\">.</span><span class=\"token function\">state</span><span class=\"token punctuation\">(</span>resource<span class=\"token punctuation\">.</span><span class=\"token function\">exists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"Cannot find config location: \"</span> <span class=\"token operator\">+</span> resource <span class=\"token operator\">+</span> <span class=\"token string\">\" (please add config file or check your Mybatis configuration)\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//自动注入SqlSessionFactory</span>\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token annotation punctuation\">@ConditionalOnMissingBean</span>\n    <span class=\"token keyword\">public</span> SqlSessionFactory <span class=\"token function\">sqlSessionFactory</span><span class=\"token punctuation\">(</span>DataSource dataSource<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//...省略很多</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token annotation punctuation\">@ConditionalOnMissingBean</span>\n    <span class=\"token keyword\">public</span> SqlSessionTemplate <span class=\"token function\">sqlSessionTemplate</span><span class=\"token punctuation\">(</span>SqlSessionFactory sqlSessionFactory<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ExecutorType executorType <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>properties<span class=\"token punctuation\">.</span><span class=\"token function\">getExecutorType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> executorType <span class=\"token operator\">!=</span> null <span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SqlSessionTemplate</span><span class=\"token punctuation\">(</span>sqlSessionFactory<span class=\"token punctuation\">,</span> executorType<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SqlSessionTemplate</span><span class=\"token punctuation\">(</span>sqlSessionFactory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//这里MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar应该是自动扫描实现了Mapper的类加入到spring容器</span>\n    <span class=\"token annotation punctuation\">@Configuration</span>\n    <span class=\"token annotation punctuation\">@Import</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>MybatisAutoConfiguration<span class=\"token punctuation\">.</span>AutoConfiguredMapperScannerRegistrar<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@ConditionalOnMissingBean</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>MapperFactoryBean<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MapperScannerRegistrarNotFoundConfiguration</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">public</span> <span class=\"token function\">MapperScannerRegistrarNotFoundConfiguration</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token annotation punctuation\">@PostConstruct</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">afterPropertiesSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            MybatisAutoConfiguration<span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No {} found.\"</span><span class=\"token punctuation\">,</span> MapperFactoryBean<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AutoConfiguredMapperScannerRegistrar</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">BeanFactoryAware</span><span class=\"token punctuation\">,</span> ImportBeanDefinitionRegistrar<span class=\"token punctuation\">,</span> ResourceLoaderAware <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> BeanFactory beanFactory<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">private</span> ResourceLoader resourceLoader<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token function\">AutoConfiguredMapperScannerRegistrar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">registerBeanDefinitions</span><span class=\"token punctuation\">(</span>AnnotationMetadata importingClassMetadata<span class=\"token punctuation\">,</span> BeanDefinitionRegistry registry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//....省略很多</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setBeanFactory</span><span class=\"token punctuation\">(</span>BeanFactory beanFactory<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> BeansException <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>beanFactory <span class=\"token operator\">=</span> beanFactory<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setResourceLoader</span><span class=\"token punctuation\">(</span>ResourceLoader resourceLoader<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resourceLoader <span class=\"token operator\">=</span> resourceLoader<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"自定义一个起步依赖\"><a href=\"#自定义一个起步依赖\" class=\"headerlink\" title=\"自定义一个起步依赖\"></a>自定义一个起步依赖</h2><p>在项目上Redis使用频繁，要求将Redis操作的工具类做成一个starter，让其他项目能够复用。</p>\n<ol>\n<li>创建一个新项目 <strong>xuzy-spring-redis-starter</strong></li>\n<li>导入<strong>spring-boot-starter-data-redis</strong>依赖</li>\n<li>创建<strong>META-INF/spring.factories</strong>文件并设置启动配置类。</li>\n<li>创建启动配置类<strong>RedisAutoConfig</strong></li>\n</ol>\n<p><img src=\"/2020/09/27/springboot-custom-start/7.png\" alt></p>\n<p>如果所示，我们参考Mybatis自动配置的方式。我们在配置类上使用了@AutoConfigureAfter(RedisTemplate.class)来保证当RedisTemplate被实例化后才加载工具类。最后我们通过@Bean注入了RedisUtil工具类。</p>\n<p>在实际项目上，我们可以根据自动配置条件依赖来更好的定义starter。上面的例子只是大概写一个过程。我们可以根据实际需要做配置。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>SpringBoot采用了“习惯优于配置”的理念，没有了繁琐的配置，让我们开发起来变得更加快捷。例如我们需要在项目中使用Redis模块进行开发。只需要引入spring-boot-starter-data-redis包，就会自动加载了Redis所需要的模块。我们只需要在配置文件application.properties上配置redis的相关连接信息，并在代码上使用RedisTemplate.java类就可以操作Redis。</p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n&lt;/dependency&gt;</code></pre>","more":"<p>类似的这种起步依赖大大降低了我们的配置成本。在SpringBoot中大概分成两类起步依赖：<strong>SpringBoot自带起步依赖</strong> 和 <strong>开发者自带起步依赖</strong>。</p>\n<ul>\n<li><p>spring-boot-starter-xxx是官方提供的starter。</p>\n</li>\n<li><p>xxx-spring-boot-starter是第三方提供的starter。</p>\n</li>\n</ul>\n<h2 id=\"自动配置原理\"><a href=\"#自动配置原理\" class=\"headerlink\" title=\"自动配置原理\"></a>自动配置原理</h2><p>SpringBoot的自动配置原理依赖于spring-boot-autoconfigure-xxx包。对应的<strong>@EnableAutoConfiguration</strong>注解。</p>\n<p><img src=\"/2020/09/27/springboot-custom-start/1.png\" alt></p>\n<p>在我们SpringBoot启动代码上使用了@SpringBootApplication注解，里面包含了@EnableAutoConfiguration。从字面看上不难猜出这个开启自动配置的意思。</p>\n<pre><code class=\"java\">@SpringBootApplication\npublic class SpringbootprojectApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(SpringbootprojectApplication.class, args);\n    }\n}</code></pre>\n<pre><code class=\"java\">@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration //开启自动注解\n@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),\n        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })\npublic @interface SpringBootApplication {\n    //...忽略\n}</code></pre>\n<pre><code class=\"java\">@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import(AutoConfigurationImportSelector.class)\npublic @interface EnableAutoConfiguration {\n    //..忽略\n}</code></pre>\n<p>@EnableAutoConfiguration注解通过@Import导入了AutoConfigurationImportSelector.class。</p>\n<p>其导入的<strong>AutoConfigurationImportSelector</strong>的selectImports()方法通过<strong>SpringFactoriesLoader.loadFactoryNames()</strong>扫描所有具有<strong>META-INF/spring.factories</strong>的jar包。spring-boot-autoconfigure-x.x.x.x.jar里就有一个这样的spring.factories文件。</p>\n<p><img src=\"/2020/09/27/springboot-custom-start/3.png\" alt></p>\n<p>到这一步我们知道了自动配置的其中原理：<font color=\"red\">SpringBoot在启动时通过注解@EnableAutoConfiguration。扫描class路径下的spring.factories文件。将key = org.springframework.boot.autoconfigure.EnableAutoConfiguration 下的配置加载到Bean容器中，这样就自动配置上了相关的类。</font></p>\n<p>到这一步我们知道了SpingBoot是如何通过导入Maven包就能将RedisAutoConfiguration交给spring容器管理。而不用我们自己创建一个Redis配置类去写一大堆的配置。<strong>但我们知道，往往要完成自动配置并能使用是有依赖条件。例如你需要定义Redis的配置信息(IP,端口等)，需要依赖Redis的操作类。</strong>所以SpringBoot提供了一系列的条件依赖注解。</p>\n<ul>\n<li>@ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。</li>\n<li>@ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。</li>\n<li>@ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。</li>\n<li>@ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。</li>\n<li>@ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。</li>\n<li>@ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。</li>\n<li>@AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。</li>\n<li>@AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。</li>\n<li>@ConditionalOnProperty，当存在某个配置的时候才加载</li>\n<li>@EnableConfigurationProperties(xxxProperties.class)，使@ConfigurationProperties注解生效，将yml或properties配置文件转换成bean。</li>\n</ul>\n<p><strong>具体分析下Redis配置类</strong></p>\n<pre><code class=\"java\">//标明这个类是一个配置类\n@Configuration(proxyBeanMethods = false)\n//当路径下存在RedisOperations.class类时才加载这个配置类\n@ConditionalOnClass(RedisOperations.class)\n//将yml或properties文件的配置映射到RedisProperties.class类上\n@EnableConfigurationProperties(RedisProperties.class)\n//@Import作用就跟&lt;import /&gt;标签作用一样，这里是表示在加载RedisAutoConfiguration这个配置类的时候\n//导入LettuceConnectionConfiguration这个配置类，最新的springboot使用lettuce作为redis的客户端\n@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\npublic class RedisAutoConfiguration {\n    //这里就是帮我们自动配置了RedisTemplate类，代码上就可以直接通过RedisTemplate进行代码编写\n    @Bean\n    //@ConditionalOnMissingBean这个的意思是表示spring容器中没有redisTemplate类的时候才配置，不然不配置。\n    @ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)\n    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)\n            throws UnknownHostException {\n        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)\n            throws UnknownHostException {\n        StringRedisTemplate template = new StringRedisTemplate();\n        template.setConnectionFactory(redisConnectionFactory);\n        return template;\n    }\n}\n\n@ConfigurationProperties(prefix = &quot;spring.redis&quot;)\npublic class RedisProperties {\n    private String url;\n    private String host = &quot;localhost&quot;;\n}</code></pre>\n<p>到这里我们知道了<strong>SpringBoot自动配置的原理。</strong>通过一张图做个总结。</p>\n<p><img src=\"/2020/09/27/springboot-custom-start/4.png\" alt></p>\n<h2 id=\"Mybatis起步依赖\"><a href=\"#Mybatis起步依赖\" class=\"headerlink\" title=\"Mybatis起步依赖\"></a>Mybatis起步依赖</h2><p>spring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。上面说的Redis是SpringBoot官方提供的起步依赖。对于Mybatis来说，是第三方提供的起步依赖。我们具体来看他是怎么实现的。</p>\n<pre><code class=\"java\">&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;1.3.2&lt;/version&gt;\n&lt;/dependency&gt;</code></pre>\n<p><img src=\"/2020/09/27/springboot-custom-start/5.png\" alt></p>\n<p>Mybatis的starter通过注入mybatis-spring-boot-starter包实现。包含了</p>\n<ul>\n<li>mybatis-spring-boot-autoconfigure ， 自动注入相关包</li>\n<li>mybatis， mybatis核心包</li>\n<li>mybatis-spring， mybatis-spring包</li>\n<li>spring-boot-starter-jdbc ，spring的jbdc包，mybatis需要依赖jdbc。</li>\n</ul>\n<p>查看mybatis-spring-boot-autoconfigure，同样的也有<strong>spring.factories</strong>。里面也是形如org.springframework.boot.autoconfigure.EnableAutoConfiguration = XXXConfiguration的配置项。</p>\n<p><img src=\"/2020/09/27/springboot-custom-start/6.png\" alt></p>\n<pre><code class=\"java\">package org.mybatis.spring.boot.autoconfigure;\n//...省略很多\n@Configuration //这个类是个配置类\n//当class路径下有SqlSessionFactory和SqlSessionFactoryBean这个两个class时才加载这个配置类（所以前提是引入mybatis类）\n@ConditionalOnClass({SqlSessionFactory.class, SqlSessionFactoryBean.class})\n//当spring上下文存在数据源时才配置。区别与上面的@ConditionalOnClass。mybatis是需要数据源的，如果没有数据源就没意义\n@ConditionalOnBean({DataSource.class})\n//yml或properties映射到MybatisProperties类\n@EnableConfigurationProperties({MybatisProperties.class})\n//当前这个类的配置必须等到DataSourceAutoConfiguration.class先配置完后再配置\n@AutoConfigureAfter({DataSourceAutoConfiguration.class})\npublic class MybatisAutoConfiguration {\n    //...省略很多\n\n    @PostConstruct\n    public void checkConfigFileExists() {\n        if (this.properties.isCheckConfigLocation() &amp;&amp; StringUtils.hasText(this.properties.getConfigLocation())) {\n            Resource resource = this.resourceLoader.getResource(this.properties.getConfigLocation());\n            Assert.state(resource.exists(), &quot;Cannot find config location: &quot; + resource + &quot; (please add config file or check your Mybatis configuration)&quot;);\n        }\n    }\n\n    //自动注入SqlSessionFactory\n    @Bean\n    @ConditionalOnMissingBean\n    public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {\n        //...省略很多\n    }\n\n    @Bean\n    @ConditionalOnMissingBean\n    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {\n        ExecutorType executorType = this.properties.getExecutorType();\n        return executorType != null ? new SqlSessionTemplate(sqlSessionFactory, executorType) : new SqlSessionTemplate(sqlSessionFactory);\n    }\n\n    //这里MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar应该是自动扫描实现了Mapper的类加入到spring容器\n    @Configuration\n    @Import({MybatisAutoConfiguration.AutoConfiguredMapperScannerRegistrar.class})\n    @ConditionalOnMissingBean({MapperFactoryBean.class})\n    public static class MapperScannerRegistrarNotFoundConfiguration {\n        public MapperScannerRegistrarNotFoundConfiguration() {\n        }\n\n        @PostConstruct\n        public void afterPropertiesSet() {\n            MybatisAutoConfiguration.logger.debug(&quot;No {} found.&quot;, MapperFactoryBean.class.getName());\n        }\n    }\n\n    public static class AutoConfiguredMapperScannerRegistrar implements BeanFactoryAware, ImportBeanDefinitionRegistrar, ResourceLoaderAware {\n        private BeanFactory beanFactory;\n        private ResourceLoader resourceLoader;\n\n        public AutoConfiguredMapperScannerRegistrar() {\n        }\n\n        public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n            //....省略很多\n        }\n\n        public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n            this.beanFactory = beanFactory;\n        }\n\n        public void setResourceLoader(ResourceLoader resourceLoader) {\n            this.resourceLoader = resourceLoader;\n        }\n    }\n}</code></pre>\n<h2 id=\"自定义一个起步依赖\"><a href=\"#自定义一个起步依赖\" class=\"headerlink\" title=\"自定义一个起步依赖\"></a>自定义一个起步依赖</h2><p>在项目上Redis使用频繁，要求将Redis操作的工具类做成一个starter，让其他项目能够复用。</p>\n<ol>\n<li>创建一个新项目 <strong>xuzy-spring-redis-starter</strong></li>\n<li>导入<strong>spring-boot-starter-data-redis</strong>依赖</li>\n<li>创建<strong>META-INF/spring.factories</strong>文件并设置启动配置类。</li>\n<li>创建启动配置类<strong>RedisAutoConfig</strong></li>\n</ol>\n<p><img src=\"/2020/09/27/springboot-custom-start/7.png\" alt></p>\n<p>如果所示，我们参考Mybatis自动配置的方式。我们在配置类上使用了@AutoConfigureAfter(RedisTemplate.class)来保证当RedisTemplate被实例化后才加载工具类。最后我们通过@Bean注入了RedisUtil工具类。</p>\n<p>在实际项目上，我们可以根据自动配置条件依赖来更好的定义starter。上面的例子只是大概写一个过程。我们可以根据实际需要做配置。</p>"},{"title":"SpringCloud注册中心详解","description":"SpringCloud注册中心详解","date":"2021-01-01T07:46:34.000Z","_content":"## 核心概念\n\n![](springcloud-1/1.png)\n\n- 服务注册。Eureka客户端（服务提供者或消费者）通过向Eureka服务器提供IP地址，端口等各项与服务相关的基本信息来完成注册操作。\n- 服务续约。Eureka客户端每隔一段时间向Eureka服务端发送服务续约信息来保证服务存活。\n- 服务取消。Eureka客户端主动告知Eureka服务器自己不想再注册到Eureka中。\n- 服务剔除。服务剔除是Eureka服务端（注册中心）做的事情，当一段时间没收到续约信息，就会认为该服务实例已经不再运行，从而将其从服务列表中进行剔除。\n- 服务发现。客户端通过定时任务定时从Eureka服务端获取服务信息并缓存。\n\n## 代码走读\n\n接口LeaseManager定义了服务注册，服务取消，服务续约，服务下线功能。研究代码入口可以从LeaseManager实现类入手。\n\n```java\npublic interface LeaseManager<T> {\n    //服务注册\n    void register(T r, int leaseDuration, boolean isReplication);\n    //服务取消\n    boolean cancel(String appName, String id, boolean isReplication);\n    //服务续约\n    boolean renew(String appName, String id, boolean isReplication);\n    //服务取消\n    void evict();\n}\n```\n\n### 服务注册\n\n1. 当服务启动时，会通过`DiscoveryClient#register()`方法发起一个REST风格的HTTP远程请求，请求包含了服务的信息（具体信息用`InstanceInfo`类表示）\n2. 注册中心接收到REST远程请求后，对服务进行注册`AbstractInstanceRegistry#register()`方法，用一个双层ConcurrentHashMap存储服务信息。外层Map的key表示服务名称（spring.application.name），内层key表示服务Id（eureka.instance.instanceId），内层Value是一个Lease类，包含了服务的信息、注册时间、最新的续约时间等。\n\n```java\n# DiscoveryClient#register()\nboolean register() throws Throwable {\n    logger.info(PREFIX + \"{}: registering service...\", appPathIdentifier);\n    EurekaHttpResponse<Void> httpResponse;\n    try {\n        //instanceInfo包含了服务的信息\n        //向服务端注册服务,通过这一行发送一个REST的远程请求\n        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);\n    } catch (Exception e) {\n        //....\n    }\n    // ...\n    return httpResponse.getStatusCode() == 204;\n}\n\n// --------------------------------分隔符--------------------------------\n\n//用来存储服务信息\nConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry\n            = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();\n\n\npublic void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {\n    try { \n        //从已存储的 registry 获取一个服务定义\n        Map<String, Lease<InstanceInfo>> gMap = registry.get(registrant.getAppName());\n        REGISTER.increment(isReplication);\n        if (gMap == null) {\n            //初始化一个 Map<String, Lease<InstanceInfo>> ，并放入 registry 中\n        }\n        //根据当前注册的 ID 找到对应的 Lease\n        Lease<InstanceInfo> existingLease = gMap.get(registrant.getId());\n \n        if (existingLease != null && (existingLease.getHolder() != null)) {\n            //如果 Lease 能找到，根据当前节点的最新更新时间和注册节点的最新更新时间比较\n            //如果前者的时间晚于后者的时间，那么注册实例就以已存在的实例为准\n        } else {\n              //如果找不到，代表是一个新注册，则更新其每分钟期望的续约数量及其阈值\n        }\n        //创建一个新 Lease 并放入 Map 中\n        Lease<InstanceInfo> lease = new Lease<InstanceInfo>(registrant, leaseDuration);\n        gMap.put(registrant.getId(), lease);\n\n        //处理服务的 InstanceStatus\n        registrant.setActionType(ActionType.ADDED);\n \n        //更新服务最新更新时间\n        registrant.setLastUpdatedTimestamp();\n \n        //刷选缓存，实现类ResponseCacheImpl Eureka二级缓存  readOnlyCacheMap(只读缓存) readWriteCacheMap(读写缓存)\n        invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());\n    } \n}\n```\n\n### 服务续约\n\n注册成功后，每隔一段时间，客户端会向注册中间发送心跳赖续约服务，也就是汇报健康状态。\n\n1. 客户端启动时会启动一个心跳(续约)定时任务。定时向注册中心发送续约信息。具体方法`DiscoveryClient#initScheduledTasks()`\n2. 注册中心接收信息，完成续约操作。`AbstractInstanceRegistry#renew()`\n\n```java\nscheduler.schedule(\n                    new TimedSupervisorTask(\n                            \"heartbeat\",\n                            scheduler,\n                            heartbeatExecutor,\n                            renewalIntervalInSecs,\n                            TimeUnit.SECONDS,\n                            expBackOffBound,\n                        \t//心跳续约线程\n                            new HeartbeatThread()\n                    ),\nrenewalIntervalInSecs, TimeUnit.SECONDS);\n```\n\n### 获取服务注册信息\n\n客户端通过定时器的方式从注册中心获取服务注册信息并更新缓存，默认每隔30秒刷选本地缓存。\n\n关键配置是eureka.client.registry-fetch-interval-seconds=30，表示定时30秒从注册中心获取服务注册信息。\n\nEureka 客户端不停地获取服务器端的更新数据，就能保证自己的数据和 Eureka 服务器端的保持一致。\n\n代码入口：`DiscoveryClient#initScheduledTasks()`\n\n```\nif (clientConfig.shouldFetchRegistry()) {\n    int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();\n    int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();\n    scheduler.schedule(\n            new TimedSupervisorTask(\n                    \"cacheRefresh\",\n                    scheduler,\n                    cacheRefreshExecutor,\n                    registryFetchIntervalSeconds,\n                    TimeUnit.SECONDS,\n                    expBackOffBound,\n                    new CacheRefreshThread()\n            ),\n            registryFetchIntervalSeconds, TimeUnit.SECONDS);\n}\n\n```\n\n客户端在获取服务注册信息时，首次拉取全量信息，之后拉取增量信息，然后增量拉取的数据跟本地缓存进行合并。拉取的数据通过一个一致性HashCode与本地缓存进行比对，如果HashCode不一致则说明本地缓存和注册中心的服务信息不一致，此时就拉取一次全量数据进行更新。\n\n### 自我保护机制\n\n自我保护机制是为了避免因网络分区故障而导致服务不可用的问题。假设服务提供者A跟注册中心由于网络的问题没法进行续约，此时注册中心就会将A的实例移除，导致消费者没法从注册中心获取到A的实例造成调用失败，但此时A与消费者网络是正常的。所以有了自动保护机制。\n\n**触发自动保护机制的前提**：如果在15分钟内超过85%的服务提供者节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制。\n\n**自动保护机制** ：\n\n- 注册中心不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。\n- 注册中心仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。\n- 当网络稳定时，当前注册中心新的注册信息会被同步到其它节点中。\n\n","source":"_posts/springcloud-1.md","raw":"---\ntitle: SpringCloud注册中心详解\ntags:\n  - SpringCloud\ncategories: SpringCloud\ndescription : SpringCloud注册中心详解\ndate: 2021-01-01 15:46:34\n---\n## 核心概念\n\n![](springcloud-1/1.png)\n\n- 服务注册。Eureka客户端（服务提供者或消费者）通过向Eureka服务器提供IP地址，端口等各项与服务相关的基本信息来完成注册操作。\n- 服务续约。Eureka客户端每隔一段时间向Eureka服务端发送服务续约信息来保证服务存活。\n- 服务取消。Eureka客户端主动告知Eureka服务器自己不想再注册到Eureka中。\n- 服务剔除。服务剔除是Eureka服务端（注册中心）做的事情，当一段时间没收到续约信息，就会认为该服务实例已经不再运行，从而将其从服务列表中进行剔除。\n- 服务发现。客户端通过定时任务定时从Eureka服务端获取服务信息并缓存。\n\n## 代码走读\n\n接口LeaseManager定义了服务注册，服务取消，服务续约，服务下线功能。研究代码入口可以从LeaseManager实现类入手。\n\n```java\npublic interface LeaseManager<T> {\n    //服务注册\n    void register(T r, int leaseDuration, boolean isReplication);\n    //服务取消\n    boolean cancel(String appName, String id, boolean isReplication);\n    //服务续约\n    boolean renew(String appName, String id, boolean isReplication);\n    //服务取消\n    void evict();\n}\n```\n\n### 服务注册\n\n1. 当服务启动时，会通过`DiscoveryClient#register()`方法发起一个REST风格的HTTP远程请求，请求包含了服务的信息（具体信息用`InstanceInfo`类表示）\n2. 注册中心接收到REST远程请求后，对服务进行注册`AbstractInstanceRegistry#register()`方法，用一个双层ConcurrentHashMap存储服务信息。外层Map的key表示服务名称（spring.application.name），内层key表示服务Id（eureka.instance.instanceId），内层Value是一个Lease类，包含了服务的信息、注册时间、最新的续约时间等。\n\n```java\n# DiscoveryClient#register()\nboolean register() throws Throwable {\n    logger.info(PREFIX + \"{}: registering service...\", appPathIdentifier);\n    EurekaHttpResponse<Void> httpResponse;\n    try {\n        //instanceInfo包含了服务的信息\n        //向服务端注册服务,通过这一行发送一个REST的远程请求\n        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);\n    } catch (Exception e) {\n        //....\n    }\n    // ...\n    return httpResponse.getStatusCode() == 204;\n}\n\n// --------------------------------分隔符--------------------------------\n\n//用来存储服务信息\nConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry\n            = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();\n\n\npublic void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {\n    try { \n        //从已存储的 registry 获取一个服务定义\n        Map<String, Lease<InstanceInfo>> gMap = registry.get(registrant.getAppName());\n        REGISTER.increment(isReplication);\n        if (gMap == null) {\n            //初始化一个 Map<String, Lease<InstanceInfo>> ，并放入 registry 中\n        }\n        //根据当前注册的 ID 找到对应的 Lease\n        Lease<InstanceInfo> existingLease = gMap.get(registrant.getId());\n \n        if (existingLease != null && (existingLease.getHolder() != null)) {\n            //如果 Lease 能找到，根据当前节点的最新更新时间和注册节点的最新更新时间比较\n            //如果前者的时间晚于后者的时间，那么注册实例就以已存在的实例为准\n        } else {\n              //如果找不到，代表是一个新注册，则更新其每分钟期望的续约数量及其阈值\n        }\n        //创建一个新 Lease 并放入 Map 中\n        Lease<InstanceInfo> lease = new Lease<InstanceInfo>(registrant, leaseDuration);\n        gMap.put(registrant.getId(), lease);\n\n        //处理服务的 InstanceStatus\n        registrant.setActionType(ActionType.ADDED);\n \n        //更新服务最新更新时间\n        registrant.setLastUpdatedTimestamp();\n \n        //刷选缓存，实现类ResponseCacheImpl Eureka二级缓存  readOnlyCacheMap(只读缓存) readWriteCacheMap(读写缓存)\n        invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());\n    } \n}\n```\n\n### 服务续约\n\n注册成功后，每隔一段时间，客户端会向注册中间发送心跳赖续约服务，也就是汇报健康状态。\n\n1. 客户端启动时会启动一个心跳(续约)定时任务。定时向注册中心发送续约信息。具体方法`DiscoveryClient#initScheduledTasks()`\n2. 注册中心接收信息，完成续约操作。`AbstractInstanceRegistry#renew()`\n\n```java\nscheduler.schedule(\n                    new TimedSupervisorTask(\n                            \"heartbeat\",\n                            scheduler,\n                            heartbeatExecutor,\n                            renewalIntervalInSecs,\n                            TimeUnit.SECONDS,\n                            expBackOffBound,\n                        \t//心跳续约线程\n                            new HeartbeatThread()\n                    ),\nrenewalIntervalInSecs, TimeUnit.SECONDS);\n```\n\n### 获取服务注册信息\n\n客户端通过定时器的方式从注册中心获取服务注册信息并更新缓存，默认每隔30秒刷选本地缓存。\n\n关键配置是eureka.client.registry-fetch-interval-seconds=30，表示定时30秒从注册中心获取服务注册信息。\n\nEureka 客户端不停地获取服务器端的更新数据，就能保证自己的数据和 Eureka 服务器端的保持一致。\n\n代码入口：`DiscoveryClient#initScheduledTasks()`\n\n```\nif (clientConfig.shouldFetchRegistry()) {\n    int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();\n    int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();\n    scheduler.schedule(\n            new TimedSupervisorTask(\n                    \"cacheRefresh\",\n                    scheduler,\n                    cacheRefreshExecutor,\n                    registryFetchIntervalSeconds,\n                    TimeUnit.SECONDS,\n                    expBackOffBound,\n                    new CacheRefreshThread()\n            ),\n            registryFetchIntervalSeconds, TimeUnit.SECONDS);\n}\n\n```\n\n客户端在获取服务注册信息时，首次拉取全量信息，之后拉取增量信息，然后增量拉取的数据跟本地缓存进行合并。拉取的数据通过一个一致性HashCode与本地缓存进行比对，如果HashCode不一致则说明本地缓存和注册中心的服务信息不一致，此时就拉取一次全量数据进行更新。\n\n### 自我保护机制\n\n自我保护机制是为了避免因网络分区故障而导致服务不可用的问题。假设服务提供者A跟注册中心由于网络的问题没法进行续约，此时注册中心就会将A的实例移除，导致消费者没法从注册中心获取到A的实例造成调用失败，但此时A与消费者网络是正常的。所以有了自动保护机制。\n\n**触发自动保护机制的前提**：如果在15分钟内超过85%的服务提供者节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制。\n\n**自动保护机制** ：\n\n- 注册中心不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。\n- 注册中心仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。\n- 当网络稳定时，当前注册中心新的注册信息会被同步到其它节点中。\n\n","slug":"springcloud-1","published":1,"updated":"2021-04-08T00:47:07.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvx0041qwv28f7z74rb","content":"<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><p><img src=\"/2021/01/01/springcloud-1/1.png\" alt></p>\n<ul>\n<li>服务注册。Eureka客户端（服务提供者或消费者）通过向Eureka服务器提供IP地址，端口等各项与服务相关的基本信息来完成注册操作。</li>\n<li>服务续约。Eureka客户端每隔一段时间向Eureka服务端发送服务续约信息来保证服务存活。</li>\n<li>服务取消。Eureka客户端主动告知Eureka服务器自己不想再注册到Eureka中。</li>\n<li>服务剔除。服务剔除是Eureka服务端（注册中心）做的事情，当一段时间没收到续约信息，就会认为该服务实例已经不再运行，从而将其从服务列表中进行剔除。</li>\n<li>服务发现。客户端通过定时任务定时从Eureka服务端获取服务信息并缓存。</li>\n</ul>\n<h2 id=\"代码走读\"><a href=\"#代码走读\" class=\"headerlink\" title=\"代码走读\"></a>代码走读</h2><p>接口LeaseManager定义了服务注册，服务取消，服务续约，服务下线功能。研究代码入口可以从LeaseManager实现类入手。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">LeaseManager</span><span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//服务注册</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span>T r<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leaseDuration<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> isReplication<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//服务取消</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">cancel</span><span class=\"token punctuation\">(</span>String appName<span class=\"token punctuation\">,</span> String id<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> isReplication<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//服务续约</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">renew</span><span class=\"token punctuation\">(</span>String appName<span class=\"token punctuation\">,</span> String id<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> isReplication<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//服务取消</span>\n    <span class=\"token keyword\">void</span> <span class=\"token function\">evict</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h3><ol>\n<li>当服务启动时，会通过<code>DiscoveryClient#register()</code>方法发起一个REST风格的HTTP远程请求，请求包含了服务的信息（具体信息用<code>InstanceInfo</code>类表示）</li>\n<li>注册中心接收到REST远程请求后，对服务进行注册<code>AbstractInstanceRegistry#register()</code>方法，用一个双层ConcurrentHashMap存储服务信息。外层Map的key表示服务名称（spring.application.name），内层key表示服务Id（eureka.instance.instanceId），内层Value是一个Lease类，包含了服务的信息、注册时间、最新的续约时间等。</li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\"># DiscoveryClient#<span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n    logger<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span>PREFIX <span class=\"token operator\">+</span> <span class=\"token string\">\"{}: registering service...\"</span><span class=\"token punctuation\">,</span> appPathIdentifier<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    EurekaHttpResponse<span class=\"token operator\">&lt;</span>Void<span class=\"token operator\">></span> httpResponse<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//instanceInfo包含了服务的信息</span>\n        <span class=\"token comment\" spellcheck=\"true\">//向服务端注册服务,通过这一行发送一个REST的远程请求</span>\n        httpResponse <span class=\"token operator\">=</span> eurekaTransport<span class=\"token punctuation\">.</span>registrationClient<span class=\"token punctuation\">.</span><span class=\"token function\">register</span><span class=\"token punctuation\">(</span>instanceInfo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//....</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token keyword\">return</span> httpResponse<span class=\"token punctuation\">.</span><span class=\"token function\">getStatusCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">204</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// --------------------------------分隔符--------------------------------</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//用来存储服务信息</span>\nConcurrentHashMap<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Lease<span class=\"token operator\">&lt;</span>InstanceInfo<span class=\"token operator\">>>></span> registry\n            <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ConcurrentHashMap</span><span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Lease<span class=\"token operator\">&lt;</span>InstanceInfo<span class=\"token operator\">>>></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span>InstanceInfo registrant<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leaseDuration<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> isReplication<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token comment\" spellcheck=\"true\">//从已存储的 registry 获取一个服务定义</span>\n        Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Lease<span class=\"token operator\">&lt;</span>InstanceInfo<span class=\"token operator\">>></span> gMap <span class=\"token operator\">=</span> registry<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>registrant<span class=\"token punctuation\">.</span><span class=\"token function\">getAppName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        REGISTER<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span>isReplication<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>gMap <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//初始化一个 Map&lt;String, Lease&lt;InstanceInfo>> ，并放入 registry 中</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//根据当前注册的 ID 找到对应的 Lease</span>\n        Lease<span class=\"token operator\">&lt;</span>InstanceInfo<span class=\"token operator\">></span> existingLease <span class=\"token operator\">=</span> gMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>registrant<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>existingLease <span class=\"token operator\">!=</span> null <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">(</span>existingLease<span class=\"token punctuation\">.</span><span class=\"token function\">getHolder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果 Lease 能找到，根据当前节点的最新更新时间和注册节点的最新更新时间比较</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果前者的时间晚于后者的时间，那么注册实例就以已存在的实例为准</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">//如果找不到，代表是一个新注册，则更新其每分钟期望的续约数量及其阈值</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//创建一个新 Lease 并放入 Map 中</span>\n        Lease<span class=\"token operator\">&lt;</span>InstanceInfo<span class=\"token operator\">></span> lease <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Lease</span><span class=\"token operator\">&lt;</span>InstanceInfo<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>registrant<span class=\"token punctuation\">,</span> leaseDuration<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        gMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>registrant<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> lease<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//处理服务的 InstanceStatus</span>\n        registrant<span class=\"token punctuation\">.</span><span class=\"token function\">setActionType</span><span class=\"token punctuation\">(</span>ActionType<span class=\"token punctuation\">.</span>ADDED<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//更新服务最新更新时间</span>\n        registrant<span class=\"token punctuation\">.</span><span class=\"token function\">setLastUpdatedTimestamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//刷选缓存，实现类ResponseCacheImpl Eureka二级缓存  readOnlyCacheMap(只读缓存) readWriteCacheMap(读写缓存)</span>\n        <span class=\"token function\">invalidateCache</span><span class=\"token punctuation\">(</span>registrant<span class=\"token punctuation\">.</span><span class=\"token function\">getAppName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> registrant<span class=\"token punctuation\">.</span><span class=\"token function\">getVIPAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> registrant<span class=\"token punctuation\">.</span><span class=\"token function\">getSecureVipAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> \n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"服务续约\"><a href=\"#服务续约\" class=\"headerlink\" title=\"服务续约\"></a>服务续约</h3><p>注册成功后，每隔一段时间，客户端会向注册中间发送心跳赖续约服务，也就是汇报健康状态。</p>\n<ol>\n<li>客户端启动时会启动一个心跳(续约)定时任务。定时向注册中心发送续约信息。具体方法<code>DiscoveryClient#initScheduledTasks()</code></li>\n<li>注册中心接收信息，完成续约操作。<code>AbstractInstanceRegistry#renew()</code></li>\n</ol>\n<pre class=\" language-java\"><code class=\"language-java\">scheduler<span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span>\n                    <span class=\"token keyword\">new</span> <span class=\"token class-name\">TimedSupervisorTask</span><span class=\"token punctuation\">(</span>\n                            <span class=\"token string\">\"heartbeat\"</span><span class=\"token punctuation\">,</span>\n                            scheduler<span class=\"token punctuation\">,</span>\n                            heartbeatExecutor<span class=\"token punctuation\">,</span>\n                            renewalIntervalInSecs<span class=\"token punctuation\">,</span>\n                            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">,</span>\n                            expBackOffBound<span class=\"token punctuation\">,</span>\n                            <span class=\"token comment\" spellcheck=\"true\">//心跳续约线程</span>\n                            <span class=\"token keyword\">new</span> <span class=\"token class-name\">HeartbeatThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\nrenewalIntervalInSecs<span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h3 id=\"获取服务注册信息\"><a href=\"#获取服务注册信息\" class=\"headerlink\" title=\"获取服务注册信息\"></a>获取服务注册信息</h3><p>客户端通过定时器的方式从注册中心获取服务注册信息并更新缓存，默认每隔30秒刷选本地缓存。</p>\n<p>关键配置是eureka.client.registry-fetch-interval-seconds=30，表示定时30秒从注册中心获取服务注册信息。</p>\n<p>Eureka 客户端不停地获取服务器端的更新数据，就能保证自己的数据和 Eureka 服务器端的保持一致。</p>\n<p>代码入口：<code>DiscoveryClient#initScheduledTasks()</code></p>\n<pre><code>if (clientConfig.shouldFetchRegistry()) {\n    int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();\n    int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();\n    scheduler.schedule(\n            new TimedSupervisorTask(\n                    &quot;cacheRefresh&quot;,\n                    scheduler,\n                    cacheRefreshExecutor,\n                    registryFetchIntervalSeconds,\n                    TimeUnit.SECONDS,\n                    expBackOffBound,\n                    new CacheRefreshThread()\n            ),\n            registryFetchIntervalSeconds, TimeUnit.SECONDS);\n}\n</code></pre><p>客户端在获取服务注册信息时，首次拉取全量信息，之后拉取增量信息，然后增量拉取的数据跟本地缓存进行合并。拉取的数据通过一个一致性HashCode与本地缓存进行比对，如果HashCode不一致则说明本地缓存和注册中心的服务信息不一致，此时就拉取一次全量数据进行更新。</p>\n<h3 id=\"自我保护机制\"><a href=\"#自我保护机制\" class=\"headerlink\" title=\"自我保护机制\"></a>自我保护机制</h3><p>自我保护机制是为了避免因网络分区故障而导致服务不可用的问题。假设服务提供者A跟注册中心由于网络的问题没法进行续约，此时注册中心就会将A的实例移除，导致消费者没法从注册中心获取到A的实例造成调用失败，但此时A与消费者网络是正常的。所以有了自动保护机制。</p>\n<p><strong>触发自动保护机制的前提</strong>：如果在15分钟内超过85%的服务提供者节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制。</p>\n<p><strong>自动保护机制</strong> ：</p>\n<ul>\n<li>注册中心不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。</li>\n<li>注册中心仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。</li>\n<li>当网络稳定时，当前注册中心新的注册信息会被同步到其它节点中。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><p><img src=\"/2021/01/01/springcloud-1/1.png\" alt></p>\n<ul>\n<li>服务注册。Eureka客户端（服务提供者或消费者）通过向Eureka服务器提供IP地址，端口等各项与服务相关的基本信息来完成注册操作。</li>\n<li>服务续约。Eureka客户端每隔一段时间向Eureka服务端发送服务续约信息来保证服务存活。</li>\n<li>服务取消。Eureka客户端主动告知Eureka服务器自己不想再注册到Eureka中。</li>\n<li>服务剔除。服务剔除是Eureka服务端（注册中心）做的事情，当一段时间没收到续约信息，就会认为该服务实例已经不再运行，从而将其从服务列表中进行剔除。</li>\n<li>服务发现。客户端通过定时任务定时从Eureka服务端获取服务信息并缓存。</li>\n</ul>\n<h2 id=\"代码走读\"><a href=\"#代码走读\" class=\"headerlink\" title=\"代码走读\"></a>代码走读</h2><p>接口LeaseManager定义了服务注册，服务取消，服务续约，服务下线功能。研究代码入口可以从LeaseManager实现类入手。</p>\n<pre><code class=\"java\">public interface LeaseManager&lt;T&gt; {\n    //服务注册\n    void register(T r, int leaseDuration, boolean isReplication);\n    //服务取消\n    boolean cancel(String appName, String id, boolean isReplication);\n    //服务续约\n    boolean renew(String appName, String id, boolean isReplication);\n    //服务取消\n    void evict();\n}</code></pre>\n<h3 id=\"服务注册\"><a href=\"#服务注册\" class=\"headerlink\" title=\"服务注册\"></a>服务注册</h3><ol>\n<li>当服务启动时，会通过<code>DiscoveryClient#register()</code>方法发起一个REST风格的HTTP远程请求，请求包含了服务的信息（具体信息用<code>InstanceInfo</code>类表示）</li>\n<li>注册中心接收到REST远程请求后，对服务进行注册<code>AbstractInstanceRegistry#register()</code>方法，用一个双层ConcurrentHashMap存储服务信息。外层Map的key表示服务名称（spring.application.name），内层key表示服务Id（eureka.instance.instanceId），内层Value是一个Lease类，包含了服务的信息、注册时间、最新的续约时间等。</li>\n</ol>\n<pre><code class=\"java\"># DiscoveryClient#register()\nboolean register() throws Throwable {\n    logger.info(PREFIX + &quot;{}: registering service...&quot;, appPathIdentifier);\n    EurekaHttpResponse&lt;Void&gt; httpResponse;\n    try {\n        //instanceInfo包含了服务的信息\n        //向服务端注册服务,通过这一行发送一个REST的远程请求\n        httpResponse = eurekaTransport.registrationClient.register(instanceInfo);\n    } catch (Exception e) {\n        //....\n    }\n    // ...\n    return httpResponse.getStatusCode() == 204;\n}\n\n// --------------------------------分隔符--------------------------------\n\n//用来存储服务信息\nConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt; registry\n            = new ConcurrentHashMap&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;();\n\n\npublic void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {\n    try { \n        //从已存储的 registry 获取一个服务定义\n        Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());\n        REGISTER.increment(isReplication);\n        if (gMap == null) {\n            //初始化一个 Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; ，并放入 registry 中\n        }\n        //根据当前注册的 ID 找到对应的 Lease\n        Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());\n\n        if (existingLease != null &amp;&amp; (existingLease.getHolder() != null)) {\n            //如果 Lease 能找到，根据当前节点的最新更新时间和注册节点的最新更新时间比较\n            //如果前者的时间晚于后者的时间，那么注册实例就以已存在的实例为准\n        } else {\n              //如果找不到，代表是一个新注册，则更新其每分钟期望的续约数量及其阈值\n        }\n        //创建一个新 Lease 并放入 Map 中\n        Lease&lt;InstanceInfo&gt; lease = new Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);\n        gMap.put(registrant.getId(), lease);\n\n        //处理服务的 InstanceStatus\n        registrant.setActionType(ActionType.ADDED);\n\n        //更新服务最新更新时间\n        registrant.setLastUpdatedTimestamp();\n\n        //刷选缓存，实现类ResponseCacheImpl Eureka二级缓存  readOnlyCacheMap(只读缓存) readWriteCacheMap(读写缓存)\n        invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());\n    } \n}</code></pre>\n<h3 id=\"服务续约\"><a href=\"#服务续约\" class=\"headerlink\" title=\"服务续约\"></a>服务续约</h3><p>注册成功后，每隔一段时间，客户端会向注册中间发送心跳赖续约服务，也就是汇报健康状态。</p>\n<ol>\n<li>客户端启动时会启动一个心跳(续约)定时任务。定时向注册中心发送续约信息。具体方法<code>DiscoveryClient#initScheduledTasks()</code></li>\n<li>注册中心接收信息，完成续约操作。<code>AbstractInstanceRegistry#renew()</code></li>\n</ol>\n<pre><code class=\"java\">scheduler.schedule(\n                    new TimedSupervisorTask(\n                            &quot;heartbeat&quot;,\n                            scheduler,\n                            heartbeatExecutor,\n                            renewalIntervalInSecs,\n                            TimeUnit.SECONDS,\n                            expBackOffBound,\n                            //心跳续约线程\n                            new HeartbeatThread()\n                    ),\nrenewalIntervalInSecs, TimeUnit.SECONDS);</code></pre>\n<h3 id=\"获取服务注册信息\"><a href=\"#获取服务注册信息\" class=\"headerlink\" title=\"获取服务注册信息\"></a>获取服务注册信息</h3><p>客户端通过定时器的方式从注册中心获取服务注册信息并更新缓存，默认每隔30秒刷选本地缓存。</p>\n<p>关键配置是eureka.client.registry-fetch-interval-seconds=30，表示定时30秒从注册中心获取服务注册信息。</p>\n<p>Eureka 客户端不停地获取服务器端的更新数据，就能保证自己的数据和 Eureka 服务器端的保持一致。</p>\n<p>代码入口：<code>DiscoveryClient#initScheduledTasks()</code></p>\n<pre><code>if (clientConfig.shouldFetchRegistry()) {\n    int registryFetchIntervalSeconds = clientConfig.getRegistryFetchIntervalSeconds();\n    int expBackOffBound = clientConfig.getCacheRefreshExecutorExponentialBackOffBound();\n    scheduler.schedule(\n            new TimedSupervisorTask(\n                    &quot;cacheRefresh&quot;,\n                    scheduler,\n                    cacheRefreshExecutor,\n                    registryFetchIntervalSeconds,\n                    TimeUnit.SECONDS,\n                    expBackOffBound,\n                    new CacheRefreshThread()\n            ),\n            registryFetchIntervalSeconds, TimeUnit.SECONDS);\n}\n</code></pre><p>客户端在获取服务注册信息时，首次拉取全量信息，之后拉取增量信息，然后增量拉取的数据跟本地缓存进行合并。拉取的数据通过一个一致性HashCode与本地缓存进行比对，如果HashCode不一致则说明本地缓存和注册中心的服务信息不一致，此时就拉取一次全量数据进行更新。</p>\n<h3 id=\"自我保护机制\"><a href=\"#自我保护机制\" class=\"headerlink\" title=\"自我保护机制\"></a>自我保护机制</h3><p>自我保护机制是为了避免因网络分区故障而导致服务不可用的问题。假设服务提供者A跟注册中心由于网络的问题没法进行续约，此时注册中心就会将A的实例移除，导致消费者没法从注册中心获取到A的实例造成调用失败，但此时A与消费者网络是正常的。所以有了自动保护机制。</p>\n<p><strong>触发自动保护机制的前提</strong>：如果在15分钟内超过85%的服务提供者节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制。</p>\n<p><strong>自动保护机制</strong> ：</p>\n<ul>\n<li>注册中心不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。</li>\n<li>注册中心仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。</li>\n<li>当网络稳定时，当前注册中心新的注册信息会被同步到其它节点中。</li>\n</ul>\n"},{"title":"记录SpringCloud实践中遇到的问题","description":"记录SpringCloud实践中遇到的问题","date":"2021-01-02T07:46:34.000Z","_content":"### Eureka 服务发现慢的原因\n\n经常遇到注册中心的问题 :\n\n1. 新服务上线后，服务消费者不能访问到刚上线的新服务，需要过一段时间后才能访问。\n2. 服务下线后，服务还是会被调用到，一段时候后才彻底停止服务。\n\n导致这个的问题是因为Eureka Server，Eureka Client，Ribbon为了提供性能，都有内置了缓存来记录服务信息。所以导致了需要等待一段时间才能获取到服务信息。\n\n- Eureka Server 二级缓存（只读缓存，读写缓存）。只读缓存默认30秒与读写缓存进行同步，通过参数eureka.server.response-cache-update-interval-ms控制。读写缓存过期时间默认180秒，当服务下线，过期，注册，状态更变时会刷新此缓存。\n- Eureka Client初始化了一个CacheRefreshThread 定时任务专门用来拉取 Eureka Server 的实例信息到本地。默认30秒，通过参数eureka.client.registry-fetch-interval-seconds控制。\n- Ribbon缓存，通过ribbon.ServerListRefreshInterval控制。\n\n#### **服务端缓存**\n\n当Eureka Client注册到Eureka Server时，注册中心通过一个`双层的ConcurrentHashMap`来记录服务实例信息（纯内存的注册表提高了性能）。且为了能支撑每天千万级的高并发访问，Eureka Server同时也实现了一个`多级缓存机制`来保证，实现类为ResponseCacheImpl。\n\n- readOnlyCacheMap，读缓存，结构是一个ConcurrentHashMap。\n- readWriteCacheMap，读写缓存，结构是guava的Cache缓存。\n\n**主动注册刷新缓存**\n\n主动刷新，指的是应用实例(即`Eureka Client`端)在进行注册，续约租期，更新状态，删除时，会主动来刷新`readWriteCacheMap`中的数据。\n\n```java\n// AbstractInstanceRegistry类关键代码\n// 这里只截取了注册相关代码，续约租期，更新状态，删除是类似的\npublic void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {\n\ttry{\n\t\t......\n\t\tinvalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());\n\t\t......\n\t}finally {\n       read.unlock();\n    }\n}\nprivate void invalidateCache(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {\n    responseCache.invalidate(appName, vipAddress, secureVipAddress);\n}\n\n// ResponseCacheImpl类关键代码\npublic void invalidate(Key... keys) {\n    for (Key key : keys) {\n        readWriteCacheMap.invalidate(key);\n        ......\n        for (Key keysWithRegion : keysWithRegions) {\n            readWriteCacheMap.invalidate(keysWithRegion);\n        }\n        ......\n    }\n}\n```\n\n**被动更新缓存**\n\n当参数shouldUseReadOnlyResponseCache（eureka.server.use-read-only-response-cache）为true时候，默认每隔30s（可以通过eureka.server.response-cache-update-interval-ms修改默认值）将`readWriteCacheMap`的数据刷入`readOnlyCacheMap`中。\n\n```java\nResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) {\n    //关键代码    \n     if (shouldUseReadOnlyResponseCache) {\n         timer.schedule(getCacheUpdateTask(),\n                 new Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)\n                         + responseCacheUpdateIntervalMs),\n                 responseCacheUpdateIntervalMs);\n     }\n}\n\nprivate TimerTask getCacheUpdateTask() {\n    return new TimerTask() {\n        @Override\n        public void run() {\n            logger.debug(\"Updating the client cache from response cache\");\n            for (Key key : readOnlyCacheMap.keySet()) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Updating the client cache from response cache for key : {} {} {} {}\",\n                            key.getEntityType(), key.getName(), key.getVersion(), key.getType());\n                }\n                try {\n                    CurrentRequestVersion.set(key.getVersion());\n                    Value cacheValue = readWriteCacheMap.get(key);\n                    Value currentCacheValue = readOnlyCacheMap.get(key);\n                    if (cacheValue != currentCacheValue) {\n                        readOnlyCacheMap.put(key, cacheValue);\n                    }\n                } catch (Throwable th) {\n                    logger.error(\"Error while updating the client cache from response cache for key {}\", key.toStringCompact(), th);\n                }\n            }\n        }\n    };\n}\n```\n\n**定时刷新缓存**\n\n如果隔了一段时间，`readWriteCacheMap`读写缓存中的数据还没刷新的话，就会将此数据给过期删除掉。默认是180S，通过参数ResponseCacheAutoExpirationInSeconds（eureka.server.response-cache-auto-expiration-in-seconds=180）控制。当服务下线，过期，注册，状态更变等操作就会来清除此缓存中的数据。\n\n```java\nResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) {\n    //采用guava的缓存框架\n   this.readWriteCacheMap =\n           CacheBuilder.newBuilder().initialCapacity(serverConfig.getInitialCapacityOfResponseCache())\n                   .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)\n                   .removalListener(new RemovalListener<Key, Value>() {\n                       @Override\n                       public void onRemoval(RemovalNotification<Key, Value> notification) {\n                           Key removedKey = notification.getKey();\n                           if (removedKey.hasRegions()) {\n                               Key cloneWithNoRegions = removedKey.cloneWithoutRegions();\n                               regionSpecificKeys.remove(cloneWithNoRegions, removedKey);\n                           }\n                       }\n                   })\n                   .build(new CacheLoader<Key, Value>() {\n                       @Override\n                       public Value load(Key key) throws Exception {\n                           if (key.hasRegions()) {\n                               Key cloneWithNoRegions = key.cloneWithoutRegions();\n                               regionSpecificKeys.put(cloneWithNoRegions, key);\n                           }\n                           Value value = generatePayload(key);\n                           return value;\n                       }\n                   });\n\n}\n```\n\n**Eureka Client如何获取服务实例信息**\n\nEureka Client 获取服务实例数据时，会先从一级缓存中获取，如果一级缓存中不存在，再从二级缓存中获取，如果二级缓存也不存在，会触发缓存的加载，从存储层拉取数据到缓存中，然后再返回给 Client。\n\n#### **客户端缓存**\n\n当Eureka Client从注册中心获取服务实例信息后，本身Client也会将信息缓存到本地。主要代码在DiscoveryClient.initScheduledTasks()方法中定义了CacheRefreshThread定时任务专门用来拉取 Eureka Server 的实例信息到本地。默认是30S，可以通过eureka.client.registry-fetch-interval-seconds控制。\n\nEureka Client从注册中心拉取服务实例信息的流程如下：\n\n1. 首次全量拉取。\n2. 定时通过CacheRefreshThread拉取增量服务实例，并通过比对hashcode来合并全量服务实例。\n\n#### **Ribbon 缓存**\n\nRibbon会从Eureka Client中获取服务信息。ServerListUpdater 是 Ribbon 中负责服务实例更新的组件，默认的实现是PollingServerListUpdater，通过线程定时去更新实例信息。定时刷新的时间间隔默认是 30 秒。可以通过ribbon.ServerListRefreshInterval控制间隔时间。\n\n以下是Ribbon各个组件作用：\n\n- ILoadBalancer：定义一系列的操作接口，比如选择服务实例。\n- IRule：算法策略，内置算法策略来为服务实例的选择提供服务。\n- ServerList：负责服务实例信息的获取，可以获取配置文件中的，也可以从注册中心获取。\n- ServerListFilter：过滤掉某些不想要的服务实例信息。\n- ServerListUpdater：更新本地缓存的服务实例信息。\n- IPing：对已有的服务实例进行可用性检查，保证选择的服务都是可用的。\n\n### Fegin、Hystrix、Ribbon超时与重试\n\n![Fegin、Hystrix、Ribbon调用关系](springcloud-2/1.png)\n\n- Ribbon的全局超时时间通过`ribbon.ReadTimeout `和 `ribbon.ConnectTimeout`配置。\n- Hyxstrix的全局超时时间通过`hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds`配置。\n- Fegin本身也有超时时间，通过`feign.client.config.default.connectTimeout`和`feign.client.config.default.connectTimeout`设置，但**如果设置了Ribbon的超时时间则以Ribbon的超时时间为准，Fegin自身的配置会被覆盖**。\n- 由于Ribbon有重试机制，所以Hystrix的超时时间要大于Ribbon的超时时间。公式 `Hystrix的超时时间 > Ribbon的重试次数(包含首次) * (ribbon.ReadTimeout + ribbon.ConnectTimeout)`\n\n这里需要明确Ribbon的重试机制。包括`同一台实例` 和 `另一个实例`的重试。所以Ribbon的重试次数公式如下：\n$$\n1 + ribbon.MaxAutoRetries  +  ribbon.MaxAutoRetriesNextServer\n$$\n\n```yml\nribbon:\n  eager-load:\n    enabled: true\n  #说明：同一台实例的最大自动重试次数，默认为1次，不包括首次\n  MaxAutoRetries: 1\n  #说明：要重试的下一个实例的最大数量，默认为1，不包括第一次被调用的实例\n  MaxAutoRetriesNextServer: 1\n  #说明：是否所有的操作都重试，默认为true\n  OkToRetryOnAllOperations: true\n  #说明：从注册中心刷新服务器列表信息的时间间隔，默认为2000毫秒，即2秒\n  ServerListRefreshInterval: 2000\n  #说明：使用Apache HttpClient连接超时时间，单位为毫秒\n  ConnectTimeout: 3000\n  #说明：使用Apache HttpClient读取的超时时间，单位为毫秒\n  ReadTimeout: 3000\n```\n\n### Fegin的封装最佳实践\n\n#### Fegin封装\n\n一般来说，我们作为Eureka Client，需要`提供给外部服务`和`实现提供的服务`。因为 Spring Cloud Open Feign 中支持继承的特性，我们可以将 API 的定义提取出来封装成一个单独的接口，给 API 的实现方和调用方共用，在一定程度上简化了重复的代码。\n\n```java\n//提供给外部的API，我们可以统一将其抽离成一个Maven工程\n@FeignClient(name = \"user-service\")\npublic interface UserFeignRemoteClient {\n\t@GetMapping(\"/user/get\")\n\tpublic User getUser(@RequestParam(\"id\") Long id);\n}\n\n\n//实现提供的服务\n@RestController\npublic class UserController implements UserFeignRemoteClient{\n\t@Override\n\tpublic User getUser(@RequestParam(\"id\") Long id){\n\t\tSystem.out.println(\"具体实现\");\n\t}\n}\n\n//提供给外部服务使用\n@Autowired\nprivate UserFeignRemoteClient userFeignRemoteClient;\n```\n\n其实在 Spring Cloud Open Feign 的文档中，给出的继承示列还要多一个类，第一步是抽出一个公共的接口，比如我们这边的 UserService，UserService 中定义了要实现的 API 的方法。\n\n```java\npublic interface UserService {\n\t@GetMapping(\"/user/get\")\n\tpublic User getUser(@RequestParam(\"id\") Long id);\n}\n\n//提供给外部的API，我们可以统一将其抽离成一个Maven工程\n@FeignClient(name = \"user-service\")\npublic interface UserFeignRemoteClient extends UserService{\n\t\n}\n\n//实现提供的服务\n@RestController\npublic class UserController implements UserService{\n\t@Override\n\tpublic User getUser(@RequestParam(\"id\") Long id){\n\t\tSystem.out.println(\"具体实现\");\n\t}\n}\n\n//提供给外部服务使用\n@Autowired\nprivate UserFeignRemoteClient userFeignRemoteClient;\n```\n\n#### Fegin多参数传递\n\n如果Fegin需要多个参数一起传递的话，一般最佳的实践是将参数封装，然后采用`@SpringQueryMap`修师。例如下面\n\n```java\n@RestController\npublic class UserController implements UserService{\n\t@Override\n\tpublic User getUser(@SpringQueryMap StudentRequest studentRequest){\n\t\tSystem.out.println(\"具体实现\");\n\t}\n}\npublic class StudentRequest{\n\tprivate Long id;\n\tprivate String name;\n}\n```\n\n#### Feign拦截器\n\n假设服务A调用服务B，然后服务A需要向服务B传递一些参数，此时就可以用Fegin拦截器。\n\n```java\n@Configuration\npublic class FeignInterceptorConfig {\n\t@Bean\n\tpublic RequestInterceptor requestInterceptor() {\n\t\tRequestInterceptor requestInterceptor = new RequestInterceptor() {\n\n\t\t\t@Override\n\t\t\tpublic void apply(RequestTemplate template) {\n\t\t\t\t//传递token\n\t\t\t\t//使用feign client访问别的微服务时，将accessToken header \n\t\t\t\t//config.anyRequest().permitAll() 非强制校验token\n\t\t\t\tif(StringUtils.isNotBlank(TokenUtil.getToken())){\n\t\t\t\t\ttemplate.header(UaaConstant.TOKEN_HEADER, TokenUtil.getToken() );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn requestInterceptor;\n\t}\n}\n```\n\n","source":"_posts/springcloud-2.md","raw":"---\ntitle: 记录SpringCloud实践中遇到的问题\ntags:\n  - SpringCloud\ncategories: SpringCloud\ndescription : 记录SpringCloud实践中遇到的问题\ndate: 2021-01-02 15:46:34\n---\n### Eureka 服务发现慢的原因\n\n经常遇到注册中心的问题 :\n\n1. 新服务上线后，服务消费者不能访问到刚上线的新服务，需要过一段时间后才能访问。\n2. 服务下线后，服务还是会被调用到，一段时候后才彻底停止服务。\n\n导致这个的问题是因为Eureka Server，Eureka Client，Ribbon为了提供性能，都有内置了缓存来记录服务信息。所以导致了需要等待一段时间才能获取到服务信息。\n\n- Eureka Server 二级缓存（只读缓存，读写缓存）。只读缓存默认30秒与读写缓存进行同步，通过参数eureka.server.response-cache-update-interval-ms控制。读写缓存过期时间默认180秒，当服务下线，过期，注册，状态更变时会刷新此缓存。\n- Eureka Client初始化了一个CacheRefreshThread 定时任务专门用来拉取 Eureka Server 的实例信息到本地。默认30秒，通过参数eureka.client.registry-fetch-interval-seconds控制。\n- Ribbon缓存，通过ribbon.ServerListRefreshInterval控制。\n\n#### **服务端缓存**\n\n当Eureka Client注册到Eureka Server时，注册中心通过一个`双层的ConcurrentHashMap`来记录服务实例信息（纯内存的注册表提高了性能）。且为了能支撑每天千万级的高并发访问，Eureka Server同时也实现了一个`多级缓存机制`来保证，实现类为ResponseCacheImpl。\n\n- readOnlyCacheMap，读缓存，结构是一个ConcurrentHashMap。\n- readWriteCacheMap，读写缓存，结构是guava的Cache缓存。\n\n**主动注册刷新缓存**\n\n主动刷新，指的是应用实例(即`Eureka Client`端)在进行注册，续约租期，更新状态，删除时，会主动来刷新`readWriteCacheMap`中的数据。\n\n```java\n// AbstractInstanceRegistry类关键代码\n// 这里只截取了注册相关代码，续约租期，更新状态，删除是类似的\npublic void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {\n\ttry{\n\t\t......\n\t\tinvalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());\n\t\t......\n\t}finally {\n       read.unlock();\n    }\n}\nprivate void invalidateCache(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {\n    responseCache.invalidate(appName, vipAddress, secureVipAddress);\n}\n\n// ResponseCacheImpl类关键代码\npublic void invalidate(Key... keys) {\n    for (Key key : keys) {\n        readWriteCacheMap.invalidate(key);\n        ......\n        for (Key keysWithRegion : keysWithRegions) {\n            readWriteCacheMap.invalidate(keysWithRegion);\n        }\n        ......\n    }\n}\n```\n\n**被动更新缓存**\n\n当参数shouldUseReadOnlyResponseCache（eureka.server.use-read-only-response-cache）为true时候，默认每隔30s（可以通过eureka.server.response-cache-update-interval-ms修改默认值）将`readWriteCacheMap`的数据刷入`readOnlyCacheMap`中。\n\n```java\nResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) {\n    //关键代码    \n     if (shouldUseReadOnlyResponseCache) {\n         timer.schedule(getCacheUpdateTask(),\n                 new Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)\n                         + responseCacheUpdateIntervalMs),\n                 responseCacheUpdateIntervalMs);\n     }\n}\n\nprivate TimerTask getCacheUpdateTask() {\n    return new TimerTask() {\n        @Override\n        public void run() {\n            logger.debug(\"Updating the client cache from response cache\");\n            for (Key key : readOnlyCacheMap.keySet()) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Updating the client cache from response cache for key : {} {} {} {}\",\n                            key.getEntityType(), key.getName(), key.getVersion(), key.getType());\n                }\n                try {\n                    CurrentRequestVersion.set(key.getVersion());\n                    Value cacheValue = readWriteCacheMap.get(key);\n                    Value currentCacheValue = readOnlyCacheMap.get(key);\n                    if (cacheValue != currentCacheValue) {\n                        readOnlyCacheMap.put(key, cacheValue);\n                    }\n                } catch (Throwable th) {\n                    logger.error(\"Error while updating the client cache from response cache for key {}\", key.toStringCompact(), th);\n                }\n            }\n        }\n    };\n}\n```\n\n**定时刷新缓存**\n\n如果隔了一段时间，`readWriteCacheMap`读写缓存中的数据还没刷新的话，就会将此数据给过期删除掉。默认是180S，通过参数ResponseCacheAutoExpirationInSeconds（eureka.server.response-cache-auto-expiration-in-seconds=180）控制。当服务下线，过期，注册，状态更变等操作就会来清除此缓存中的数据。\n\n```java\nResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) {\n    //采用guava的缓存框架\n   this.readWriteCacheMap =\n           CacheBuilder.newBuilder().initialCapacity(serverConfig.getInitialCapacityOfResponseCache())\n                   .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)\n                   .removalListener(new RemovalListener<Key, Value>() {\n                       @Override\n                       public void onRemoval(RemovalNotification<Key, Value> notification) {\n                           Key removedKey = notification.getKey();\n                           if (removedKey.hasRegions()) {\n                               Key cloneWithNoRegions = removedKey.cloneWithoutRegions();\n                               regionSpecificKeys.remove(cloneWithNoRegions, removedKey);\n                           }\n                       }\n                   })\n                   .build(new CacheLoader<Key, Value>() {\n                       @Override\n                       public Value load(Key key) throws Exception {\n                           if (key.hasRegions()) {\n                               Key cloneWithNoRegions = key.cloneWithoutRegions();\n                               regionSpecificKeys.put(cloneWithNoRegions, key);\n                           }\n                           Value value = generatePayload(key);\n                           return value;\n                       }\n                   });\n\n}\n```\n\n**Eureka Client如何获取服务实例信息**\n\nEureka Client 获取服务实例数据时，会先从一级缓存中获取，如果一级缓存中不存在，再从二级缓存中获取，如果二级缓存也不存在，会触发缓存的加载，从存储层拉取数据到缓存中，然后再返回给 Client。\n\n#### **客户端缓存**\n\n当Eureka Client从注册中心获取服务实例信息后，本身Client也会将信息缓存到本地。主要代码在DiscoveryClient.initScheduledTasks()方法中定义了CacheRefreshThread定时任务专门用来拉取 Eureka Server 的实例信息到本地。默认是30S，可以通过eureka.client.registry-fetch-interval-seconds控制。\n\nEureka Client从注册中心拉取服务实例信息的流程如下：\n\n1. 首次全量拉取。\n2. 定时通过CacheRefreshThread拉取增量服务实例，并通过比对hashcode来合并全量服务实例。\n\n#### **Ribbon 缓存**\n\nRibbon会从Eureka Client中获取服务信息。ServerListUpdater 是 Ribbon 中负责服务实例更新的组件，默认的实现是PollingServerListUpdater，通过线程定时去更新实例信息。定时刷新的时间间隔默认是 30 秒。可以通过ribbon.ServerListRefreshInterval控制间隔时间。\n\n以下是Ribbon各个组件作用：\n\n- ILoadBalancer：定义一系列的操作接口，比如选择服务实例。\n- IRule：算法策略，内置算法策略来为服务实例的选择提供服务。\n- ServerList：负责服务实例信息的获取，可以获取配置文件中的，也可以从注册中心获取。\n- ServerListFilter：过滤掉某些不想要的服务实例信息。\n- ServerListUpdater：更新本地缓存的服务实例信息。\n- IPing：对已有的服务实例进行可用性检查，保证选择的服务都是可用的。\n\n### Fegin、Hystrix、Ribbon超时与重试\n\n![Fegin、Hystrix、Ribbon调用关系](springcloud-2/1.png)\n\n- Ribbon的全局超时时间通过`ribbon.ReadTimeout `和 `ribbon.ConnectTimeout`配置。\n- Hyxstrix的全局超时时间通过`hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds`配置。\n- Fegin本身也有超时时间，通过`feign.client.config.default.connectTimeout`和`feign.client.config.default.connectTimeout`设置，但**如果设置了Ribbon的超时时间则以Ribbon的超时时间为准，Fegin自身的配置会被覆盖**。\n- 由于Ribbon有重试机制，所以Hystrix的超时时间要大于Ribbon的超时时间。公式 `Hystrix的超时时间 > Ribbon的重试次数(包含首次) * (ribbon.ReadTimeout + ribbon.ConnectTimeout)`\n\n这里需要明确Ribbon的重试机制。包括`同一台实例` 和 `另一个实例`的重试。所以Ribbon的重试次数公式如下：\n$$\n1 + ribbon.MaxAutoRetries  +  ribbon.MaxAutoRetriesNextServer\n$$\n\n```yml\nribbon:\n  eager-load:\n    enabled: true\n  #说明：同一台实例的最大自动重试次数，默认为1次，不包括首次\n  MaxAutoRetries: 1\n  #说明：要重试的下一个实例的最大数量，默认为1，不包括第一次被调用的实例\n  MaxAutoRetriesNextServer: 1\n  #说明：是否所有的操作都重试，默认为true\n  OkToRetryOnAllOperations: true\n  #说明：从注册中心刷新服务器列表信息的时间间隔，默认为2000毫秒，即2秒\n  ServerListRefreshInterval: 2000\n  #说明：使用Apache HttpClient连接超时时间，单位为毫秒\n  ConnectTimeout: 3000\n  #说明：使用Apache HttpClient读取的超时时间，单位为毫秒\n  ReadTimeout: 3000\n```\n\n### Fegin的封装最佳实践\n\n#### Fegin封装\n\n一般来说，我们作为Eureka Client，需要`提供给外部服务`和`实现提供的服务`。因为 Spring Cloud Open Feign 中支持继承的特性，我们可以将 API 的定义提取出来封装成一个单独的接口，给 API 的实现方和调用方共用，在一定程度上简化了重复的代码。\n\n```java\n//提供给外部的API，我们可以统一将其抽离成一个Maven工程\n@FeignClient(name = \"user-service\")\npublic interface UserFeignRemoteClient {\n\t@GetMapping(\"/user/get\")\n\tpublic User getUser(@RequestParam(\"id\") Long id);\n}\n\n\n//实现提供的服务\n@RestController\npublic class UserController implements UserFeignRemoteClient{\n\t@Override\n\tpublic User getUser(@RequestParam(\"id\") Long id){\n\t\tSystem.out.println(\"具体实现\");\n\t}\n}\n\n//提供给外部服务使用\n@Autowired\nprivate UserFeignRemoteClient userFeignRemoteClient;\n```\n\n其实在 Spring Cloud Open Feign 的文档中，给出的继承示列还要多一个类，第一步是抽出一个公共的接口，比如我们这边的 UserService，UserService 中定义了要实现的 API 的方法。\n\n```java\npublic interface UserService {\n\t@GetMapping(\"/user/get\")\n\tpublic User getUser(@RequestParam(\"id\") Long id);\n}\n\n//提供给外部的API，我们可以统一将其抽离成一个Maven工程\n@FeignClient(name = \"user-service\")\npublic interface UserFeignRemoteClient extends UserService{\n\t\n}\n\n//实现提供的服务\n@RestController\npublic class UserController implements UserService{\n\t@Override\n\tpublic User getUser(@RequestParam(\"id\") Long id){\n\t\tSystem.out.println(\"具体实现\");\n\t}\n}\n\n//提供给外部服务使用\n@Autowired\nprivate UserFeignRemoteClient userFeignRemoteClient;\n```\n\n#### Fegin多参数传递\n\n如果Fegin需要多个参数一起传递的话，一般最佳的实践是将参数封装，然后采用`@SpringQueryMap`修师。例如下面\n\n```java\n@RestController\npublic class UserController implements UserService{\n\t@Override\n\tpublic User getUser(@SpringQueryMap StudentRequest studentRequest){\n\t\tSystem.out.println(\"具体实现\");\n\t}\n}\npublic class StudentRequest{\n\tprivate Long id;\n\tprivate String name;\n}\n```\n\n#### Feign拦截器\n\n假设服务A调用服务B，然后服务A需要向服务B传递一些参数，此时就可以用Fegin拦截器。\n\n```java\n@Configuration\npublic class FeignInterceptorConfig {\n\t@Bean\n\tpublic RequestInterceptor requestInterceptor() {\n\t\tRequestInterceptor requestInterceptor = new RequestInterceptor() {\n\n\t\t\t@Override\n\t\t\tpublic void apply(RequestTemplate template) {\n\t\t\t\t//传递token\n\t\t\t\t//使用feign client访问别的微服务时，将accessToken header \n\t\t\t\t//config.anyRequest().permitAll() 非强制校验token\n\t\t\t\tif(StringUtils.isNotBlank(TokenUtil.getToken())){\n\t\t\t\t\ttemplate.header(UaaConstant.TOKEN_HEADER, TokenUtil.getToken() );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn requestInterceptor;\n\t}\n}\n```\n\n","slug":"springcloud-2","published":1,"updated":"2021-04-08T00:47:07.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhvz0046qwv22hrf25le","content":"<h3 id=\"Eureka-服务发现慢的原因\"><a href=\"#Eureka-服务发现慢的原因\" class=\"headerlink\" title=\"Eureka 服务发现慢的原因\"></a>Eureka 服务发现慢的原因</h3><p>经常遇到注册中心的问题 :</p>\n<ol>\n<li>新服务上线后，服务消费者不能访问到刚上线的新服务，需要过一段时间后才能访问。</li>\n<li>服务下线后，服务还是会被调用到，一段时候后才彻底停止服务。</li>\n</ol>\n<p>导致这个的问题是因为Eureka Server，Eureka Client，Ribbon为了提供性能，都有内置了缓存来记录服务信息。所以导致了需要等待一段时间才能获取到服务信息。</p>\n<ul>\n<li>Eureka Server 二级缓存（只读缓存，读写缓存）。只读缓存默认30秒与读写缓存进行同步，通过参数eureka.server.response-cache-update-interval-ms控制。读写缓存过期时间默认180秒，当服务下线，过期，注册，状态更变时会刷新此缓存。</li>\n<li>Eureka Client初始化了一个CacheRefreshThread 定时任务专门用来拉取 Eureka Server 的实例信息到本地。默认30秒，通过参数eureka.client.registry-fetch-interval-seconds控制。</li>\n<li>Ribbon缓存，通过ribbon.ServerListRefreshInterval控制。</li>\n</ul>\n<h4 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a><strong>服务端缓存</strong></h4><p>当Eureka Client注册到Eureka Server时，注册中心通过一个<code>双层的ConcurrentHashMap</code>来记录服务实例信息（纯内存的注册表提高了性能）。且为了能支撑每天千万级的高并发访问，Eureka Server同时也实现了一个<code>多级缓存机制</code>来保证，实现类为ResponseCacheImpl。</p>\n<ul>\n<li>readOnlyCacheMap，读缓存，结构是一个ConcurrentHashMap。</li>\n<li>readWriteCacheMap，读写缓存，结构是guava的Cache缓存。</li>\n</ul>\n<p><strong>主动注册刷新缓存</strong></p>\n<p>主动刷新，指的是应用实例(即<code>Eureka Client</code>端)在进行注册，续约租期，更新状态，删除时，会主动来刷新<code>readWriteCacheMap</code>中的数据。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">// AbstractInstanceRegistry类关键代码</span>\n<span class=\"token comment\" spellcheck=\"true\">// 这里只截取了注册相关代码，续约租期，更新状态，删除是类似的</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">register</span><span class=\"token punctuation\">(</span>InstanceInfo registrant<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> leaseDuration<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> isReplication<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        <span class=\"token function\">invalidateCache</span><span class=\"token punctuation\">(</span>registrant<span class=\"token punctuation\">.</span><span class=\"token function\">getAppName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> registrant<span class=\"token punctuation\">.</span><span class=\"token function\">getVIPAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> registrant<span class=\"token punctuation\">.</span><span class=\"token function\">getSecureVipAddress</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n       read<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">invalidateCache</span><span class=\"token punctuation\">(</span>String appName<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@Nullable</span> String vipAddress<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@Nullable</span> String secureVipAddress<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    responseCache<span class=\"token punctuation\">.</span><span class=\"token function\">invalidate</span><span class=\"token punctuation\">(</span>appName<span class=\"token punctuation\">,</span> vipAddress<span class=\"token punctuation\">,</span> secureVipAddress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// ResponseCacheImpl类关键代码</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">invalidate</span><span class=\"token punctuation\">(</span>Key<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span> keys<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Key key <span class=\"token operator\">:</span> keys<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        readWriteCacheMap<span class=\"token punctuation\">.</span><span class=\"token function\">invalidate</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Key keysWithRegion <span class=\"token operator\">:</span> keysWithRegions<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            readWriteCacheMap<span class=\"token punctuation\">.</span><span class=\"token function\">invalidate</span><span class=\"token punctuation\">(</span>keysWithRegion<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>被动更新缓存</strong></p>\n<p>当参数shouldUseReadOnlyResponseCache（eureka.server.use-read-only-response-cache）为true时候，默认每隔30s（可以通过eureka.server.response-cache-update-interval-ms修改默认值）将<code>readWriteCacheMap</code>的数据刷入<code>readOnlyCacheMap</code>中。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token function\">ResponseCacheImpl</span><span class=\"token punctuation\">(</span>EurekaServerConfig serverConfig<span class=\"token punctuation\">,</span> ServerCodecs serverCodecs<span class=\"token punctuation\">,</span> AbstractInstanceRegistry registry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//关键代码    </span>\n     <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>shouldUseReadOnlyResponseCache<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         timer<span class=\"token punctuation\">.</span><span class=\"token function\">schedule</span><span class=\"token punctuation\">(</span><span class=\"token function\">getCacheUpdateTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                 <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>System<span class=\"token punctuation\">.</span><span class=\"token function\">currentTimeMillis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> responseCacheUpdateIntervalMs<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> responseCacheUpdateIntervalMs<span class=\"token punctuation\">)</span>\n                         <span class=\"token operator\">+</span> responseCacheUpdateIntervalMs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                 responseCacheUpdateIntervalMs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n     <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> TimerTask <span class=\"token function\">getCacheUpdateTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">TimerTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            logger<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Updating the client cache from response cache\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Key key <span class=\"token operator\">:</span> readOnlyCacheMap<span class=\"token punctuation\">.</span><span class=\"token function\">keySet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">isDebugEnabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    logger<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Updating the client cache from response cache for key : {} {} {} {}\"</span><span class=\"token punctuation\">,</span>\n                            key<span class=\"token punctuation\">.</span><span class=\"token function\">getEntityType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">getVersion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">getType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    CurrentRequestVersion<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">getVersion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    Value cacheValue <span class=\"token operator\">=</span> readWriteCacheMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    Value currentCacheValue <span class=\"token operator\">=</span> readOnlyCacheMap<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>cacheValue <span class=\"token operator\">!=</span> currentCacheValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        readOnlyCacheMap<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> cacheValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> th<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    logger<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error while updating the client cache from response cache for key {}\"</span><span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">toStringCompact</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> th<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>定时刷新缓存</strong></p>\n<p>如果隔了一段时间，<code>readWriteCacheMap</code>读写缓存中的数据还没刷新的话，就会将此数据给过期删除掉。默认是180S，通过参数ResponseCacheAutoExpirationInSeconds（eureka.server.response-cache-auto-expiration-in-seconds=180）控制。当服务下线，过期，注册，状态更变等操作就会来清除此缓存中的数据。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token function\">ResponseCacheImpl</span><span class=\"token punctuation\">(</span>EurekaServerConfig serverConfig<span class=\"token punctuation\">,</span> ServerCodecs serverCodecs<span class=\"token punctuation\">,</span> AbstractInstanceRegistry registry<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//采用guava的缓存框架</span>\n   <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>readWriteCacheMap <span class=\"token operator\">=</span>\n           CacheBuilder<span class=\"token punctuation\">.</span><span class=\"token function\">newBuilder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">initialCapacity</span><span class=\"token punctuation\">(</span>serverConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getInitialCapacityOfResponseCache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                   <span class=\"token punctuation\">.</span><span class=\"token function\">expireAfterWrite</span><span class=\"token punctuation\">(</span>serverConfig<span class=\"token punctuation\">.</span><span class=\"token function\">getResponseCacheAutoExpirationInSeconds</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span>\n                   <span class=\"token punctuation\">.</span><span class=\"token function\">removalListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">RemovalListener</span><span class=\"token operator\">&lt;</span>Key<span class=\"token punctuation\">,</span> Value<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                       <span class=\"token annotation punctuation\">@Override</span>\n                       <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onRemoval</span><span class=\"token punctuation\">(</span>RemovalNotification<span class=\"token operator\">&lt;</span>Key<span class=\"token punctuation\">,</span> Value<span class=\"token operator\">></span> notification<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                           Key removedKey <span class=\"token operator\">=</span> notification<span class=\"token punctuation\">.</span><span class=\"token function\">getKey</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                           <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>removedKey<span class=\"token punctuation\">.</span><span class=\"token function\">hasRegions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                               Key cloneWithNoRegions <span class=\"token operator\">=</span> removedKey<span class=\"token punctuation\">.</span><span class=\"token function\">cloneWithoutRegions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                               regionSpecificKeys<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span>cloneWithNoRegions<span class=\"token punctuation\">,</span> removedKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                           <span class=\"token punctuation\">}</span>\n                       <span class=\"token punctuation\">}</span>\n                   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n                   <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">CacheLoader</span><span class=\"token operator\">&lt;</span>Key<span class=\"token punctuation\">,</span> Value<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                       <span class=\"token annotation punctuation\">@Override</span>\n                       <span class=\"token keyword\">public</span> Value <span class=\"token function\">load</span><span class=\"token punctuation\">(</span>Key key<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n                           <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span><span class=\"token function\">hasRegions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                               Key cloneWithNoRegions <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span><span class=\"token function\">cloneWithoutRegions</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                               regionSpecificKeys<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>cloneWithNoRegions<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                           <span class=\"token punctuation\">}</span>\n                           Value value <span class=\"token operator\">=</span> <span class=\"token function\">generatePayload</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                           <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>\n                       <span class=\"token punctuation\">}</span>\n                   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>Eureka Client如何获取服务实例信息</strong></p>\n<p>Eureka Client 获取服务实例数据时，会先从一级缓存中获取，如果一级缓存中不存在，再从二级缓存中获取，如果二级缓存也不存在，会触发缓存的加载，从存储层拉取数据到缓存中，然后再返回给 Client。</p>\n<h4 id=\"客户端缓存\"><a href=\"#客户端缓存\" class=\"headerlink\" title=\"客户端缓存\"></a><strong>客户端缓存</strong></h4><p>当Eureka Client从注册中心获取服务实例信息后，本身Client也会将信息缓存到本地。主要代码在DiscoveryClient.initScheduledTasks()方法中定义了CacheRefreshThread定时任务专门用来拉取 Eureka Server 的实例信息到本地。默认是30S，可以通过eureka.client.registry-fetch-interval-seconds控制。</p>\n<p>Eureka Client从注册中心拉取服务实例信息的流程如下：</p>\n<ol>\n<li>首次全量拉取。</li>\n<li>定时通过CacheRefreshThread拉取增量服务实例，并通过比对hashcode来合并全量服务实例。</li>\n</ol>\n<h4 id=\"Ribbon-缓存\"><a href=\"#Ribbon-缓存\" class=\"headerlink\" title=\"Ribbon 缓存\"></a><strong>Ribbon 缓存</strong></h4><p>Ribbon会从Eureka Client中获取服务信息。ServerListUpdater 是 Ribbon 中负责服务实例更新的组件，默认的实现是PollingServerListUpdater，通过线程定时去更新实例信息。定时刷新的时间间隔默认是 30 秒。可以通过ribbon.ServerListRefreshInterval控制间隔时间。</p>\n<p>以下是Ribbon各个组件作用：</p>\n<ul>\n<li>ILoadBalancer：定义一系列的操作接口，比如选择服务实例。</li>\n<li>IRule：算法策略，内置算法策略来为服务实例的选择提供服务。</li>\n<li>ServerList：负责服务实例信息的获取，可以获取配置文件中的，也可以从注册中心获取。</li>\n<li>ServerListFilter：过滤掉某些不想要的服务实例信息。</li>\n<li>ServerListUpdater：更新本地缓存的服务实例信息。</li>\n<li>IPing：对已有的服务实例进行可用性检查，保证选择的服务都是可用的。</li>\n</ul>\n<h3 id=\"Fegin、Hystrix、Ribbon超时与重试\"><a href=\"#Fegin、Hystrix、Ribbon超时与重试\" class=\"headerlink\" title=\"Fegin、Hystrix、Ribbon超时与重试\"></a>Fegin、Hystrix、Ribbon超时与重试</h3><p><img src=\"/2021/01/02/springcloud-2/1.png\" alt=\"Fegin、Hystrix、Ribbon调用关系\"></p>\n<ul>\n<li>Ribbon的全局超时时间通过<code>ribbon.ReadTimeout</code>和 <code>ribbon.ConnectTimeout</code>配置。</li>\n<li>Hyxstrix的全局超时时间通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>配置。</li>\n<li>Fegin本身也有超时时间，通过<code>feign.client.config.default.connectTimeout</code>和<code>feign.client.config.default.connectTimeout</code>设置，但<strong>如果设置了Ribbon的超时时间则以Ribbon的超时时间为准，Fegin自身的配置会被覆盖</strong>。</li>\n<li>由于Ribbon有重试机制，所以Hystrix的超时时间要大于Ribbon的超时时间。公式 <code>Hystrix的超时时间 &gt; Ribbon的重试次数(包含首次) * (ribbon.ReadTimeout + ribbon.ConnectTimeout)</code></li>\n</ul>\n<p>这里需要明确Ribbon的重试机制。包括<code>同一台实例</code> 和 <code>另一个实例</code>的重试。所以Ribbon的重试次数公式如下：<br>$$<br>1 + ribbon.MaxAutoRetries  +  ribbon.MaxAutoRetriesNextServer<br>$$</p>\n<pre class=\" language-yml\"><code class=\"language-yml\">ribbon:\n  eager-load:\n    enabled: true\n  #说明：同一台实例的最大自动重试次数，默认为1次，不包括首次\n  MaxAutoRetries: 1\n  #说明：要重试的下一个实例的最大数量，默认为1，不包括第一次被调用的实例\n  MaxAutoRetriesNextServer: 1\n  #说明：是否所有的操作都重试，默认为true\n  OkToRetryOnAllOperations: true\n  #说明：从注册中心刷新服务器列表信息的时间间隔，默认为2000毫秒，即2秒\n  ServerListRefreshInterval: 2000\n  #说明：使用Apache HttpClient连接超时时间，单位为毫秒\n  ConnectTimeout: 3000\n  #说明：使用Apache HttpClient读取的超时时间，单位为毫秒\n  ReadTimeout: 3000</code></pre>\n<h3 id=\"Fegin的封装最佳实践\"><a href=\"#Fegin的封装最佳实践\" class=\"headerlink\" title=\"Fegin的封装最佳实践\"></a>Fegin的封装最佳实践</h3><h4 id=\"Fegin封装\"><a href=\"#Fegin封装\" class=\"headerlink\" title=\"Fegin封装\"></a>Fegin封装</h4><p>一般来说，我们作为Eureka Client，需要<code>提供给外部服务</code>和<code>实现提供的服务</code>。因为 Spring Cloud Open Feign 中支持继承的特性，我们可以将 API 的定义提取出来封装成一个单独的接口，给 API 的实现方和调用方共用，在一定程度上简化了重复的代码。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//提供给外部的API，我们可以统一将其抽离成一个Maven工程</span>\n<span class=\"token annotation punctuation\">@FeignClient</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"user-service\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserFeignRemoteClient</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/user/get\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> User <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span> Long id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">//实现提供的服务</span>\n<span class=\"token annotation punctuation\">@RestController</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserController</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">UserFeignRemoteClient</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> User <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span> Long id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"具体实现\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//提供给外部服务使用</span>\n<span class=\"token annotation punctuation\">@Autowired</span>\n<span class=\"token keyword\">private</span> UserFeignRemoteClient userFeignRemoteClient<span class=\"token punctuation\">;</span></code></pre>\n<p>其实在 Spring Cloud Open Feign 的文档中，给出的继承示列还要多一个类，第一步是抽出一个公共的接口，比如我们这边的 UserService，UserService 中定义了要实现的 API 的方法。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserService</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/user/get\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> User <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span> Long id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//提供给外部的API，我们可以统一将其抽离成一个Maven工程</span>\n<span class=\"token annotation punctuation\">@FeignClient</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"user-service\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">UserFeignRemoteClient</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">UserService</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//实现提供的服务</span>\n<span class=\"token annotation punctuation\">@RestController</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserController</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">UserService</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> User <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RequestParam</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"id\"</span><span class=\"token punctuation\">)</span> Long id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"具体实现\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//提供给外部服务使用</span>\n<span class=\"token annotation punctuation\">@Autowired</span>\n<span class=\"token keyword\">private</span> UserFeignRemoteClient userFeignRemoteClient<span class=\"token punctuation\">;</span></code></pre>\n<h4 id=\"Fegin多参数传递\"><a href=\"#Fegin多参数传递\" class=\"headerlink\" title=\"Fegin多参数传递\"></a>Fegin多参数传递</h4><p>如果Fegin需要多个参数一起传递的话，一般最佳的实践是将参数封装，然后采用<code>@SpringQueryMap</code>修师。例如下面</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RestController</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UserController</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">UserService</span><span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> User <span class=\"token function\">getUser</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@SpringQueryMap</span> StudentRequest studentRequest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"具体实现\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StudentRequest</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> Long id<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> String name<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"Feign拦截器\"><a href=\"#Feign拦截器\" class=\"headerlink\" title=\"Feign拦截器\"></a>Feign拦截器</h4><p>假设服务A调用服务B，然后服务A需要向服务B传递一些参数，此时就可以用Fegin拦截器。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FeignInterceptorConfig</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Bean</span>\n    <span class=\"token keyword\">public</span> RequestInterceptor <span class=\"token function\">requestInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        RequestInterceptor requestInterceptor <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RequestInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>RequestTemplate template<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">//传递token</span>\n                <span class=\"token comment\" spellcheck=\"true\">//使用feign client访问别的微服务时，将accessToken header </span>\n                <span class=\"token comment\" spellcheck=\"true\">//config.anyRequest().permitAll() 非强制校验token</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>StringUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isNotBlank</span><span class=\"token punctuation\">(</span>TokenUtil<span class=\"token punctuation\">.</span><span class=\"token function\">getToken</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    template<span class=\"token punctuation\">.</span><span class=\"token function\">header</span><span class=\"token punctuation\">(</span>UaaConstant<span class=\"token punctuation\">.</span>TOKEN_HEADER<span class=\"token punctuation\">,</span> TokenUtil<span class=\"token punctuation\">.</span><span class=\"token function\">getToken</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> requestInterceptor<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Eureka-服务发现慢的原因\"><a href=\"#Eureka-服务发现慢的原因\" class=\"headerlink\" title=\"Eureka 服务发现慢的原因\"></a>Eureka 服务发现慢的原因</h3><p>经常遇到注册中心的问题 :</p>\n<ol>\n<li>新服务上线后，服务消费者不能访问到刚上线的新服务，需要过一段时间后才能访问。</li>\n<li>服务下线后，服务还是会被调用到，一段时候后才彻底停止服务。</li>\n</ol>\n<p>导致这个的问题是因为Eureka Server，Eureka Client，Ribbon为了提供性能，都有内置了缓存来记录服务信息。所以导致了需要等待一段时间才能获取到服务信息。</p>\n<ul>\n<li>Eureka Server 二级缓存（只读缓存，读写缓存）。只读缓存默认30秒与读写缓存进行同步，通过参数eureka.server.response-cache-update-interval-ms控制。读写缓存过期时间默认180秒，当服务下线，过期，注册，状态更变时会刷新此缓存。</li>\n<li>Eureka Client初始化了一个CacheRefreshThread 定时任务专门用来拉取 Eureka Server 的实例信息到本地。默认30秒，通过参数eureka.client.registry-fetch-interval-seconds控制。</li>\n<li>Ribbon缓存，通过ribbon.ServerListRefreshInterval控制。</li>\n</ul>\n<h4 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a><strong>服务端缓存</strong></h4><p>当Eureka Client注册到Eureka Server时，注册中心通过一个<code>双层的ConcurrentHashMap</code>来记录服务实例信息（纯内存的注册表提高了性能）。且为了能支撑每天千万级的高并发访问，Eureka Server同时也实现了一个<code>多级缓存机制</code>来保证，实现类为ResponseCacheImpl。</p>\n<ul>\n<li>readOnlyCacheMap，读缓存，结构是一个ConcurrentHashMap。</li>\n<li>readWriteCacheMap，读写缓存，结构是guava的Cache缓存。</li>\n</ul>\n<p><strong>主动注册刷新缓存</strong></p>\n<p>主动刷新，指的是应用实例(即<code>Eureka Client</code>端)在进行注册，续约租期，更新状态，删除时，会主动来刷新<code>readWriteCacheMap</code>中的数据。</p>\n<pre><code class=\"java\">// AbstractInstanceRegistry类关键代码\n// 这里只截取了注册相关代码，续约租期，更新状态，删除是类似的\npublic void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {\n    try{\n        ......\n        invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());\n        ......\n    }finally {\n       read.unlock();\n    }\n}\nprivate void invalidateCache(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {\n    responseCache.invalidate(appName, vipAddress, secureVipAddress);\n}\n\n// ResponseCacheImpl类关键代码\npublic void invalidate(Key... keys) {\n    for (Key key : keys) {\n        readWriteCacheMap.invalidate(key);\n        ......\n        for (Key keysWithRegion : keysWithRegions) {\n            readWriteCacheMap.invalidate(keysWithRegion);\n        }\n        ......\n    }\n}</code></pre>\n<p><strong>被动更新缓存</strong></p>\n<p>当参数shouldUseReadOnlyResponseCache（eureka.server.use-read-only-response-cache）为true时候，默认每隔30s（可以通过eureka.server.response-cache-update-interval-ms修改默认值）将<code>readWriteCacheMap</code>的数据刷入<code>readOnlyCacheMap</code>中。</p>\n<pre><code class=\"java\">ResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) {\n    //关键代码    \n     if (shouldUseReadOnlyResponseCache) {\n         timer.schedule(getCacheUpdateTask(),\n                 new Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)\n                         + responseCacheUpdateIntervalMs),\n                 responseCacheUpdateIntervalMs);\n     }\n}\n\nprivate TimerTask getCacheUpdateTask() {\n    return new TimerTask() {\n        @Override\n        public void run() {\n            logger.debug(&quot;Updating the client cache from response cache&quot;);\n            for (Key key : readOnlyCacheMap.keySet()) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(&quot;Updating the client cache from response cache for key : {} {} {} {}&quot;,\n                            key.getEntityType(), key.getName(), key.getVersion(), key.getType());\n                }\n                try {\n                    CurrentRequestVersion.set(key.getVersion());\n                    Value cacheValue = readWriteCacheMap.get(key);\n                    Value currentCacheValue = readOnlyCacheMap.get(key);\n                    if (cacheValue != currentCacheValue) {\n                        readOnlyCacheMap.put(key, cacheValue);\n                    }\n                } catch (Throwable th) {\n                    logger.error(&quot;Error while updating the client cache from response cache for key {}&quot;, key.toStringCompact(), th);\n                }\n            }\n        }\n    };\n}</code></pre>\n<p><strong>定时刷新缓存</strong></p>\n<p>如果隔了一段时间，<code>readWriteCacheMap</code>读写缓存中的数据还没刷新的话，就会将此数据给过期删除掉。默认是180S，通过参数ResponseCacheAutoExpirationInSeconds（eureka.server.response-cache-auto-expiration-in-seconds=180）控制。当服务下线，过期，注册，状态更变等操作就会来清除此缓存中的数据。</p>\n<pre><code class=\"java\">ResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) {\n    //采用guava的缓存框架\n   this.readWriteCacheMap =\n           CacheBuilder.newBuilder().initialCapacity(serverConfig.getInitialCapacityOfResponseCache())\n                   .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)\n                   .removalListener(new RemovalListener&lt;Key, Value&gt;() {\n                       @Override\n                       public void onRemoval(RemovalNotification&lt;Key, Value&gt; notification) {\n                           Key removedKey = notification.getKey();\n                           if (removedKey.hasRegions()) {\n                               Key cloneWithNoRegions = removedKey.cloneWithoutRegions();\n                               regionSpecificKeys.remove(cloneWithNoRegions, removedKey);\n                           }\n                       }\n                   })\n                   .build(new CacheLoader&lt;Key, Value&gt;() {\n                       @Override\n                       public Value load(Key key) throws Exception {\n                           if (key.hasRegions()) {\n                               Key cloneWithNoRegions = key.cloneWithoutRegions();\n                               regionSpecificKeys.put(cloneWithNoRegions, key);\n                           }\n                           Value value = generatePayload(key);\n                           return value;\n                       }\n                   });\n\n}</code></pre>\n<p><strong>Eureka Client如何获取服务实例信息</strong></p>\n<p>Eureka Client 获取服务实例数据时，会先从一级缓存中获取，如果一级缓存中不存在，再从二级缓存中获取，如果二级缓存也不存在，会触发缓存的加载，从存储层拉取数据到缓存中，然后再返回给 Client。</p>\n<h4 id=\"客户端缓存\"><a href=\"#客户端缓存\" class=\"headerlink\" title=\"客户端缓存\"></a><strong>客户端缓存</strong></h4><p>当Eureka Client从注册中心获取服务实例信息后，本身Client也会将信息缓存到本地。主要代码在DiscoveryClient.initScheduledTasks()方法中定义了CacheRefreshThread定时任务专门用来拉取 Eureka Server 的实例信息到本地。默认是30S，可以通过eureka.client.registry-fetch-interval-seconds控制。</p>\n<p>Eureka Client从注册中心拉取服务实例信息的流程如下：</p>\n<ol>\n<li>首次全量拉取。</li>\n<li>定时通过CacheRefreshThread拉取增量服务实例，并通过比对hashcode来合并全量服务实例。</li>\n</ol>\n<h4 id=\"Ribbon-缓存\"><a href=\"#Ribbon-缓存\" class=\"headerlink\" title=\"Ribbon 缓存\"></a><strong>Ribbon 缓存</strong></h4><p>Ribbon会从Eureka Client中获取服务信息。ServerListUpdater 是 Ribbon 中负责服务实例更新的组件，默认的实现是PollingServerListUpdater，通过线程定时去更新实例信息。定时刷新的时间间隔默认是 30 秒。可以通过ribbon.ServerListRefreshInterval控制间隔时间。</p>\n<p>以下是Ribbon各个组件作用：</p>\n<ul>\n<li>ILoadBalancer：定义一系列的操作接口，比如选择服务实例。</li>\n<li>IRule：算法策略，内置算法策略来为服务实例的选择提供服务。</li>\n<li>ServerList：负责服务实例信息的获取，可以获取配置文件中的，也可以从注册中心获取。</li>\n<li>ServerListFilter：过滤掉某些不想要的服务实例信息。</li>\n<li>ServerListUpdater：更新本地缓存的服务实例信息。</li>\n<li>IPing：对已有的服务实例进行可用性检查，保证选择的服务都是可用的。</li>\n</ul>\n<h3 id=\"Fegin、Hystrix、Ribbon超时与重试\"><a href=\"#Fegin、Hystrix、Ribbon超时与重试\" class=\"headerlink\" title=\"Fegin、Hystrix、Ribbon超时与重试\"></a>Fegin、Hystrix、Ribbon超时与重试</h3><p><img src=\"/2021/01/02/springcloud-2/1.png\" alt=\"Fegin、Hystrix、Ribbon调用关系\"></p>\n<ul>\n<li>Ribbon的全局超时时间通过<code>ribbon.ReadTimeout</code>和 <code>ribbon.ConnectTimeout</code>配置。</li>\n<li>Hyxstrix的全局超时时间通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>配置。</li>\n<li>Fegin本身也有超时时间，通过<code>feign.client.config.default.connectTimeout</code>和<code>feign.client.config.default.connectTimeout</code>设置，但<strong>如果设置了Ribbon的超时时间则以Ribbon的超时时间为准，Fegin自身的配置会被覆盖</strong>。</li>\n<li>由于Ribbon有重试机制，所以Hystrix的超时时间要大于Ribbon的超时时间。公式 <code>Hystrix的超时时间 &gt; Ribbon的重试次数(包含首次) * (ribbon.ReadTimeout + ribbon.ConnectTimeout)</code></li>\n</ul>\n<p>这里需要明确Ribbon的重试机制。包括<code>同一台实例</code> 和 <code>另一个实例</code>的重试。所以Ribbon的重试次数公式如下：<br>$$<br>1 + ribbon.MaxAutoRetries  +  ribbon.MaxAutoRetriesNextServer<br>$$</p>\n<pre><code class=\"yml\">ribbon:\n  eager-load:\n    enabled: true\n  #说明：同一台实例的最大自动重试次数，默认为1次，不包括首次\n  MaxAutoRetries: 1\n  #说明：要重试的下一个实例的最大数量，默认为1，不包括第一次被调用的实例\n  MaxAutoRetriesNextServer: 1\n  #说明：是否所有的操作都重试，默认为true\n  OkToRetryOnAllOperations: true\n  #说明：从注册中心刷新服务器列表信息的时间间隔，默认为2000毫秒，即2秒\n  ServerListRefreshInterval: 2000\n  #说明：使用Apache HttpClient连接超时时间，单位为毫秒\n  ConnectTimeout: 3000\n  #说明：使用Apache HttpClient读取的超时时间，单位为毫秒\n  ReadTimeout: 3000</code></pre>\n<h3 id=\"Fegin的封装最佳实践\"><a href=\"#Fegin的封装最佳实践\" class=\"headerlink\" title=\"Fegin的封装最佳实践\"></a>Fegin的封装最佳实践</h3><h4 id=\"Fegin封装\"><a href=\"#Fegin封装\" class=\"headerlink\" title=\"Fegin封装\"></a>Fegin封装</h4><p>一般来说，我们作为Eureka Client，需要<code>提供给外部服务</code>和<code>实现提供的服务</code>。因为 Spring Cloud Open Feign 中支持继承的特性，我们可以将 API 的定义提取出来封装成一个单独的接口，给 API 的实现方和调用方共用，在一定程度上简化了重复的代码。</p>\n<pre><code class=\"java\">//提供给外部的API，我们可以统一将其抽离成一个Maven工程\n@FeignClient(name = &quot;user-service&quot;)\npublic interface UserFeignRemoteClient {\n    @GetMapping(&quot;/user/get&quot;)\n    public User getUser(@RequestParam(&quot;id&quot;) Long id);\n}\n\n\n//实现提供的服务\n@RestController\npublic class UserController implements UserFeignRemoteClient{\n    @Override\n    public User getUser(@RequestParam(&quot;id&quot;) Long id){\n        System.out.println(&quot;具体实现&quot;);\n    }\n}\n\n//提供给外部服务使用\n@Autowired\nprivate UserFeignRemoteClient userFeignRemoteClient;</code></pre>\n<p>其实在 Spring Cloud Open Feign 的文档中，给出的继承示列还要多一个类，第一步是抽出一个公共的接口，比如我们这边的 UserService，UserService 中定义了要实现的 API 的方法。</p>\n<pre><code class=\"java\">public interface UserService {\n    @GetMapping(&quot;/user/get&quot;)\n    public User getUser(@RequestParam(&quot;id&quot;) Long id);\n}\n\n//提供给外部的API，我们可以统一将其抽离成一个Maven工程\n@FeignClient(name = &quot;user-service&quot;)\npublic interface UserFeignRemoteClient extends UserService{\n\n}\n\n//实现提供的服务\n@RestController\npublic class UserController implements UserService{\n    @Override\n    public User getUser(@RequestParam(&quot;id&quot;) Long id){\n        System.out.println(&quot;具体实现&quot;);\n    }\n}\n\n//提供给外部服务使用\n@Autowired\nprivate UserFeignRemoteClient userFeignRemoteClient;</code></pre>\n<h4 id=\"Fegin多参数传递\"><a href=\"#Fegin多参数传递\" class=\"headerlink\" title=\"Fegin多参数传递\"></a>Fegin多参数传递</h4><p>如果Fegin需要多个参数一起传递的话，一般最佳的实践是将参数封装，然后采用<code>@SpringQueryMap</code>修师。例如下面</p>\n<pre><code class=\"java\">@RestController\npublic class UserController implements UserService{\n    @Override\n    public User getUser(@SpringQueryMap StudentRequest studentRequest){\n        System.out.println(&quot;具体实现&quot;);\n    }\n}\npublic class StudentRequest{\n    private Long id;\n    private String name;\n}</code></pre>\n<h4 id=\"Feign拦截器\"><a href=\"#Feign拦截器\" class=\"headerlink\" title=\"Feign拦截器\"></a>Feign拦截器</h4><p>假设服务A调用服务B，然后服务A需要向服务B传递一些参数，此时就可以用Fegin拦截器。</p>\n<pre><code class=\"java\">@Configuration\npublic class FeignInterceptorConfig {\n    @Bean\n    public RequestInterceptor requestInterceptor() {\n        RequestInterceptor requestInterceptor = new RequestInterceptor() {\n\n            @Override\n            public void apply(RequestTemplate template) {\n                //传递token\n                //使用feign client访问别的微服务时，将accessToken header \n                //config.anyRequest().permitAll() 非强制校验token\n                if(StringUtils.isNotBlank(TokenUtil.getToken())){\n                    template.header(UaaConstant.TOKEN_HEADER, TokenUtil.getToken() );\n                }\n            }\n        };\n        return requestInterceptor;\n    }\n}</code></pre>\n"},{"title":"SpringMVC详细解析之工作流程（二）","description":"SpringMVC详细解析之工作流程","date":"2020-01-03T16:00:20.000Z","_content":"## SpringMVC工作流程\n\n### 工作流程概述\n\n- 客户端（浏览器）发送请求，直接请求到 DispatcherServlet。\n- DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求成对应的 Handler（HandlerExecutionChain包含该请求的handler和拦截器链）。\n- 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。\n- HandlerAdapter 会根据 Handler 来调用真正的处理器开始处理请求，执行对应的业务逻辑。\n- 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。\n- ViewResolver 会根据逻辑 View 查找实际的 View。\n- DispaterServlet 把返回的 Model 传给 View（视图渲染）。\n- 把 View 返回给请求者（浏览器）。\n<!--more-->\n### 流程分析\n\n<font size=4 color=red>第一步：客户端（浏览器）发送请求，直接请求到DispatcherServlet</font>\n\n前面说过SpringMVC是遵循Sevlet规范的。且DispatcherServlet继承了HttpServlet。所以请求会通过HttpServlet的doGet方法或者doPost方法处理。所以我们在根据DispatcherServlet及其父类上需要doGet和doPost入口。\n\n![](springmvc2/10.png)\n\n![](springmvc2/11.png)\n\n![](springmvc2/12.png)\n\n所以，我们最终请求会到DispatcherServlet类中的doDispatch方法中进行处理。\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\tHttpServletRequest processedRequest = request;\n\tHandlerExecutionChain mappedHandler = null;\n\tboolean multipartRequestParsed = false;\n\n\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\ttry {\n\t\tModelAndView mv = null;\n\t\tException dispatchException = null;\n\n\t\ttry {\n\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t//DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler\n\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\tif (mappedHandler == null) {\n\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理\n\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\n\t\t\tString method = request.getMethod();\n\t\t\tboolean isGet = \"GET\".equals(method);\n\t\t\tif (isGet || \"HEAD\".equals(method)) {\n\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//执行前置拦截器\n\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑\n\t\t\t// 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View\n\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//解析默认的视图\n\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t//执行后置拦截器\n\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tdispatchException = ex;\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\t\n\t\t\tdispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n\t\t}\n\t\t//处理转发结果\n\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t}\n\tcatch (Exception ex) {\n\t\t//异常执行拦截器的完成事件\n\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t}\n\tcatch (Throwable err) {\n\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\tnew NestedServletException(\"Handler processing failed\", err));\n\t}\n\tfinally {\n\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t// 处理异步请求\n\t\t\tif (mappedHandler != null) {\n\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// 清空上传的临时文件\n\t\t\tif (multipartRequestParsed) {\n\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n<font size=4 color=red>第二步：DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler并封装成HandlerExecutionChain对象(一个Handler + 多个HandlerInterceptor拦截器)</font>\n\n通过遍历handlerMappings找到请求对应的Handler，并将Handler + 拦截器 封装成HandlerExecutionChain对象。\n\n![](springmvc2/13.png)\n\n<font size=4 color=red>第三步：通过Handler找到对应的处理器适配器（HandlerAdapter）</font>\n\nHandlerAdapter采用了适配器模式提供了两个方法 ：\n\n- boolean supports(Object handler)  -- 判断参数的handler是不是我这个适配器可以处理的处理器。\n- ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)  -- 处理并返回ModelAndView\n\n![](springmvc2/14.png)\n\n例如RequestMappingHandlerAdapter适配器，他判断如果这个handler是HandlerMethod则这个handler使用他来进行处理。\n\n<font size=4 color=red>第四步：执行handler前先执行拦截器的前置拦截</font>\n\n拦截器提供的3个方法：\n\n- **preHandle** - 该方法将在请求处理之前进行调用\n- **postHandle** - Controller 处理之后的ModelAndView 对象进行，此时视图还没做渲染\n- **afterCompletion** - 渲染了视图后执行，主要是清理资源等\n\n```java\n//mappedHandler.applyPreHandle(processedRequest, response);\nboolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\tHandlerInterceptor[] interceptors = getInterceptors(); //获取定义的拦截器\n\tif (!ObjectUtils.isEmpty(interceptors)) {\n\t\tfor (int i = 0; i < interceptors.length; i++) {\n\t\t\tHandlerInterceptor interceptor = interceptors[i];\n             //执行前置拦截\n\t\t\tif (!interceptor.preHandle(request, response, this.handler)) {\n\t\t\t\ttriggerAfterCompletion(request, response, null);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.interceptorIndex = i;\n\t\t}\n\t}\n\treturn true;\n}\n```\n\n<font size=4 color=red>第五步：调用HandlerAdapter(处理器适配器)执行handler并返回ModelAndView</font>\n\n```java\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n```\n\n分析RequestMappingHandlerAdapter的执行逻辑如下：\n\n![执行handler](springmvc2/15.png)\n\n![hanlder结果封装成ModelAndView](springmvc2/16.png)\n\n<font size=4 color=red>第六步：执行拦截器后置拦截</font>\n\n```\n//如果没有视图，设置默认视图\napplyDefaultViewName(processedRequest, mv)\n//执行后置拦截\nmappedHandler.applyPostHandle(processedRequest, response, mv)\n```\n\n<font size=4 color=red>第七步：前端控制器请求视图解析器（ViewResolver）去进行视图解析</font>\n\n```java\n//获取视图并进行渲染\nprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tLocale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());\n\t\tresponse.setLocale(locale);\n\t\tView view;\n\t\tString viewName = mv.getViewName();\n\t\tif (viewName != null) {\n\t\t\t//遍历视图解析器解析当前view对应的视图\n\t\t\tview = resolveViewName(viewName, mv.getModelInternal(), locale, request);\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"Could not resolve view with name '\" + mv.getViewName() +\n\t\t\t\t\t\t\"' in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tview = mv.getView();\n\t\t}\n\t\ttry {\n\t\t\tif (mv.getStatus() != null) {\n\t\t\t\tresponse.setStatus(mv.getStatus().value());\n\t\t\t}\n\t\t\t//渲染视图\n\t\t\tview.render(mv.getModelInternal(), request, response);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error rendering view [\" + view + \"]\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n}\n\nprotected View resolveViewName(String viewName, @Nullable Map<String, Object> model,\n\t\tLocale locale, HttpServletRequest request) throws Exception {\n\tif (this.viewResolvers != null) {\n\t\t//遍历所有的视图列表并选择一个合适的视图\n\t\tfor (ViewResolver viewResolver : this.viewResolvers) {\n\t\t\tView view = viewResolver.resolveViewName(viewName, locale);\n\t\t\tif (view != null) {\n\t\t\t\treturn view;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n```\n\n","source":"_posts/springmvc2.md","raw":"---\ntitle: SpringMVC详细解析之工作流程（二）\ntags:\n  - spring\ncategories: \n  - spring\ndescription : SpringMVC详细解析之工作流程\ndate: 2020-01-04 00:00:20\n---\n## SpringMVC工作流程\n\n### 工作流程概述\n\n- 客户端（浏览器）发送请求，直接请求到 DispatcherServlet。\n- DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求成对应的 Handler（HandlerExecutionChain包含该请求的handler和拦截器链）。\n- 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。\n- HandlerAdapter 会根据 Handler 来调用真正的处理器开始处理请求，执行对应的业务逻辑。\n- 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。\n- ViewResolver 会根据逻辑 View 查找实际的 View。\n- DispaterServlet 把返回的 Model 传给 View（视图渲染）。\n- 把 View 返回给请求者（浏览器）。\n<!--more-->\n### 流程分析\n\n<font size=4 color=red>第一步：客户端（浏览器）发送请求，直接请求到DispatcherServlet</font>\n\n前面说过SpringMVC是遵循Sevlet规范的。且DispatcherServlet继承了HttpServlet。所以请求会通过HttpServlet的doGet方法或者doPost方法处理。所以我们在根据DispatcherServlet及其父类上需要doGet和doPost入口。\n\n![](springmvc2/10.png)\n\n![](springmvc2/11.png)\n\n![](springmvc2/12.png)\n\n所以，我们最终请求会到DispatcherServlet类中的doDispatch方法中进行处理。\n\n```java\nprotected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\tHttpServletRequest processedRequest = request;\n\tHandlerExecutionChain mappedHandler = null;\n\tboolean multipartRequestParsed = false;\n\n\tWebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n\ttry {\n\t\tModelAndView mv = null;\n\t\tException dispatchException = null;\n\n\t\ttry {\n\t\t\tprocessedRequest = checkMultipart(request);\n\t\t\tmultipartRequestParsed = (processedRequest != request);\n\n\t\t\t//DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler\n\t\t\tmappedHandler = getHandler(processedRequest);\n\t\t\tif (mappedHandler == null) {\n\t\t\t\tnoHandlerFound(processedRequest, response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理\n\t\t\tHandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\t\t\t\n\t\t\tString method = request.getMethod();\n\t\t\tboolean isGet = \"GET\".equals(method);\n\t\t\tif (isGet || \"HEAD\".equals(method)) {\n\t\t\t\tlong lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n\t\t\t\tif (new ServletWebRequest(request, response).checkNotModified(lastModified) && isGet) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//执行前置拦截器\n\t\t\tif (!mappedHandler.applyPreHandle(processedRequest, response)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑\n\t\t\t// 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View\n\t\t\tmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n\t\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//解析默认的视图\n\t\t\tapplyDefaultViewName(processedRequest, mv);\n\t\t\t//执行后置拦截器\n\t\t\tmappedHandler.applyPostHandle(processedRequest, response, mv);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tdispatchException = ex;\n\t\t}\n\t\tcatch (Throwable err) {\n\t\t\t\n\t\t\tdispatchException = new NestedServletException(\"Handler dispatch failed\", err);\n\t\t}\n\t\t//处理转发结果\n\t\tprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\t}\n\tcatch (Exception ex) {\n\t\t//异常执行拦截器的完成事件\n\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n\t}\n\tcatch (Throwable err) {\n\t\ttriggerAfterCompletion(processedRequest, response, mappedHandler,\n\t\t\t\tnew NestedServletException(\"Handler processing failed\", err));\n\t}\n\tfinally {\n\t\tif (asyncManager.isConcurrentHandlingStarted()) {\n\t\t\t// 处理异步请求\n\t\t\tif (mappedHandler != null) {\n\t\t\t\tmappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// 清空上传的临时文件\n\t\t\tif (multipartRequestParsed) {\n\t\t\t\tcleanupMultipart(processedRequest);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n<font size=4 color=red>第二步：DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler并封装成HandlerExecutionChain对象(一个Handler + 多个HandlerInterceptor拦截器)</font>\n\n通过遍历handlerMappings找到请求对应的Handler，并将Handler + 拦截器 封装成HandlerExecutionChain对象。\n\n![](springmvc2/13.png)\n\n<font size=4 color=red>第三步：通过Handler找到对应的处理器适配器（HandlerAdapter）</font>\n\nHandlerAdapter采用了适配器模式提供了两个方法 ：\n\n- boolean supports(Object handler)  -- 判断参数的handler是不是我这个适配器可以处理的处理器。\n- ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)  -- 处理并返回ModelAndView\n\n![](springmvc2/14.png)\n\n例如RequestMappingHandlerAdapter适配器，他判断如果这个handler是HandlerMethod则这个handler使用他来进行处理。\n\n<font size=4 color=red>第四步：执行handler前先执行拦截器的前置拦截</font>\n\n拦截器提供的3个方法：\n\n- **preHandle** - 该方法将在请求处理之前进行调用\n- **postHandle** - Controller 处理之后的ModelAndView 对象进行，此时视图还没做渲染\n- **afterCompletion** - 渲染了视图后执行，主要是清理资源等\n\n```java\n//mappedHandler.applyPreHandle(processedRequest, response);\nboolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {\n\tHandlerInterceptor[] interceptors = getInterceptors(); //获取定义的拦截器\n\tif (!ObjectUtils.isEmpty(interceptors)) {\n\t\tfor (int i = 0; i < interceptors.length; i++) {\n\t\t\tHandlerInterceptor interceptor = interceptors[i];\n             //执行前置拦截\n\t\t\tif (!interceptor.preHandle(request, response, this.handler)) {\n\t\t\t\ttriggerAfterCompletion(request, response, null);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis.interceptorIndex = i;\n\t\t}\n\t}\n\treturn true;\n}\n```\n\n<font size=4 color=red>第五步：调用HandlerAdapter(处理器适配器)执行handler并返回ModelAndView</font>\n\n```java\nmv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n```\n\n分析RequestMappingHandlerAdapter的执行逻辑如下：\n\n![执行handler](springmvc2/15.png)\n\n![hanlder结果封装成ModelAndView](springmvc2/16.png)\n\n<font size=4 color=red>第六步：执行拦截器后置拦截</font>\n\n```\n//如果没有视图，设置默认视图\napplyDefaultViewName(processedRequest, mv)\n//执行后置拦截\nmappedHandler.applyPostHandle(processedRequest, response, mv)\n```\n\n<font size=4 color=red>第七步：前端控制器请求视图解析器（ViewResolver）去进行视图解析</font>\n\n```java\n//获取视图并进行渲染\nprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {\n\t\tLocale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());\n\t\tresponse.setLocale(locale);\n\t\tView view;\n\t\tString viewName = mv.getViewName();\n\t\tif (viewName != null) {\n\t\t\t//遍历视图解析器解析当前view对应的视图\n\t\t\tview = resolveViewName(viewName, mv.getModelInternal(), locale, request);\n\t\t\tif (view == null) {\n\t\t\t\tthrow new ServletException(\"Could not resolve view with name '\" + mv.getViewName() +\n\t\t\t\t\t\t\"' in servlet with name '\" + getServletName() + \"'\");\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tview = mv.getView();\n\t\t}\n\t\ttry {\n\t\t\tif (mv.getStatus() != null) {\n\t\t\t\tresponse.setStatus(mv.getStatus().value());\n\t\t\t}\n\t\t\t//渲染视图\n\t\t\tview.render(mv.getModelInternal(), request, response);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Error rendering view [\" + view + \"]\", ex);\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n}\n\nprotected View resolveViewName(String viewName, @Nullable Map<String, Object> model,\n\t\tLocale locale, HttpServletRequest request) throws Exception {\n\tif (this.viewResolvers != null) {\n\t\t//遍历所有的视图列表并选择一个合适的视图\n\t\tfor (ViewResolver viewResolver : this.viewResolvers) {\n\t\t\tView view = viewResolver.resolveViewName(viewName, locale);\n\t\t\tif (view != null) {\n\t\t\t\treturn view;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n```\n\n","slug":"springmvc2","published":1,"updated":"2021-04-08T00:47:07.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhw00049qwv23866gmu1","content":"<h2 id=\"SpringMVC工作流程\"><a href=\"#SpringMVC工作流程\" class=\"headerlink\" title=\"SpringMVC工作流程\"></a>SpringMVC工作流程</h2><h3 id=\"工作流程概述\"><a href=\"#工作流程概述\" class=\"headerlink\" title=\"工作流程概述\"></a>工作流程概述</h3><ul>\n<li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet。</li>\n<li>DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求成对应的 Handler（HandlerExecutionChain包含该请求的handler和拦截器链）。</li>\n<li>解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。</li>\n<li>HandlerAdapter 会根据 Handler 来调用真正的处理器开始处理请求，执行对应的业务逻辑。</li>\n<li>处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。</li>\n<li>ViewResolver 会根据逻辑 View 查找实际的 View。</li>\n<li>DispaterServlet 把返回的 Model 传给 View（视图渲染）。</li>\n<li>把 View 返回给请求者（浏览器）。<a id=\"more\"></a>\n<h3 id=\"流程分析\"><a href=\"#流程分析\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h3></li>\n</ul>\n<p><font size=\"4\" color=\"red\">第一步：客户端（浏览器）发送请求，直接请求到DispatcherServlet</font></p>\n<p>前面说过SpringMVC是遵循Sevlet规范的。且DispatcherServlet继承了HttpServlet。所以请求会通过HttpServlet的doGet方法或者doPost方法处理。所以我们在根据DispatcherServlet及其父类上需要doGet和doPost入口。</p>\n<p><img src=\"/2020/01/04/springmvc2/10.png\" alt></p>\n<p><img src=\"/2020/01/04/springmvc2/11.png\" alt></p>\n<p><img src=\"/2020/01/04/springmvc2/12.png\" alt></p>\n<p>所以，我们最终请求会到DispatcherServlet类中的doDispatch方法中进行处理。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">doDispatch</span><span class=\"token punctuation\">(</span>HttpServletRequest request<span class=\"token punctuation\">,</span> HttpServletResponse response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n    HttpServletRequest processedRequest <span class=\"token operator\">=</span> request<span class=\"token punctuation\">;</span>\n    HandlerExecutionChain mappedHandler <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">boolean</span> multipartRequestParsed <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n    WebAsyncManager asyncManager <span class=\"token operator\">=</span> WebAsyncUtils<span class=\"token punctuation\">.</span><span class=\"token function\">getAsyncManager</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        ModelAndView mv <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        Exception dispatchException <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            processedRequest <span class=\"token operator\">=</span> <span class=\"token function\">checkMultipart</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            multipartRequestParsed <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>processedRequest <span class=\"token operator\">!=</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">//DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler</span>\n            mappedHandler <span class=\"token operator\">=</span> <span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mappedHandler <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">noHandlerFound</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理</span>\n            HandlerAdapter ha <span class=\"token operator\">=</span> <span class=\"token function\">getHandlerAdapter</span><span class=\"token punctuation\">(</span>mappedHandler<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n            String method <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">getMethod</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">boolean</span> isGet <span class=\"token operator\">=</span> <span class=\"token string\">\"GET\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isGet <span class=\"token operator\">||</span> <span class=\"token string\">\"HEAD\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>method<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">long</span> lastModified <span class=\"token operator\">=</span> ha<span class=\"token punctuation\">.</span><span class=\"token function\">getLastModified</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> mappedHandler<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ServletWebRequest</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">checkNotModified</span><span class=\"token punctuation\">(</span>lastModified<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> isGet<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//执行前置拦截器</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>mappedHandler<span class=\"token punctuation\">.</span><span class=\"token function\">applyPreHandle</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View</span>\n            mv <span class=\"token operator\">=</span> ha<span class=\"token punctuation\">.</span><span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> mappedHandler<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>asyncManager<span class=\"token punctuation\">.</span><span class=\"token function\">isConcurrentHandlingStarted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//解析默认的视图</span>\n            <span class=\"token function\">applyDefaultViewName</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> mv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//执行后置拦截器</span>\n            mappedHandler<span class=\"token punctuation\">.</span><span class=\"token function\">applyPostHandle</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> mv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            dispatchException <span class=\"token operator\">=</span> ex<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n            dispatchException <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NestedServletException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Handler dispatch failed\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//处理转发结果</span>\n        <span class=\"token function\">processDispatchResult</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> mappedHandler<span class=\"token punctuation\">,</span> mv<span class=\"token punctuation\">,</span> dispatchException<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//异常执行拦截器的完成事件</span>\n        <span class=\"token function\">triggerAfterCompletion</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> mappedHandler<span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">triggerAfterCompletion</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> mappedHandler<span class=\"token punctuation\">,</span>\n                <span class=\"token keyword\">new</span> <span class=\"token class-name\">NestedServletException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Handler processing failed\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>asyncManager<span class=\"token punctuation\">.</span><span class=\"token function\">isConcurrentHandlingStarted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 处理异步请求</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mappedHandler <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                mappedHandler<span class=\"token punctuation\">.</span><span class=\"token function\">applyAfterConcurrentHandlingStarted</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 清空上传的临时文件</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>multipartRequestParsed<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">cleanupMultipart</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><font size=\"4\" color=\"red\">第二步：DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler并封装成HandlerExecutionChain对象(一个Handler + 多个HandlerInterceptor拦截器)</font></p>\n<p>通过遍历handlerMappings找到请求对应的Handler，并将Handler + 拦截器 封装成HandlerExecutionChain对象。</p>\n<p><img src=\"/2020/01/04/springmvc2/13.png\" alt></p>\n<p><font size=\"4\" color=\"red\">第三步：通过Handler找到对应的处理器适配器（HandlerAdapter）</font></p>\n<p>HandlerAdapter采用了适配器模式提供了两个方法 ：</p>\n<ul>\n<li>boolean supports(Object handler)  – 判断参数的handler是不是我这个适配器可以处理的处理器。</li>\n<li>ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)  – 处理并返回ModelAndView</li>\n</ul>\n<p><img src=\"/2020/01/04/springmvc2/14.png\" alt></p>\n<p>例如RequestMappingHandlerAdapter适配器，他判断如果这个handler是HandlerMethod则这个handler使用他来进行处理。</p>\n<p><font size=\"4\" color=\"red\">第四步：执行handler前先执行拦截器的前置拦截</font></p>\n<p>拦截器提供的3个方法：</p>\n<ul>\n<li><strong>preHandle</strong> - 该方法将在请求处理之前进行调用</li>\n<li><strong>postHandle</strong> - Controller 处理之后的ModelAndView 对象进行，此时视图还没做渲染</li>\n<li><strong>afterCompletion</strong> - 渲染了视图后执行，主要是清理资源等</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//mappedHandler.applyPreHandle(processedRequest, response);</span>\n<span class=\"token keyword\">boolean</span> <span class=\"token function\">applyPreHandle</span><span class=\"token punctuation\">(</span>HttpServletRequest request<span class=\"token punctuation\">,</span> HttpServletResponse response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n    HandlerInterceptor<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> interceptors <span class=\"token operator\">=</span> <span class=\"token function\">getInterceptors</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//获取定义的拦截器</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ObjectUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isEmpty</span><span class=\"token punctuation\">(</span>interceptors<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> interceptors<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            HandlerInterceptor interceptor <span class=\"token operator\">=</span> interceptors<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n             <span class=\"token comment\" spellcheck=\"true\">//执行前置拦截</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>interceptor<span class=\"token punctuation\">.</span><span class=\"token function\">preHandle</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">triggerAfterCompletion</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>interceptorIndex <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><font size=\"4\" color=\"red\">第五步：调用HandlerAdapter(处理器适配器)执行handler并返回ModelAndView</font></p>\n<pre class=\" language-java\"><code class=\"language-java\">mv <span class=\"token operator\">=</span> ha<span class=\"token punctuation\">.</span><span class=\"token function\">handle</span><span class=\"token punctuation\">(</span>processedRequest<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">,</span> mappedHandler<span class=\"token punctuation\">.</span><span class=\"token function\">getHandler</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<p>分析RequestMappingHandlerAdapter的执行逻辑如下：</p>\n<p><img src=\"/2020/01/04/springmvc2/15.png\" alt=\"执行handler\"></p>\n<p><img src=\"/2020/01/04/springmvc2/16.png\" alt=\"hanlder结果封装成ModelAndView\"></p>\n<p><font size=\"4\" color=\"red\">第六步：执行拦截器后置拦截</font></p>\n<pre><code>//如果没有视图，设置默认视图\napplyDefaultViewName(processedRequest, mv)\n//执行后置拦截\nmappedHandler.applyPostHandle(processedRequest, response, mv)</code></pre><p><font size=\"4\" color=\"red\">第七步：前端控制器请求视图解析器（ViewResolver）去进行视图解析</font></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//获取视图并进行渲染</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">render</span><span class=\"token punctuation\">(</span>ModelAndView mv<span class=\"token punctuation\">,</span> HttpServletRequest request<span class=\"token punctuation\">,</span> HttpServletResponse response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        Locale locale <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>localeResolver <span class=\"token operator\">!=</span> null <span class=\"token operator\">?</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>localeResolver<span class=\"token punctuation\">.</span><span class=\"token function\">resolveLocale</span><span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> request<span class=\"token punctuation\">.</span><span class=\"token function\">getLocale</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        response<span class=\"token punctuation\">.</span><span class=\"token function\">setLocale</span><span class=\"token punctuation\">(</span>locale<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        View view<span class=\"token punctuation\">;</span>\n        String viewName <span class=\"token operator\">=</span> mv<span class=\"token punctuation\">.</span><span class=\"token function\">getViewName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>viewName <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//遍历视图解析器解析当前view对应的视图</span>\n            view <span class=\"token operator\">=</span> <span class=\"token function\">resolveViewName</span><span class=\"token punctuation\">(</span>viewName<span class=\"token punctuation\">,</span> mv<span class=\"token punctuation\">.</span><span class=\"token function\">getModelInternal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> locale<span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>view <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ServletException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Could not resolve view with name '\"</span> <span class=\"token operator\">+</span> mv<span class=\"token punctuation\">.</span><span class=\"token function\">getViewName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span>\n                        <span class=\"token string\">\"' in servlet with name '\"</span> <span class=\"token operator\">+</span> <span class=\"token function\">getServletName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"'\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            view <span class=\"token operator\">=</span> mv<span class=\"token punctuation\">.</span><span class=\"token function\">getView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mv<span class=\"token punctuation\">.</span><span class=\"token function\">getStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                response<span class=\"token punctuation\">.</span><span class=\"token function\">setStatus</span><span class=\"token punctuation\">(</span>mv<span class=\"token punctuation\">.</span><span class=\"token function\">getStatus</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">//渲染视图</span>\n            view<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>mv<span class=\"token punctuation\">.</span><span class=\"token function\">getModelInternal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> request<span class=\"token punctuation\">,</span> response<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">isDebugEnabled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                logger<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error rendering view [\"</span> <span class=\"token operator\">+</span> view <span class=\"token operator\">+</span> <span class=\"token string\">\"]\"</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">throw</span> ex<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">protected</span> View <span class=\"token function\">resolveViewName</span><span class=\"token punctuation\">(</span>String viewName<span class=\"token punctuation\">,</span> <span class=\"token annotation punctuation\">@Nullable</span> Map<span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span> Object<span class=\"token operator\">></span> model<span class=\"token punctuation\">,</span>\n        Locale locale<span class=\"token punctuation\">,</span> HttpServletRequest request<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>viewResolvers <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//遍历所有的视图列表并选择一个合适的视图</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>ViewResolver viewResolver <span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>viewResolvers<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            View view <span class=\"token operator\">=</span> viewResolver<span class=\"token punctuation\">.</span><span class=\"token function\">resolveViewName</span><span class=\"token punctuation\">(</span>viewName<span class=\"token punctuation\">,</span> locale<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>view <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> view<span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"SpringMVC工作流程\"><a href=\"#SpringMVC工作流程\" class=\"headerlink\" title=\"SpringMVC工作流程\"></a>SpringMVC工作流程</h2><h3 id=\"工作流程概述\"><a href=\"#工作流程概述\" class=\"headerlink\" title=\"工作流程概述\"></a>工作流程概述</h3><ul>\n<li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet。</li>\n<li>DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求成对应的 Handler（HandlerExecutionChain包含该请求的handler和拦截器链）。</li>\n<li>解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。</li>\n<li>HandlerAdapter 会根据 Handler 来调用真正的处理器开始处理请求，执行对应的业务逻辑。</li>\n<li>处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。</li>\n<li>ViewResolver 会根据逻辑 View 查找实际的 View。</li>\n<li>DispaterServlet 把返回的 Model 传给 View（视图渲染）。</li>\n<li>把 View 返回给请求者（浏览器）。</li></ul>","more":"<h3 id=\"流程分析\"><a href=\"#流程分析\" class=\"headerlink\" title=\"流程分析\"></a>流程分析</h3>\n\n<p><font size=\"4\" color=\"red\">第一步：客户端（浏览器）发送请求，直接请求到DispatcherServlet</font></p>\n<p>前面说过SpringMVC是遵循Sevlet规范的。且DispatcherServlet继承了HttpServlet。所以请求会通过HttpServlet的doGet方法或者doPost方法处理。所以我们在根据DispatcherServlet及其父类上需要doGet和doPost入口。</p>\n<p><img src=\"/2020/01/04/springmvc2/10.png\" alt></p>\n<p><img src=\"/2020/01/04/springmvc2/11.png\" alt></p>\n<p><img src=\"/2020/01/04/springmvc2/12.png\" alt></p>\n<p>所以，我们最终请求会到DispatcherServlet类中的doDispatch方法中进行处理。</p>\n<pre><code class=\"java\">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HttpServletRequest processedRequest = request;\n    HandlerExecutionChain mappedHandler = null;\n    boolean multipartRequestParsed = false;\n\n    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n\n    try {\n        ModelAndView mv = null;\n        Exception dispatchException = null;\n\n        try {\n            processedRequest = checkMultipart(request);\n            multipartRequestParsed = (processedRequest != request);\n\n            //DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler\n            mappedHandler = getHandler(processedRequest);\n            if (mappedHandler == null) {\n                noHandlerFound(processedRequest, response);\n                return;\n            }\n\n            // 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理\n            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());\n\n\n            String method = request.getMethod();\n            boolean isGet = &quot;GET&quot;.equals(method);\n            if (isGet || &quot;HEAD&quot;.equals(method)) {\n                long lastModified = ha.getLastModified(request, mappedHandler.getHandler());\n                if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {\n                    return;\n                }\n            }\n            //执行前置拦截器\n            if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n                return;\n            }\n\n            // HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑\n            // 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View\n            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());\n\n            if (asyncManager.isConcurrentHandlingStarted()) {\n                return;\n            }\n            //解析默认的视图\n            applyDefaultViewName(processedRequest, mv);\n            //执行后置拦截器\n            mappedHandler.applyPostHandle(processedRequest, response, mv);\n        }\n        catch (Exception ex) {\n            dispatchException = ex;\n        }\n        catch (Throwable err) {\n\n            dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);\n        }\n        //处理转发结果\n        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n    }\n    catch (Exception ex) {\n        //异常执行拦截器的完成事件\n        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);\n    }\n    catch (Throwable err) {\n        triggerAfterCompletion(processedRequest, response, mappedHandler,\n                new NestedServletException(&quot;Handler processing failed&quot;, err));\n    }\n    finally {\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            // 处理异步请求\n            if (mappedHandler != null) {\n                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);\n            }\n        }\n        else {\n            // 清空上传的临时文件\n            if (multipartRequestParsed) {\n                cleanupMultipart(processedRequest);\n            }\n        }\n    }\n}</code></pre>\n<p><font size=\"4\" color=\"red\">第二步：DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler并封装成HandlerExecutionChain对象(一个Handler + 多个HandlerInterceptor拦截器)</font></p>\n<p>通过遍历handlerMappings找到请求对应的Handler，并将Handler + 拦截器 封装成HandlerExecutionChain对象。</p>\n<p><img src=\"/2020/01/04/springmvc2/13.png\" alt></p>\n<p><font size=\"4\" color=\"red\">第三步：通过Handler找到对应的处理器适配器（HandlerAdapter）</font></p>\n<p>HandlerAdapter采用了适配器模式提供了两个方法 ：</p>\n<ul>\n<li>boolean supports(Object handler)  – 判断参数的handler是不是我这个适配器可以处理的处理器。</li>\n<li>ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)  – 处理并返回ModelAndView</li>\n</ul>\n<p><img src=\"/2020/01/04/springmvc2/14.png\" alt></p>\n<p>例如RequestMappingHandlerAdapter适配器，他判断如果这个handler是HandlerMethod则这个handler使用他来进行处理。</p>\n<p><font size=\"4\" color=\"red\">第四步：执行handler前先执行拦截器的前置拦截</font></p>\n<p>拦截器提供的3个方法：</p>\n<ul>\n<li><strong>preHandle</strong> - 该方法将在请求处理之前进行调用</li>\n<li><strong>postHandle</strong> - Controller 处理之后的ModelAndView 对象进行，此时视图还没做渲染</li>\n<li><strong>afterCompletion</strong> - 渲染了视图后执行，主要是清理资源等</li>\n</ul>\n<pre><code class=\"java\">//mappedHandler.applyPreHandle(processedRequest, response);\nboolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HandlerInterceptor[] interceptors = getInterceptors(); //获取定义的拦截器\n    if (!ObjectUtils.isEmpty(interceptors)) {\n        for (int i = 0; i &lt; interceptors.length; i++) {\n            HandlerInterceptor interceptor = interceptors[i];\n             //执行前置拦截\n            if (!interceptor.preHandle(request, response, this.handler)) {\n                triggerAfterCompletion(request, response, null);\n                return false;\n            }\n            this.interceptorIndex = i;\n        }\n    }\n    return true;\n}</code></pre>\n<p><font size=\"4\" color=\"red\">第五步：调用HandlerAdapter(处理器适配器)执行handler并返回ModelAndView</font></p>\n<pre><code class=\"java\">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code></pre>\n<p>分析RequestMappingHandlerAdapter的执行逻辑如下：</p>\n<p><img src=\"/2020/01/04/springmvc2/15.png\" alt=\"执行handler\"></p>\n<p><img src=\"/2020/01/04/springmvc2/16.png\" alt=\"hanlder结果封装成ModelAndView\"></p>\n<p><font size=\"4\" color=\"red\">第六步：执行拦截器后置拦截</font></p>\n<pre><code>//如果没有视图，设置默认视图\napplyDefaultViewName(processedRequest, mv)\n//执行后置拦截\nmappedHandler.applyPostHandle(processedRequest, response, mv)</code></pre><p><font size=\"4\" color=\"red\">第七步：前端控制器请求视图解析器（ViewResolver）去进行视图解析</font></p>\n<pre><code class=\"java\">//获取视图并进行渲染\nprotected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());\n        response.setLocale(locale);\n        View view;\n        String viewName = mv.getViewName();\n        if (viewName != null) {\n            //遍历视图解析器解析当前view对应的视图\n            view = resolveViewName(viewName, mv.getModelInternal(), locale, request);\n            if (view == null) {\n                throw new ServletException(&quot;Could not resolve view with name &#39;&quot; + mv.getViewName() +\n                        &quot;&#39; in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);\n            }\n        }\n        else {\n            view = mv.getView();\n        }\n        try {\n            if (mv.getStatus() != null) {\n                response.setStatus(mv.getStatus().value());\n            }\n            //渲染视图\n            view.render(mv.getModelInternal(), request, response);\n        }\n        catch (Exception ex) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(&quot;Error rendering view [&quot; + view + &quot;]&quot;, ex);\n            }\n            throw ex;\n        }\n}\n\nprotected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model,\n        Locale locale, HttpServletRequest request) throws Exception {\n    if (this.viewResolvers != null) {\n        //遍历所有的视图列表并选择一个合适的视图\n        for (ViewResolver viewResolver : this.viewResolvers) {\n            View view = viewResolver.resolveViewName(viewName, locale);\n            if (view != null) {\n                return view;\n            }\n        }\n    }\n    return null;\n}</code></pre>"},{"title":"SpringMVC详细解析之初始化（一）","description":"SpringMVC详细解析之初始化","date":"2020-01-01T08:02:20.000Z","_content":"## SpringMVC初始化\n\n### SpringMVC搭建流程\n\n1.新建applicationContext.xml配置文件\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd\">\n    <context:annotation-config/>\n    <bean id=\"beanService\" class=\"com.xzy.bean.BeanService\"></bean>\n    //...忽略其他配置\n</bean>\n</beans>\n```\n<!--more-->\n2.新建springmvc.xml配置文件\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 -->\n    <context:component-scan base-package=\"com.xzy.controller\"/>\n    <mvc:annotation-driven />\n    <!-- 定义跳转的文件的前后缀 ，视图模式配置-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 -->\n        <property name=\"prefix\" value=\"/WEB-INF/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n</beans>\n```\n\n3.新建web.xml\n\n```xml\n <!—创建Root WebApplicationContext-->\n    <context-param>  \n        <param-name>contextConfigLocation</param-name>  \n        <param-value>classpath:applicationContext.xml</param-value>  \n    </context-param>  \n  \n    <listener>  \n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  \n    </listener>\n    <!—创建Servlet WebApplicationContext-->\n    <servlet>  \n        <servlet-name>dispatcher</servlet-name>  \n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  \n        <init-param>  \n            <param-name>contextConfigLocation</param-name>  \n            <param-value>classpath:spring-mvc.xml</param-value>  \n        </init-param>  \n        <load-on-startup>1</load-on-startup>  \n    </servlet>  \n    <servlet-mapping>  \n        <servlet-name>dispatcher</servlet-name>  \n        <url-pattern>/*</url-pattern>  \n    </servlet-mapping>\n```\n\n### SpringMVC父子容器\n\n我们先来回顾下JavaWeb的三个组建：Listener(监听器)，Servlet，Filter。他们的作用如下 ：\n\n- Listener，主要用来监听生命周期内的各种变化，例如监听servlet容器启动和关闭等\n- Servlet，每个请求要经过的地方，提供了doGet方法，doPost方法\n- Filter，过滤器，例如过滤一些不符合的请求\n\n在web.xml我们定义了ContextLoaderListener监听器和DispatcherServlet的Servlet。他们分别用来加载父容器和子容器\n\n- Root WebApplicationContext：这是对J2EE三层架构中的service层、dao层进行配置，如业务bean，数据源(DataSource)等。通常情况下，配置文件的名称为applicationContext.xml。在web应用中，其一般通过ContextLoaderListener来加载\n- Servlet WebApplicationContext：这是对J2EE三层架构中的web层进行配置，如控制器(controller)、视图解析器(view resolvers)等相关的bean。通过spring mvc中提供的DispatchServlet来加载配置，通常情况下，配置文件的名称为spring-servlet.xml\n\n**为什么要有父子容器?**\n\n父子容器的作用主要是划分框架边界。\n\n## ContextLoaderListener详解\n\nContextLoaderListener实现了ServletContextListener接口，所以它能够监听 ServletContext 对象的生命周期。在Web应用启动时会调用contextInitialized方法加载applicationContext.xml对应的Bean。也就是我们说的父容器的东西，包括三层架构中的service层、dao层进行配置，如业务bean。\n\n![ContextLoaderListener继承关系](springmvc/4.png)\n\n## DispatcherServlet初始化\n\n### httpServlet初始化init\n\n![DispatcherServlet继承结构](springmvc/5.png)\n\nDispatcherServlet集成HttpServlet类，所以在容器启动后会执行init()方法。主要做的事包括\n\n- 加载Spring-mvc.xml对应的容器\n\n- 通过解析自定义标签<mvc:annotation-driven /> ，往容器中注入处理映射器(HandlerMapping)，处理映射器(HandlerAdapter)，视图控制器等。\n\n  流程如下：\\<mvc:annotation-driven\\/> -----》 MvcNamespaceHandler#init() -----》 AnnotationDrivenBeanDefinitionParser#parse()\n\n- 执行initStrategies初始化方法\n\n![](springmvc/6.png)\n\n```java\n//执行initStrategies初始化方法\nprotected void initStrategies(ApplicationContext context) {\n\t//初始化文件上传\n\tinitMultipartResolver(context);\n\t//初始化国家化\n\tinitLocaleResolver(context);\n\t//初始化主题\n\tinitThemeResolver(context);\n\t//初始化处理映射器\n\tinitHandlerMappings(context);\n\t//初始化处理适配器\n\tinitHandlerAdapters(context);\n\t//初始化请求异常\n\tinitHandlerExceptionResolvers(context);\n\t//初始化请求视图名\n\tinitRequestToViewNameTranslator(context);\n\t//初始化视图解析器\n\tinitViewResolvers(context);\n\t//\n\tinitFlashMapManager(context);\n}\n```\n\n\n\n### 映射处理器HandlerMapping\n\nSpringMVC 内部是根据 `HandlerMapping` 将 `Request` 和 `Controller` 里面的方法对应起来的。在初始化后就会将这个映射注册到mappingRegistry.java类中。后面请求过来的时才可以通过url找到对应的Controller方法进行处理。映射处理器在Web启动后，自动加载了RequestMappingHandlerMapping.java 和 BeanNameUrlHandlerMapping.java。他们分别对应不同的处理方式。\n\n接下来我们通过RequestMappingHandlerMapping.java来了解下是如何将Request和Controller映射起来的。\n\n![RequestMappingHandlerMapping继承结构](springmvc/7.png)\n\nRequestMappingHandlerMapping实现了InitializingBean接口，所以在对象实例化后会执行afterPropertiesSet方法。具体链路如下：\n\n1. RequestMappingHandlerMapping#afterPropertiesSet()\n2. AbstractHandlerMethodMapping#initHandlerMethods() \n3. AbstractHandlerMethodMapping#processCandidateBean(beanName)\n4. AbstractHandlerMethodMapping#detectHandlerMethods(beanName)\n5. AbstractHandlerMethodMapping#registerMapping()\n6. AbstractHandlerMethodMapping#register(T mapping, Object handler, Method method)\n\n![](springmvc/8.png)\n\n![](springmvc/9.png)\n\n![](springmvc/10.png)\n\n所以说HandlerMapping主要是将请求和对应的处理类(Handler)对应起来。例如我们Controller可以是如下两种定义方式：\n\n```java\n//采用注解方式@Controller 和 @RequestMapping\n@Controller\n@RequestMapping(value = \"/demo\")\npublic class DemoController {\n    @RequestMapping(value = \"/demo1.action\")\n    @ResponseBody\n    public Map demo1() {\n        //..省略很多代码\n    }\n}\n\n//通过实现Controller方法的方式\npublic class OtherController implements Controller {\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ModelAndView mv = new ModelAndView();\n        mv.addObject(\"hello\",\"world\");\n        mv.setViewName(\"result\");\n        return mv;\n    }\n}\n<bean id=\"/other.action\" class=\"com.xzy.controller.OtherController\"></bean>\n```\n\nHandlerMapping通过不同的实现类来将url和handler映射起来。后面执行getHandler()方法时，就可以通过url找到对应的handler。并将handler+多个HandlerInterceptor拦截器封装成HandlerExecutionChain对象。\n\n具体的实现类包括：\n\n- RequestMappingHandlerMapping，使用注解的时候,通过注解将url映射到对应的Controller上。也是我们最常用的方式。\n- BeanNameUrlHandlerMapping，需要在spring-mvc.xml中配置BeanNameUrlHandlerMapping以及bean实现了AbstractController。通过bean将url映射的对应的Controller。\n\n```java\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"></bean>\n<bean id=\"/hello\" class=\"com.cyw.web.controller.HelloController\"></bean>\npublic class HelloController extends AbstractController {\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)\n            throws Exception {\n        return new ModelAndView(\"Hello\");\n    }\n}\n```\n\n- SimpleUrlHandlerMapping，通过url直接映射。\n\n```xml\n<bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n   <property name=\"mappings\">\n    <props>\n       <prop key=\"/hello.htm\">helloController</prop>\n     </props>\n   </property>\n</bean>\n<bean id=\"helloController\" class=\"com.cyw.web.controller.HelloController\" />\n```\n\n### 处理适配器(HandlerAdapter)\n\nHandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）。由于handler是有不同的实现方式，例如是实现Controller还是使用@Controller注解，所以需要使用适配器的方式找到不通方式的处理器。系统默认提供了处理适配器来对应不同方式的handler。\n\n- RequestMappingHandlerAdapter.java\n- HttpRequestHandlerAdapter.java\n- SimpleControllerHandlerAdapter.java\n\n","source":"_posts/springmvc.md","raw":"---\ntitle: SpringMVC详细解析之初始化（一）\ntags:\n  - spring\ncategories: \n  - spring\ndescription : SpringMVC详细解析之初始化\ndate: 2020-01-01 16:02:20\n---\n## SpringMVC初始化\n\n### SpringMVC搭建流程\n\n1.新建applicationContext.xml配置文件\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd\">\n    <context:annotation-config/>\n    <bean id=\"beanService\" class=\"com.xzy.bean.BeanService\"></bean>\n    //...忽略其他配置\n</bean>\n</beans>\n```\n<!--more-->\n2.新建springmvc.xml配置文件\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\n\n    <!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 -->\n    <context:component-scan base-package=\"com.xzy.controller\"/>\n    <mvc:annotation-driven />\n    <!-- 定义跳转的文件的前后缀 ，视图模式配置-->\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 -->\n        <property name=\"prefix\" value=\"/WEB-INF/\"/>\n        <property name=\"suffix\" value=\".jsp\"/>\n    </bean>\n</beans>\n```\n\n3.新建web.xml\n\n```xml\n <!—创建Root WebApplicationContext-->\n    <context-param>  \n        <param-name>contextConfigLocation</param-name>  \n        <param-value>classpath:applicationContext.xml</param-value>  \n    </context-param>  \n  \n    <listener>  \n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>  \n    </listener>\n    <!—创建Servlet WebApplicationContext-->\n    <servlet>  \n        <servlet-name>dispatcher</servlet-name>  \n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>  \n        <init-param>  \n            <param-name>contextConfigLocation</param-name>  \n            <param-value>classpath:spring-mvc.xml</param-value>  \n        </init-param>  \n        <load-on-startup>1</load-on-startup>  \n    </servlet>  \n    <servlet-mapping>  \n        <servlet-name>dispatcher</servlet-name>  \n        <url-pattern>/*</url-pattern>  \n    </servlet-mapping>\n```\n\n### SpringMVC父子容器\n\n我们先来回顾下JavaWeb的三个组建：Listener(监听器)，Servlet，Filter。他们的作用如下 ：\n\n- Listener，主要用来监听生命周期内的各种变化，例如监听servlet容器启动和关闭等\n- Servlet，每个请求要经过的地方，提供了doGet方法，doPost方法\n- Filter，过滤器，例如过滤一些不符合的请求\n\n在web.xml我们定义了ContextLoaderListener监听器和DispatcherServlet的Servlet。他们分别用来加载父容器和子容器\n\n- Root WebApplicationContext：这是对J2EE三层架构中的service层、dao层进行配置，如业务bean，数据源(DataSource)等。通常情况下，配置文件的名称为applicationContext.xml。在web应用中，其一般通过ContextLoaderListener来加载\n- Servlet WebApplicationContext：这是对J2EE三层架构中的web层进行配置，如控制器(controller)、视图解析器(view resolvers)等相关的bean。通过spring mvc中提供的DispatchServlet来加载配置，通常情况下，配置文件的名称为spring-servlet.xml\n\n**为什么要有父子容器?**\n\n父子容器的作用主要是划分框架边界。\n\n## ContextLoaderListener详解\n\nContextLoaderListener实现了ServletContextListener接口，所以它能够监听 ServletContext 对象的生命周期。在Web应用启动时会调用contextInitialized方法加载applicationContext.xml对应的Bean。也就是我们说的父容器的东西，包括三层架构中的service层、dao层进行配置，如业务bean。\n\n![ContextLoaderListener继承关系](springmvc/4.png)\n\n## DispatcherServlet初始化\n\n### httpServlet初始化init\n\n![DispatcherServlet继承结构](springmvc/5.png)\n\nDispatcherServlet集成HttpServlet类，所以在容器启动后会执行init()方法。主要做的事包括\n\n- 加载Spring-mvc.xml对应的容器\n\n- 通过解析自定义标签<mvc:annotation-driven /> ，往容器中注入处理映射器(HandlerMapping)，处理映射器(HandlerAdapter)，视图控制器等。\n\n  流程如下：\\<mvc:annotation-driven\\/> -----》 MvcNamespaceHandler#init() -----》 AnnotationDrivenBeanDefinitionParser#parse()\n\n- 执行initStrategies初始化方法\n\n![](springmvc/6.png)\n\n```java\n//执行initStrategies初始化方法\nprotected void initStrategies(ApplicationContext context) {\n\t//初始化文件上传\n\tinitMultipartResolver(context);\n\t//初始化国家化\n\tinitLocaleResolver(context);\n\t//初始化主题\n\tinitThemeResolver(context);\n\t//初始化处理映射器\n\tinitHandlerMappings(context);\n\t//初始化处理适配器\n\tinitHandlerAdapters(context);\n\t//初始化请求异常\n\tinitHandlerExceptionResolvers(context);\n\t//初始化请求视图名\n\tinitRequestToViewNameTranslator(context);\n\t//初始化视图解析器\n\tinitViewResolvers(context);\n\t//\n\tinitFlashMapManager(context);\n}\n```\n\n\n\n### 映射处理器HandlerMapping\n\nSpringMVC 内部是根据 `HandlerMapping` 将 `Request` 和 `Controller` 里面的方法对应起来的。在初始化后就会将这个映射注册到mappingRegistry.java类中。后面请求过来的时才可以通过url找到对应的Controller方法进行处理。映射处理器在Web启动后，自动加载了RequestMappingHandlerMapping.java 和 BeanNameUrlHandlerMapping.java。他们分别对应不同的处理方式。\n\n接下来我们通过RequestMappingHandlerMapping.java来了解下是如何将Request和Controller映射起来的。\n\n![RequestMappingHandlerMapping继承结构](springmvc/7.png)\n\nRequestMappingHandlerMapping实现了InitializingBean接口，所以在对象实例化后会执行afterPropertiesSet方法。具体链路如下：\n\n1. RequestMappingHandlerMapping#afterPropertiesSet()\n2. AbstractHandlerMethodMapping#initHandlerMethods() \n3. AbstractHandlerMethodMapping#processCandidateBean(beanName)\n4. AbstractHandlerMethodMapping#detectHandlerMethods(beanName)\n5. AbstractHandlerMethodMapping#registerMapping()\n6. AbstractHandlerMethodMapping#register(T mapping, Object handler, Method method)\n\n![](springmvc/8.png)\n\n![](springmvc/9.png)\n\n![](springmvc/10.png)\n\n所以说HandlerMapping主要是将请求和对应的处理类(Handler)对应起来。例如我们Controller可以是如下两种定义方式：\n\n```java\n//采用注解方式@Controller 和 @RequestMapping\n@Controller\n@RequestMapping(value = \"/demo\")\npublic class DemoController {\n    @RequestMapping(value = \"/demo1.action\")\n    @ResponseBody\n    public Map demo1() {\n        //..省略很多代码\n    }\n}\n\n//通过实现Controller方法的方式\npublic class OtherController implements Controller {\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ModelAndView mv = new ModelAndView();\n        mv.addObject(\"hello\",\"world\");\n        mv.setViewName(\"result\");\n        return mv;\n    }\n}\n<bean id=\"/other.action\" class=\"com.xzy.controller.OtherController\"></bean>\n```\n\nHandlerMapping通过不同的实现类来将url和handler映射起来。后面执行getHandler()方法时，就可以通过url找到对应的handler。并将handler+多个HandlerInterceptor拦截器封装成HandlerExecutionChain对象。\n\n具体的实现类包括：\n\n- RequestMappingHandlerMapping，使用注解的时候,通过注解将url映射到对应的Controller上。也是我们最常用的方式。\n- BeanNameUrlHandlerMapping，需要在spring-mvc.xml中配置BeanNameUrlHandlerMapping以及bean实现了AbstractController。通过bean将url映射的对应的Controller。\n\n```java\n<bean class=\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"></bean>\n<bean id=\"/hello\" class=\"com.cyw.web.controller.HelloController\"></bean>\npublic class HelloController extends AbstractController {\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)\n            throws Exception {\n        return new ModelAndView(\"Hello\");\n    }\n}\n```\n\n- SimpleUrlHandlerMapping，通过url直接映射。\n\n```xml\n<bean class=\"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping\">\n   <property name=\"mappings\">\n    <props>\n       <prop key=\"/hello.htm\">helloController</prop>\n     </props>\n   </property>\n</bean>\n<bean id=\"helloController\" class=\"com.cyw.web.controller.HelloController\" />\n```\n\n### 处理适配器(HandlerAdapter)\n\nHandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）。由于handler是有不同的实现方式，例如是实现Controller还是使用@Controller注解，所以需要使用适配器的方式找到不通方式的处理器。系统默认提供了处理适配器来对应不同方式的handler。\n\n- RequestMappingHandlerAdapter.java\n- HttpRequestHandlerAdapter.java\n- SimpleControllerHandlerAdapter.java\n\n","slug":"springmvc","published":1,"updated":"2021-04-08T00:47:07.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhw1004eqwv24fnn05x6","content":"<h2 id=\"SpringMVC初始化\"><a href=\"#SpringMVC初始化\" class=\"headerlink\" title=\"SpringMVC初始化\"></a>SpringMVC初始化</h2><h3 id=\"SpringMVC搭建流程\"><a href=\"#SpringMVC搭建流程\" class=\"headerlink\" title=\"SpringMVC搭建流程\"></a>SpringMVC搭建流程</h3><p>1.新建applicationContext.xml配置文件</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>xml version<span class=\"token operator\">=</span><span class=\"token string\">\"1.0\"</span> encoding<span class=\"token operator\">=</span><span class=\"token string\">\"UTF-8\"</span><span class=\"token operator\">?</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>beans xmlns<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.springframework.org/schema/beans\"</span>\n       xmlns<span class=\"token operator\">:</span>xsi<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n       xmlns<span class=\"token operator\">:</span>context<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.springframework.org/schema/context\"</span>\n       xmlns<span class=\"token operator\">:</span>tx<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.springframework.org/schema/tx\"</span>\n       xsi<span class=\"token operator\">:</span>schemaLocation<span class=\"token operator\">=</span>\"http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>beans\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>beans<span class=\"token operator\">/</span>spring<span class=\"token operator\">-</span>beans<span class=\"token punctuation\">.</span>xsd\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>context\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>context<span class=\"token operator\">/</span>spring<span class=\"token operator\">-</span>context<span class=\"token punctuation\">.</span>xsd\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>tx\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>tx<span class=\"token operator\">/</span>spring<span class=\"token operator\">-</span>tx<span class=\"token punctuation\">.</span>xsd\"<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>context<span class=\"token operator\">:</span>annotation<span class=\"token operator\">-</span>config<span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>bean id<span class=\"token operator\">=</span><span class=\"token string\">\"beanService\"</span> <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"com.xzy.bean.BeanService\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>bean<span class=\"token operator\">></span>\n    <span class=\"token comment\" spellcheck=\"true\">//...忽略其他配置</span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>bean<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>beans<span class=\"token operator\">></span></code></pre>\n<a id=\"more\"></a>\n<p>2.新建springmvc.xml配置文件</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span>xml version<span class=\"token operator\">=</span><span class=\"token string\">\"1.0\"</span> encoding<span class=\"token operator\">=</span><span class=\"token string\">\"UTF-8\"</span><span class=\"token operator\">?</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>beans xmlns<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.springframework.org/schema/beans\"</span>\n       xmlns<span class=\"token operator\">:</span>xsi<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span>\n       xmlns<span class=\"token operator\">:</span>context<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.springframework.org/schema/context\"</span>\n       xmlns<span class=\"token operator\">:</span>tx<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.springframework.org/schema/tx\"</span> xmlns<span class=\"token operator\">:</span>mvc<span class=\"token operator\">=</span><span class=\"token string\">\"http://www.springframework.org/schema/mvc\"</span>\n       xsi<span class=\"token operator\">:</span>schemaLocation<span class=\"token operator\">=</span>\"http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>beans\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>beans<span class=\"token operator\">/</span>spring<span class=\"token operator\">-</span>beans<span class=\"token punctuation\">.</span>xsd\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>context\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>context<span class=\"token operator\">/</span>spring<span class=\"token operator\">-</span>context<span class=\"token punctuation\">.</span>xsd\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>tx\n        http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>tx<span class=\"token operator\">/</span>spring<span class=\"token operator\">-</span>tx<span class=\"token punctuation\">.</span>xsd http<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>mvc https<span class=\"token operator\">:</span><span class=\"token operator\">/</span><span class=\"token operator\">/</span>www<span class=\"token punctuation\">.</span>springframework<span class=\"token punctuation\">.</span>org<span class=\"token operator\">/</span>schema<span class=\"token operator\">/</span>mvc<span class=\"token operator\">/</span>spring<span class=\"token operator\">-</span>mvc<span class=\"token punctuation\">.</span>xsd\"<span class=\"token operator\">></span>\n\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 自动扫描该包，使SpringMVC认为包下用了<span class=\"token annotation punctuation\">@controller</span>注解的类是控制器 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>context<span class=\"token operator\">:</span>component<span class=\"token operator\">-</span>scan base<span class=\"token operator\">-</span><span class=\"token keyword\">package</span><span class=\"token operator\">=</span><span class=\"token string\">\"com.xzy.controller\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>mvc<span class=\"token operator\">:</span>annotation<span class=\"token operator\">-</span>driven <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 定义跳转的文件的前后缀 ，视图模式配置<span class=\"token operator\">--</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>bean <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"org.springframework.web.servlet.view.InternalResourceViewResolver\"</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 这里的配置我的理解是自动给后面action的方法<span class=\"token keyword\">return</span>的字符串加上前缀和后缀，变成一个 可用的url地址 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>property name<span class=\"token operator\">=</span><span class=\"token string\">\"prefix\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\"/WEB-INF/\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span>property name<span class=\"token operator\">=</span><span class=\"token string\">\"suffix\"</span> value<span class=\"token operator\">=</span><span class=\"token string\">\".jsp\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>bean<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>beans<span class=\"token operator\">></span></code></pre>\n<p>3.新建web.xml</p>\n<pre class=\" language-xml\"><code class=\"language-xml\"> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>!—创建Root</span> <span class=\"token attr-name\">WebApplicationContext--</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>context-param</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>param-name</span><span class=\"token punctuation\">></span></span>contextConfigLocation<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>param-name</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>param-value</span><span class=\"token punctuation\">></span></span>classpath:applicationContext.xml<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>param-value</span><span class=\"token punctuation\">></span></span>  \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>context-param</span><span class=\"token punctuation\">></span></span>  \n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>listener</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>listener-class</span><span class=\"token punctuation\">></span></span>org.springframework.web.context.ContextLoaderListener<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>listener-class</span><span class=\"token punctuation\">></span></span>  \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>listener</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>!—创建Servlet</span> <span class=\"token attr-name\">WebApplicationContext--</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>servlet</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>servlet-name</span><span class=\"token punctuation\">></span></span>dispatcher<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>servlet-name</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>servlet-class</span><span class=\"token punctuation\">></span></span>org.springframework.web.servlet.DispatcherServlet<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>servlet-class</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>init-param</span><span class=\"token punctuation\">></span></span>  \n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>param-name</span><span class=\"token punctuation\">></span></span>contextConfigLocation<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>param-name</span><span class=\"token punctuation\">></span></span>  \n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>param-value</span><span class=\"token punctuation\">></span></span>classpath:spring-mvc.xml<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>param-value</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>init-param</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>load-on-startup</span><span class=\"token punctuation\">></span></span>1<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>load-on-startup</span><span class=\"token punctuation\">></span></span>  \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>servlet</span><span class=\"token punctuation\">></span></span>  \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>servlet-mapping</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>servlet-name</span><span class=\"token punctuation\">></span></span>dispatcher<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>servlet-name</span><span class=\"token punctuation\">></span></span>  \n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>url-pattern</span><span class=\"token punctuation\">></span></span>/*<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>url-pattern</span><span class=\"token punctuation\">></span></span>  \n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>servlet-mapping</span><span class=\"token punctuation\">></span></span></code></pre>\n<h3 id=\"SpringMVC父子容器\"><a href=\"#SpringMVC父子容器\" class=\"headerlink\" title=\"SpringMVC父子容器\"></a>SpringMVC父子容器</h3><p>我们先来回顾下JavaWeb的三个组建：Listener(监听器)，Servlet，Filter。他们的作用如下 ：</p>\n<ul>\n<li>Listener，主要用来监听生命周期内的各种变化，例如监听servlet容器启动和关闭等</li>\n<li>Servlet，每个请求要经过的地方，提供了doGet方法，doPost方法</li>\n<li>Filter，过滤器，例如过滤一些不符合的请求</li>\n</ul>\n<p>在web.xml我们定义了ContextLoaderListener监听器和DispatcherServlet的Servlet。他们分别用来加载父容器和子容器</p>\n<ul>\n<li>Root WebApplicationContext：这是对J2EE三层架构中的service层、dao层进行配置，如业务bean，数据源(DataSource)等。通常情况下，配置文件的名称为applicationContext.xml。在web应用中，其一般通过ContextLoaderListener来加载</li>\n<li>Servlet WebApplicationContext：这是对J2EE三层架构中的web层进行配置，如控制器(controller)、视图解析器(view resolvers)等相关的bean。通过spring mvc中提供的DispatchServlet来加载配置，通常情况下，配置文件的名称为spring-servlet.xml</li>\n</ul>\n<p><strong>为什么要有父子容器?</strong></p>\n<p>父子容器的作用主要是划分框架边界。</p>\n<h2 id=\"ContextLoaderListener详解\"><a href=\"#ContextLoaderListener详解\" class=\"headerlink\" title=\"ContextLoaderListener详解\"></a>ContextLoaderListener详解</h2><p>ContextLoaderListener实现了ServletContextListener接口，所以它能够监听 ServletContext 对象的生命周期。在Web应用启动时会调用contextInitialized方法加载applicationContext.xml对应的Bean。也就是我们说的父容器的东西，包括三层架构中的service层、dao层进行配置，如业务bean。</p>\n<p><img src=\"/2020/01/01/springmvc/4.png\" alt=\"ContextLoaderListener继承关系\"></p>\n<h2 id=\"DispatcherServlet初始化\"><a href=\"#DispatcherServlet初始化\" class=\"headerlink\" title=\"DispatcherServlet初始化\"></a>DispatcherServlet初始化</h2><h3 id=\"httpServlet初始化init\"><a href=\"#httpServlet初始化init\" class=\"headerlink\" title=\"httpServlet初始化init\"></a>httpServlet初始化init</h3><p><img src=\"/2020/01/01/springmvc/5.png\" alt=\"DispatcherServlet继承结构\"></p>\n<p>DispatcherServlet集成HttpServlet类，所以在容器启动后会执行init()方法。主要做的事包括</p>\n<ul>\n<li><p>加载Spring-mvc.xml对应的容器</p>\n</li>\n<li><p>通过解析自定义标签&lt;mvc:annotation-driven /&gt; ，往容器中注入处理映射器(HandlerMapping)，处理映射器(HandlerAdapter)，视图控制器等。</p>\n<p>流程如下：&lt;mvc:annotation-driven/&gt; —–》 MvcNamespaceHandler#init() —–》 AnnotationDrivenBeanDefinitionParser#parse()</p>\n</li>\n<li><p>执行initStrategies初始化方法</p>\n</li>\n</ul>\n<p><img src=\"/2020/01/01/springmvc/6.png\" alt></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//执行initStrategies初始化方法</span>\n<span class=\"token keyword\">protected</span> <span class=\"token keyword\">void</span> <span class=\"token function\">initStrategies</span><span class=\"token punctuation\">(</span>ApplicationContext context<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化文件上传</span>\n    <span class=\"token function\">initMultipartResolver</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化国家化</span>\n    <span class=\"token function\">initLocaleResolver</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化主题</span>\n    <span class=\"token function\">initThemeResolver</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化处理映射器</span>\n    <span class=\"token function\">initHandlerMappings</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化处理适配器</span>\n    <span class=\"token function\">initHandlerAdapters</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化请求异常</span>\n    <span class=\"token function\">initHandlerExceptionResolvers</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化请求视图名</span>\n    <span class=\"token function\">initRequestToViewNameTranslator</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化视图解析器</span>\n    <span class=\"token function\">initViewResolvers</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//</span>\n    <span class=\"token function\">initFlashMapManager</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"映射处理器HandlerMapping\"><a href=\"#映射处理器HandlerMapping\" class=\"headerlink\" title=\"映射处理器HandlerMapping\"></a>映射处理器HandlerMapping</h3><p>SpringMVC 内部是根据 <code>HandlerMapping</code> 将 <code>Request</code> 和 <code>Controller</code> 里面的方法对应起来的。在初始化后就会将这个映射注册到mappingRegistry.java类中。后面请求过来的时才可以通过url找到对应的Controller方法进行处理。映射处理器在Web启动后，自动加载了RequestMappingHandlerMapping.java 和 BeanNameUrlHandlerMapping.java。他们分别对应不同的处理方式。</p>\n<p>接下来我们通过RequestMappingHandlerMapping.java来了解下是如何将Request和Controller映射起来的。</p>\n<p><img src=\"/2020/01/01/springmvc/7.png\" alt=\"RequestMappingHandlerMapping继承结构\"></p>\n<p>RequestMappingHandlerMapping实现了InitializingBean接口，所以在对象实例化后会执行afterPropertiesSet方法。具体链路如下：</p>\n<ol>\n<li>RequestMappingHandlerMapping#afterPropertiesSet()</li>\n<li>AbstractHandlerMethodMapping#initHandlerMethods() </li>\n<li>AbstractHandlerMethodMapping#processCandidateBean(beanName)</li>\n<li>AbstractHandlerMethodMapping#detectHandlerMethods(beanName)</li>\n<li>AbstractHandlerMethodMapping#registerMapping()</li>\n<li>AbstractHandlerMethodMapping#register(T mapping, Object handler, Method method)</li>\n</ol>\n<p><img src=\"/2020/01/01/springmvc/8.png\" alt></p>\n<p><img src=\"/2020/01/01/springmvc/9.png\" alt></p>\n<p><img src=\"/2020/01/01/springmvc/10.png\" alt></p>\n<p>所以说HandlerMapping主要是将请求和对应的处理类(Handler)对应起来。例如我们Controller可以是如下两种定义方式：</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//采用注解方式@Controller 和 @RequestMapping</span>\n<span class=\"token annotation punctuation\">@Controller</span>\n<span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"/demo\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DemoController</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@RequestMapping</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token string\">\"/demo1.action\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token annotation punctuation\">@ResponseBody</span>\n    <span class=\"token keyword\">public</span> Map <span class=\"token function\">demo1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//..省略很多代码</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//通过实现Controller方法的方式</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherController</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Controller</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> ModelAndView <span class=\"token function\">handleRequest</span><span class=\"token punctuation\">(</span>HttpServletRequest request<span class=\"token punctuation\">,</span> HttpServletResponse response<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        ModelAndView mv <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ModelAndView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mv<span class=\"token punctuation\">.</span><span class=\"token function\">addObject</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        mv<span class=\"token punctuation\">.</span><span class=\"token function\">setViewName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"result\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> mv<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token operator\">&lt;</span>bean id<span class=\"token operator\">=</span><span class=\"token string\">\"/other.action\"</span> <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"com.xzy.controller.OtherController\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>bean<span class=\"token operator\">></span></code></pre>\n<p>HandlerMapping通过不同的实现类来将url和handler映射起来。后面执行getHandler()方法时，就可以通过url找到对应的handler。并将handler+多个HandlerInterceptor拦截器封装成HandlerExecutionChain对象。</p>\n<p>具体的实现类包括：</p>\n<ul>\n<li>RequestMappingHandlerMapping，使用注解的时候,通过注解将url映射到对应的Controller上。也是我们最常用的方式。</li>\n<li>BeanNameUrlHandlerMapping，需要在spring-mvc.xml中配置BeanNameUrlHandlerMapping以及bean实现了AbstractController。通过bean将url映射的对应的Controller。</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token operator\">&lt;</span>bean <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>bean<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span>bean id<span class=\"token operator\">=</span><span class=\"token string\">\"/hello\"</span> <span class=\"token keyword\">class</span><span class=\"token operator\">=</span><span class=\"token string\">\"com.cyw.web.controller.HelloController\"</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>bean<span class=\"token operator\">></span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">HelloController</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">AbstractController</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">protected</span> ModelAndView <span class=\"token function\">handleRequestInternal</span><span class=\"token punctuation\">(</span>HttpServletRequest request<span class=\"token punctuation\">,</span> HttpServletResponse response<span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ModelAndView</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>SimpleUrlHandlerMapping，通过url直接映射。</li>\n</ul>\n<pre class=\" language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>org.springframework.web.servlet.handler.SimpleUrlHandlerMapping<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>property</span> <span class=\"token attr-name\">name</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>mappings<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>props</span><span class=\"token punctuation\">></span></span>\n       <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>prop</span> <span class=\"token attr-name\">key</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>/hello.htm<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>helloController<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>prop</span><span class=\"token punctuation\">></span></span>\n     <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>props</span><span class=\"token punctuation\">></span></span>\n   <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>property</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>bean</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>bean</span> <span class=\"token attr-name\">id</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>helloController<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">class</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>com.cyw.web.controller.HelloController<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span></code></pre>\n<h3 id=\"处理适配器-HandlerAdapter\"><a href=\"#处理适配器-HandlerAdapter\" class=\"headerlink\" title=\"处理适配器(HandlerAdapter)\"></a>处理适配器(HandlerAdapter)</h3><p>HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）。由于handler是有不同的实现方式，例如是实现Controller还是使用@Controller注解，所以需要使用适配器的方式找到不通方式的处理器。系统默认提供了处理适配器来对应不同方式的handler。</p>\n<ul>\n<li>RequestMappingHandlerAdapter.java</li>\n<li>HttpRequestHandlerAdapter.java</li>\n<li>SimpleControllerHandlerAdapter.java</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"SpringMVC初始化\"><a href=\"#SpringMVC初始化\" class=\"headerlink\" title=\"SpringMVC初始化\"></a>SpringMVC初始化</h2><h3 id=\"SpringMVC搭建流程\"><a href=\"#SpringMVC搭建流程\" class=\"headerlink\" title=\"SpringMVC搭建流程\"></a>SpringMVC搭建流程</h3><p>1.新建applicationContext.xml配置文件</p>\n<pre><code class=\"java\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;\n    &lt;context:annotation-config/&gt;\n    &lt;bean id=&quot;beanService&quot; class=&quot;com.xzy.bean.BeanService&quot;&gt;&lt;/bean&gt;\n    //...忽略其他配置\n&lt;/bean&gt;\n&lt;/beans&gt;</code></pre>","more":"<p>2.新建springmvc.xml配置文件</p>\n<pre><code class=\"java\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        http://www.springframework.org/schema/context/spring-context.xsd\n        http://www.springframework.org/schema/tx\n        http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;\n\n    &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt;\n    &lt;context:component-scan base-package=&quot;com.xzy.controller&quot;/&gt;\n    &lt;mvc:annotation-driven /&gt;\n    &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置--&gt;\n    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;\n        &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt;\n        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;/&gt;\n        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;\n    &lt;/bean&gt;\n&lt;/beans&gt;</code></pre>\n<p>3.新建web.xml</p>\n<pre><code class=\"xml\"> &lt;!—创建Root WebApplicationContext--&gt;\n    &lt;context-param&gt;  \n        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  \n        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;  \n    &lt;/context-param&gt;  \n\n    &lt;listener&gt;  \n        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;  \n    &lt;/listener&gt;\n    &lt;!—创建Servlet WebApplicationContext--&gt;\n    &lt;servlet&gt;  \n        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;  \n        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  \n        &lt;init-param&gt;  \n            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;  \n            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;  \n        &lt;/init-param&gt;  \n        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  \n    &lt;/servlet&gt;  \n    &lt;servlet-mapping&gt;  \n        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;  \n        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  \n    &lt;/servlet-mapping&gt;</code></pre>\n<h3 id=\"SpringMVC父子容器\"><a href=\"#SpringMVC父子容器\" class=\"headerlink\" title=\"SpringMVC父子容器\"></a>SpringMVC父子容器</h3><p>我们先来回顾下JavaWeb的三个组建：Listener(监听器)，Servlet，Filter。他们的作用如下 ：</p>\n<ul>\n<li>Listener，主要用来监听生命周期内的各种变化，例如监听servlet容器启动和关闭等</li>\n<li>Servlet，每个请求要经过的地方，提供了doGet方法，doPost方法</li>\n<li>Filter，过滤器，例如过滤一些不符合的请求</li>\n</ul>\n<p>在web.xml我们定义了ContextLoaderListener监听器和DispatcherServlet的Servlet。他们分别用来加载父容器和子容器</p>\n<ul>\n<li>Root WebApplicationContext：这是对J2EE三层架构中的service层、dao层进行配置，如业务bean，数据源(DataSource)等。通常情况下，配置文件的名称为applicationContext.xml。在web应用中，其一般通过ContextLoaderListener来加载</li>\n<li>Servlet WebApplicationContext：这是对J2EE三层架构中的web层进行配置，如控制器(controller)、视图解析器(view resolvers)等相关的bean。通过spring mvc中提供的DispatchServlet来加载配置，通常情况下，配置文件的名称为spring-servlet.xml</li>\n</ul>\n<p><strong>为什么要有父子容器?</strong></p>\n<p>父子容器的作用主要是划分框架边界。</p>\n<h2 id=\"ContextLoaderListener详解\"><a href=\"#ContextLoaderListener详解\" class=\"headerlink\" title=\"ContextLoaderListener详解\"></a>ContextLoaderListener详解</h2><p>ContextLoaderListener实现了ServletContextListener接口，所以它能够监听 ServletContext 对象的生命周期。在Web应用启动时会调用contextInitialized方法加载applicationContext.xml对应的Bean。也就是我们说的父容器的东西，包括三层架构中的service层、dao层进行配置，如业务bean。</p>\n<p><img src=\"/2020/01/01/springmvc/4.png\" alt=\"ContextLoaderListener继承关系\"></p>\n<h2 id=\"DispatcherServlet初始化\"><a href=\"#DispatcherServlet初始化\" class=\"headerlink\" title=\"DispatcherServlet初始化\"></a>DispatcherServlet初始化</h2><h3 id=\"httpServlet初始化init\"><a href=\"#httpServlet初始化init\" class=\"headerlink\" title=\"httpServlet初始化init\"></a>httpServlet初始化init</h3><p><img src=\"/2020/01/01/springmvc/5.png\" alt=\"DispatcherServlet继承结构\"></p>\n<p>DispatcherServlet集成HttpServlet类，所以在容器启动后会执行init()方法。主要做的事包括</p>\n<ul>\n<li><p>加载Spring-mvc.xml对应的容器</p>\n</li>\n<li><p>通过解析自定义标签&lt;mvc:annotation-driven /&gt; ，往容器中注入处理映射器(HandlerMapping)，处理映射器(HandlerAdapter)，视图控制器等。</p>\n<p>流程如下：&lt;mvc:annotation-driven/&gt; —–》 MvcNamespaceHandler#init() —–》 AnnotationDrivenBeanDefinitionParser#parse()</p>\n</li>\n<li><p>执行initStrategies初始化方法</p>\n</li>\n</ul>\n<p><img src=\"/2020/01/01/springmvc/6.png\" alt></p>\n<pre><code class=\"java\">//执行initStrategies初始化方法\nprotected void initStrategies(ApplicationContext context) {\n    //初始化文件上传\n    initMultipartResolver(context);\n    //初始化国家化\n    initLocaleResolver(context);\n    //初始化主题\n    initThemeResolver(context);\n    //初始化处理映射器\n    initHandlerMappings(context);\n    //初始化处理适配器\n    initHandlerAdapters(context);\n    //初始化请求异常\n    initHandlerExceptionResolvers(context);\n    //初始化请求视图名\n    initRequestToViewNameTranslator(context);\n    //初始化视图解析器\n    initViewResolvers(context);\n    //\n    initFlashMapManager(context);\n}</code></pre>\n<h3 id=\"映射处理器HandlerMapping\"><a href=\"#映射处理器HandlerMapping\" class=\"headerlink\" title=\"映射处理器HandlerMapping\"></a>映射处理器HandlerMapping</h3><p>SpringMVC 内部是根据 <code>HandlerMapping</code> 将 <code>Request</code> 和 <code>Controller</code> 里面的方法对应起来的。在初始化后就会将这个映射注册到mappingRegistry.java类中。后面请求过来的时才可以通过url找到对应的Controller方法进行处理。映射处理器在Web启动后，自动加载了RequestMappingHandlerMapping.java 和 BeanNameUrlHandlerMapping.java。他们分别对应不同的处理方式。</p>\n<p>接下来我们通过RequestMappingHandlerMapping.java来了解下是如何将Request和Controller映射起来的。</p>\n<p><img src=\"/2020/01/01/springmvc/7.png\" alt=\"RequestMappingHandlerMapping继承结构\"></p>\n<p>RequestMappingHandlerMapping实现了InitializingBean接口，所以在对象实例化后会执行afterPropertiesSet方法。具体链路如下：</p>\n<ol>\n<li>RequestMappingHandlerMapping#afterPropertiesSet()</li>\n<li>AbstractHandlerMethodMapping#initHandlerMethods() </li>\n<li>AbstractHandlerMethodMapping#processCandidateBean(beanName)</li>\n<li>AbstractHandlerMethodMapping#detectHandlerMethods(beanName)</li>\n<li>AbstractHandlerMethodMapping#registerMapping()</li>\n<li>AbstractHandlerMethodMapping#register(T mapping, Object handler, Method method)</li>\n</ol>\n<p><img src=\"/2020/01/01/springmvc/8.png\" alt></p>\n<p><img src=\"/2020/01/01/springmvc/9.png\" alt></p>\n<p><img src=\"/2020/01/01/springmvc/10.png\" alt></p>\n<p>所以说HandlerMapping主要是将请求和对应的处理类(Handler)对应起来。例如我们Controller可以是如下两种定义方式：</p>\n<pre><code class=\"java\">//采用注解方式@Controller 和 @RequestMapping\n@Controller\n@RequestMapping(value = &quot;/demo&quot;)\npublic class DemoController {\n    @RequestMapping(value = &quot;/demo1.action&quot;)\n    @ResponseBody\n    public Map demo1() {\n        //..省略很多代码\n    }\n}\n\n//通过实现Controller方法的方式\npublic class OtherController implements Controller {\n    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ModelAndView mv = new ModelAndView();\n        mv.addObject(&quot;hello&quot;,&quot;world&quot;);\n        mv.setViewName(&quot;result&quot;);\n        return mv;\n    }\n}\n&lt;bean id=&quot;/other.action&quot; class=&quot;com.xzy.controller.OtherController&quot;&gt;&lt;/bean&gt;</code></pre>\n<p>HandlerMapping通过不同的实现类来将url和handler映射起来。后面执行getHandler()方法时，就可以通过url找到对应的handler。并将handler+多个HandlerInterceptor拦截器封装成HandlerExecutionChain对象。</p>\n<p>具体的实现类包括：</p>\n<ul>\n<li>RequestMappingHandlerMapping，使用注解的时候,通过注解将url映射到对应的Controller上。也是我们最常用的方式。</li>\n<li>BeanNameUrlHandlerMapping，需要在spring-mvc.xml中配置BeanNameUrlHandlerMapping以及bean实现了AbstractController。通过bean将url映射的对应的Controller。</li>\n</ul>\n<pre><code class=\"java\">&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;/hello&quot; class=&quot;com.cyw.web.controller.HelloController&quot;&gt;&lt;/bean&gt;\npublic class HelloController extends AbstractController {\n    @Override\n    protected ModelAndView handleRequestInternal(HttpServletRequest request, HttpServletResponse response)\n            throws Exception {\n        return new ModelAndView(&quot;Hello&quot;);\n    }\n}</code></pre>\n<ul>\n<li>SimpleUrlHandlerMapping，通过url直接映射。</li>\n</ul>\n<pre><code class=\"xml\">&lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;\n   &lt;property name=&quot;mappings&quot;&gt;\n    &lt;props&gt;\n       &lt;prop key=&quot;/hello.htm&quot;&gt;helloController&lt;/prop&gt;\n     &lt;/props&gt;\n   &lt;/property&gt;\n&lt;/bean&gt;\n&lt;bean id=&quot;helloController&quot; class=&quot;com.cyw.web.controller.HelloController&quot; /&gt;</code></pre>\n<h3 id=\"处理适配器-HandlerAdapter\"><a href=\"#处理适配器-HandlerAdapter\" class=\"headerlink\" title=\"处理适配器(HandlerAdapter)\"></a>处理适配器(HandlerAdapter)</h3><p>HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）。由于handler是有不同的实现方式，例如是实现Controller还是使用@Controller注解，所以需要使用适配器的方式找到不通方式的处理器。系统默认提供了处理适配器来对应不同方式的handler。</p>\n<ul>\n<li>RequestMappingHandlerAdapter.java</li>\n<li>HttpRequestHandlerAdapter.java</li>\n<li>SimpleControllerHandlerAdapter.java</li>\n</ul>"},{"title":"java并发之synchronized锁升级、锁消除、锁粗化","description":"java并发之synchronized锁升级、锁消除、锁粗化","date":"2020-08-09T11:57:48.000Z","_content":"## 概念\n\nsynchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为**监视器锁**，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁（Mutex Lock）实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。\n\n**总结：synchronized修饰的代码会在编译的时候加入monitorenter,monitorexit指令，这两个指令是通过操作系统的Mutex Lock实现的，由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。**\n\n\n## synchronized使用方法\n\n|              | 锁的是什么        | 代码                                                         |\n| ------------ | ----------------- | ------------------------------------------------------------ |\n| 修饰实例方法 | 方法对应的new对象 | public synchronized void doSome(){}                          |\n| 修饰静态方法 | 静态方法对应的类  | public static synchronized void doSome(){}                   |\n| 修饰代码块1  | 方法对应的new对象 | public void doSome(){<br/>\t&nbsp;&nbsp;&nbsp;synchronized(this){<br/>\t &nbsp;&nbsp;&nbsp; ...<br/>\t&nbsp;}<br/>} |\n| 修饰代码块2  | 括号内的类        | public void doSome(){<br/>\t&nbsp;synchronized(Dog.class){<br/>\t &nbsp;&nbsp; ...<br/>\t&nbsp;}<br/>} |\n\n## synchronized原理\n\n如下代码，使用`javap -v OtherTest.class` 解析。\n\n```java\npublic class OtherTest {\n    public static void main(String[] args) {\n        Object o = new Object();\n        synchronized (o){\n            System.out.println(o);\n        }\n    }\n}\n```\n\n<!--more-->\n\n![](synchronized-up/6.png)\n\n如下图所示，synchronized的再JVM里的实现原理是<font color=red>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步</font>，主要是使用`monitorenter`和`monnitorexit`指令实现。[java并发系列-monitor机制实现](https://www.cnblogs.com/qingshan-tang/p/12698705.html)。\n\n## 什么是锁升级？\n\nJDK6以前synchronized锁实现都是重量级锁的形式，效率低下，为了提升效率进行了优化，所以出现了锁升级的过程。在JDK6之前每次调用synchronized加锁时都需要进行系统调用，系统调用会涉及到用户态和系统态的切换，此过程比较复杂且时间长导致了synchronized效率底下。所以在JDK6以后提出了锁升级的概念。\n\nsynchronized锁升级包括如下几个状态，级别从低到高分别是：<font color=red>无锁状态、偏向锁状态、轻量锁状态、重量锁状态</font>。这里需要注意的是锁升级过程中提到的偏向锁、轻量锁、重量锁都是synchronized锁的具体实现所要经历的过程，<font color=red>他们并不是单独的锁</font>。\n\n## 锁升级原理\n\n<font color=red>synchronized锁的是对象</font>。在JVM中每个对象都是有由三部分组成的 ：对象头、实例数据、数据填充。<font color=red>synchronized的锁的信息都是存储在对象头里</font>。\n\n![对象的存储布局](synchronized-up/1.jpg)\n\n我们可以看到对象头中有一个MarkWord。<font color=red>锁升级就是markWord里面标志位的变化</font>。这里我们主要看后面的锁标志位，不同的标志位代表不同的锁状态。大家发现一共有五种状态，用两位是不够的，所以01的时候在向前借一位。\n\n![不同锁状态对应的锁标志位](synchronized-up/2.png)\n\n### 偏向锁状态\n\n***偏向锁产生的原因？*** 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。\n\n![无锁->偏向锁](synchronized-up/3.png)\n\n- 当一个线程A访问同步块时，如果发现MarkWord没有存储线程ID，那判定是无锁状态，此时通过CAS方式试图将自己的线程ID存储到MarkWord中\n- 线程A判断当前MardWord存储的线程是不是自己的线程ID？如果是直接获得锁(此时MarkWord上是线程IDA)。并把标志为改成01，表示现在是偏向锁状态。\n- 执行同步体\n- 假设在期间有了线程B来争抢，由于此时MardWord上是线程A的ID，所以线程B执行CAS失败。此时线程B阻塞，并撤销偏向锁,升级为轻量级锁。\n\n所以，偏向锁是<font color=red>在同一个线程加锁的情况下，不存在多个线程竞争只需要判断线程指针是否同一个，可直接执行同步代码块</font>。适用于一个线程反复进入同步块的时候。\n\n<font color=red>如果有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁</font>（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行。\n\n### 轻量级锁\n\n当出现锁竞争时，会升级为轻量级锁。\n\n![偏向锁->轻量级锁](synchronized-up/4.png)\n\n每个线程在自己的线程栈生成LockRecord（用于存储锁记录的空间）。用CAS操作将markword设置为指向自己这个线程的LockRecord的指针，设置成功者得到锁。假设线程A通过CAS设置成功了，线程A获得锁。线程B由于CAS失败，只能<font color=red>重复自旋</font>。一般自旋次数10次，如果10次之后或者自旋线程数超过CPU核数的一半。那么此时升级为重量级锁。\n\n当然并不是都是10次，JDK6引入了<font color=red>自适应自选锁</font>。自适应意味着自旋的次数不是固定不变的，而是根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。(如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源)\n\n所以，可以总结轻量级锁出现在<font color=red>多个锁出现竞争的情况下，且多个线程之间是交替执行的</font>。这个要区别于下面说的重量级锁，假设多个线程之间是交替在执行同步块，也就是说自旋没超过条件，此时还是用轻量级锁。\n\n### 重量级锁\n\n当多个线程出现竞争，且不是那种交替的情况下。此时升级成了重量级锁。\n\n在重量级锁中将LockRecord对象替换为了monitor对象的实现。主要通过<font color=red>monitorenter</font>和<font color=red>monitorexit</font>两个指令来实现。需要经过系统调用，在并发低的情况下效率会低。\n\n通过反编译查看，如下图\n\n![](synchronized-up/5.png)\n\njava中每个对象都关联了一个监视器锁monitor，当monitor被占用时就会处于锁定状态。线程执行monitorenter 指令时尝试获取monitor的所有权。<font color=red>monitor是可重入的，有计数器，且是非公平的</font>。<font color=red>monitor 依赖操作系统的mutexLock(互斥锁)来实现的，线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能</font>。\n\n## 锁清除\n\n编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。\n\n例如StringBuffer类。我们可以看StringBuffer类是线程安全的，因为他的方法用了synchronized修饰过，但是在使用上，我们经常是直接在方法内部new一个StringBuffer类，这样的情况其实StringBuffer是没有竞争的，但是他还是用了synchronized修饰，此时编译器会进行锁清除。\n\n```java\n//方法内部创建了StringBuffer并不会出现锁竞争的情况。\npublic void addStr(String buffer){\n\tStringBuffer sb = new StringBuffer();\n\tsb.append(\"1\").append(\"2\");\n\treturn sb.toString(); \n}\n```\n\n## 锁粗化\n\n若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。\n\n## 总结\n\nJDK6对synchronized做了锁优化，使其适应了各种情况，包括<font color=red>只有一个线程多次访问同步块、多个线程交替访问同步块、多个线程争抢同步块</font>。不同的情况对应不通的锁状态，当然<font color=red>锁可以升级但不能降级</font>。也在编译器层面做了锁清除和锁粗化的优化。\n\n本文没有深入研究底层编译器原理，只是对synchronized的锁升级做了介绍，了解synchronized是怎么不通情况下对应不同的锁状态来达到优化的。\n\n也是JDK6以后synchronized性能有了提升，现在用synchronized的性能几乎和AQS什么太大区别。在原理上也是借鉴了AQS上的CAS操作。\n\n## 参考\n\n- https://mp.weixin.qq.com/s/OAO7PGdKemLbdNb6bYtq-w\n\n","source":"_posts/synchronized-up.md","raw":"---\ntitle: java并发之synchronized锁升级、锁消除、锁粗化\ntags:\n  - java并发\ncategories:  java\ndescription: java并发之synchronized锁升级、锁消除、锁粗化\ndate: 2020-08-09 19:57:48\n---\n## 概念\n\nsynchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为**监视器锁**，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁（Mutex Lock）实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。\n\n**总结：synchronized修饰的代码会在编译的时候加入monitorenter,monitorexit指令，这两个指令是通过操作系统的Mutex Lock实现的，由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。**\n\n\n## synchronized使用方法\n\n|              | 锁的是什么        | 代码                                                         |\n| ------------ | ----------------- | ------------------------------------------------------------ |\n| 修饰实例方法 | 方法对应的new对象 | public synchronized void doSome(){}                          |\n| 修饰静态方法 | 静态方法对应的类  | public static synchronized void doSome(){}                   |\n| 修饰代码块1  | 方法对应的new对象 | public void doSome(){<br/>\t&nbsp;&nbsp;&nbsp;synchronized(this){<br/>\t &nbsp;&nbsp;&nbsp; ...<br/>\t&nbsp;}<br/>} |\n| 修饰代码块2  | 括号内的类        | public void doSome(){<br/>\t&nbsp;synchronized(Dog.class){<br/>\t &nbsp;&nbsp; ...<br/>\t&nbsp;}<br/>} |\n\n## synchronized原理\n\n如下代码，使用`javap -v OtherTest.class` 解析。\n\n```java\npublic class OtherTest {\n    public static void main(String[] args) {\n        Object o = new Object();\n        synchronized (o){\n            System.out.println(o);\n        }\n    }\n}\n```\n\n<!--more-->\n\n![](synchronized-up/6.png)\n\n如下图所示，synchronized的再JVM里的实现原理是<font color=red>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步</font>，主要是使用`monitorenter`和`monnitorexit`指令实现。[java并发系列-monitor机制实现](https://www.cnblogs.com/qingshan-tang/p/12698705.html)。\n\n## 什么是锁升级？\n\nJDK6以前synchronized锁实现都是重量级锁的形式，效率低下，为了提升效率进行了优化，所以出现了锁升级的过程。在JDK6之前每次调用synchronized加锁时都需要进行系统调用，系统调用会涉及到用户态和系统态的切换，此过程比较复杂且时间长导致了synchronized效率底下。所以在JDK6以后提出了锁升级的概念。\n\nsynchronized锁升级包括如下几个状态，级别从低到高分别是：<font color=red>无锁状态、偏向锁状态、轻量锁状态、重量锁状态</font>。这里需要注意的是锁升级过程中提到的偏向锁、轻量锁、重量锁都是synchronized锁的具体实现所要经历的过程，<font color=red>他们并不是单独的锁</font>。\n\n## 锁升级原理\n\n<font color=red>synchronized锁的是对象</font>。在JVM中每个对象都是有由三部分组成的 ：对象头、实例数据、数据填充。<font color=red>synchronized的锁的信息都是存储在对象头里</font>。\n\n![对象的存储布局](synchronized-up/1.jpg)\n\n我们可以看到对象头中有一个MarkWord。<font color=red>锁升级就是markWord里面标志位的变化</font>。这里我们主要看后面的锁标志位，不同的标志位代表不同的锁状态。大家发现一共有五种状态，用两位是不够的，所以01的时候在向前借一位。\n\n![不同锁状态对应的锁标志位](synchronized-up/2.png)\n\n### 偏向锁状态\n\n***偏向锁产生的原因？*** 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。\n\n![无锁->偏向锁](synchronized-up/3.png)\n\n- 当一个线程A访问同步块时，如果发现MarkWord没有存储线程ID，那判定是无锁状态，此时通过CAS方式试图将自己的线程ID存储到MarkWord中\n- 线程A判断当前MardWord存储的线程是不是自己的线程ID？如果是直接获得锁(此时MarkWord上是线程IDA)。并把标志为改成01，表示现在是偏向锁状态。\n- 执行同步体\n- 假设在期间有了线程B来争抢，由于此时MardWord上是线程A的ID，所以线程B执行CAS失败。此时线程B阻塞，并撤销偏向锁,升级为轻量级锁。\n\n所以，偏向锁是<font color=red>在同一个线程加锁的情况下，不存在多个线程竞争只需要判断线程指针是否同一个，可直接执行同步代码块</font>。适用于一个线程反复进入同步块的时候。\n\n<font color=red>如果有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁</font>（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行。\n\n### 轻量级锁\n\n当出现锁竞争时，会升级为轻量级锁。\n\n![偏向锁->轻量级锁](synchronized-up/4.png)\n\n每个线程在自己的线程栈生成LockRecord（用于存储锁记录的空间）。用CAS操作将markword设置为指向自己这个线程的LockRecord的指针，设置成功者得到锁。假设线程A通过CAS设置成功了，线程A获得锁。线程B由于CAS失败，只能<font color=red>重复自旋</font>。一般自旋次数10次，如果10次之后或者自旋线程数超过CPU核数的一半。那么此时升级为重量级锁。\n\n当然并不是都是10次，JDK6引入了<font color=red>自适应自选锁</font>。自适应意味着自旋的次数不是固定不变的，而是根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。(如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源)\n\n所以，可以总结轻量级锁出现在<font color=red>多个锁出现竞争的情况下，且多个线程之间是交替执行的</font>。这个要区别于下面说的重量级锁，假设多个线程之间是交替在执行同步块，也就是说自旋没超过条件，此时还是用轻量级锁。\n\n### 重量级锁\n\n当多个线程出现竞争，且不是那种交替的情况下。此时升级成了重量级锁。\n\n在重量级锁中将LockRecord对象替换为了monitor对象的实现。主要通过<font color=red>monitorenter</font>和<font color=red>monitorexit</font>两个指令来实现。需要经过系统调用，在并发低的情况下效率会低。\n\n通过反编译查看，如下图\n\n![](synchronized-up/5.png)\n\njava中每个对象都关联了一个监视器锁monitor，当monitor被占用时就会处于锁定状态。线程执行monitorenter 指令时尝试获取monitor的所有权。<font color=red>monitor是可重入的，有计数器，且是非公平的</font>。<font color=red>monitor 依赖操作系统的mutexLock(互斥锁)来实现的，线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能</font>。\n\n## 锁清除\n\n编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。\n\n例如StringBuffer类。我们可以看StringBuffer类是线程安全的，因为他的方法用了synchronized修饰过，但是在使用上，我们经常是直接在方法内部new一个StringBuffer类，这样的情况其实StringBuffer是没有竞争的，但是他还是用了synchronized修饰，此时编译器会进行锁清除。\n\n```java\n//方法内部创建了StringBuffer并不会出现锁竞争的情况。\npublic void addStr(String buffer){\n\tStringBuffer sb = new StringBuffer();\n\tsb.append(\"1\").append(\"2\");\n\treturn sb.toString(); \n}\n```\n\n## 锁粗化\n\n若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。\n\n## 总结\n\nJDK6对synchronized做了锁优化，使其适应了各种情况，包括<font color=red>只有一个线程多次访问同步块、多个线程交替访问同步块、多个线程争抢同步块</font>。不同的情况对应不通的锁状态，当然<font color=red>锁可以升级但不能降级</font>。也在编译器层面做了锁清除和锁粗化的优化。\n\n本文没有深入研究底层编译器原理，只是对synchronized的锁升级做了介绍，了解synchronized是怎么不通情况下对应不同的锁状态来达到优化的。\n\n也是JDK6以后synchronized性能有了提升，现在用synchronized的性能几乎和AQS什么太大区别。在原理上也是借鉴了AQS上的CAS操作。\n\n## 参考\n\n- https://mp.weixin.qq.com/s/OAO7PGdKemLbdNb6bYtq-w\n\n","slug":"synchronized-up","published":1,"updated":"2021-04-08T00:47:07.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhw2004gqwv2f31ef3cp","content":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为<strong>监视器锁</strong>，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁（Mutex Lock）实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。</p>\n<p><strong>总结：synchronized修饰的代码会在编译的时候加入monitorenter,monitorexit指令，这两个指令是通过操作系统的Mutex Lock实现的，由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。</strong></p>\n<h2 id=\"synchronized使用方法\"><a href=\"#synchronized使用方法\" class=\"headerlink\" title=\"synchronized使用方法\"></a>synchronized使用方法</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>锁的是什么</th>\n<th>代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>修饰实例方法</td>\n<td>方法对应的new对象</td>\n<td>public synchronized void doSome(){}</td>\n</tr>\n<tr>\n<td>修饰静态方法</td>\n<td>静态方法对应的类</td>\n<td>public static synchronized void doSome(){}</td>\n</tr>\n<tr>\n<td>修饰代码块1</td>\n<td>方法对应的new对象</td>\n<td>public void doSome(){<br>    &nbsp;&nbsp;&nbsp;synchronized(this){<br>     &nbsp;&nbsp;&nbsp; …<br>    &nbsp;}<br>}</td>\n</tr>\n<tr>\n<td>修饰代码块2</td>\n<td>括号内的类</td>\n<td>public void doSome(){<br>    &nbsp;synchronized(Dog.class){<br>     &nbsp;&nbsp; …<br>    &nbsp;}<br>}</td>\n</tr>\n</tbody></table>\n<h2 id=\"synchronized原理\"><a href=\"#synchronized原理\" class=\"headerlink\" title=\"synchronized原理\"></a>synchronized原理</h2><p>如下代码，使用<code>javap -v OtherTest.class</code> 解析。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Object o <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<a id=\"more\"></a>\n\n<p><img src=\"/2020/08/09/synchronized-up/6.png\" alt></p>\n<p>如下图所示，synchronized的再JVM里的实现原理是<font color=\"red\">JVM基于进入和退出Monitor对象来实现方法同步和代码块同步</font>，主要是使用<code>monitorenter</code>和<code>monnitorexit</code>指令实现。<a href=\"https://www.cnblogs.com/qingshan-tang/p/12698705.html\" target=\"_blank\" rel=\"noopener\">java并发系列-monitor机制实现</a>。</p>\n<h2 id=\"什么是锁升级？\"><a href=\"#什么是锁升级？\" class=\"headerlink\" title=\"什么是锁升级？\"></a>什么是锁升级？</h2><p>JDK6以前synchronized锁实现都是重量级锁的形式，效率低下，为了提升效率进行了优化，所以出现了锁升级的过程。在JDK6之前每次调用synchronized加锁时都需要进行系统调用，系统调用会涉及到用户态和系统态的切换，此过程比较复杂且时间长导致了synchronized效率底下。所以在JDK6以后提出了锁升级的概念。</p>\n<p>synchronized锁升级包括如下几个状态，级别从低到高分别是：<font color=\"red\">无锁状态、偏向锁状态、轻量锁状态、重量锁状态</font>。这里需要注意的是锁升级过程中提到的偏向锁、轻量锁、重量锁都是synchronized锁的具体实现所要经历的过程，<font color=\"red\">他们并不是单独的锁</font>。</p>\n<h2 id=\"锁升级原理\"><a href=\"#锁升级原理\" class=\"headerlink\" title=\"锁升级原理\"></a>锁升级原理</h2><p><font color=\"red\">synchronized锁的是对象</font>。在JVM中每个对象都是有由三部分组成的 ：对象头、实例数据、数据填充。<font color=\"red\">synchronized的锁的信息都是存储在对象头里</font>。</p>\n<p><img src=\"/2020/08/09/synchronized-up/1.jpg\" alt=\"对象的存储布局\"></p>\n<p>我们可以看到对象头中有一个MarkWord。<font color=\"red\">锁升级就是markWord里面标志位的变化</font>。这里我们主要看后面的锁标志位，不同的标志位代表不同的锁状态。大家发现一共有五种状态，用两位是不够的，所以01的时候在向前借一位。</p>\n<p><img src=\"/2020/08/09/synchronized-up/2.png\" alt=\"不同锁状态对应的锁标志位\"></p>\n<h3 id=\"偏向锁状态\"><a href=\"#偏向锁状态\" class=\"headerlink\" title=\"偏向锁状态\"></a>偏向锁状态</h3><p><strong><em>偏向锁产生的原因？</em></strong> 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>\n<p><img src=\"/2020/08/09/synchronized-up/3.png\" alt=\"无锁-&gt;偏向锁\"></p>\n<ul>\n<li>当一个线程A访问同步块时，如果发现MarkWord没有存储线程ID，那判定是无锁状态，此时通过CAS方式试图将自己的线程ID存储到MarkWord中</li>\n<li>线程A判断当前MardWord存储的线程是不是自己的线程ID？如果是直接获得锁(此时MarkWord上是线程IDA)。并把标志为改成01，表示现在是偏向锁状态。</li>\n<li>执行同步体</li>\n<li>假设在期间有了线程B来争抢，由于此时MardWord上是线程A的ID，所以线程B执行CAS失败。此时线程B阻塞，并撤销偏向锁,升级为轻量级锁。</li>\n</ul>\n<p>所以，偏向锁是<font color=\"red\">在同一个线程加锁的情况下，不存在多个线程竞争只需要判断线程指针是否同一个，可直接执行同步代码块</font>。适用于一个线程反复进入同步块的时候。</p>\n<p><font color=\"red\">如果有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁</font>（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行。</p>\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><p>当出现锁竞争时，会升级为轻量级锁。</p>\n<p><img src=\"/2020/08/09/synchronized-up/4.png\" alt=\"偏向锁-&gt;轻量级锁\"></p>\n<p>每个线程在自己的线程栈生成LockRecord（用于存储锁记录的空间）。用CAS操作将markword设置为指向自己这个线程的LockRecord的指针，设置成功者得到锁。假设线程A通过CAS设置成功了，线程A获得锁。线程B由于CAS失败，只能<font color=\"red\">重复自旋</font>。一般自旋次数10次，如果10次之后或者自旋线程数超过CPU核数的一半。那么此时升级为重量级锁。</p>\n<p>当然并不是都是10次，JDK6引入了<font color=\"red\">自适应自选锁</font>。自适应意味着自旋的次数不是固定不变的，而是根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。(如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源)</p>\n<p>所以，可以总结轻量级锁出现在<font color=\"red\">多个锁出现竞争的情况下，且多个线程之间是交替执行的</font>。这个要区别于下面说的重量级锁，假设多个线程之间是交替在执行同步块，也就是说自旋没超过条件，此时还是用轻量级锁。</p>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><p>当多个线程出现竞争，且不是那种交替的情况下。此时升级成了重量级锁。</p>\n<p>在重量级锁中将LockRecord对象替换为了monitor对象的实现。主要通过<font color=\"red\">monitorenter</font>和<font color=\"red\">monitorexit</font>两个指令来实现。需要经过系统调用，在并发低的情况下效率会低。</p>\n<p>通过反编译查看，如下图</p>\n<p><img src=\"/2020/08/09/synchronized-up/5.png\" alt></p>\n<p>java中每个对象都关联了一个监视器锁monitor，当monitor被占用时就会处于锁定状态。线程执行monitorenter 指令时尝试获取monitor的所有权。<font color=\"red\">monitor是可重入的，有计数器，且是非公平的</font>。<font color=\"red\">monitor 依赖操作系统的mutexLock(互斥锁)来实现的，线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能</font>。</p>\n<h2 id=\"锁清除\"><a href=\"#锁清除\" class=\"headerlink\" title=\"锁清除\"></a>锁清除</h2><p>编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。</p>\n<p>例如StringBuffer类。我们可以看StringBuffer类是线程安全的，因为他的方法用了synchronized修饰过，但是在使用上，我们经常是直接在方法内部new一个StringBuffer类，这样的情况其实StringBuffer是没有竞争的，但是他还是用了synchronized修饰，此时编译器会进行锁清除。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//方法内部创建了StringBuffer并不会出现锁竞争的情况。</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">addStr</span><span class=\"token punctuation\">(</span>String buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    StringBuffer sb <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">StringBuffer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    sb<span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> sb<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h2><p>若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>JDK6对synchronized做了锁优化，使其适应了各种情况，包括<font color=\"red\">只有一个线程多次访问同步块、多个线程交替访问同步块、多个线程争抢同步块</font>。不同的情况对应不通的锁状态，当然<font color=\"red\">锁可以升级但不能降级</font>。也在编译器层面做了锁清除和锁粗化的优化。</p>\n<p>本文没有深入研究底层编译器原理，只是对synchronized的锁升级做了介绍，了解synchronized是怎么不通情况下对应不同的锁状态来达到优化的。</p>\n<p>也是JDK6以后synchronized性能有了提升，现在用synchronized的性能几乎和AQS什么太大区别。在原理上也是借鉴了AQS上的CAS操作。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/OAO7PGdKemLbdNb6bYtq-w\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/OAO7PGdKemLbdNb6bYtq-w</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>synchronized是java提供的原子性内置锁，这种内置的并且使用者看不到的锁也被称为<strong>监视器锁</strong>，使用synchronized之后，会在编译之后在同步的代码块前后加上monitorenter和monitorexit字节码指令，他依赖操作系统底层互斥锁（Mutex Lock）实现。他的作用主要就是实现原子性操作和解决共享变量的内存可见性问题。</p>\n<p><strong>总结：synchronized修饰的代码会在编译的时候加入monitorenter,monitorexit指令，这两个指令是通过操作系统的Mutex Lock实现的，由于使用Mutex Lock需要将当前线程挂起并从用户态切换到内核态来执行，这种切换的代价是非常昂贵的。</strong></p>\n<h2 id=\"synchronized使用方法\"><a href=\"#synchronized使用方法\" class=\"headerlink\" title=\"synchronized使用方法\"></a>synchronized使用方法</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>锁的是什么</th>\n<th>代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>修饰实例方法</td>\n<td>方法对应的new对象</td>\n<td>public synchronized void doSome(){}</td>\n</tr>\n<tr>\n<td>修饰静态方法</td>\n<td>静态方法对应的类</td>\n<td>public static synchronized void doSome(){}</td>\n</tr>\n<tr>\n<td>修饰代码块1</td>\n<td>方法对应的new对象</td>\n<td>public void doSome(){<br>    &nbsp;&nbsp;&nbsp;synchronized(this){<br>     &nbsp;&nbsp;&nbsp; …<br>    &nbsp;}<br>}</td>\n</tr>\n<tr>\n<td>修饰代码块2</td>\n<td>括号内的类</td>\n<td>public void doSome(){<br>    &nbsp;synchronized(Dog.class){<br>     &nbsp;&nbsp; …<br>    &nbsp;}<br>}</td>\n</tr>\n</tbody></table>\n<h2 id=\"synchronized原理\"><a href=\"#synchronized原理\" class=\"headerlink\" title=\"synchronized原理\"></a>synchronized原理</h2><p>如下代码，使用<code>javap -v OtherTest.class</code> 解析。</p>\n<pre><code class=\"java\">public class OtherTest {\n    public static void main(String[] args) {\n        Object o = new Object();\n        synchronized (o){\n            System.out.println(o);\n        }\n    }\n}</code></pre>","more":"<p><img src=\"/2020/08/09/synchronized-up/6.png\" alt></p>\n<p>如下图所示，synchronized的再JVM里的实现原理是<font color=\"red\">JVM基于进入和退出Monitor对象来实现方法同步和代码块同步</font>，主要是使用<code>monitorenter</code>和<code>monnitorexit</code>指令实现。<a href=\"https://www.cnblogs.com/qingshan-tang/p/12698705.html\" target=\"_blank\" rel=\"noopener\">java并发系列-monitor机制实现</a>。</p>\n<h2 id=\"什么是锁升级？\"><a href=\"#什么是锁升级？\" class=\"headerlink\" title=\"什么是锁升级？\"></a>什么是锁升级？</h2><p>JDK6以前synchronized锁实现都是重量级锁的形式，效率低下，为了提升效率进行了优化，所以出现了锁升级的过程。在JDK6之前每次调用synchronized加锁时都需要进行系统调用，系统调用会涉及到用户态和系统态的切换，此过程比较复杂且时间长导致了synchronized效率底下。所以在JDK6以后提出了锁升级的概念。</p>\n<p>synchronized锁升级包括如下几个状态，级别从低到高分别是：<font color=\"red\">无锁状态、偏向锁状态、轻量锁状态、重量锁状态</font>。这里需要注意的是锁升级过程中提到的偏向锁、轻量锁、重量锁都是synchronized锁的具体实现所要经历的过程，<font color=\"red\">他们并不是单独的锁</font>。</p>\n<h2 id=\"锁升级原理\"><a href=\"#锁升级原理\" class=\"headerlink\" title=\"锁升级原理\"></a>锁升级原理</h2><p><font color=\"red\">synchronized锁的是对象</font>。在JVM中每个对象都是有由三部分组成的 ：对象头、实例数据、数据填充。<font color=\"red\">synchronized的锁的信息都是存储在对象头里</font>。</p>\n<p><img src=\"/2020/08/09/synchronized-up/1.jpg\" alt=\"对象的存储布局\"></p>\n<p>我们可以看到对象头中有一个MarkWord。<font color=\"red\">锁升级就是markWord里面标志位的变化</font>。这里我们主要看后面的锁标志位，不同的标志位代表不同的锁状态。大家发现一共有五种状态，用两位是不够的，所以01的时候在向前借一位。</p>\n<p><img src=\"/2020/08/09/synchronized-up/2.png\" alt=\"不同锁状态对应的锁标志位\"></p>\n<h3 id=\"偏向锁状态\"><a href=\"#偏向锁状态\" class=\"headerlink\" title=\"偏向锁状态\"></a>偏向锁状态</h3><p><strong><em>偏向锁产生的原因？</em></strong> 大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>\n<p><img src=\"/2020/08/09/synchronized-up/3.png\" alt=\"无锁-&gt;偏向锁\"></p>\n<ul>\n<li>当一个线程A访问同步块时，如果发现MarkWord没有存储线程ID，那判定是无锁状态，此时通过CAS方式试图将自己的线程ID存储到MarkWord中</li>\n<li>线程A判断当前MardWord存储的线程是不是自己的线程ID？如果是直接获得锁(此时MarkWord上是线程IDA)。并把标志为改成01，表示现在是偏向锁状态。</li>\n<li>执行同步体</li>\n<li>假设在期间有了线程B来争抢，由于此时MardWord上是线程A的ID，所以线程B执行CAS失败。此时线程B阻塞，并撤销偏向锁,升级为轻量级锁。</li>\n</ul>\n<p>所以，偏向锁是<font color=\"red\">在同一个线程加锁的情况下，不存在多个线程竞争只需要判断线程指针是否同一个，可直接执行同步代码块</font>。适用于一个线程反复进入同步块的时候。</p>\n<p><font color=\"red\">如果有其他线程已经获得了偏向锁，这种情况说明当前锁存在竞争，需要撤销已获得偏向锁的线程，并且把它持有的锁升级为轻量级锁</font>（这个操作需要等到全局安全点，也就是没有线程在执行字节码）才能执行。</p>\n<h3 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h3><p>当出现锁竞争时，会升级为轻量级锁。</p>\n<p><img src=\"/2020/08/09/synchronized-up/4.png\" alt=\"偏向锁-&gt;轻量级锁\"></p>\n<p>每个线程在自己的线程栈生成LockRecord（用于存储锁记录的空间）。用CAS操作将markword设置为指向自己这个线程的LockRecord的指针，设置成功者得到锁。假设线程A通过CAS设置成功了，线程A获得锁。线程B由于CAS失败，只能<font color=\"red\">重复自旋</font>。一般自旋次数10次，如果10次之后或者自旋线程数超过CPU核数的一半。那么此时升级为重量级锁。</p>\n<p>当然并不是都是10次，JDK6引入了<font color=\"red\">自适应自选锁</font>。自适应意味着自旋的次数不是固定不变的，而是根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。(如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源)</p>\n<p>所以，可以总结轻量级锁出现在<font color=\"red\">多个锁出现竞争的情况下，且多个线程之间是交替执行的</font>。这个要区别于下面说的重量级锁，假设多个线程之间是交替在执行同步块，也就是说自旋没超过条件，此时还是用轻量级锁。</p>\n<h3 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h3><p>当多个线程出现竞争，且不是那种交替的情况下。此时升级成了重量级锁。</p>\n<p>在重量级锁中将LockRecord对象替换为了monitor对象的实现。主要通过<font color=\"red\">monitorenter</font>和<font color=\"red\">monitorexit</font>两个指令来实现。需要经过系统调用，在并发低的情况下效率会低。</p>\n<p>通过反编译查看，如下图</p>\n<p><img src=\"/2020/08/09/synchronized-up/5.png\" alt></p>\n<p>java中每个对象都关联了一个监视器锁monitor，当monitor被占用时就会处于锁定状态。线程执行monitorenter 指令时尝试获取monitor的所有权。<font color=\"red\">monitor是可重入的，有计数器，且是非公平的</font>。<font color=\"red\">monitor 依赖操作系统的mutexLock(互斥锁)来实现的，线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能</font>。</p>\n<h2 id=\"锁清除\"><a href=\"#锁清除\" class=\"headerlink\" title=\"锁清除\"></a>锁清除</h2><p>编译器会清除一些使用了同步，但同步块中没有涉及共享数据的锁，从而减少多余的同步。</p>\n<p>例如StringBuffer类。我们可以看StringBuffer类是线程安全的，因为他的方法用了synchronized修饰过，但是在使用上，我们经常是直接在方法内部new一个StringBuffer类，这样的情况其实StringBuffer是没有竞争的，但是他还是用了synchronized修饰，此时编译器会进行锁清除。</p>\n<pre><code class=\"java\">//方法内部创建了StringBuffer并不会出现锁竞争的情况。\npublic void addStr(String buffer){\n    StringBuffer sb = new StringBuffer();\n    sb.append(&quot;1&quot;).append(&quot;2&quot;);\n    return sb.toString(); \n}</code></pre>\n<h2 id=\"锁粗化\"><a href=\"#锁粗化\" class=\"headerlink\" title=\"锁粗化\"></a>锁粗化</h2><p>若有一系列操作，反复地对同一把锁进行上锁和解锁操作，编译器会扩大这部分代码的同步块的边界，从而只使用一次上锁和解锁操作。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>JDK6对synchronized做了锁优化，使其适应了各种情况，包括<font color=\"red\">只有一个线程多次访问同步块、多个线程交替访问同步块、多个线程争抢同步块</font>。不同的情况对应不通的锁状态，当然<font color=\"red\">锁可以升级但不能降级</font>。也在编译器层面做了锁清除和锁粗化的优化。</p>\n<p>本文没有深入研究底层编译器原理，只是对synchronized的锁升级做了介绍，了解synchronized是怎么不通情况下对应不同的锁状态来达到优化的。</p>\n<p>也是JDK6以后synchronized性能有了提升，现在用synchronized的性能几乎和AQS什么太大区别。在原理上也是借鉴了AQS上的CAS操作。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/OAO7PGdKemLbdNb6bYtq-w\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/OAO7PGdKemLbdNb6bYtq-w</a></li>\n</ul>"},{"title":"java并发之ThreadLocal详解","description":"ThreadLocal详解用法和原理","date":"2020-08-12T05:57:14.000Z","_content":"## ThreadLocal是什么\nThreadLocal是JAVA线程安全提供的一个工具类，用来存放线程的局部变量，使用他可以为每个线程创建一个副本，线程间可以独立改变自己线程的这个这个变量而不影响其他线程，相对于使用加锁会会导致线程阻塞从而影响性能，ThreadLocal采用了一种\"以空间换时间\"的方式来达到线程的安全。\n<!--more-->\n```java\nimport org.junit.Test;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class ThreadLocalTest {\n    private static final AtomicInteger nextId = new AtomicInteger(0);\n    private static final ThreadLocal<Integer> threadId = new ThreadLocal<Integer>(){\n        @Override\n        protected Integer initialValue() {\n            return nextId.getAndIncrement();\n        }\n    };\n    @Test\n    public void test1() throws InterruptedException {\n        for(int i = 0 ; i < 5 ; i++){\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"threadName=\" + Thread.currentThread().getName() + \",threadId=\" + threadId.get());\n                }\n            },\"线程\" + i).start();\n        }\n        TimeUnit.SECONDS.sleep(2);\n    }\n}\n//结果\nthreadName=Thread-1,threadId=0\nthreadName=Thread-0,threadId=1\nthreadName=Thread-2,threadId=2\nthreadName=Thread-3,threadId=3\nthreadName=Thread-4,threadId=4\n```\n\n## ThreadLocal结构\n\n为什么ThreadLocal能做到每个线程一个副本并且之间不会相互影响呢。我们来看下ThreadLocal结构。\n\n![ThreadLocalMap](threadlocal/1.png)\n\n![Thread中ThreadLocalMap](threadlocal/2.png)\n\n从代码上我们可以知道\n\n- ThreadLocal类中定义着一个ThreadLocalMap内部类，ThreadLocalMap的key为ThreadLocal对象，值为Object。\n- Thread类中维护这个一个变量threadLocals，类型是ThreadLocal.ThreadLocalMap。\n- <font color=red>我们说的副本是存在在Thread类的，而不是ThreadLocal，ThreadLocal只是可以获取到各个线程的这个副本。</font>\n\n到这里我们大概能知道为什么ThreadLocal能做到每个线程一个变量互补干扰。因为Thread类维护这一个局部变量threadLocals，这样相当于每个线程有自己的一份数据，而ThreadLocal通过获取每个线程的这个局部变量进行操作，所以是互不干扰的。\n\n![ThreadLocal与线程关系图](threadlocal/3.png)\n\n- 每一个线程都维护这一个ThreadLocalMap的数组，这个就是实现线程之间互不影响的原因，因为每个线程自己维护了一个Entry\n- ThreadLocal只是用来管理每个线程中Entry的一个工具，因为真正的ThreadLocalMap是定义在每一个线程中\n- **为啥是一个Entry数组？**因为可能你定义了多个ThreadLocal变量，每个ThreadLocal指向一个Entry,这样不同的ThreadLocal可以操作不同的数据。\n\n## ThreadLocal内存泄露问题\n\n我们先提出几个问题：\n- 为什么ThreadLocalMap中的Entry要用弱引用?\n- 引起ThreadLocal内存泄露的原因是什么，是因为弱引用吗?\n\n弱引用指的是如果一个对象没有强引用链可达，那么一般活不过下一次GC。在ThreadLocal.ThreadLocalMap中的节点Entry使用了弱引用。\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\n![ThreadLocal在JVM上结构](threadlocal/4.png)\n\n从图上可以看出，虚线指得是弱引用。我们结合本文前面的代码来进行分析。假设下图是线程2的现在的内存结构。可以看出线程2中的局部变量ThreadLocalMap中有一个Entry,key为threadId，值为2。key是弱引用，当threadId=null时，key会在下一次GC时被清除。\n![线程2内存结构](threadlocal/5.png)\n**为什么ThreadLocalMap中的Entry要用弱引用？**\n如果是强引用的话，在线程运行过程中，如果我们设置了threadId=null，按道理来说相当于ThreadLocalRef->ThreadLocal这条线断了，threadId应该被回收，但是看图我们知道key->ThreadLocal还存在着导致ThreadLocal没法被回收。所以在key->ThreadLocal使用了弱引用。当ThreadLocal没有被其他强引用时，在下一次GC时，ThreadLocal会被回收，且key = null 也被回收。\n\n**那引起内存泄露的是弱引用吗？**\n显然不是，用了弱引用避免了threadId=null时，其实内部还被引用着导致实际上没被回收。\n\n**引起内存泄露的真正原因是什么？**\n上面说到当我们threadId=null时，ThreadLocal可以被回收了。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread --> ThreadLocalMap-->Entry-->Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。<font color=red>所以说，真正造成内存泄露的原因是由于当线程的生命周期很长时，Value没法通过ThreadLocal的remove来清理，或者说没清理导致一直占用内存导致的。</font>\n\n**如何避免内存泄露?**\n通过上面分析我们知道了内存泄露的原因，在使用上我们也要注意\n- 每次用完ThreadLocal时要记得调用<font color=red>remove方法</font>清理防止内存泄露。\n- 如果线程生命周期很长，在使用完Value时要先调用<font color=red>remove方法</font>清理，防止线程生命过期过长导致Value一直占用内存。\n\n## ThreadLocal源码分析\n\n### set方法\n\n```java\npublic void set(T value) {\n    //获取当前调用set的线程\n    Thread t = Thread.currentThread();\n    //获取当前线程的threadLocals变量\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        //如果threadLocals已经初始化则直接赋值，this是当前的ThreadLocal\n        map.set(this, value);\n    else\n        //初始化t.threadLocals\n        createMap(t, value);\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\nvoid createMap(Thread t, T firstValue) {\n    //初始化ThreadLocalMap并设值。 这个ThreadLocalMap是整个ThreadLocal的重点，后面分析\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n### get方法\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        //从ThreadLocalMap中获取当前线程ThreadLocalMap下，key = 当前ThreadLocal的值\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    //初始化t.threadLocals并设值\n    return setInitialValue();\n}\n\n//初始化\nprivate T setInitialValue() {\n    //initialValue这个方法是子类需要重写的方法，用来设定初始的value\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n```\n\n### remove方法\n\n```java\npublic void remove() {\n    //调用ThreadLocalMap的remove方法删除值\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n```\n\n\n\n## ThreadLocalMap源码分析(重点)\n\nThreadLocal方法都是调用ThreadLocalMap方法实现的。ThreadLocalMap才是ThreadLocal的重点。\n\nThreadLocalMap结构上有点类似HashMap，但也有不同的地方。\n\n### 数据结构和成员变量\n\n```java\n//Entry是TheadLocalMap的节点结构，类似与HashMap中的Node\n//key是ThreadLocal且是弱引用\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    Object value;\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n//初始容量，必须为2的幂\nprivate static final int INITIAL_CAPACITY = 16;\n//Entry表，大小必须为2的幂 在ThreadLocalMap中，table其实是一个环形数组\nprivate Entry[] table;\t\n//表里entry的个数\nprivate int size = 0;\n//重新分配表大小的阈值，默认为0\nprivate int threshold;\n```\n\n<font color=red>**由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的。**</font>\n\n![Entry[]数组](threadlocal/6.png)\n\nThreadLocalMap维护了Entry环形数组，数组中元素Entry的逻辑上的key为某个ThreadLocal对象（实际上是指向该ThreadLocal对象的弱引用），value为代码中该线程往该ThreadLoacl变量实际塞入的值。\n\n### 构造方法\n\n```java\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    //初始化table,容量是16\n    table = new Entry[INITIAL_CAPACITY];\n    //到对应的数组下标\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    //赋值\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    //设置重新分配表大小的阈值\n    setThreshold(INITIAL_CAPACITY);\n}\nprivate void setThreshold(int len) {\n   threshold = len * 2 / 3;\n}\n```\n\n**ThreadLocal.threadLocalHashCode取值**\n\n```java\nprivate static AtomicInteger nextHashCode = new AtomicInteger();\n\nprivate final int threadLocalHashCode = nextHashCode();\n//定义魔数\nprivate static final int HASH_INCREMENT = 0x61c88647;\n//每次创建一个ThreadLocal时，都在nextHashCode基础上加一个HASH_INCREMENT\nprivate static int nextHashCode() {\n    return nextHashCode.getAndAdd(HASH_INCREMENT);\n}\n```\n\n可以看到，每当创建 `ThreadLocal` 实例时这个值都会`getAndAdd(0x61c88647)`作为ThreadLocal的哈希值。<font color=red>通过理论与实践，当我们用0x61c88647作为魔数累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀</font>。\n\n### set()方法\n\n```java\nprivate void set(ThreadLocal<?> key, Object value) {\n    Entry[] tab = table;\n    int len = tab.length;\n    //通过hash * (table.length - 1) 路由寻址到下标\n    int i = key.threadLocalHashCode & (len-1);\n    //nextIndex采用线性探测的方式\n    //因为ThreadLocal在hash冲突的时候是采用线性探测的方式，例如这个下标被占了，就找往后的一个位置看看有没有被占\n    for (Entry e = tab[i]; e != null ; e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        //如果下标i对应的ThreadLocal跟我传进来的ThraedLocal一致，那就做赋值操作。\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        //k == null表示原来的ThreadLocal已经被清理了，这里重新设置新的ThreadLocal到这个数组下标并会尽可能清理无效slot\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n        //继续循环表示哈希与冲突，获取下一个的数组下标继续查询\n    }\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n\nprivate static int nextIndex(int i, int len) {\n   return ((i + 1 < len) ? i + 1 : 0);\n}\n```\n\n## 参考\n\n- https://www.cnblogs.com/micrari/p/6790229.html","source":"_posts/threadlocal.md","raw":"---\ntitle: java并发之ThreadLocal详解\ntags:\n  - java并发\ncategories:  java\ndescription : ThreadLocal详解用法和原理\ndate: 2020-08-12 13:57:14\n---\n## ThreadLocal是什么\nThreadLocal是JAVA线程安全提供的一个工具类，用来存放线程的局部变量，使用他可以为每个线程创建一个副本，线程间可以独立改变自己线程的这个这个变量而不影响其他线程，相对于使用加锁会会导致线程阻塞从而影响性能，ThreadLocal采用了一种\"以空间换时间\"的方式来达到线程的安全。\n<!--more-->\n```java\nimport org.junit.Test;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class ThreadLocalTest {\n    private static final AtomicInteger nextId = new AtomicInteger(0);\n    private static final ThreadLocal<Integer> threadId = new ThreadLocal<Integer>(){\n        @Override\n        protected Integer initialValue() {\n            return nextId.getAndIncrement();\n        }\n    };\n    @Test\n    public void test1() throws InterruptedException {\n        for(int i = 0 ; i < 5 ; i++){\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(\"threadName=\" + Thread.currentThread().getName() + \",threadId=\" + threadId.get());\n                }\n            },\"线程\" + i).start();\n        }\n        TimeUnit.SECONDS.sleep(2);\n    }\n}\n//结果\nthreadName=Thread-1,threadId=0\nthreadName=Thread-0,threadId=1\nthreadName=Thread-2,threadId=2\nthreadName=Thread-3,threadId=3\nthreadName=Thread-4,threadId=4\n```\n\n## ThreadLocal结构\n\n为什么ThreadLocal能做到每个线程一个副本并且之间不会相互影响呢。我们来看下ThreadLocal结构。\n\n![ThreadLocalMap](threadlocal/1.png)\n\n![Thread中ThreadLocalMap](threadlocal/2.png)\n\n从代码上我们可以知道\n\n- ThreadLocal类中定义着一个ThreadLocalMap内部类，ThreadLocalMap的key为ThreadLocal对象，值为Object。\n- Thread类中维护这个一个变量threadLocals，类型是ThreadLocal.ThreadLocalMap。\n- <font color=red>我们说的副本是存在在Thread类的，而不是ThreadLocal，ThreadLocal只是可以获取到各个线程的这个副本。</font>\n\n到这里我们大概能知道为什么ThreadLocal能做到每个线程一个变量互补干扰。因为Thread类维护这一个局部变量threadLocals，这样相当于每个线程有自己的一份数据，而ThreadLocal通过获取每个线程的这个局部变量进行操作，所以是互不干扰的。\n\n![ThreadLocal与线程关系图](threadlocal/3.png)\n\n- 每一个线程都维护这一个ThreadLocalMap的数组，这个就是实现线程之间互不影响的原因，因为每个线程自己维护了一个Entry\n- ThreadLocal只是用来管理每个线程中Entry的一个工具，因为真正的ThreadLocalMap是定义在每一个线程中\n- **为啥是一个Entry数组？**因为可能你定义了多个ThreadLocal变量，每个ThreadLocal指向一个Entry,这样不同的ThreadLocal可以操作不同的数据。\n\n## ThreadLocal内存泄露问题\n\n我们先提出几个问题：\n- 为什么ThreadLocalMap中的Entry要用弱引用?\n- 引起ThreadLocal内存泄露的原因是什么，是因为弱引用吗?\n\n弱引用指的是如果一个对象没有强引用链可达，那么一般活不过下一次GC。在ThreadLocal.ThreadLocalMap中的节点Entry使用了弱引用。\n```java\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n```\n![ThreadLocal在JVM上结构](threadlocal/4.png)\n\n从图上可以看出，虚线指得是弱引用。我们结合本文前面的代码来进行分析。假设下图是线程2的现在的内存结构。可以看出线程2中的局部变量ThreadLocalMap中有一个Entry,key为threadId，值为2。key是弱引用，当threadId=null时，key会在下一次GC时被清除。\n![线程2内存结构](threadlocal/5.png)\n**为什么ThreadLocalMap中的Entry要用弱引用？**\n如果是强引用的话，在线程运行过程中，如果我们设置了threadId=null，按道理来说相当于ThreadLocalRef->ThreadLocal这条线断了，threadId应该被回收，但是看图我们知道key->ThreadLocal还存在着导致ThreadLocal没法被回收。所以在key->ThreadLocal使用了弱引用。当ThreadLocal没有被其他强引用时，在下一次GC时，ThreadLocal会被回收，且key = null 也被回收。\n\n**那引起内存泄露的是弱引用吗？**\n显然不是，用了弱引用避免了threadId=null时，其实内部还被引用着导致实际上没被回收。\n\n**引起内存泄露的真正原因是什么？**\n上面说到当我们threadId=null时，ThreadLocal可以被回收了。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread --> ThreadLocalMap-->Entry-->Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。<font color=red>所以说，真正造成内存泄露的原因是由于当线程的生命周期很长时，Value没法通过ThreadLocal的remove来清理，或者说没清理导致一直占用内存导致的。</font>\n\n**如何避免内存泄露?**\n通过上面分析我们知道了内存泄露的原因，在使用上我们也要注意\n- 每次用完ThreadLocal时要记得调用<font color=red>remove方法</font>清理防止内存泄露。\n- 如果线程生命周期很长，在使用完Value时要先调用<font color=red>remove方法</font>清理，防止线程生命过期过长导致Value一直占用内存。\n\n## ThreadLocal源码分析\n\n### set方法\n\n```java\npublic void set(T value) {\n    //获取当前调用set的线程\n    Thread t = Thread.currentThread();\n    //获取当前线程的threadLocals变量\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        //如果threadLocals已经初始化则直接赋值，this是当前的ThreadLocal\n        map.set(this, value);\n    else\n        //初始化t.threadLocals\n        createMap(t, value);\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\nvoid createMap(Thread t, T firstValue) {\n    //初始化ThreadLocalMap并设值。 这个ThreadLocalMap是整个ThreadLocal的重点，后面分析\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n### get方法\n\n```java\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        //从ThreadLocalMap中获取当前线程ThreadLocalMap下，key = 当前ThreadLocal的值\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(\"unchecked\")\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    //初始化t.threadLocals并设值\n    return setInitialValue();\n}\n\n//初始化\nprivate T setInitialValue() {\n    //initialValue这个方法是子类需要重写的方法，用来设定初始的value\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n```\n\n### remove方法\n\n```java\npublic void remove() {\n    //调用ThreadLocalMap的remove方法删除值\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}\n```\n\n\n\n## ThreadLocalMap源码分析(重点)\n\nThreadLocal方法都是调用ThreadLocalMap方法实现的。ThreadLocalMap才是ThreadLocal的重点。\n\nThreadLocalMap结构上有点类似HashMap，但也有不同的地方。\n\n### 数据结构和成员变量\n\n```java\n//Entry是TheadLocalMap的节点结构，类似与HashMap中的Node\n//key是ThreadLocal且是弱引用\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    Object value;\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n//初始容量，必须为2的幂\nprivate static final int INITIAL_CAPACITY = 16;\n//Entry表，大小必须为2的幂 在ThreadLocalMap中，table其实是一个环形数组\nprivate Entry[] table;\t\n//表里entry的个数\nprivate int size = 0;\n//重新分配表大小的阈值，默认为0\nprivate int threshold;\n```\n\n<font color=red>**由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的。**</font>\n\n![Entry[]数组](threadlocal/6.png)\n\nThreadLocalMap维护了Entry环形数组，数组中元素Entry的逻辑上的key为某个ThreadLocal对象（实际上是指向该ThreadLocal对象的弱引用），value为代码中该线程往该ThreadLoacl变量实际塞入的值。\n\n### 构造方法\n\n```java\nThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n    //初始化table,容量是16\n    table = new Entry[INITIAL_CAPACITY];\n    //到对应的数组下标\n    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n    //赋值\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    //设置重新分配表大小的阈值\n    setThreshold(INITIAL_CAPACITY);\n}\nprivate void setThreshold(int len) {\n   threshold = len * 2 / 3;\n}\n```\n\n**ThreadLocal.threadLocalHashCode取值**\n\n```java\nprivate static AtomicInteger nextHashCode = new AtomicInteger();\n\nprivate final int threadLocalHashCode = nextHashCode();\n//定义魔数\nprivate static final int HASH_INCREMENT = 0x61c88647;\n//每次创建一个ThreadLocal时，都在nextHashCode基础上加一个HASH_INCREMENT\nprivate static int nextHashCode() {\n    return nextHashCode.getAndAdd(HASH_INCREMENT);\n}\n```\n\n可以看到，每当创建 `ThreadLocal` 实例时这个值都会`getAndAdd(0x61c88647)`作为ThreadLocal的哈希值。<font color=red>通过理论与实践，当我们用0x61c88647作为魔数累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀</font>。\n\n### set()方法\n\n```java\nprivate void set(ThreadLocal<?> key, Object value) {\n    Entry[] tab = table;\n    int len = tab.length;\n    //通过hash * (table.length - 1) 路由寻址到下标\n    int i = key.threadLocalHashCode & (len-1);\n    //nextIndex采用线性探测的方式\n    //因为ThreadLocal在hash冲突的时候是采用线性探测的方式，例如这个下标被占了，就找往后的一个位置看看有没有被占\n    for (Entry e = tab[i]; e != null ; e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        //如果下标i对应的ThreadLocal跟我传进来的ThraedLocal一致，那就做赋值操作。\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        //k == null表示原来的ThreadLocal已经被清理了，这里重新设置新的ThreadLocal到这个数组下标并会尽可能清理无效slot\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n        //继续循环表示哈希与冲突，获取下一个的数组下标继续查询\n    }\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n\nprivate static int nextIndex(int i, int len) {\n   return ((i + 1 < len) ? i + 1 : 0);\n}\n```\n\n## 参考\n\n- https://www.cnblogs.com/micrari/p/6790229.html","slug":"threadlocal","published":1,"updated":"2021-04-08T00:47:07.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhw3004kqwv2gassfatz","content":"<h2 id=\"ThreadLocal是什么\"><a href=\"#ThreadLocal是什么\" class=\"headerlink\" title=\"ThreadLocal是什么\"></a>ThreadLocal是什么</h2><p>ThreadLocal是JAVA线程安全提供的一个工具类，用来存放线程的局部变量，使用他可以为每个线程创建一个副本，线程间可以独立改变自己线程的这个这个变量而不影响其他线程，相对于使用加锁会会导致线程阻塞从而影响性能，ThreadLocal采用了一种”以空间换时间”的方式来达到线程的安全。</p>\n<a id=\"more\"></a>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>junit<span class=\"token punctuation\">.</span>Test<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>atomic<span class=\"token punctuation\">.</span>AtomicInteger<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ThreadLocalTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> AtomicInteger nextId <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> ThreadLocal<span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span> threadId <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> Integer <span class=\"token function\">initialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> nextId<span class=\"token punctuation\">.</span><span class=\"token function\">getAndIncrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token annotation punctuation\">@Test</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token annotation punctuation\">@Override</span>\n                <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"threadName=\"</span> <span class=\"token operator\">+</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\",threadId=\"</span> <span class=\"token operator\">+</span> threadId<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"线程\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//结果</span>\nthreadName<span class=\"token operator\">=</span>Thread<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>threadId<span class=\"token operator\">=</span><span class=\"token number\">0</span>\nthreadName<span class=\"token operator\">=</span>Thread<span class=\"token operator\">-</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>threadId<span class=\"token operator\">=</span><span class=\"token number\">1</span>\nthreadName<span class=\"token operator\">=</span>Thread<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>threadId<span class=\"token operator\">=</span><span class=\"token number\">2</span>\nthreadName<span class=\"token operator\">=</span>Thread<span class=\"token operator\">-</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span>threadId<span class=\"token operator\">=</span><span class=\"token number\">3</span>\nthreadName<span class=\"token operator\">=</span>Thread<span class=\"token operator\">-</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span>threadId<span class=\"token operator\">=</span><span class=\"token number\">4</span></code></pre>\n<h2 id=\"ThreadLocal结构\"><a href=\"#ThreadLocal结构\" class=\"headerlink\" title=\"ThreadLocal结构\"></a>ThreadLocal结构</h2><p>为什么ThreadLocal能做到每个线程一个副本并且之间不会相互影响呢。我们来看下ThreadLocal结构。</p>\n<p><img src=\"/2020/08/12/threadlocal/1.png\" alt=\"ThreadLocalMap\"></p>\n<p><img src=\"/2020/08/12/threadlocal/2.png\" alt=\"Thread中ThreadLocalMap\"></p>\n<p>从代码上我们可以知道</p>\n<ul>\n<li>ThreadLocal类中定义着一个ThreadLocalMap内部类，ThreadLocalMap的key为ThreadLocal对象，值为Object。</li>\n<li>Thread类中维护这个一个变量threadLocals，类型是ThreadLocal.ThreadLocalMap。</li>\n<li><font color=\"red\">我们说的副本是存在在Thread类的，而不是ThreadLocal，ThreadLocal只是可以获取到各个线程的这个副本。</font></li>\n</ul>\n<p>到这里我们大概能知道为什么ThreadLocal能做到每个线程一个变量互补干扰。因为Thread类维护这一个局部变量threadLocals，这样相当于每个线程有自己的一份数据，而ThreadLocal通过获取每个线程的这个局部变量进行操作，所以是互不干扰的。</p>\n<p><img src=\"/2020/08/12/threadlocal/3.png\" alt=\"ThreadLocal与线程关系图\"></p>\n<ul>\n<li>每一个线程都维护这一个ThreadLocalMap的数组，这个就是实现线程之间互不影响的原因，因为每个线程自己维护了一个Entry</li>\n<li>ThreadLocal只是用来管理每个线程中Entry的一个工具，因为真正的ThreadLocalMap是定义在每一个线程中</li>\n<li><strong>为啥是一个Entry数组？</strong>因为可能你定义了多个ThreadLocal变量，每个ThreadLocal指向一个Entry,这样不同的ThreadLocal可以操作不同的数据。</li>\n</ul>\n<h2 id=\"ThreadLocal内存泄露问题\"><a href=\"#ThreadLocal内存泄露问题\" class=\"headerlink\" title=\"ThreadLocal内存泄露问题\"></a>ThreadLocal内存泄露问题</h2><p>我们先提出几个问题：</p>\n<ul>\n<li>为什么ThreadLocalMap中的Entry要用弱引用?</li>\n<li>引起ThreadLocal内存泄露的原因是什么，是因为弱引用吗?</li>\n</ul>\n<p>弱引用指的是如果一个对象没有强引用链可达，那么一般活不过下一次GC。在ThreadLocal.ThreadLocalMap中的节点Entry使用了弱引用。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Entry</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">WeakReference</span><span class=\"token operator\">&lt;</span>ThreadLocal<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">/** The value associated with this ThreadLocal. */</span>\n    Object value<span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">Entry</span><span class=\"token punctuation\">(</span>ThreadLocal<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> k<span class=\"token punctuation\">,</span> Object v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        value <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><img src=\"/2020/08/12/threadlocal/4.png\" alt=\"ThreadLocal在JVM上结构\"></p>\n<p>从图上可以看出，虚线指得是弱引用。我们结合本文前面的代码来进行分析。假设下图是线程2的现在的内存结构。可以看出线程2中的局部变量ThreadLocalMap中有一个Entry,key为threadId，值为2。key是弱引用，当threadId=null时，key会在下一次GC时被清除。<br><img src=\"/2020/08/12/threadlocal/5.png\" alt=\"线程2内存结构\"><br><strong>为什么ThreadLocalMap中的Entry要用弱引用？</strong><br>如果是强引用的话，在线程运行过程中，如果我们设置了threadId=null，按道理来说相当于ThreadLocalRef-&gt;ThreadLocal这条线断了，threadId应该被回收，但是看图我们知道key-&gt;ThreadLocal还存在着导致ThreadLocal没法被回收。所以在key-&gt;ThreadLocal使用了弱引用。当ThreadLocal没有被其他强引用时，在下一次GC时，ThreadLocal会被回收，且key = null 也被回收。</p>\n<p><strong>那引起内存泄露的是弱引用吗？</strong><br>显然不是，用了弱引用避免了threadId=null时，其实内部还被引用着导致实际上没被回收。</p>\n<p><strong>引起内存泄露的真正原因是什么？</strong><br>上面说到当我们threadId=null时，ThreadLocal可以被回收了。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread –&gt; ThreadLocalMap–&gt;Entry–&gt;Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。<font color=\"red\">所以说，真正造成内存泄露的原因是由于当线程的生命周期很长时，Value没法通过ThreadLocal的remove来清理，或者说没清理导致一直占用内存导致的。</font></p>\n<p><strong>如何避免内存泄露?</strong><br>通过上面分析我们知道了内存泄露的原因，在使用上我们也要注意</p>\n<ul>\n<li>每次用完ThreadLocal时要记得调用<font color=\"red\">remove方法</font>清理防止内存泄露。</li>\n<li>如果线程生命周期很长，在使用完Value时要先调用<font color=\"red\">remove方法</font>清理，防止线程生命过期过长导致Value一直占用内存。</li>\n</ul>\n<h2 id=\"ThreadLocal源码分析\"><a href=\"#ThreadLocal源码分析\" class=\"headerlink\" title=\"ThreadLocal源码分析\"></a>ThreadLocal源码分析</h2><h3 id=\"set方法\"><a href=\"#set方法\" class=\"headerlink\" title=\"set方法\"></a>set方法</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>T value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//获取当前调用set的线程</span>\n    Thread t <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//获取当前线程的threadLocals变量</span>\n    ThreadLocalMap map <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果threadLocals已经初始化则直接赋值，this是当前的ThreadLocal</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token comment\" spellcheck=\"true\">//初始化t.threadLocals</span>\n        <span class=\"token function\">createMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nThreadLocalMap <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>Thread t<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> t<span class=\"token punctuation\">.</span>threadLocals<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">createMap</span><span class=\"token punctuation\">(</span>Thread t<span class=\"token punctuation\">,</span> T firstValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化ThreadLocalMap并设值。 这个ThreadLocalMap是整个ThreadLocal的重点，后面分析</span>\n    t<span class=\"token punctuation\">.</span>threadLocals <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadLocalMap</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> firstValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> T <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Thread t <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ThreadLocalMap map <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//从ThreadLocalMap中获取当前线程ThreadLocalMap下，key = 当前ThreadLocal的值</span>\n        ThreadLocalMap<span class=\"token punctuation\">.</span>Entry e <span class=\"token operator\">=</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">getEntry</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@SuppressWarnings</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"unchecked\"</span><span class=\"token punctuation\">)</span>\n            T result <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>T<span class=\"token punctuation\">)</span>e<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化t.threadLocals并设值</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">setInitialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//初始化</span>\n<span class=\"token keyword\">private</span> T <span class=\"token function\">setInitialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//initialValue这个方法是子类需要重写的方法，用来设定初始的value</span>\n    T value <span class=\"token operator\">=</span> <span class=\"token function\">initialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Thread t <span class=\"token operator\">=</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ThreadLocalMap map <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>map <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        map<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span>\n        <span class=\"token function\">createMap</span><span class=\"token punctuation\">(</span>t<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"remove方法\"><a href=\"#remove方法\" class=\"headerlink\" title=\"remove方法\"></a>remove方法</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//调用ThreadLocalMap的remove方法删除值</span>\n    ThreadLocalMap m <span class=\"token operator\">=</span> <span class=\"token function\">getMap</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span>\n        m<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"ThreadLocalMap源码分析-重点\"><a href=\"#ThreadLocalMap源码分析-重点\" class=\"headerlink\" title=\"ThreadLocalMap源码分析(重点)\"></a>ThreadLocalMap源码分析(重点)</h2><p>ThreadLocal方法都是调用ThreadLocalMap方法实现的。ThreadLocalMap才是ThreadLocal的重点。</p>\n<p>ThreadLocalMap结构上有点类似HashMap，但也有不同的地方。</p>\n<h3 id=\"数据结构和成员变量\"><a href=\"#数据结构和成员变量\" class=\"headerlink\" title=\"数据结构和成员变量\"></a>数据结构和成员变量</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//Entry是TheadLocalMap的节点结构，类似与HashMap中的Node</span>\n<span class=\"token comment\" spellcheck=\"true\">//key是ThreadLocal且是弱引用</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Entry</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">WeakReference</span><span class=\"token operator\">&lt;</span>ThreadLocal<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">>></span> <span class=\"token punctuation\">{</span>\n    Object value<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Entry</span><span class=\"token punctuation\">(</span>ThreadLocal<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> k<span class=\"token punctuation\">,</span> Object v<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        value <span class=\"token operator\">=</span> v<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//初始容量，必须为2的幂</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> INITIAL_CAPACITY <span class=\"token operator\">=</span> <span class=\"token number\">16</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//Entry表，大小必须为2的幂 在ThreadLocalMap中，table其实是一个环形数组</span>\n<span class=\"token keyword\">private</span> Entry<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> table<span class=\"token punctuation\">;</span>    \n<span class=\"token comment\" spellcheck=\"true\">//表里entry的个数</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> size <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//重新分配表大小的阈值，默认为0</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">int</span> threshold<span class=\"token punctuation\">;</span></code></pre>\n<p><font color=\"red\"><strong>由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的。</strong></font></p>\n<p><img src=\"/2020/08/12/threadlocal/6.png\" alt=\"Entry[]数组\"></p>\n<p>ThreadLocalMap维护了Entry环形数组，数组中元素Entry的逻辑上的key为某个ThreadLocal对象（实际上是指向该ThreadLocal对象的弱引用），value为代码中该线程往该ThreadLoacl变量实际塞入的值。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token function\">ThreadLocalMap</span><span class=\"token punctuation\">(</span>ThreadLocal<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> firstKey<span class=\"token punctuation\">,</span> Object firstValue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//初始化table,容量是16</span>\n    table <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">[</span>INITIAL_CAPACITY<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//到对应的数组下标</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> firstKey<span class=\"token punctuation\">.</span>threadLocalHashCode <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>INITIAL_CAPACITY <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//赋值</span>\n    table<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">(</span>firstKey<span class=\"token punctuation\">,</span> firstValue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    size <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//设置重新分配表大小的阈值</span>\n    <span class=\"token function\">setThreshold</span><span class=\"token punctuation\">(</span>INITIAL_CAPACITY<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setThreshold</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   threshold <span class=\"token operator\">=</span> len <span class=\"token operator\">*</span> <span class=\"token number\">2</span> <span class=\"token operator\">/</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>ThreadLocal.threadLocalHashCode取值</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> AtomicInteger nextHashCode <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicInteger</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> threadLocalHashCode <span class=\"token operator\">=</span> <span class=\"token function\">nextHashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//定义魔数</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> HASH_INCREMENT <span class=\"token operator\">=</span> <span class=\"token number\">0x61c88647</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//每次创建一个ThreadLocal时，都在nextHashCode基础上加一个HASH_INCREMENT</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">nextHashCode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> nextHashCode<span class=\"token punctuation\">.</span><span class=\"token function\">getAndAdd</span><span class=\"token punctuation\">(</span>HASH_INCREMENT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>可以看到，每当创建 <code>ThreadLocal</code> 实例时这个值都会<code>getAndAdd(0x61c88647)</code>作为ThreadLocal的哈希值。<font color=\"red\">通过理论与实践，当我们用0x61c88647作为魔数累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀</font>。</p>\n<h3 id=\"set-方法\"><a href=\"#set-方法\" class=\"headerlink\" title=\"set()方法\"></a>set()方法</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span>ThreadLocal<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> key<span class=\"token punctuation\">,</span> Object value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    Entry<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> tab <span class=\"token operator\">=</span> table<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//通过hash * (table.length - 1) 路由寻址到下标</span>\n    <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> key<span class=\"token punctuation\">.</span>threadLocalHashCode <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>len<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//nextIndex采用线性探测的方式</span>\n    <span class=\"token comment\" spellcheck=\"true\">//因为ThreadLocal在hash冲突的时候是采用线性探测的方式，例如这个下标被占了，就找往后的一个位置看看有没有被占</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>Entry e <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> e <span class=\"token operator\">!=</span> null <span class=\"token punctuation\">;</span> e <span class=\"token operator\">=</span> tab<span class=\"token punctuation\">[</span>i <span class=\"token operator\">=</span> <span class=\"token function\">nextIndex</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> len<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ThreadLocal<span class=\"token operator\">&lt;</span><span class=\"token operator\">?</span><span class=\"token operator\">></span> k <span class=\"token operator\">=</span> e<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//如果下标i对应的ThreadLocal跟我传进来的ThraedLocal一致，那就做赋值操作。</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">==</span> key<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//k == null表示原来的ThreadLocal已经被清理了，这里重新设置新的ThreadLocal到这个数组下标并会尽可能清理无效slot</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>k <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">replaceStaleEntry</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">//继续循环表示哈希与冲突，获取下一个的数组下标继续查询</span>\n    <span class=\"token punctuation\">}</span>\n    tab<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Entry</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> sz <span class=\"token operator\">=</span> <span class=\"token operator\">++</span>size<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">cleanSomeSlots</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> sz<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> sz <span class=\"token operator\">>=</span> threshold<span class=\"token punctuation\">)</span>\n        <span class=\"token function\">rehash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">nextIndex</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> len<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">&lt;</span> len<span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> i <span class=\"token operator\">+</span> <span class=\"token number\">1</span> <span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cnblogs.com/micrari/p/6790229.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/micrari/p/6790229.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"ThreadLocal是什么\"><a href=\"#ThreadLocal是什么\" class=\"headerlink\" title=\"ThreadLocal是什么\"></a>ThreadLocal是什么</h2><p>ThreadLocal是JAVA线程安全提供的一个工具类，用来存放线程的局部变量，使用他可以为每个线程创建一个副本，线程间可以独立改变自己线程的这个这个变量而不影响其他线程，相对于使用加锁会会导致线程阻塞从而影响性能，ThreadLocal采用了一种”以空间换时间”的方式来达到线程的安全。</p>","more":"<pre><code class=\"java\">import org.junit.Test;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\npublic class ThreadLocalTest {\n    private static final AtomicInteger nextId = new AtomicInteger(0);\n    private static final ThreadLocal&lt;Integer&gt; threadId = new ThreadLocal&lt;Integer&gt;(){\n        @Override\n        protected Integer initialValue() {\n            return nextId.getAndIncrement();\n        }\n    };\n    @Test\n    public void test1() throws InterruptedException {\n        for(int i = 0 ; i &lt; 5 ; i++){\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    System.out.println(&quot;threadName=&quot; + Thread.currentThread().getName() + &quot;,threadId=&quot; + threadId.get());\n                }\n            },&quot;线程&quot; + i).start();\n        }\n        TimeUnit.SECONDS.sleep(2);\n    }\n}\n//结果\nthreadName=Thread-1,threadId=0\nthreadName=Thread-0,threadId=1\nthreadName=Thread-2,threadId=2\nthreadName=Thread-3,threadId=3\nthreadName=Thread-4,threadId=4</code></pre>\n<h2 id=\"ThreadLocal结构\"><a href=\"#ThreadLocal结构\" class=\"headerlink\" title=\"ThreadLocal结构\"></a>ThreadLocal结构</h2><p>为什么ThreadLocal能做到每个线程一个副本并且之间不会相互影响呢。我们来看下ThreadLocal结构。</p>\n<p><img src=\"/2020/08/12/threadlocal/1.png\" alt=\"ThreadLocalMap\"></p>\n<p><img src=\"/2020/08/12/threadlocal/2.png\" alt=\"Thread中ThreadLocalMap\"></p>\n<p>从代码上我们可以知道</p>\n<ul>\n<li>ThreadLocal类中定义着一个ThreadLocalMap内部类，ThreadLocalMap的key为ThreadLocal对象，值为Object。</li>\n<li>Thread类中维护这个一个变量threadLocals，类型是ThreadLocal.ThreadLocalMap。</li>\n<li><font color=\"red\">我们说的副本是存在在Thread类的，而不是ThreadLocal，ThreadLocal只是可以获取到各个线程的这个副本。</font></li>\n</ul>\n<p>到这里我们大概能知道为什么ThreadLocal能做到每个线程一个变量互补干扰。因为Thread类维护这一个局部变量threadLocals，这样相当于每个线程有自己的一份数据，而ThreadLocal通过获取每个线程的这个局部变量进行操作，所以是互不干扰的。</p>\n<p><img src=\"/2020/08/12/threadlocal/3.png\" alt=\"ThreadLocal与线程关系图\"></p>\n<ul>\n<li>每一个线程都维护这一个ThreadLocalMap的数组，这个就是实现线程之间互不影响的原因，因为每个线程自己维护了一个Entry</li>\n<li>ThreadLocal只是用来管理每个线程中Entry的一个工具，因为真正的ThreadLocalMap是定义在每一个线程中</li>\n<li><strong>为啥是一个Entry数组？</strong>因为可能你定义了多个ThreadLocal变量，每个ThreadLocal指向一个Entry,这样不同的ThreadLocal可以操作不同的数据。</li>\n</ul>\n<h2 id=\"ThreadLocal内存泄露问题\"><a href=\"#ThreadLocal内存泄露问题\" class=\"headerlink\" title=\"ThreadLocal内存泄露问题\"></a>ThreadLocal内存泄露问题</h2><p>我们先提出几个问题：</p>\n<ul>\n<li>为什么ThreadLocalMap中的Entry要用弱引用?</li>\n<li>引起ThreadLocal内存泄露的原因是什么，是因为弱引用吗?</li>\n</ul>\n<p>弱引用指的是如果一个对象没有强引用链可达，那么一般活不过下一次GC。在ThreadLocal.ThreadLocalMap中的节点Entry使用了弱引用。</p>\n<pre><code class=\"java\">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal&lt;?&gt; k, Object v) {\n        super(k);\n        value = v;\n    }\n}</code></pre>\n<p><img src=\"/2020/08/12/threadlocal/4.png\" alt=\"ThreadLocal在JVM上结构\"></p>\n<p>从图上可以看出，虚线指得是弱引用。我们结合本文前面的代码来进行分析。假设下图是线程2的现在的内存结构。可以看出线程2中的局部变量ThreadLocalMap中有一个Entry,key为threadId，值为2。key是弱引用，当threadId=null时，key会在下一次GC时被清除。<br><img src=\"/2020/08/12/threadlocal/5.png\" alt=\"线程2内存结构\"><br><strong>为什么ThreadLocalMap中的Entry要用弱引用？</strong><br>如果是强引用的话，在线程运行过程中，如果我们设置了threadId=null，按道理来说相当于ThreadLocalRef-&gt;ThreadLocal这条线断了，threadId应该被回收，但是看图我们知道key-&gt;ThreadLocal还存在着导致ThreadLocal没法被回收。所以在key-&gt;ThreadLocal使用了弱引用。当ThreadLocal没有被其他强引用时，在下一次GC时，ThreadLocal会被回收，且key = null 也被回收。</p>\n<p><strong>那引起内存泄露的是弱引用吗？</strong><br>显然不是，用了弱引用避免了threadId=null时，其实内部还被引用着导致实际上没被回收。</p>\n<p><strong>引起内存泄露的真正原因是什么？</strong><br>上面说到当我们threadId=null时，ThreadLocal可以被回收了。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread –&gt; ThreadLocalMap–&gt;Entry–&gt;Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。<font color=\"red\">所以说，真正造成内存泄露的原因是由于当线程的生命周期很长时，Value没法通过ThreadLocal的remove来清理，或者说没清理导致一直占用内存导致的。</font></p>\n<p><strong>如何避免内存泄露?</strong><br>通过上面分析我们知道了内存泄露的原因，在使用上我们也要注意</p>\n<ul>\n<li>每次用完ThreadLocal时要记得调用<font color=\"red\">remove方法</font>清理防止内存泄露。</li>\n<li>如果线程生命周期很长，在使用完Value时要先调用<font color=\"red\">remove方法</font>清理，防止线程生命过期过长导致Value一直占用内存。</li>\n</ul>\n<h2 id=\"ThreadLocal源码分析\"><a href=\"#ThreadLocal源码分析\" class=\"headerlink\" title=\"ThreadLocal源码分析\"></a>ThreadLocal源码分析</h2><h3 id=\"set方法\"><a href=\"#set方法\" class=\"headerlink\" title=\"set方法\"></a>set方法</h3><pre><code class=\"java\">public void set(T value) {\n    //获取当前调用set的线程\n    Thread t = Thread.currentThread();\n    //获取当前线程的threadLocals变量\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        //如果threadLocals已经初始化则直接赋值，this是当前的ThreadLocal\n        map.set(this, value);\n    else\n        //初始化t.threadLocals\n        createMap(t, value);\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\nvoid createMap(Thread t, T firstValue) {\n    //初始化ThreadLocalMap并设值。 这个ThreadLocalMap是整个ThreadLocal的重点，后面分析\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}</code></pre>\n<h3 id=\"get方法\"><a href=\"#get方法\" class=\"headerlink\" title=\"get方法\"></a>get方法</h3><pre><code class=\"java\">public T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        //从ThreadLocalMap中获取当前线程ThreadLocalMap下，key = 当前ThreadLocal的值\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings(&quot;unchecked&quot;)\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    //初始化t.threadLocals并设值\n    return setInitialValue();\n}\n\n//初始化\nprivate T setInitialValue() {\n    //initialValue这个方法是子类需要重写的方法，用来设定初始的value\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}</code></pre>\n<h3 id=\"remove方法\"><a href=\"#remove方法\" class=\"headerlink\" title=\"remove方法\"></a>remove方法</h3><pre><code class=\"java\">public void remove() {\n    //调用ThreadLocalMap的remove方法删除值\n    ThreadLocalMap m = getMap(Thread.currentThread());\n    if (m != null)\n        m.remove(this);\n}</code></pre>\n<h2 id=\"ThreadLocalMap源码分析-重点\"><a href=\"#ThreadLocalMap源码分析-重点\" class=\"headerlink\" title=\"ThreadLocalMap源码分析(重点)\"></a>ThreadLocalMap源码分析(重点)</h2><p>ThreadLocal方法都是调用ThreadLocalMap方法实现的。ThreadLocalMap才是ThreadLocal的重点。</p>\n<p>ThreadLocalMap结构上有点类似HashMap，但也有不同的地方。</p>\n<h3 id=\"数据结构和成员变量\"><a href=\"#数据结构和成员变量\" class=\"headerlink\" title=\"数据结构和成员变量\"></a>数据结构和成员变量</h3><pre><code class=\"java\">//Entry是TheadLocalMap的节点结构，类似与HashMap中的Node\n//key是ThreadLocal且是弱引用\nstatic class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {\n    Object value;\n    Entry(ThreadLocal&lt;?&gt; k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n//初始容量，必须为2的幂\nprivate static final int INITIAL_CAPACITY = 16;\n//Entry表，大小必须为2的幂 在ThreadLocalMap中，table其实是一个环形数组\nprivate Entry[] table;    \n//表里entry的个数\nprivate int size = 0;\n//重新分配表大小的阈值，默认为0\nprivate int threshold;</code></pre>\n<p><font color=\"red\"><strong>由于ThreadLocalMap使用线性探测法来解决散列冲突，所以实际上Entry[]数组在程序逻辑上是作为一个环形存在的。</strong></font></p>\n<p><img src=\"/2020/08/12/threadlocal/6.png\" alt=\"Entry[]数组\"></p>\n<p>ThreadLocalMap维护了Entry环形数组，数组中元素Entry的逻辑上的key为某个ThreadLocal对象（实际上是指向该ThreadLocal对象的弱引用），value为代码中该线程往该ThreadLoacl变量实际塞入的值。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><pre><code class=\"java\">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {\n    //初始化table,容量是16\n    table = new Entry[INITIAL_CAPACITY];\n    //到对应的数组下标\n    int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);\n    //赋值\n    table[i] = new Entry(firstKey, firstValue);\n    size = 1;\n    //设置重新分配表大小的阈值\n    setThreshold(INITIAL_CAPACITY);\n}\nprivate void setThreshold(int len) {\n   threshold = len * 2 / 3;\n}</code></pre>\n<p><strong>ThreadLocal.threadLocalHashCode取值</strong></p>\n<pre><code class=\"java\">private static AtomicInteger nextHashCode = new AtomicInteger();\n\nprivate final int threadLocalHashCode = nextHashCode();\n//定义魔数\nprivate static final int HASH_INCREMENT = 0x61c88647;\n//每次创建一个ThreadLocal时，都在nextHashCode基础上加一个HASH_INCREMENT\nprivate static int nextHashCode() {\n    return nextHashCode.getAndAdd(HASH_INCREMENT);\n}</code></pre>\n<p>可以看到，每当创建 <code>ThreadLocal</code> 实例时这个值都会<code>getAndAdd(0x61c88647)</code>作为ThreadLocal的哈希值。<font color=\"red\">通过理论与实践，当我们用0x61c88647作为魔数累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀</font>。</p>\n<h3 id=\"set-方法\"><a href=\"#set-方法\" class=\"headerlink\" title=\"set()方法\"></a>set()方法</h3><pre><code class=\"java\">private void set(ThreadLocal&lt;?&gt; key, Object value) {\n    Entry[] tab = table;\n    int len = tab.length;\n    //通过hash * (table.length - 1) 路由寻址到下标\n    int i = key.threadLocalHashCode &amp; (len-1);\n    //nextIndex采用线性探测的方式\n    //因为ThreadLocal在hash冲突的时候是采用线性探测的方式，例如这个下标被占了，就找往后的一个位置看看有没有被占\n    for (Entry e = tab[i]; e != null ; e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal&lt;?&gt; k = e.get();\n        //如果下标i对应的ThreadLocal跟我传进来的ThraedLocal一致，那就做赋值操作。\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        //k == null表示原来的ThreadLocal已经被清理了，这里重新设置新的ThreadLocal到这个数组下标并会尽可能清理无效slot\n        if (k == null) {\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n        //继续循环表示哈希与冲突，获取下一个的数组下标继续查询\n    }\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)\n        rehash();\n}\n\nprivate static int nextIndex(int i, int len) {\n   return ((i + 1 &lt; len) ? i + 1 : 0);\n}</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.cnblogs.com/micrari/p/6790229.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/micrari/p/6790229.html</a></li>\n</ul>"},{"title":"彻底理解class常量池、String常量池、运行时常量池","description":"彻底理解class常量池、String常量池、运行时常量池","_content":"## 前言\n经常看网上博客，发现很多文章用了常量池，class常量池，运行时常量池，字符串常量池。傻傻分不清楚他们之间有什么区别。\n## 常量池和class常量池\n其实，常量池 <font color=red>=</font> Class常量池。\n\n常量池,也叫 Class 常量池。Java文件被编译成 Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，Class常量池可以理解为是Class文件中的资源仓库。用于存放编译器生成的各种`字面量`和`符号引用`。\n\n![](sring-class/1.jpg)\n\n<!--more-->\n\n如，我们有如下代码\n\n```java\npublic class OtherTest {\n    public static void main(String[] args) {\n        int a = 11;\n        String s = \"helloWorld\";\n    }\n}\n```\n\n使用 javap -v OtherTest.class查看\n\n![编译后常量池内容](sring-class/4.png)\n\n### 字面量\n\n前面说过，运行时常量池中主要保存的是字面量和符号引用，那么到底什么字面量？说简单点，字面量就是指由字母、数字等构成的字符串或者数值。\n\n字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=11这里的a为左值，11为右值。在这个例子中11就是字面量。上面的代码中`11`和`helloWorld`都是字面量。\n\n### 符号引用\n\n符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： * 类和接口的全限定名 * 字段的名称和描述符 * 方法的名称和描述符。这也就可以印证前面的常量池中还包含一些`xzy//OtherTest`、`main`、`([Ljava/lang/String;)V`等常量的原因了。\n\n## 运行时常量池\n\n运行时常量池是<font color=red>方法区的一部分</font>。\n\n运行时常量池是当Class文件被加载到内存后，Java虚拟机会将Class常量池里的内容转移到运行时常量池里(<font color=red>运行时常量池也是每个类都有一个</font>)。\n\n运行时常量池相对于Class常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。\n\n\n\n## Class常量池和运行时常量池关系\n\n![](sring-class/2.jpg)\n\n## 字符串常量池\n字符串常量池又称为：字符串池，全局字符串池,英文也叫String Pool（<font color=red>一组指针指向Heap中的String对象的内存地址</font>）。\nJVM为了提升性能和减少内存开销,避免字符串重复创建，所以维护了一块特殊的内存空间，字符串常量池。在JDK7之前，字符串常量池是存在在永久代里，JDK7以后转移到了堆里面。\n\n**哪些字符串会放到字符串常量池中?**\n\n我们可以把我们在代码上经常用到的字符串分成下面这几类\n\n- 全局变量直接声明(包含静态变量)，例如 public static final String str = \"hello\"\n- 局部变量直接声明，String str = \"hello\"\n- 程序中动态生成的字符串，例如动态拼接，从文件读取出来的字符串等。\n- 通过new声明，String str = new String()\n\n下面，进行测试，这里有个知识点，增加JVM参数<font color=red>-XX:+PrintStringTableStatistics</font>可以打印出字符串常量池的量。\n\n```java\npublic class OtherTest {\n    public static void main(String[] args){\n    \t//空代码\n    }\n}\n//输出 空代码时候，字符串常量池中的量为1774\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1774 =     42576 bytes, avg  24.000\nNumber of literals      :      1774 =    158832 bytes, avg  89.533\nTotal footprint         :           =    681512 bytes\n```\n\n结论1：字面字符串常量会进入到字符串常量池中\n```java\npublic class OtherTest {\n    public static void main(String[] args){\n    \tString str = \"hello\";\n    }\n}\n//输出，字符串常量池的量+1，字面字符串常量会进入到字符串常量池\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1775 =     42600 bytes, avg  24.000\nNumber of literals      :      1775 =    158888 bytes, avg  89.514\nTotal footprint         :           =    681592 bytes\n```\n结论2：相同的字面字符串只在字符串常量池创建一份，另外一份复用\n```java\npublic class OtherTest {\n    public static void main(String[] args){\n    \tString str = \"hello\";\n        String str2 = \"hello\";\n    }\n}\n//输出，字符串常量池的量1775，所以说str，str2是同一个，str2没有继续创建一个新的，优化了空间\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1775 =     42600 bytes, avg  24.000\nNumber of literals      :      1775 =    158888 bytes, avg  89.514\nTotal footprint         :           =    681592 bytes\n```\n\n结论3：new字符串对象的情况，也会在字符串常量池创建一个\n\n```java\npublic class OtherTest {\n    public static void main(String[] args){\n    \tString str = new String(\"hello\");\n    }\n}\n//输出字符串常量池的量1775\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1775 =     42600 bytes, avg  24.000\nNumber of literals      :      1775 =    158888 bytes, avg  89.514\nTotal footprint         :           =    681592 bytes\n```\n\n结论4：代码中动态创建的字符串不会进入字符串常量池\n\n```java\npublic class OtherTest {\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            String temp = String.valueOf(i);\n        }\n    }\n}\n#常量池没变\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1774 =     42576 bytes, avg  24.000\nNumber of literals      :      1774 =    158832 bytes, avg  89.533\nTotal footprint         :           =    681512 bytes\n```\n\n结论5：intern方法可以主动让字符串进入常量池\n\n```java\npublic class OtherTest {\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            String temp = String.valueOf(i).intern();\n        }\n    }\n}\n//量增加了10\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1784 =     42816 bytes, avg  24.000\nNumber of literals      :      1784 =    159312 bytes, avg  89.300\nTotal footprint         :           =    682232 bytes\n```\n\n**面试常见：String str = new String(\"hello\")创建了几个对象**\n\n通过javap反编译代码，具体看创建了几个对象\n\n```java\npackage xzy;\npublic class OtherTest {\n    public static void main(String[] args) {\n        String str = new String(\"hello\");\n    }\n}\n\n//反编译输出\nCompiled from \"OtherTest.java\"\npublic class xzy.OtherTest {\n  public xzy.OtherTest();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #2                  // class java/lang/String    -- new一个String对象\n       3: dup                                                            -- 压入(dup)到栈顶\n       4: ldc           #3                  // String hello              -- 从常量池中(ldc)初始化hello字符串\n       6: invokespecial #4                  // Method java/lang/String.\"<init>\":(Ljava/lang/String;)V --构造函数初始化(invokespecial)对象\n       9: astore_1                            --将对象引用赋值(astore_1)给本地变量str     \n      10: return\n}\n```\n\n所以，在常量池没有hello的情况下，创建了两个对象和一个引用。\n\n再来看看`String str = new String(\"A\" + \"B\")` 生成了几个对象。\n\n从下图看，在字符串常量池里面只有+1。我看网上对于这个问题是说字符串常量池里面生成了A,B,AB三个，其实是只有一个，因为在编译有做了优化，会将A+B变成AB。这个只需要将class文件进行反编译就知道了。所以字符串常量池里面只有一个。\n\n![](sring-class/1.png)\n\n**疑问：在JVM中，字符串常量到底存放到哪里**\n\n例如 `String str = \"ABC\"` ，那么“ABC”这个对象是放在内存中的哪个位置，<font color=red>是字符串常量池还是堆</font>？\n\n看网上的回答 ：abc当然在字符串常量池中，只有new String(\"abc\")这个对象在堆中创建。<font color=red>abc这个东西放在常量池中，这个答案是错误的。</font>\n\n**正确答案：<font color=green>字符串abc的本体，实例应该是存在在JVM的堆中。</font>**\n\n```java\npublic static void main(String[] args){\n\tString str = \"hello\";\n}\n```\n\n1. 首先，字面量 \"hello\" 在编译期，就会被记录在class文件的class常量池。\n2. 而当 class文件被加载到内存中后，JVM就会将class常量池中的大部分内容存放到运行时常量池中，但是字符串 \"hello\" 的本体（对象）和其他所有对象一样，是会在堆中创建，再将引用放到字符串常量池。\n3. 而到了String str = \"hello\"这一步，JVM会去字符串常量池中找，如果找到了，JVM会在栈中的局部变量表中创建str变量，然后把字符串常量池中的（hello对象的）引用复制给str变量。\n\n**疑问：JVM中字符串常量池会进行垃圾回收吗？**\n\n会，假设一个字符串”everor”已经进入了常量池，但是当前系统中没有一个String对象引用常量池中的”everor”常量（即String str = new String(“everor”);），也没有其他地方引用了这个字面量（即String str = “everor”;），如果这个时候发生了内存回收，而且有必要的话，这个”everor”常量就会被系统清理出常量池。\n\n## 总结\n\n- String常量池在每个JVM中只有一份，存放的是字符串常量的引用值。\n- class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。\n- 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。\n\n## 参考\n\n- [详解JVM常量池、Class、运行时、字符串常量池](https://www.baidu.com/link?url=M8Bauh76JXr4VhFH84A2uK6PkDyDwfw8Si1uo23sMjKXirLJF2BHwIutcY1jMBx03jjyPJmnrXVVMyt_N_-jP_&wd=&eqid=b278744100018add000000065f237350)\n- [字符串常量池、class常量池和运行时常量池](https://blog.csdn.net/u011552955/article/details/100079685)\n- https://segmentfault.com/a/1190000017952075?utm_source=tag-newest\n- https://mrdear.cn/posts/java-string-pool.html","source":"_posts/sring-class.md","raw":"---\ntitle: 彻底理解class常量池、String常量池、运行时常量池\ntags:\n  - jvm\ncategories:  java\ndescription: 彻底理解class常量池、String常量池、运行时常量池\n---\n## 前言\n经常看网上博客，发现很多文章用了常量池，class常量池，运行时常量池，字符串常量池。傻傻分不清楚他们之间有什么区别。\n## 常量池和class常量池\n其实，常量池 <font color=red>=</font> Class常量池。\n\n常量池,也叫 Class 常量池。Java文件被编译成 Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，Class常量池可以理解为是Class文件中的资源仓库。用于存放编译器生成的各种`字面量`和`符号引用`。\n\n![](sring-class/1.jpg)\n\n<!--more-->\n\n如，我们有如下代码\n\n```java\npublic class OtherTest {\n    public static void main(String[] args) {\n        int a = 11;\n        String s = \"helloWorld\";\n    }\n}\n```\n\n使用 javap -v OtherTest.class查看\n\n![编译后常量池内容](sring-class/4.png)\n\n### 字面量\n\n前面说过，运行时常量池中主要保存的是字面量和符号引用，那么到底什么字面量？说简单点，字面量就是指由字母、数字等构成的字符串或者数值。\n\n字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=11这里的a为左值，11为右值。在这个例子中11就是字面量。上面的代码中`11`和`helloWorld`都是字面量。\n\n### 符号引用\n\n符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： * 类和接口的全限定名 * 字段的名称和描述符 * 方法的名称和描述符。这也就可以印证前面的常量池中还包含一些`xzy//OtherTest`、`main`、`([Ljava/lang/String;)V`等常量的原因了。\n\n## 运行时常量池\n\n运行时常量池是<font color=red>方法区的一部分</font>。\n\n运行时常量池是当Class文件被加载到内存后，Java虚拟机会将Class常量池里的内容转移到运行时常量池里(<font color=red>运行时常量池也是每个类都有一个</font>)。\n\n运行时常量池相对于Class常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。\n\n\n\n## Class常量池和运行时常量池关系\n\n![](sring-class/2.jpg)\n\n## 字符串常量池\n字符串常量池又称为：字符串池，全局字符串池,英文也叫String Pool（<font color=red>一组指针指向Heap中的String对象的内存地址</font>）。\nJVM为了提升性能和减少内存开销,避免字符串重复创建，所以维护了一块特殊的内存空间，字符串常量池。在JDK7之前，字符串常量池是存在在永久代里，JDK7以后转移到了堆里面。\n\n**哪些字符串会放到字符串常量池中?**\n\n我们可以把我们在代码上经常用到的字符串分成下面这几类\n\n- 全局变量直接声明(包含静态变量)，例如 public static final String str = \"hello\"\n- 局部变量直接声明，String str = \"hello\"\n- 程序中动态生成的字符串，例如动态拼接，从文件读取出来的字符串等。\n- 通过new声明，String str = new String()\n\n下面，进行测试，这里有个知识点，增加JVM参数<font color=red>-XX:+PrintStringTableStatistics</font>可以打印出字符串常量池的量。\n\n```java\npublic class OtherTest {\n    public static void main(String[] args){\n    \t//空代码\n    }\n}\n//输出 空代码时候，字符串常量池中的量为1774\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1774 =     42576 bytes, avg  24.000\nNumber of literals      :      1774 =    158832 bytes, avg  89.533\nTotal footprint         :           =    681512 bytes\n```\n\n结论1：字面字符串常量会进入到字符串常量池中\n```java\npublic class OtherTest {\n    public static void main(String[] args){\n    \tString str = \"hello\";\n    }\n}\n//输出，字符串常量池的量+1，字面字符串常量会进入到字符串常量池\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1775 =     42600 bytes, avg  24.000\nNumber of literals      :      1775 =    158888 bytes, avg  89.514\nTotal footprint         :           =    681592 bytes\n```\n结论2：相同的字面字符串只在字符串常量池创建一份，另外一份复用\n```java\npublic class OtherTest {\n    public static void main(String[] args){\n    \tString str = \"hello\";\n        String str2 = \"hello\";\n    }\n}\n//输出，字符串常量池的量1775，所以说str，str2是同一个，str2没有继续创建一个新的，优化了空间\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1775 =     42600 bytes, avg  24.000\nNumber of literals      :      1775 =    158888 bytes, avg  89.514\nTotal footprint         :           =    681592 bytes\n```\n\n结论3：new字符串对象的情况，也会在字符串常量池创建一个\n\n```java\npublic class OtherTest {\n    public static void main(String[] args){\n    \tString str = new String(\"hello\");\n    }\n}\n//输出字符串常量池的量1775\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1775 =     42600 bytes, avg  24.000\nNumber of literals      :      1775 =    158888 bytes, avg  89.514\nTotal footprint         :           =    681592 bytes\n```\n\n结论4：代码中动态创建的字符串不会进入字符串常量池\n\n```java\npublic class OtherTest {\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            String temp = String.valueOf(i);\n        }\n    }\n}\n#常量池没变\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1774 =     42576 bytes, avg  24.000\nNumber of literals      :      1774 =    158832 bytes, avg  89.533\nTotal footprint         :           =    681512 bytes\n```\n\n结论5：intern方法可以主动让字符串进入常量池\n\n```java\npublic class OtherTest {\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            String temp = String.valueOf(i).intern();\n        }\n    }\n}\n//量增加了10\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1784 =     42816 bytes, avg  24.000\nNumber of literals      :      1784 =    159312 bytes, avg  89.300\nTotal footprint         :           =    682232 bytes\n```\n\n**面试常见：String str = new String(\"hello\")创建了几个对象**\n\n通过javap反编译代码，具体看创建了几个对象\n\n```java\npackage xzy;\npublic class OtherTest {\n    public static void main(String[] args) {\n        String str = new String(\"hello\");\n    }\n}\n\n//反编译输出\nCompiled from \"OtherTest.java\"\npublic class xzy.OtherTest {\n  public xzy.OtherTest();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #2                  // class java/lang/String    -- new一个String对象\n       3: dup                                                            -- 压入(dup)到栈顶\n       4: ldc           #3                  // String hello              -- 从常量池中(ldc)初始化hello字符串\n       6: invokespecial #4                  // Method java/lang/String.\"<init>\":(Ljava/lang/String;)V --构造函数初始化(invokespecial)对象\n       9: astore_1                            --将对象引用赋值(astore_1)给本地变量str     \n      10: return\n}\n```\n\n所以，在常量池没有hello的情况下，创建了两个对象和一个引用。\n\n再来看看`String str = new String(\"A\" + \"B\")` 生成了几个对象。\n\n从下图看，在字符串常量池里面只有+1。我看网上对于这个问题是说字符串常量池里面生成了A,B,AB三个，其实是只有一个，因为在编译有做了优化，会将A+B变成AB。这个只需要将class文件进行反编译就知道了。所以字符串常量池里面只有一个。\n\n![](sring-class/1.png)\n\n**疑问：在JVM中，字符串常量到底存放到哪里**\n\n例如 `String str = \"ABC\"` ，那么“ABC”这个对象是放在内存中的哪个位置，<font color=red>是字符串常量池还是堆</font>？\n\n看网上的回答 ：abc当然在字符串常量池中，只有new String(\"abc\")这个对象在堆中创建。<font color=red>abc这个东西放在常量池中，这个答案是错误的。</font>\n\n**正确答案：<font color=green>字符串abc的本体，实例应该是存在在JVM的堆中。</font>**\n\n```java\npublic static void main(String[] args){\n\tString str = \"hello\";\n}\n```\n\n1. 首先，字面量 \"hello\" 在编译期，就会被记录在class文件的class常量池。\n2. 而当 class文件被加载到内存中后，JVM就会将class常量池中的大部分内容存放到运行时常量池中，但是字符串 \"hello\" 的本体（对象）和其他所有对象一样，是会在堆中创建，再将引用放到字符串常量池。\n3. 而到了String str = \"hello\"这一步，JVM会去字符串常量池中找，如果找到了，JVM会在栈中的局部变量表中创建str变量，然后把字符串常量池中的（hello对象的）引用复制给str变量。\n\n**疑问：JVM中字符串常量池会进行垃圾回收吗？**\n\n会，假设一个字符串”everor”已经进入了常量池，但是当前系统中没有一个String对象引用常量池中的”everor”常量（即String str = new String(“everor”);），也没有其他地方引用了这个字面量（即String str = “everor”;），如果这个时候发生了内存回收，而且有必要的话，这个”everor”常量就会被系统清理出常量池。\n\n## 总结\n\n- String常量池在每个JVM中只有一份，存放的是字符串常量的引用值。\n- class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。\n- 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。\n\n## 参考\n\n- [详解JVM常量池、Class、运行时、字符串常量池](https://www.baidu.com/link?url=M8Bauh76JXr4VhFH84A2uK6PkDyDwfw8Si1uo23sMjKXirLJF2BHwIutcY1jMBx03jjyPJmnrXVVMyt_N_-jP_&wd=&eqid=b278744100018add000000065f237350)\n- [字符串常量池、class常量池和运行时常量池](https://blog.csdn.net/u011552955/article/details/100079685)\n- https://segmentfault.com/a/1190000017952075?utm_source=tag-newest\n- https://mrdear.cn/posts/java-string-pool.html","slug":"sring-class","published":1,"date":"2021-04-08T00:47:07.077Z","updated":"2021-04-08T00:47:07.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhw5004nqwv2d3r39hb6","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>经常看网上博客，发现很多文章用了常量池，class常量池，运行时常量池，字符串常量池。傻傻分不清楚他们之间有什么区别。</p>\n<h2 id=\"常量池和class常量池\"><a href=\"#常量池和class常量池\" class=\"headerlink\" title=\"常量池和class常量池\"></a>常量池和class常量池</h2><p>其实，常量池 <font color=\"red\">=</font> Class常量池。</p>\n<p>常量池,也叫 Class 常量池。Java文件被编译成 Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，Class常量池可以理解为是Class文件中的资源仓库。用于存放编译器生成的各种<code>字面量</code>和<code>符号引用</code>。</p>\n<p><img src=\"/2021/04/08/sring-class/1.jpg\" alt></p>\n<a id=\"more\"></a>\n\n<p>如，我们有如下代码</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">11</span><span class=\"token punctuation\">;</span>\n        String s <span class=\"token operator\">=</span> <span class=\"token string\">\"helloWorld\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>使用 javap -v OtherTest.class查看</p>\n<p><img src=\"/2021/04/08/sring-class/4.png\" alt=\"编译后常量池内容\"></p>\n<h3 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h3><p>前面说过，运行时常量池中主要保存的是字面量和符号引用，那么到底什么字面量？说简单点，字面量就是指由字母、数字等构成的字符串或者数值。</p>\n<p>字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=11这里的a为左值，11为右值。在这个例子中11就是字面量。上面的代码中<code>11</code>和<code>helloWorld</code>都是字面量。</p>\n<h3 id=\"符号引用\"><a href=\"#符号引用\" class=\"headerlink\" title=\"符号引用\"></a>符号引用</h3><p>符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： * 类和接口的全限定名 * 字段的名称和描述符 * 方法的名称和描述符。这也就可以印证前面的常量池中还包含一些<code>xzy//OtherTest</code>、<code>main</code>、<code>([Ljava/lang/String;)V</code>等常量的原因了。</p>\n<h2 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h2><p>运行时常量池是<font color=\"red\">方法区的一部分</font>。</p>\n<p>运行时常量池是当Class文件被加载到内存后，Java虚拟机会将Class常量池里的内容转移到运行时常量池里(<font color=\"red\">运行时常量池也是每个类都有一个</font>)。</p>\n<p>运行时常量池相对于Class常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。</p>\n<h2 id=\"Class常量池和运行时常量池关系\"><a href=\"#Class常量池和运行时常量池关系\" class=\"headerlink\" title=\"Class常量池和运行时常量池关系\"></a>Class常量池和运行时常量池关系</h2><p><img src=\"/2021/04/08/sring-class/2.jpg\" alt></p>\n<h2 id=\"字符串常量池\"><a href=\"#字符串常量池\" class=\"headerlink\" title=\"字符串常量池\"></a>字符串常量池</h2><p>字符串常量池又称为：字符串池，全局字符串池,英文也叫String Pool（<font color=\"red\">一组指针指向Heap中的String对象的内存地址</font>）。<br>JVM为了提升性能和减少内存开销,避免字符串重复创建，所以维护了一块特殊的内存空间，字符串常量池。在JDK7之前，字符串常量池是存在在永久代里，JDK7以后转移到了堆里面。</p>\n<p><strong>哪些字符串会放到字符串常量池中?</strong></p>\n<p>我们可以把我们在代码上经常用到的字符串分成下面这几类</p>\n<ul>\n<li>全局变量直接声明(包含静态变量)，例如 public static final String str = “hello”</li>\n<li>局部变量直接声明，String str = “hello”</li>\n<li>程序中动态生成的字符串，例如动态拼接，从文件读取出来的字符串等。</li>\n<li>通过new声明，String str = new String()</li>\n</ul>\n<p>下面，进行测试，这里有个知识点，增加JVM参数<font color=\"red\">-XX:+PrintStringTableStatistics</font>可以打印出字符串常量池的量。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">//空代码</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//输出 空代码时候，字符串常量池中的量为1774</span>\nStringTable statistics<span class=\"token operator\">:</span>\nNumber of buckets       <span class=\"token operator\">:</span>     <span class=\"token number\">60013</span> <span class=\"token operator\">=</span>    <span class=\"token number\">480104</span> bytes<span class=\"token punctuation\">,</span> avg   <span class=\"token number\">8.000</span>\nNumber of entries       <span class=\"token operator\">:</span>      <span class=\"token number\">1774</span> <span class=\"token operator\">=</span>     <span class=\"token number\">42576</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">24.000</span>\nNumber of literals      <span class=\"token operator\">:</span>      <span class=\"token number\">1774</span> <span class=\"token operator\">=</span>    <span class=\"token number\">158832</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">89.533</span>\nTotal footprint         <span class=\"token operator\">:</span>           <span class=\"token operator\">=</span>    <span class=\"token number\">681512</span> bytes</code></pre>\n<p>结论1：字面字符串常量会进入到字符串常量池中</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        String str <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//输出，字符串常量池的量+1，字面字符串常量会进入到字符串常量池</span>\nStringTable statistics<span class=\"token operator\">:</span>\nNumber of buckets       <span class=\"token operator\">:</span>     <span class=\"token number\">60013</span> <span class=\"token operator\">=</span>    <span class=\"token number\">480104</span> bytes<span class=\"token punctuation\">,</span> avg   <span class=\"token number\">8.000</span>\nNumber of entries       <span class=\"token operator\">:</span>      <span class=\"token number\">1775</span> <span class=\"token operator\">=</span>     <span class=\"token number\">42600</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">24.000</span>\nNumber of literals      <span class=\"token operator\">:</span>      <span class=\"token number\">1775</span> <span class=\"token operator\">=</span>    <span class=\"token number\">158888</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">89.514</span>\nTotal footprint         <span class=\"token operator\">:</span>           <span class=\"token operator\">=</span>    <span class=\"token number\">681592</span> bytes</code></pre>\n<p>结论2：相同的字面字符串只在字符串常量池创建一份，另外一份复用</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        String str <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n        String str2 <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//输出，字符串常量池的量1775，所以说str，str2是同一个，str2没有继续创建一个新的，优化了空间</span>\nStringTable statistics<span class=\"token operator\">:</span>\nNumber of buckets       <span class=\"token operator\">:</span>     <span class=\"token number\">60013</span> <span class=\"token operator\">=</span>    <span class=\"token number\">480104</span> bytes<span class=\"token punctuation\">,</span> avg   <span class=\"token number\">8.000</span>\nNumber of entries       <span class=\"token operator\">:</span>      <span class=\"token number\">1775</span> <span class=\"token operator\">=</span>     <span class=\"token number\">42600</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">24.000</span>\nNumber of literals      <span class=\"token operator\">:</span>      <span class=\"token number\">1775</span> <span class=\"token operator\">=</span>    <span class=\"token number\">158888</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">89.514</span>\nTotal footprint         <span class=\"token operator\">:</span>           <span class=\"token operator\">=</span>    <span class=\"token number\">681592</span> bytes</code></pre>\n<p>结论3：new字符串对象的情况，也会在字符串常量池创建一个</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        String str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//输出字符串常量池的量1775</span>\nStringTable statistics<span class=\"token operator\">:</span>\nNumber of buckets       <span class=\"token operator\">:</span>     <span class=\"token number\">60013</span> <span class=\"token operator\">=</span>    <span class=\"token number\">480104</span> bytes<span class=\"token punctuation\">,</span> avg   <span class=\"token number\">8.000</span>\nNumber of entries       <span class=\"token operator\">:</span>      <span class=\"token number\">1775</span> <span class=\"token operator\">=</span>     <span class=\"token number\">42600</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">24.000</span>\nNumber of literals      <span class=\"token operator\">:</span>      <span class=\"token number\">1775</span> <span class=\"token operator\">=</span>    <span class=\"token number\">158888</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">89.514</span>\nTotal footprint         <span class=\"token operator\">:</span>           <span class=\"token operator\">=</span>    <span class=\"token number\">681592</span> bytes</code></pre>\n<p>结论4：代码中动态创建的字符串不会进入字符串常量池</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            String temp <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n#常量池没变\nStringTable statistics<span class=\"token operator\">:</span>\nNumber of buckets       <span class=\"token operator\">:</span>     <span class=\"token number\">60013</span> <span class=\"token operator\">=</span>    <span class=\"token number\">480104</span> bytes<span class=\"token punctuation\">,</span> avg   <span class=\"token number\">8.000</span>\nNumber of entries       <span class=\"token operator\">:</span>      <span class=\"token number\">1774</span> <span class=\"token operator\">=</span>     <span class=\"token number\">42576</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">24.000</span>\nNumber of literals      <span class=\"token operator\">:</span>      <span class=\"token number\">1774</span> <span class=\"token operator\">=</span>    <span class=\"token number\">158832</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">89.533</span>\nTotal footprint         <span class=\"token operator\">:</span>           <span class=\"token operator\">=</span>    <span class=\"token number\">681512</span> bytes</code></pre>\n<p>结论5：intern方法可以主动让字符串进入常量池</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            String temp <span class=\"token operator\">=</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intern</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//量增加了10</span>\nStringTable statistics<span class=\"token operator\">:</span>\nNumber of buckets       <span class=\"token operator\">:</span>     <span class=\"token number\">60013</span> <span class=\"token operator\">=</span>    <span class=\"token number\">480104</span> bytes<span class=\"token punctuation\">,</span> avg   <span class=\"token number\">8.000</span>\nNumber of entries       <span class=\"token operator\">:</span>      <span class=\"token number\">1784</span> <span class=\"token operator\">=</span>     <span class=\"token number\">42816</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">24.000</span>\nNumber of literals      <span class=\"token operator\">:</span>      <span class=\"token number\">1784</span> <span class=\"token operator\">=</span>    <span class=\"token number\">159312</span> bytes<span class=\"token punctuation\">,</span> avg  <span class=\"token number\">89.300</span>\nTotal footprint         <span class=\"token operator\">:</span>           <span class=\"token operator\">=</span>    <span class=\"token number\">682232</span> bytes</code></pre>\n<p><strong>面试常见：String str = new String(“hello”)创建了几个对象</strong></p>\n<p>通过javap反编译代码，具体看创建了几个对象</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> xzy<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OtherTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        String str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//反编译输出</span>\nCompiled from <span class=\"token string\">\"OtherTest.java\"</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">xzy<span class=\"token punctuation\">.</span>OtherTest</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> xzy<span class=\"token punctuation\">.</span><span class=\"token function\">OtherTest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Code<span class=\"token operator\">:</span>\n       <span class=\"token number\">0</span><span class=\"token operator\">:</span> aload_0\n       <span class=\"token number\">1</span><span class=\"token operator\">:</span> invokespecial #<span class=\"token number\">1</span>                  <span class=\"token comment\" spellcheck=\"true\">// Method java/lang/Object.\"&lt;init>\":()V</span>\n       <span class=\"token number\">4</span><span class=\"token operator\">:</span> <span class=\"token keyword\">return</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>java<span class=\"token punctuation\">.</span>lang<span class=\"token punctuation\">.</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Code<span class=\"token operator\">:</span>\n       <span class=\"token number\">0</span><span class=\"token operator\">:</span> <span class=\"token keyword\">new</span>           #<span class=\"token number\">2</span>                  <span class=\"token comment\" spellcheck=\"true\">// class java/lang/String    -- new一个String对象</span>\n       <span class=\"token number\">3</span><span class=\"token operator\">:</span> dup                                                            <span class=\"token operator\">--</span> 压入<span class=\"token punctuation\">(</span>dup<span class=\"token punctuation\">)</span>到栈顶\n       <span class=\"token number\">4</span><span class=\"token operator\">:</span> ldc           #<span class=\"token number\">3</span>                  <span class=\"token comment\" spellcheck=\"true\">// String hello              -- 从常量池中(ldc)初始化hello字符串</span>\n       <span class=\"token number\">6</span><span class=\"token operator\">:</span> invokespecial #<span class=\"token number\">4</span>                  <span class=\"token comment\" spellcheck=\"true\">// Method java/lang/String.\"&lt;init>\":(Ljava/lang/String;)V --构造函数初始化(invokespecial)对象</span>\n       <span class=\"token number\">9</span><span class=\"token operator\">:</span> astore_1                            <span class=\"token operator\">--</span>将对象引用赋值<span class=\"token punctuation\">(</span>astore_1<span class=\"token punctuation\">)</span>给本地变量str     \n      <span class=\"token number\">10</span><span class=\"token operator\">:</span> <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>所以，在常量池没有hello的情况下，创建了两个对象和一个引用。</p>\n<p>再来看看<code>String str = new String(&quot;A&quot; + &quot;B&quot;)</code> 生成了几个对象。</p>\n<p>从下图看，在字符串常量池里面只有+1。我看网上对于这个问题是说字符串常量池里面生成了A,B,AB三个，其实是只有一个，因为在编译有做了优化，会将A+B变成AB。这个只需要将class文件进行反编译就知道了。所以字符串常量池里面只有一个。</p>\n<p><img src=\"/2021/04/08/sring-class/1.png\" alt></p>\n<p><strong>疑问：在JVM中，字符串常量到底存放到哪里</strong></p>\n<p>例如 <code>String str = &quot;ABC&quot;</code> ，那么“ABC”这个对象是放在内存中的哪个位置，<font color=\"red\">是字符串常量池还是堆</font>？</p>\n<p>看网上的回答 ：abc当然在字符串常量池中，只有new String(“abc”)这个对象在堆中创建。<font color=\"red\">abc这个东西放在常量池中，这个答案是错误的。</font></p>\n<p><strong>正确答案：<font color=\"green\">字符串abc的本体，实例应该是存在在JVM的堆中。</font></strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    String str <span class=\"token operator\">=</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ol>\n<li>首先，字面量 “hello” 在编译期，就会被记录在class文件的class常量池。</li>\n<li>而当 class文件被加载到内存中后，JVM就会将class常量池中的大部分内容存放到运行时常量池中，但是字符串 “hello” 的本体（对象）和其他所有对象一样，是会在堆中创建，再将引用放到字符串常量池。</li>\n<li>而到了String str = “hello”这一步，JVM会去字符串常量池中找，如果找到了，JVM会在栈中的局部变量表中创建str变量，然后把字符串常量池中的（hello对象的）引用复制给str变量。</li>\n</ol>\n<p><strong>疑问：JVM中字符串常量池会进行垃圾回收吗？</strong></p>\n<p>会，假设一个字符串”everor”已经进入了常量池，但是当前系统中没有一个String对象引用常量池中的”everor”常量（即String str = new String(“everor”);），也没有其他地方引用了这个字面量（即String str = “everor”;），如果这个时候发生了内存回收，而且有必要的话，这个”everor”常量就会被系统清理出常量池。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>String常量池在每个JVM中只有一份，存放的是字符串常量的引用值。</li>\n<li>class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</li>\n<li>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.baidu.com/link?url=M8Bauh76JXr4VhFH84A2uK6PkDyDwfw8Si1uo23sMjKXirLJF2BHwIutcY1jMBx03jjyPJmnrXVVMyt_N_-jP_&wd=&eqid=b278744100018add000000065f237350\" target=\"_blank\" rel=\"noopener\">详解JVM常量池、Class、运行时、字符串常量池</a></li>\n<li><a href=\"https://blog.csdn.net/u011552955/article/details/100079685\" target=\"_blank\" rel=\"noopener\">字符串常量池、class常量池和运行时常量池</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017952075?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017952075?utm_source=tag-newest</a></li>\n<li><a href=\"https://mrdear.cn/posts/java-string-pool.html\" target=\"_blank\" rel=\"noopener\">https://mrdear.cn/posts/java-string-pool.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>经常看网上博客，发现很多文章用了常量池，class常量池，运行时常量池，字符串常量池。傻傻分不清楚他们之间有什么区别。</p>\n<h2 id=\"常量池和class常量池\"><a href=\"#常量池和class常量池\" class=\"headerlink\" title=\"常量池和class常量池\"></a>常量池和class常量池</h2><p>其实，常量池 <font color=\"red\">=</font> Class常量池。</p>\n<p>常量池,也叫 Class 常量池。Java文件被编译成 Class文件，Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是常量池，Class常量池可以理解为是Class文件中的资源仓库。用于存放编译器生成的各种<code>字面量</code>和<code>符号引用</code>。</p>\n<p><img src=\"/2021/04/08/sring-class/1.jpg\" alt></p>","more":"<p>如，我们有如下代码</p>\n<pre><code class=\"java\">public class OtherTest {\n    public static void main(String[] args) {\n        int a = 11;\n        String s = &quot;helloWorld&quot;;\n    }\n}</code></pre>\n<p>使用 javap -v OtherTest.class查看</p>\n<p><img src=\"/2021/04/08/sring-class/4.png\" alt=\"编译后常量池内容\"></p>\n<h3 id=\"字面量\"><a href=\"#字面量\" class=\"headerlink\" title=\"字面量\"></a>字面量</h3><p>前面说过，运行时常量池中主要保存的是字面量和符号引用，那么到底什么字面量？说简单点，字面量就是指由字母、数字等构成的字符串或者数值。</p>\n<p>字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=11这里的a为左值，11为右值。在这个例子中11就是字面量。上面的代码中<code>11</code>和<code>helloWorld</code>都是字面量。</p>\n<h3 id=\"符号引用\"><a href=\"#符号引用\" class=\"headerlink\" title=\"符号引用\"></a>符号引用</h3><p>符号引用是编译原理中的概念，是相对于直接引用来说的。主要包括了以下三类常量： * 类和接口的全限定名 * 字段的名称和描述符 * 方法的名称和描述符。这也就可以印证前面的常量池中还包含一些<code>xzy//OtherTest</code>、<code>main</code>、<code>([Ljava/lang/String;)V</code>等常量的原因了。</p>\n<h2 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h2><p>运行时常量池是<font color=\"red\">方法区的一部分</font>。</p>\n<p>运行时常量池是当Class文件被加载到内存后，Java虚拟机会将Class常量池里的内容转移到运行时常量池里(<font color=\"red\">运行时常量池也是每个类都有一个</font>)。</p>\n<p>运行时常量池相对于Class常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中。</p>\n<h2 id=\"Class常量池和运行时常量池关系\"><a href=\"#Class常量池和运行时常量池关系\" class=\"headerlink\" title=\"Class常量池和运行时常量池关系\"></a>Class常量池和运行时常量池关系</h2><p><img src=\"/2021/04/08/sring-class/2.jpg\" alt></p>\n<h2 id=\"字符串常量池\"><a href=\"#字符串常量池\" class=\"headerlink\" title=\"字符串常量池\"></a>字符串常量池</h2><p>字符串常量池又称为：字符串池，全局字符串池,英文也叫String Pool（<font color=\"red\">一组指针指向Heap中的String对象的内存地址</font>）。<br>JVM为了提升性能和减少内存开销,避免字符串重复创建，所以维护了一块特殊的内存空间，字符串常量池。在JDK7之前，字符串常量池是存在在永久代里，JDK7以后转移到了堆里面。</p>\n<p><strong>哪些字符串会放到字符串常量池中?</strong></p>\n<p>我们可以把我们在代码上经常用到的字符串分成下面这几类</p>\n<ul>\n<li>全局变量直接声明(包含静态变量)，例如 public static final String str = “hello”</li>\n<li>局部变量直接声明，String str = “hello”</li>\n<li>程序中动态生成的字符串，例如动态拼接，从文件读取出来的字符串等。</li>\n<li>通过new声明，String str = new String()</li>\n</ul>\n<p>下面，进行测试，这里有个知识点，增加JVM参数<font color=\"red\">-XX:+PrintStringTableStatistics</font>可以打印出字符串常量池的量。</p>\n<pre><code class=\"java\">public class OtherTest {\n    public static void main(String[] args){\n        //空代码\n    }\n}\n//输出 空代码时候，字符串常量池中的量为1774\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1774 =     42576 bytes, avg  24.000\nNumber of literals      :      1774 =    158832 bytes, avg  89.533\nTotal footprint         :           =    681512 bytes</code></pre>\n<p>结论1：字面字符串常量会进入到字符串常量池中</p>\n<pre><code class=\"java\">public class OtherTest {\n    public static void main(String[] args){\n        String str = &quot;hello&quot;;\n    }\n}\n//输出，字符串常量池的量+1，字面字符串常量会进入到字符串常量池\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1775 =     42600 bytes, avg  24.000\nNumber of literals      :      1775 =    158888 bytes, avg  89.514\nTotal footprint         :           =    681592 bytes</code></pre>\n<p>结论2：相同的字面字符串只在字符串常量池创建一份，另外一份复用</p>\n<pre><code class=\"java\">public class OtherTest {\n    public static void main(String[] args){\n        String str = &quot;hello&quot;;\n        String str2 = &quot;hello&quot;;\n    }\n}\n//输出，字符串常量池的量1775，所以说str，str2是同一个，str2没有继续创建一个新的，优化了空间\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1775 =     42600 bytes, avg  24.000\nNumber of literals      :      1775 =    158888 bytes, avg  89.514\nTotal footprint         :           =    681592 bytes</code></pre>\n<p>结论3：new字符串对象的情况，也会在字符串常量池创建一个</p>\n<pre><code class=\"java\">public class OtherTest {\n    public static void main(String[] args){\n        String str = new String(&quot;hello&quot;);\n    }\n}\n//输出字符串常量池的量1775\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1775 =     42600 bytes, avg  24.000\nNumber of literals      :      1775 =    158888 bytes, avg  89.514\nTotal footprint         :           =    681592 bytes</code></pre>\n<p>结论4：代码中动态创建的字符串不会进入字符串常量池</p>\n<pre><code class=\"java\">public class OtherTest {\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 10; i++) {\n            String temp = String.valueOf(i);\n        }\n    }\n}\n#常量池没变\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1774 =     42576 bytes, avg  24.000\nNumber of literals      :      1774 =    158832 bytes, avg  89.533\nTotal footprint         :           =    681512 bytes</code></pre>\n<p>结论5：intern方法可以主动让字符串进入常量池</p>\n<pre><code class=\"java\">public class OtherTest {\n    public static void main(String[] args) {\n        for (int i = 0; i &lt; 10; i++) {\n            String temp = String.valueOf(i).intern();\n        }\n    }\n}\n//量增加了10\nStringTable statistics:\nNumber of buckets       :     60013 =    480104 bytes, avg   8.000\nNumber of entries       :      1784 =     42816 bytes, avg  24.000\nNumber of literals      :      1784 =    159312 bytes, avg  89.300\nTotal footprint         :           =    682232 bytes</code></pre>\n<p><strong>面试常见：String str = new String(“hello”)创建了几个对象</strong></p>\n<p>通过javap反编译代码，具体看创建了几个对象</p>\n<pre><code class=\"java\">package xzy;\npublic class OtherTest {\n    public static void main(String[] args) {\n        String str = new String(&quot;hello&quot;);\n    }\n}\n\n//反编译输出\nCompiled from &quot;OtherTest.java&quot;\npublic class xzy.OtherTest {\n  public xzy.OtherTest();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #2                  // class java/lang/String    -- new一个String对象\n       3: dup                                                            -- 压入(dup)到栈顶\n       4: ldc           #3                  // String hello              -- 从常量池中(ldc)初始化hello字符串\n       6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V --构造函数初始化(invokespecial)对象\n       9: astore_1                            --将对象引用赋值(astore_1)给本地变量str     \n      10: return\n}</code></pre>\n<p>所以，在常量池没有hello的情况下，创建了两个对象和一个引用。</p>\n<p>再来看看<code>String str = new String(&quot;A&quot; + &quot;B&quot;)</code> 生成了几个对象。</p>\n<p>从下图看，在字符串常量池里面只有+1。我看网上对于这个问题是说字符串常量池里面生成了A,B,AB三个，其实是只有一个，因为在编译有做了优化，会将A+B变成AB。这个只需要将class文件进行反编译就知道了。所以字符串常量池里面只有一个。</p>\n<p><img src=\"/2021/04/08/sring-class/1.png\" alt></p>\n<p><strong>疑问：在JVM中，字符串常量到底存放到哪里</strong></p>\n<p>例如 <code>String str = &quot;ABC&quot;</code> ，那么“ABC”这个对象是放在内存中的哪个位置，<font color=\"red\">是字符串常量池还是堆</font>？</p>\n<p>看网上的回答 ：abc当然在字符串常量池中，只有new String(“abc”)这个对象在堆中创建。<font color=\"red\">abc这个东西放在常量池中，这个答案是错误的。</font></p>\n<p><strong>正确答案：<font color=\"green\">字符串abc的本体，实例应该是存在在JVM的堆中。</font></strong></p>\n<pre><code class=\"java\">public static void main(String[] args){\n    String str = &quot;hello&quot;;\n}</code></pre>\n<ol>\n<li>首先，字面量 “hello” 在编译期，就会被记录在class文件的class常量池。</li>\n<li>而当 class文件被加载到内存中后，JVM就会将class常量池中的大部分内容存放到运行时常量池中，但是字符串 “hello” 的本体（对象）和其他所有对象一样，是会在堆中创建，再将引用放到字符串常量池。</li>\n<li>而到了String str = “hello”这一步，JVM会去字符串常量池中找，如果找到了，JVM会在栈中的局部变量表中创建str变量，然后把字符串常量池中的（hello对象的）引用复制给str变量。</li>\n</ol>\n<p><strong>疑问：JVM中字符串常量池会进行垃圾回收吗？</strong></p>\n<p>会，假设一个字符串”everor”已经进入了常量池，但是当前系统中没有一个String对象引用常量池中的”everor”常量（即String str = new String(“everor”);），也没有其他地方引用了这个字面量（即String str = “everor”;），如果这个时候发生了内存回收，而且有必要的话，这个”everor”常量就会被系统清理出常量池。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>String常量池在每个JVM中只有一份，存放的是字符串常量的引用值。</li>\n<li>class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量的符号引用。</li>\n<li>运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.baidu.com/link?url=M8Bauh76JXr4VhFH84A2uK6PkDyDwfw8Si1uo23sMjKXirLJF2BHwIutcY1jMBx03jjyPJmnrXVVMyt_N_-jP_&wd=&eqid=b278744100018add000000065f237350\" target=\"_blank\" rel=\"noopener\">详解JVM常量池、Class、运行时、字符串常量池</a></li>\n<li><a href=\"https://blog.csdn.net/u011552955/article/details/100079685\" target=\"_blank\" rel=\"noopener\">字符串常量池、class常量池和运行时常量池</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017952075?utm_source=tag-newest\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017952075?utm_source=tag-newest</a></li>\n<li><a href=\"https://mrdear.cn/posts/java-string-pool.html\" target=\"_blank\" rel=\"noopener\">https://mrdear.cn/posts/java-string-pool.html</a></li>\n</ul>"},{"title":"java并发之volatile","description":"详解volatile用法和原理","date":"2019-07-18T02:00:00.000Z","_content":"\n## Java内存模型(jmm)\n看个例子\n```java\npublic class VolatileExample extends Thread{\n    //设置类静态变量,各线程访问这同一共享变量\n    private  static boolean flag = false;\n    //无限循环,等待flag变为true时才跳出循环\n   public void run() {\n       while (!flag){\n       };\n       System.out.println(\"停止了\");\n   }\n\n    public static void main(String[] args) throws Exception {\n        new VolatileExample().start();\n        //sleep的目的是等待线程启动完毕,也就是说进入run的无限循环体了\n        Thread.sleep(100);\n        flag = true;\n    }\n}\n```\n上面程序运行后发现当主线程设置flag为true时子线程的循环并没有停掉。\n<!--more-->\n***为什么会出现上面的问题?***\n\nJava内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。如下图\n\n![](volatile/1.png)\n所以根据JMM规范，每个线程都有单独的一个工作内存，当主线程在运行时会将flag变量的值拷贝一份到自己的工作内存中，当改变了flag时但是还没来得及写入主存中，主线程转去做其他事情，那么子线程就不知道flag的更改，所以就一直循环下去。\n\n## volatile详解\n### 线程中的三个概念\n- 原子性，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行\n- 可见性，保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值\n- 有序性，在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行\n\n### volatile作用\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n- 保证了不同线程对volatile修饰的变量进行改动时，其他线程能马上可见\n- 禁止执行重排序\n\n### volatile如何保证可见性\n\nhttps://www.toutiao.com/a6845877313154843148/\n\n出现上面的问题的原因在硬件层面是由于**CPU缓存的问题**。\n\n![](volatile/2.png)\n\n由于内存的速度跟不上CPU的运算，所以加入了CPU高速缓存，也也就导致了上面的问题，CPU0修改的数据存在CPU0上的缓存没来得及写入到主内存，导致CPU1没获取到最近的修改值。CPU为了解决这个问题使用了**MESI缓存一致性协议**（<font color=red>多个CPU从主内存读取同一个数据到各自的高速缓存，当其中某个CPU修改了缓存里的数据，该数据会马上同步回主内存，其他CPU通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效</font>）。\n\n**缓存一致性原理协议(MESI)**\n\n当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时， 发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读。\n\nvolatile关键字在汇编底层的<font color=red>实现原理就是通过汇编lock前缀指令</font>。\n\n```\n0x000000010d3f3203: lock addl $0x0,(%rsp)     ;*putstatic flag\n; - com.java.study.VolatileStudy::lambda$main$1@9 (line 31)\n```\n\nlock前缀指令实现了如下效果：\n\n- 它会强制将对缓存的修改操作立即写入主存。\n- 如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n综合上面两条实现原则，我们了解到：**如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的**。\n\n### volatile支持有序性\nvolatile有序性的保证就是通过禁止指令重排序来实现的。在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。原理还是通过<font color=red>lock前缀指令</font>。lock前缀指令实际上相当于一个内存屏障。除了上面的两个效果，还有下面这个效果。\n\n- 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。\n\n虚拟机在执行程序时，如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序，举个例子。\n\n```\nx = 1; //1\ny = 10; //2\nc = x + y; //3\n```\n由于1,2操作上前后没有关系，虚拟机可以对他们进行重排序，但是3一定在1,2后面，这是根据happens-before规则来规范的。\n**那volatile修饰的变量保证有序性是如何理解呢?**\n```\nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3 flag为volatile变量\nx = 4;         //语句4\ny = -1;       //语句5\n```\n由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的\n\n那么禁止指令重排序又是如何实现的呢？答案是<font color=red>加内存屏障</font>。JMM为volatile加内存屏障有以下4种情况：JMM为volatile加内存屏障有以下4种情况：\n\n- 在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。\n- 在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。\n- 在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。\n- 在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。\n\n### volatile不支持原子性\n\n首先先理解原子性的概念，它指的是在**一个操作过程**中是不可分的，要嘛成功要嘛失败,主体是一个操作过程，一个操作过程是可以包含多条操作语句的，但是volatile只能保证一个变量的可见性和有序性。\n```\nvolatile int i = 5;\ntemp = i + 1;\ni = temp;\n```\n假设上面一个操作过程，i使用了volatile修饰，首先AB两个线程同时读取到i = 5，然后A执行了 temp = i + 1; 此时temp变成了6，此时 i 还是5。这时B也执行到了temp = i + 1; temp = 6,然后AB接下去执行i = temp时，就有一个线程少+1了。\n\n## java中使用volatile\n### 单例模式的双检查锁\n```\npublic class SingletonFour {\n    private static volatile SingletonFour singletonFour;\n    private SingletonFour(){}\n    private static SingletonFour getSingleton(){\n        if(singletonFour == null){  //第一次检查\n            synchronized (SingletonFour.class){\n                if(singletonFour == null) //第二次检查\n                    singletonFour = new SingletonFour(); // 标注1\n            }\n        }\n        return singletonFour;\n    }\n}\n```\n这里单例使用了volatile修饰，原因是标注1会发生重排序另一个并发执行的线程B就有可能在判断instance不为null时，线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。\n这里说一下 new Object()背后的指令 例如 Cache cache=new Cache()\n```\n\t// 创建 Cache 对象实例，分配内存\n       0: new           #5                  // class com/query/Cache\n       // 复制栈顶地址，并再将其压入栈顶\n       3: dup\n\t// 调用构造器方法，初始化 Cache 对象\n       4: invokespecial #6                  // Method \"<init>\":()V\n\t// 存入局部方法变量表\n       7: astore_1\n```\n从字节码可以看到创建一个对象实例，可以分为三步\n1. 分配对象内存\n2. 调用构造器方法，执行初始化\n3. 将对象引用赋值给变量\n\n虚拟机实际运行时，以上指令可能发生重排序。以上代码 2,3 可能发生重排序，但是并不会重排序 1 的顺序。也就是说 1 这个指令都需要先执行，因为 2,3 指令需要依托 1 指令执行结果。所以用volatile修饰可以保证有序性\n### happens-before\n\nhappens-before是JMM用来阐述多线程直接有序性的原则。在Java内存模型中，如果要确保有序性可以靠volatile和synchronized来实现，但是如果所有的有序性都仅仅依靠这两个关键字来完成，那么有一些操作将会变得很繁琐，但是我们在编写Java代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生(happens-before)”的原则。\n\nhappends-before可以翻译成：<font color=red>前一个操作的结果可以被后续的操作获取。</font>讲白点就是前面一个操作把变量a赋值成1，那后面一个操作肯定能知道a已经变成1了。\n\n1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；\n2. 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；\n3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；\n4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；\n5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；\n6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；\n7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；\n8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n### as-if-serial语义\n\nas-if-serial语义的意思是：**不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。**as-if-serial语义使程序员不必担心单线程中重排序的问题干扰他们。\n\n## 总结\n\n- volatile保证了线程的可见性，当一个线程对其修饰volatile的变量进行改动时会立即被更新到主存\n- volatile保证了线程的有序性\n- volatile不能保证原子性\n\n## 参考\n\n- https://www.toutiao.com/a6839502799437300237/","source":"_posts/volatile.md","raw":"---\ntitle: java并发之volatile\ntags:\n  - java并发\ncategories:  java\ndescription : 详解volatile用法和原理\ndate: 2019-07-18 10:00:00\n---\n\n## Java内存模型(jmm)\n看个例子\n```java\npublic class VolatileExample extends Thread{\n    //设置类静态变量,各线程访问这同一共享变量\n    private  static boolean flag = false;\n    //无限循环,等待flag变为true时才跳出循环\n   public void run() {\n       while (!flag){\n       };\n       System.out.println(\"停止了\");\n   }\n\n    public static void main(String[] args) throws Exception {\n        new VolatileExample().start();\n        //sleep的目的是等待线程启动完毕,也就是说进入run的无限循环体了\n        Thread.sleep(100);\n        flag = true;\n    }\n}\n```\n上面程序运行后发现当主线程设置flag为true时子线程的循环并没有停掉。\n<!--more-->\n***为什么会出现上面的问题?***\n\nJava内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。如下图\n\n![](volatile/1.png)\n所以根据JMM规范，每个线程都有单独的一个工作内存，当主线程在运行时会将flag变量的值拷贝一份到自己的工作内存中，当改变了flag时但是还没来得及写入主存中，主线程转去做其他事情，那么子线程就不知道flag的更改，所以就一直循环下去。\n\n## volatile详解\n### 线程中的三个概念\n- 原子性，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行\n- 可见性，保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值\n- 有序性，在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行\n\n### volatile作用\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n- 保证了不同线程对volatile修饰的变量进行改动时，其他线程能马上可见\n- 禁止执行重排序\n\n### volatile如何保证可见性\n\nhttps://www.toutiao.com/a6845877313154843148/\n\n出现上面的问题的原因在硬件层面是由于**CPU缓存的问题**。\n\n![](volatile/2.png)\n\n由于内存的速度跟不上CPU的运算，所以加入了CPU高速缓存，也也就导致了上面的问题，CPU0修改的数据存在CPU0上的缓存没来得及写入到主内存，导致CPU1没获取到最近的修改值。CPU为了解决这个问题使用了**MESI缓存一致性协议**（<font color=red>多个CPU从主内存读取同一个数据到各自的高速缓存，当其中某个CPU修改了缓存里的数据，该数据会马上同步回主内存，其他CPU通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效</font>）。\n\n**缓存一致性原理协议(MESI)**\n\n当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时， 发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读。\n\nvolatile关键字在汇编底层的<font color=red>实现原理就是通过汇编lock前缀指令</font>。\n\n```\n0x000000010d3f3203: lock addl $0x0,(%rsp)     ;*putstatic flag\n; - com.java.study.VolatileStudy::lambda$main$1@9 (line 31)\n```\n\nlock前缀指令实现了如下效果：\n\n- 它会强制将对缓存的修改操作立即写入主存。\n- 如果是写操作，它会导致其他CPU中对应的缓存行无效。\n\n综合上面两条实现原则，我们了解到：**如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的**。\n\n### volatile支持有序性\nvolatile有序性的保证就是通过禁止指令重排序来实现的。在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。原理还是通过<font color=red>lock前缀指令</font>。lock前缀指令实际上相当于一个内存屏障。除了上面的两个效果，还有下面这个效果。\n\n- 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。\n\n虚拟机在执行程序时，如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序，举个例子。\n\n```\nx = 1; //1\ny = 10; //2\nc = x + y; //3\n```\n由于1,2操作上前后没有关系，虚拟机可以对他们进行重排序，但是3一定在1,2后面，这是根据happens-before规则来规范的。\n**那volatile修饰的变量保证有序性是如何理解呢?**\n```\nx = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3 flag为volatile变量\nx = 4;         //语句4\ny = -1;       //语句5\n```\n由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的\n\n那么禁止指令重排序又是如何实现的呢？答案是<font color=red>加内存屏障</font>。JMM为volatile加内存屏障有以下4种情况：JMM为volatile加内存屏障有以下4种情况：\n\n- 在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。\n- 在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。\n- 在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。\n- 在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。\n\n### volatile不支持原子性\n\n首先先理解原子性的概念，它指的是在**一个操作过程**中是不可分的，要嘛成功要嘛失败,主体是一个操作过程，一个操作过程是可以包含多条操作语句的，但是volatile只能保证一个变量的可见性和有序性。\n```\nvolatile int i = 5;\ntemp = i + 1;\ni = temp;\n```\n假设上面一个操作过程，i使用了volatile修饰，首先AB两个线程同时读取到i = 5，然后A执行了 temp = i + 1; 此时temp变成了6，此时 i 还是5。这时B也执行到了temp = i + 1; temp = 6,然后AB接下去执行i = temp时，就有一个线程少+1了。\n\n## java中使用volatile\n### 单例模式的双检查锁\n```\npublic class SingletonFour {\n    private static volatile SingletonFour singletonFour;\n    private SingletonFour(){}\n    private static SingletonFour getSingleton(){\n        if(singletonFour == null){  //第一次检查\n            synchronized (SingletonFour.class){\n                if(singletonFour == null) //第二次检查\n                    singletonFour = new SingletonFour(); // 标注1\n            }\n        }\n        return singletonFour;\n    }\n}\n```\n这里单例使用了volatile修饰，原因是标注1会发生重排序另一个并发执行的线程B就有可能在判断instance不为null时，线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。\n这里说一下 new Object()背后的指令 例如 Cache cache=new Cache()\n```\n\t// 创建 Cache 对象实例，分配内存\n       0: new           #5                  // class com/query/Cache\n       // 复制栈顶地址，并再将其压入栈顶\n       3: dup\n\t// 调用构造器方法，初始化 Cache 对象\n       4: invokespecial #6                  // Method \"<init>\":()V\n\t// 存入局部方法变量表\n       7: astore_1\n```\n从字节码可以看到创建一个对象实例，可以分为三步\n1. 分配对象内存\n2. 调用构造器方法，执行初始化\n3. 将对象引用赋值给变量\n\n虚拟机实际运行时，以上指令可能发生重排序。以上代码 2,3 可能发生重排序，但是并不会重排序 1 的顺序。也就是说 1 这个指令都需要先执行，因为 2,3 指令需要依托 1 指令执行结果。所以用volatile修饰可以保证有序性\n### happens-before\n\nhappens-before是JMM用来阐述多线程直接有序性的原则。在Java内存模型中，如果要确保有序性可以靠volatile和synchronized来实现，但是如果所有的有序性都仅仅依靠这两个关键字来完成，那么有一些操作将会变得很繁琐，但是我们在编写Java代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生(happens-before)”的原则。\n\nhappends-before可以翻译成：<font color=red>前一个操作的结果可以被后续的操作获取。</font>讲白点就是前面一个操作把变量a赋值成1，那后面一个操作肯定能知道a已经变成1了。\n\n1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；\n2. 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；\n3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；\n4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；\n5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；\n6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；\n7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；\n8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始\n\n### as-if-serial语义\n\nas-if-serial语义的意思是：**不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。**as-if-serial语义使程序员不必担心单线程中重排序的问题干扰他们。\n\n## 总结\n\n- volatile保证了线程的可见性，当一个线程对其修饰volatile的变量进行改动时会立即被更新到主存\n- volatile保证了线程的有序性\n- volatile不能保证原子性\n\n## 参考\n\n- https://www.toutiao.com/a6839502799437300237/","slug":"volatile","published":1,"updated":"2021-04-08T00:47:07.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhw6004sqwv2c40o9wr5","content":"<h2 id=\"Java内存模型-jmm\"><a href=\"#Java内存模型-jmm\" class=\"headerlink\" title=\"Java内存模型(jmm)\"></a>Java内存模型(jmm)</h2><p>看个例子</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">VolatileExample</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//设置类静态变量,各线程访问这同一共享变量</span>\n    <span class=\"token keyword\">private</span>  <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> flag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">//无限循环,等待flag变为true时才跳出循环</span>\n   <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n       <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n       System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"停止了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">VolatileExample</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//sleep的目的是等待线程启动完毕,也就是说进入run的无限循环体了</span>\n        Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上面程序运行后发现当主线程设置flag为true时子线程的循环并没有停掉。</p>\n<a id=\"more\"></a>\n<p><strong><em>为什么会出现上面的问题?</em></strong></p>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。如下图</p>\n<p><img src=\"/2019/07/18/volatile/1.png\" alt><br>所以根据JMM规范，每个线程都有单独的一个工作内存，当主线程在运行时会将flag变量的值拷贝一份到自己的工作内存中，当改变了flag时但是还没来得及写入主存中，主线程转去做其他事情，那么子线程就不知道flag的更改，所以就一直循环下去。</p>\n<h2 id=\"volatile详解\"><a href=\"#volatile详解\" class=\"headerlink\" title=\"volatile详解\"></a>volatile详解</h2><h3 id=\"线程中的三个概念\"><a href=\"#线程中的三个概念\" class=\"headerlink\" title=\"线程中的三个概念\"></a>线程中的三个概念</h3><ul>\n<li>原子性，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行</li>\n<li>可见性，保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值</li>\n<li>有序性，在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行</li>\n</ul>\n<h3 id=\"volatile作用\"><a href=\"#volatile作用\" class=\"headerlink\" title=\"volatile作用\"></a>volatile作用</h3><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<ul>\n<li>保证了不同线程对volatile修饰的变量进行改动时，其他线程能马上可见</li>\n<li>禁止执行重排序</li>\n</ul>\n<h3 id=\"volatile如何保证可见性\"><a href=\"#volatile如何保证可见性\" class=\"headerlink\" title=\"volatile如何保证可见性\"></a>volatile如何保证可见性</h3><p><a href=\"https://www.toutiao.com/a6845877313154843148/\" target=\"_blank\" rel=\"noopener\">https://www.toutiao.com/a6845877313154843148/</a></p>\n<p>出现上面的问题的原因在硬件层面是由于<strong>CPU缓存的问题</strong>。</p>\n<p><img src=\"/2019/07/18/volatile/2.png\" alt></p>\n<p>由于内存的速度跟不上CPU的运算，所以加入了CPU高速缓存，也也就导致了上面的问题，CPU0修改的数据存在CPU0上的缓存没来得及写入到主内存，导致CPU1没获取到最近的修改值。CPU为了解决这个问题使用了<strong>MESI缓存一致性协议</strong>（<font color=\"red\">多个CPU从主内存读取同一个数据到各自的高速缓存，当其中某个CPU修改了缓存里的数据，该数据会马上同步回主内存，其他CPU通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效</font>）。</p>\n<p><strong>缓存一致性原理协议(MESI)</strong></p>\n<p>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时， 发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读。</p>\n<p>volatile关键字在汇编底层的<font color=\"red\">实现原理就是通过汇编lock前缀指令</font>。</p>\n<pre><code>0x000000010d3f3203: lock addl $0x0,(%rsp)     ;*putstatic flag\n; - com.java.study.VolatileStudy::lambda$main$1@9 (line 31)</code></pre><p>lock前缀指令实现了如下效果：</p>\n<ul>\n<li>它会强制将对缓存的修改操作立即写入主存。</li>\n<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>\n</ul>\n<p>综合上面两条实现原则，我们了解到：<strong>如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的</strong>。</p>\n<h3 id=\"volatile支持有序性\"><a href=\"#volatile支持有序性\" class=\"headerlink\" title=\"volatile支持有序性\"></a>volatile支持有序性</h3><p>volatile有序性的保证就是通过禁止指令重排序来实现的。在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。原理还是通过<font color=\"red\">lock前缀指令</font>。lock前缀指令实际上相当于一个内存屏障。除了上面的两个效果，还有下面这个效果。</p>\n<ul>\n<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</li>\n</ul>\n<p>虚拟机在执行程序时，如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序，举个例子。</p>\n<pre><code>x = 1; //1\ny = 10; //2\nc = x + y; //3</code></pre><p>由于1,2操作上前后没有关系，虚拟机可以对他们进行重排序，但是3一定在1,2后面，这是根据happens-before规则来规范的。<br><strong>那volatile修饰的变量保证有序性是如何理解呢?</strong></p>\n<pre><code>x = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3 flag为volatile变量\nx = 4;         //语句4\ny = -1;       //语句5</code></pre><p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的</p>\n<p>那么禁止指令重排序又是如何实现的呢？答案是<font color=\"red\">加内存屏障</font>。JMM为volatile加内存屏障有以下4种情况：JMM为volatile加内存屏障有以下4种情况：</p>\n<ul>\n<li>在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。</li>\n<li>在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。</li>\n<li>在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。</li>\n<li>在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。</li>\n</ul>\n<h3 id=\"volatile不支持原子性\"><a href=\"#volatile不支持原子性\" class=\"headerlink\" title=\"volatile不支持原子性\"></a>volatile不支持原子性</h3><p>首先先理解原子性的概念，它指的是在<strong>一个操作过程</strong>中是不可分的，要嘛成功要嘛失败,主体是一个操作过程，一个操作过程是可以包含多条操作语句的，但是volatile只能保证一个变量的可见性和有序性。</p>\n<pre><code>volatile int i = 5;\ntemp = i + 1;\ni = temp;</code></pre><p>假设上面一个操作过程，i使用了volatile修饰，首先AB两个线程同时读取到i = 5，然后A执行了 temp = i + 1; 此时temp变成了6，此时 i 还是5。这时B也执行到了temp = i + 1; temp = 6,然后AB接下去执行i = temp时，就有一个线程少+1了。</p>\n<h2 id=\"java中使用volatile\"><a href=\"#java中使用volatile\" class=\"headerlink\" title=\"java中使用volatile\"></a>java中使用volatile</h2><h3 id=\"单例模式的双检查锁\"><a href=\"#单例模式的双检查锁\" class=\"headerlink\" title=\"单例模式的双检查锁\"></a>单例模式的双检查锁</h3><pre><code>public class SingletonFour {\n    private static volatile SingletonFour singletonFour;\n    private SingletonFour(){}\n    private static SingletonFour getSingleton(){\n        if(singletonFour == null){  //第一次检查\n            synchronized (SingletonFour.class){\n                if(singletonFour == null) //第二次检查\n                    singletonFour = new SingletonFour(); // 标注1\n            }\n        }\n        return singletonFour;\n    }\n}</code></pre><p>这里单例使用了volatile修饰，原因是标注1会发生重排序另一个并发执行的线程B就有可能在判断instance不为null时，线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。<br>这里说一下 new Object()背后的指令 例如 Cache cache=new Cache()</p>\n<pre><code>    // 创建 Cache 对象实例，分配内存\n       0: new           #5                  // class com/query/Cache\n       // 复制栈顶地址，并再将其压入栈顶\n       3: dup\n    // 调用构造器方法，初始化 Cache 对象\n       4: invokespecial #6                  // Method &quot;&lt;init&gt;&quot;:()V\n    // 存入局部方法变量表\n       7: astore_1</code></pre><p>从字节码可以看到创建一个对象实例，可以分为三步</p>\n<ol>\n<li>分配对象内存</li>\n<li>调用构造器方法，执行初始化</li>\n<li>将对象引用赋值给变量</li>\n</ol>\n<p>虚拟机实际运行时，以上指令可能发生重排序。以上代码 2,3 可能发生重排序，但是并不会重排序 1 的顺序。也就是说 1 这个指令都需要先执行，因为 2,3 指令需要依托 1 指令执行结果。所以用volatile修饰可以保证有序性</p>\n<h3 id=\"happens-before\"><a href=\"#happens-before\" class=\"headerlink\" title=\"happens-before\"></a>happens-before</h3><p>happens-before是JMM用来阐述多线程直接有序性的原则。在Java内存模型中，如果要确保有序性可以靠volatile和synchronized来实现，但是如果所有的有序性都仅仅依靠这两个关键字来完成，那么有一些操作将会变得很繁琐，但是我们在编写Java代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生(happens-before)”的原则。</p>\n<p>happends-before可以翻译成：<font color=\"red\">前一个操作的结果可以被后续的操作获取。</font>讲白点就是前面一个操作把变量a赋值成1，那后面一个操作肯定能知道a已经变成1了。</p>\n<ol>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；</li>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>\n<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>\n<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ol>\n<h3 id=\"as-if-serial语义\"><a href=\"#as-if-serial语义\" class=\"headerlink\" title=\"as-if-serial语义\"></a>as-if-serial语义</h3><p>as-if-serial语义的意思是：<strong>不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。</strong>as-if-serial语义使程序员不必担心单线程中重排序的问题干扰他们。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>volatile保证了线程的可见性，当一个线程对其修饰volatile的变量进行改动时会立即被更新到主存</li>\n<li>volatile保证了线程的有序性</li>\n<li>volatile不能保证原子性</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.toutiao.com/a6839502799437300237/\" target=\"_blank\" rel=\"noopener\">https://www.toutiao.com/a6839502799437300237/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Java内存模型-jmm\"><a href=\"#Java内存模型-jmm\" class=\"headerlink\" title=\"Java内存模型(jmm)\"></a>Java内存模型(jmm)</h2><p>看个例子</p>\n<pre><code class=\"java\">public class VolatileExample extends Thread{\n    //设置类静态变量,各线程访问这同一共享变量\n    private  static boolean flag = false;\n    //无限循环,等待flag变为true时才跳出循环\n   public void run() {\n       while (!flag){\n       };\n       System.out.println(&quot;停止了&quot;);\n   }\n\n    public static void main(String[] args) throws Exception {\n        new VolatileExample().start();\n        //sleep的目的是等待线程启动完毕,也就是说进入run的无限循环体了\n        Thread.sleep(100);\n        flag = true;\n    }\n}</code></pre>\n<p>上面程序运行后发现当主线程设置flag为true时子线程的循环并没有停掉。</p>","more":"<p><strong><em>为什么会出现上面的问题?</em></strong></p>\n<p>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。如下图</p>\n<p><img src=\"/2019/07/18/volatile/1.png\" alt><br>所以根据JMM规范，每个线程都有单独的一个工作内存，当主线程在运行时会将flag变量的值拷贝一份到自己的工作内存中，当改变了flag时但是还没来得及写入主存中，主线程转去做其他事情，那么子线程就不知道flag的更改，所以就一直循环下去。</p>\n<h2 id=\"volatile详解\"><a href=\"#volatile详解\" class=\"headerlink\" title=\"volatile详解\"></a>volatile详解</h2><h3 id=\"线程中的三个概念\"><a href=\"#线程中的三个概念\" class=\"headerlink\" title=\"线程中的三个概念\"></a>线程中的三个概念</h3><ul>\n<li>原子性，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行</li>\n<li>可见性，保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值</li>\n<li>有序性，在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行</li>\n</ul>\n<h3 id=\"volatile作用\"><a href=\"#volatile作用\" class=\"headerlink\" title=\"volatile作用\"></a>volatile作用</h3><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>\n<ul>\n<li>保证了不同线程对volatile修饰的变量进行改动时，其他线程能马上可见</li>\n<li>禁止执行重排序</li>\n</ul>\n<h3 id=\"volatile如何保证可见性\"><a href=\"#volatile如何保证可见性\" class=\"headerlink\" title=\"volatile如何保证可见性\"></a>volatile如何保证可见性</h3><p><a href=\"https://www.toutiao.com/a6845877313154843148/\" target=\"_blank\" rel=\"noopener\">https://www.toutiao.com/a6845877313154843148/</a></p>\n<p>出现上面的问题的原因在硬件层面是由于<strong>CPU缓存的问题</strong>。</p>\n<p><img src=\"/2019/07/18/volatile/2.png\" alt></p>\n<p>由于内存的速度跟不上CPU的运算，所以加入了CPU高速缓存，也也就导致了上面的问题，CPU0修改的数据存在CPU0上的缓存没来得及写入到主内存，导致CPU1没获取到最近的修改值。CPU为了解决这个问题使用了<strong>MESI缓存一致性协议</strong>（<font color=\"red\">多个CPU从主内存读取同一个数据到各自的高速缓存，当其中某个CPU修改了缓存里的数据，该数据会马上同步回主内存，其他CPU通过总线嗅探机制可以感知到数据的变化从而将自己缓存里的数据失效</font>）。</p>\n<p><strong>缓存一致性原理协议(MESI)</strong></p>\n<p>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时， 发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读。</p>\n<p>volatile关键字在汇编底层的<font color=\"red\">实现原理就是通过汇编lock前缀指令</font>。</p>\n<pre><code>0x000000010d3f3203: lock addl $0x0,(%rsp)     ;*putstatic flag\n; - com.java.study.VolatileStudy::lambda$main$1@9 (line 31)</code></pre><p>lock前缀指令实现了如下效果：</p>\n<ul>\n<li>它会强制将对缓存的修改操作立即写入主存。</li>\n<li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li>\n</ul>\n<p>综合上面两条实现原则，我们了解到：<strong>如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的</strong>。</p>\n<h3 id=\"volatile支持有序性\"><a href=\"#volatile支持有序性\" class=\"headerlink\" title=\"volatile支持有序性\"></a>volatile支持有序性</h3><p>volatile有序性的保证就是通过禁止指令重排序来实现的。在执行程序时，为了提高性能，编译器和处理器会对指令做重排序。原理还是通过<font color=\"red\">lock前缀指令</font>。lock前缀指令实际上相当于一个内存屏障。除了上面的两个效果，还有下面这个效果。</p>\n<ul>\n<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。</li>\n</ul>\n<p>虚拟机在执行程序时，如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序，举个例子。</p>\n<pre><code>x = 1; //1\ny = 10; //2\nc = x + y; //3</code></pre><p>由于1,2操作上前后没有关系，虚拟机可以对他们进行重排序，但是3一定在1,2后面，这是根据happens-before规则来规范的。<br><strong>那volatile修饰的变量保证有序性是如何理解呢?</strong></p>\n<pre><code>x = 2;        //语句1\ny = 0;        //语句2\nflag = true;  //语句3 flag为volatile变量\nx = 4;         //语句4\ny = -1;       //语句5</code></pre><p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的</p>\n<p>那么禁止指令重排序又是如何实现的呢？答案是<font color=\"red\">加内存屏障</font>。JMM为volatile加内存屏障有以下4种情况：JMM为volatile加内存屏障有以下4种情况：</p>\n<ul>\n<li>在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。</li>\n<li>在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。</li>\n<li>在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。</li>\n<li>在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。</li>\n</ul>\n<h3 id=\"volatile不支持原子性\"><a href=\"#volatile不支持原子性\" class=\"headerlink\" title=\"volatile不支持原子性\"></a>volatile不支持原子性</h3><p>首先先理解原子性的概念，它指的是在<strong>一个操作过程</strong>中是不可分的，要嘛成功要嘛失败,主体是一个操作过程，一个操作过程是可以包含多条操作语句的，但是volatile只能保证一个变量的可见性和有序性。</p>\n<pre><code>volatile int i = 5;\ntemp = i + 1;\ni = temp;</code></pre><p>假设上面一个操作过程，i使用了volatile修饰，首先AB两个线程同时读取到i = 5，然后A执行了 temp = i + 1; 此时temp变成了6，此时 i 还是5。这时B也执行到了temp = i + 1; temp = 6,然后AB接下去执行i = temp时，就有一个线程少+1了。</p>\n<h2 id=\"java中使用volatile\"><a href=\"#java中使用volatile\" class=\"headerlink\" title=\"java中使用volatile\"></a>java中使用volatile</h2><h3 id=\"单例模式的双检查锁\"><a href=\"#单例模式的双检查锁\" class=\"headerlink\" title=\"单例模式的双检查锁\"></a>单例模式的双检查锁</h3><pre><code>public class SingletonFour {\n    private static volatile SingletonFour singletonFour;\n    private SingletonFour(){}\n    private static SingletonFour getSingleton(){\n        if(singletonFour == null){  //第一次检查\n            synchronized (SingletonFour.class){\n                if(singletonFour == null) //第二次检查\n                    singletonFour = new SingletonFour(); // 标注1\n            }\n        }\n        return singletonFour;\n    }\n}</code></pre><p>这里单例使用了volatile修饰，原因是标注1会发生重排序另一个并发执行的线程B就有可能在判断instance不为null时，线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始化。<br>这里说一下 new Object()背后的指令 例如 Cache cache=new Cache()</p>\n<pre><code>    // 创建 Cache 对象实例，分配内存\n       0: new           #5                  // class com/query/Cache\n       // 复制栈顶地址，并再将其压入栈顶\n       3: dup\n    // 调用构造器方法，初始化 Cache 对象\n       4: invokespecial #6                  // Method &quot;&lt;init&gt;&quot;:()V\n    // 存入局部方法变量表\n       7: astore_1</code></pre><p>从字节码可以看到创建一个对象实例，可以分为三步</p>\n<ol>\n<li>分配对象内存</li>\n<li>调用构造器方法，执行初始化</li>\n<li>将对象引用赋值给变量</li>\n</ol>\n<p>虚拟机实际运行时，以上指令可能发生重排序。以上代码 2,3 可能发生重排序，但是并不会重排序 1 的顺序。也就是说 1 这个指令都需要先执行，因为 2,3 指令需要依托 1 指令执行结果。所以用volatile修饰可以保证有序性</p>\n<h3 id=\"happens-before\"><a href=\"#happens-before\" class=\"headerlink\" title=\"happens-before\"></a>happens-before</h3><p>happens-before是JMM用来阐述多线程直接有序性的原则。在Java内存模型中，如果要确保有序性可以靠volatile和synchronized来实现，但是如果所有的有序性都仅仅依靠这两个关键字来完成，那么有一些操作将会变得很繁琐，但是我们在编写Java代码的时候并没有感觉到这一点，这是因为Java语言中有一个“先行发生(happens-before)”的原则。</p>\n<p>happends-before可以翻译成：<font color=\"red\">前一个操作的结果可以被后续的操作获取。</font>讲白点就是前面一个操作把变量a赋值成1，那后面一个操作肯定能知道a已经变成1了。</p>\n<ol>\n<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>\n<li>锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；</li>\n<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>\n<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>\n<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>\n<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>\n<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>\n<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>\n</ol>\n<h3 id=\"as-if-serial语义\"><a href=\"#as-if-serial语义\" class=\"headerlink\" title=\"as-if-serial语义\"></a>as-if-serial语义</h3><p>as-if-serial语义的意思是：<strong>不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。</strong>as-if-serial语义使程序员不必担心单线程中重排序的问题干扰他们。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>volatile保证了线程的可见性，当一个线程对其修饰volatile的变量进行改动时会立即被更新到主存</li>\n<li>volatile保证了线程的有序性</li>\n<li>volatile不能保证原子性</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.toutiao.com/a6839502799437300237/\" target=\"_blank\" rel=\"noopener\">https://www.toutiao.com/a6839502799437300237/</a></li>\n</ul>"},{"title":"java并发之中断详解","description":"详解java中断线程的几种方式和方法interrupt()，Thread.interrupt()，isInterrupted()区别","date":"2020-08-27T02:57:08.000Z","_content":"\n## 概述\n\njava中提供了多种方式来实现线程的中断。本文通过列举其中的方式。并对方法interrupt()，Thread.interrupt()，isInterrupted()进行区分。\n<!--more-->\n## 中断方法分析\n\n涉及中断的方法有如下三个，\n\n| 方法                 | 方法类型             | 说明                                                         |\n| -------------------- | -------------------- | ------------------------------------------------------------ |\n| interrupt()          | Thread类下的实例方法 | 作用是中断线程，只是改变中断状态不会中断线程，后续就是根据这个中断状态去调用isInterrupted()或Thread.interrupted()或抛出interruptedException异常来结束中断 |\n| isInterrupted()      | Thread类下的实例方法 | 测试线程是否已经中断，不会重置当前线程的中断状态             |\n| Thread.interrupted() | Thread类下的静态方法 | 测试当前线程(内部用的是currentThread())是否已经中断，会重置当前线程的中断状态 |\n\n说明：\n\n- 会不会重置当前线程的中断状态指的是如果原来是中断，调用Thread.interrupted()就重新设置成不中断了\n- 两个判断中断的方法最终都是调用本地方法boolean isInterrupted(boolean ClearInterrupted)\n\n```java\n//Thread.interrupted();\npublic static boolean interrupted() {\n    return currentThread().isInterrupted(true);\n}\n//this.isInterrupted\npublic boolean isInterrupted() {\n    return isInterrupted(false);\n}\nprivate native boolean isInterrupted(boolean ClearInterrupted);\n```\n\n\n\n## stop方法中断\n\n<font color=red>不推荐使用</font>。使用stop方法虽然可以`强行终止`正在运行或挂起的线程，但使用stop方法是很`危险`的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，因此，并不推荐使用stop方法来终止线程。\n\n## 代码上使用标志位中断\n\n在线程执行方法run中使用一个循环体，如果想使while循环在某一特定条件下退出，最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出。\n\n```java\npublic class myTest {\n\t//这里必须使用volatile修饰保证可见性\n    public static volatile boolean exit =false;  //退出标志\n    public static void main(String[] args) {\n        new Thread() {\n            public void run() {\n                System.out.println(\"线程启动了\");\n                while (!exit) {\n                    System.out.println(\"模拟运行很长的代码段............\");\n                }\n                System.out.println(\"线程结束了\");\n            }\n        }.start();\n        \n        try {\n            Thread.sleep(1000 * 5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        exit = true;//5秒后更改退出标志的值,没有这段代码，线程就一直不能停止\n    }\n}\n```\n\n## interrupt()+InterruptedException中断线程\n\n线程处于阻塞状态，如Thread.sleep、wait、IO阻塞等情况时，调用interrupt方法后，sleep等方法将会抛出一个InterruptedException。通过异常退出的方式\n\n```java\npublic class Interrupt2 {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new MyThread(), \"testThread\");\n        thread.start();\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n\n        }\n        MyThread.on = true;\n        thread.interrupt();\n    }\n\n    static class MyThread extends Thread {\n        private volatile static boolean on = false;\n        @Override\n        public void run() {\n            //通过抛出异常结束阻塞中的代码块，然后通过标志判断退出循环\n            //好像中断都需要写在循环里比较安全\n            while (!on) {\n                try {\n                    System.out.println(\"begin Sleep\");\n                    Thread.sleep(10000000);\n                    System.out.println(\"end Sleep\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"Oh, myGod!\");\n            }\n        }\n    }\n}\n```\n\n## interrupt()+isInterrupted()中断线程\n\n通过设置中断状态+判断中断标志来中断线程。\n\n```java\npublic class Interrupt {\n    public static void main(String[] agrs) {\n        try{\n            MyThread myThread = new MyThread();\n            myThread.start();\n            TimeUnit.SECONDS.sleep(1); //休眠两秒\n            myThread.interrupt(); //请求中断\n        }catch (Exception e){\n            System.out.println(\"main catch\");\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread extends Thread {\n        @Override\n        public void run() {\n            for (int i = 0; i < 500000; i++) {\n                if (this.isInterrupted()) {\n                    System.out.println(\"should be stopped and exit\");\n                    break;\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"this line is also executed. thread does not stopped\"); //尽管线程被中断,但并没有结束运行。这行代码还是会被执行\n        }\n    }\n}\n```\n\n","source":"_posts/thread-interrupted.md","raw":"---\ntitle: java并发之中断详解\ntags:\n  - java并发\ncategories:  java\ndescription : 详解java中断线程的几种方式和方法interrupt()，Thread.interrupt()，isInterrupted()区别\ndate: 2020-08-27 10:57:08\n---\n\n## 概述\n\njava中提供了多种方式来实现线程的中断。本文通过列举其中的方式。并对方法interrupt()，Thread.interrupt()，isInterrupted()进行区分。\n<!--more-->\n## 中断方法分析\n\n涉及中断的方法有如下三个，\n\n| 方法                 | 方法类型             | 说明                                                         |\n| -------------------- | -------------------- | ------------------------------------------------------------ |\n| interrupt()          | Thread类下的实例方法 | 作用是中断线程，只是改变中断状态不会中断线程，后续就是根据这个中断状态去调用isInterrupted()或Thread.interrupted()或抛出interruptedException异常来结束中断 |\n| isInterrupted()      | Thread类下的实例方法 | 测试线程是否已经中断，不会重置当前线程的中断状态             |\n| Thread.interrupted() | Thread类下的静态方法 | 测试当前线程(内部用的是currentThread())是否已经中断，会重置当前线程的中断状态 |\n\n说明：\n\n- 会不会重置当前线程的中断状态指的是如果原来是中断，调用Thread.interrupted()就重新设置成不中断了\n- 两个判断中断的方法最终都是调用本地方法boolean isInterrupted(boolean ClearInterrupted)\n\n```java\n//Thread.interrupted();\npublic static boolean interrupted() {\n    return currentThread().isInterrupted(true);\n}\n//this.isInterrupted\npublic boolean isInterrupted() {\n    return isInterrupted(false);\n}\nprivate native boolean isInterrupted(boolean ClearInterrupted);\n```\n\n\n\n## stop方法中断\n\n<font color=red>不推荐使用</font>。使用stop方法虽然可以`强行终止`正在运行或挂起的线程，但使用stop方法是很`危险`的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，因此，并不推荐使用stop方法来终止线程。\n\n## 代码上使用标志位中断\n\n在线程执行方法run中使用一个循环体，如果想使while循环在某一特定条件下退出，最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出。\n\n```java\npublic class myTest {\n\t//这里必须使用volatile修饰保证可见性\n    public static volatile boolean exit =false;  //退出标志\n    public static void main(String[] args) {\n        new Thread() {\n            public void run() {\n                System.out.println(\"线程启动了\");\n                while (!exit) {\n                    System.out.println(\"模拟运行很长的代码段............\");\n                }\n                System.out.println(\"线程结束了\");\n            }\n        }.start();\n        \n        try {\n            Thread.sleep(1000 * 5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        exit = true;//5秒后更改退出标志的值,没有这段代码，线程就一直不能停止\n    }\n}\n```\n\n## interrupt()+InterruptedException中断线程\n\n线程处于阻塞状态，如Thread.sleep、wait、IO阻塞等情况时，调用interrupt方法后，sleep等方法将会抛出一个InterruptedException。通过异常退出的方式\n\n```java\npublic class Interrupt2 {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new MyThread(), \"testThread\");\n        thread.start();\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n\n        }\n        MyThread.on = true;\n        thread.interrupt();\n    }\n\n    static class MyThread extends Thread {\n        private volatile static boolean on = false;\n        @Override\n        public void run() {\n            //通过抛出异常结束阻塞中的代码块，然后通过标志判断退出循环\n            //好像中断都需要写在循环里比较安全\n            while (!on) {\n                try {\n                    System.out.println(\"begin Sleep\");\n                    Thread.sleep(10000000);\n                    System.out.println(\"end Sleep\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"Oh, myGod!\");\n            }\n        }\n    }\n}\n```\n\n## interrupt()+isInterrupted()中断线程\n\n通过设置中断状态+判断中断标志来中断线程。\n\n```java\npublic class Interrupt {\n    public static void main(String[] agrs) {\n        try{\n            MyThread myThread = new MyThread();\n            myThread.start();\n            TimeUnit.SECONDS.sleep(1); //休眠两秒\n            myThread.interrupt(); //请求中断\n        }catch (Exception e){\n            System.out.println(\"main catch\");\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread extends Thread {\n        @Override\n        public void run() {\n            for (int i = 0; i < 500000; i++) {\n                if (this.isInterrupted()) {\n                    System.out.println(\"should be stopped and exit\");\n                    break;\n                }\n                System.out.println(\"i=\" + (i + 1));\n            }\n            System.out.println(\"this line is also executed. thread does not stopped\"); //尽管线程被中断,但并没有结束运行。这行代码还是会被执行\n        }\n    }\n}\n```\n\n","slug":"thread-interrupted","published":1,"updated":"2021-04-08T00:47:07.107Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhw7004vqwv2doo29zz0","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>java中提供了多种方式来实现线程的中断。本文通过列举其中的方式。并对方法interrupt()，Thread.interrupt()，isInterrupted()进行区分。</p>\n<a id=\"more\"></a>\n<h2 id=\"中断方法分析\"><a href=\"#中断方法分析\" class=\"headerlink\" title=\"中断方法分析\"></a>中断方法分析</h2><p>涉及中断的方法有如下三个，</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>方法类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>interrupt()</td>\n<td>Thread类下的实例方法</td>\n<td>作用是中断线程，只是改变中断状态不会中断线程，后续就是根据这个中断状态去调用isInterrupted()或Thread.interrupted()或抛出interruptedException异常来结束中断</td>\n</tr>\n<tr>\n<td>isInterrupted()</td>\n<td>Thread类下的实例方法</td>\n<td>测试线程是否已经中断，不会重置当前线程的中断状态</td>\n</tr>\n<tr>\n<td>Thread.interrupted()</td>\n<td>Thread类下的静态方法</td>\n<td>测试当前线程(内部用的是currentThread())是否已经中断，会重置当前线程的中断状态</td>\n</tr>\n</tbody></table>\n<p>说明：</p>\n<ul>\n<li>会不会重置当前线程的中断状态指的是如果原来是中断，调用Thread.interrupted()就重新设置成不中断了</li>\n<li>两个判断中断的方法最终都是调用本地方法boolean isInterrupted(boolean ClearInterrupted)</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//Thread.interrupted();</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">interrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//this.isInterrupted</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">native</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> ClearInterrupted<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n<h2 id=\"stop方法中断\"><a href=\"#stop方法中断\" class=\"headerlink\" title=\"stop方法中断\"></a>stop方法中断</h2><p><font color=\"red\">不推荐使用</font>。使用stop方法虽然可以<code>强行终止</code>正在运行或挂起的线程，但使用stop方法是很<code>危险</code>的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，因此，并不推荐使用stop方法来终止线程。</p>\n<h2 id=\"代码上使用标志位中断\"><a href=\"#代码上使用标志位中断\" class=\"headerlink\" title=\"代码上使用标志位中断\"></a>代码上使用标志位中断</h2><p>在线程执行方法run中使用一个循环体，如果想使while循环在某一特定条件下退出，最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">myTest</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">//这里必须使用volatile修饰保证可见性</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">boolean</span> exit <span class=\"token operator\">=</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//退出标志</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程启动了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>exit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"模拟运行很长的代码段............\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程结束了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span> <span class=\"token operator\">*</span> <span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        exit <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//5秒后更改退出标志的值,没有这段代码，线程就一直不能停止</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"interrupt-InterruptedException中断线程\"><a href=\"#interrupt-InterruptedException中断线程\" class=\"headerlink\" title=\"interrupt()+InterruptedException中断线程\"></a>interrupt()+InterruptedException中断线程</h2><p>线程处于阻塞状态，如Thread.sleep、wait、IO阻塞等情况时，调用interrupt方法后，sleep等方法将会抛出一个InterruptedException。通过异常退出的方式</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Interrupt2</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Thread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MyThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"testThread\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n        <span class=\"token punctuation\">}</span>\n        MyThread<span class=\"token punctuation\">.</span>on <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">private</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> on <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//通过抛出异常结束阻塞中的代码块，然后通过标志判断退出循环</span>\n            <span class=\"token comment\" spellcheck=\"true\">//好像中断都需要写在循环里比较安全</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>on<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"begin Sleep\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    Thread<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"end Sleep\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Oh, myGod!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"interrupt-isInterrupted-中断线程\"><a href=\"#interrupt-isInterrupted-中断线程\" class=\"headerlink\" title=\"interrupt()+isInterrupted()中断线程\"></a>interrupt()+isInterrupted()中断线程</h2><p>通过设置中断状态+判断中断标志来中断线程。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Interrupt</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> agrs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n            MyThread myThread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            myThread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//休眠两秒</span>\n            myThread<span class=\"token punctuation\">.</span><span class=\"token function\">interrupt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//请求中断</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"main catch\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyThread</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Thread</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">500000</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">isInterrupted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"should be stopped and exit\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"i=\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>i <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"this line is also executed. thread does not stopped\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//尽管线程被中断,但并没有结束运行。这行代码还是会被执行</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>java中提供了多种方式来实现线程的中断。本文通过列举其中的方式。并对方法interrupt()，Thread.interrupt()，isInterrupted()进行区分。</p>","more":"<h2 id=\"中断方法分析\"><a href=\"#中断方法分析\" class=\"headerlink\" title=\"中断方法分析\"></a>中断方法分析</h2><p>涉及中断的方法有如下三个，</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>方法类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>interrupt()</td>\n<td>Thread类下的实例方法</td>\n<td>作用是中断线程，只是改变中断状态不会中断线程，后续就是根据这个中断状态去调用isInterrupted()或Thread.interrupted()或抛出interruptedException异常来结束中断</td>\n</tr>\n<tr>\n<td>isInterrupted()</td>\n<td>Thread类下的实例方法</td>\n<td>测试线程是否已经中断，不会重置当前线程的中断状态</td>\n</tr>\n<tr>\n<td>Thread.interrupted()</td>\n<td>Thread类下的静态方法</td>\n<td>测试当前线程(内部用的是currentThread())是否已经中断，会重置当前线程的中断状态</td>\n</tr>\n</tbody></table>\n<p>说明：</p>\n<ul>\n<li>会不会重置当前线程的中断状态指的是如果原来是中断，调用Thread.interrupted()就重新设置成不中断了</li>\n<li>两个判断中断的方法最终都是调用本地方法boolean isInterrupted(boolean ClearInterrupted)</li>\n</ul>\n<pre><code class=\"java\">//Thread.interrupted();\npublic static boolean interrupted() {\n    return currentThread().isInterrupted(true);\n}\n//this.isInterrupted\npublic boolean isInterrupted() {\n    return isInterrupted(false);\n}\nprivate native boolean isInterrupted(boolean ClearInterrupted);</code></pre>\n<h2 id=\"stop方法中断\"><a href=\"#stop方法中断\" class=\"headerlink\" title=\"stop方法中断\"></a>stop方法中断</h2><p><font color=\"red\">不推荐使用</font>。使用stop方法虽然可以<code>强行终止</code>正在运行或挂起的线程，但使用stop方法是很<code>危险</code>的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，因此，并不推荐使用stop方法来终止线程。</p>\n<h2 id=\"代码上使用标志位中断\"><a href=\"#代码上使用标志位中断\" class=\"headerlink\" title=\"代码上使用标志位中断\"></a>代码上使用标志位中断</h2><p>在线程执行方法run中使用一个循环体，如果想使while循环在某一特定条件下退出，最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false来控制while循环是否退出。</p>\n<pre><code class=\"java\">public class myTest {\n    //这里必须使用volatile修饰保证可见性\n    public static volatile boolean exit =false;  //退出标志\n    public static void main(String[] args) {\n        new Thread() {\n            public void run() {\n                System.out.println(&quot;线程启动了&quot;);\n                while (!exit) {\n                    System.out.println(&quot;模拟运行很长的代码段............&quot;);\n                }\n                System.out.println(&quot;线程结束了&quot;);\n            }\n        }.start();\n\n        try {\n            Thread.sleep(1000 * 5);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        exit = true;//5秒后更改退出标志的值,没有这段代码，线程就一直不能停止\n    }\n}</code></pre>\n<h2 id=\"interrupt-InterruptedException中断线程\"><a href=\"#interrupt-InterruptedException中断线程\" class=\"headerlink\" title=\"interrupt()+InterruptedException中断线程\"></a>interrupt()+InterruptedException中断线程</h2><p>线程处于阻塞状态，如Thread.sleep、wait、IO阻塞等情况时，调用interrupt方法后，sleep等方法将会抛出一个InterruptedException。通过异常退出的方式</p>\n<pre><code class=\"java\">public class Interrupt2 {\n    public static void main(String[] args) {\n        Thread thread = new Thread(new MyThread(), &quot;testThread&quot;);\n        thread.start();\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n\n        }\n        MyThread.on = true;\n        thread.interrupt();\n    }\n\n    static class MyThread extends Thread {\n        private volatile static boolean on = false;\n        @Override\n        public void run() {\n            //通过抛出异常结束阻塞中的代码块，然后通过标志判断退出循环\n            //好像中断都需要写在循环里比较安全\n            while (!on) {\n                try {\n                    System.out.println(&quot;begin Sleep&quot;);\n                    Thread.sleep(10000000);\n                    System.out.println(&quot;end Sleep&quot;);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(&quot;Oh, myGod!&quot;);\n            }\n        }\n    }\n}</code></pre>\n<h2 id=\"interrupt-isInterrupted-中断线程\"><a href=\"#interrupt-isInterrupted-中断线程\" class=\"headerlink\" title=\"interrupt()+isInterrupted()中断线程\"></a>interrupt()+isInterrupted()中断线程</h2><p>通过设置中断状态+判断中断标志来中断线程。</p>\n<pre><code class=\"java\">public class Interrupt {\n    public static void main(String[] agrs) {\n        try{\n            MyThread myThread = new MyThread();\n            myThread.start();\n            TimeUnit.SECONDS.sleep(1); //休眠两秒\n            myThread.interrupt(); //请求中断\n        }catch (Exception e){\n            System.out.println(&quot;main catch&quot;);\n            e.printStackTrace();\n        }\n    }\n\n    static class MyThread extends Thread {\n        @Override\n        public void run() {\n            for (int i = 0; i &lt; 500000; i++) {\n                if (this.isInterrupted()) {\n                    System.out.println(&quot;should be stopped and exit&quot;);\n                    break;\n                }\n                System.out.println(&quot;i=&quot; + (i + 1));\n            }\n            System.out.println(&quot;this line is also executed. thread does not stopped&quot;); //尽管线程被中断,但并没有结束运行。这行代码还是会被执行\n        }\n    }\n}</code></pre>"},{"title":"Zookeeper实现分布式锁（附代码）","description":"详解Zookeeper实现分布式锁","date":"2020-08-27T09:06:06.000Z","_content":"\n\n\n\n## 什么是分布式锁\n\n在日常开发中，我们最熟悉也常用的分布式锁场景是在开发多线程的时候。为了协调本地应用上多个线程对某一资源的访问，就要对该资源或数值变量进行加锁，以保证在多线程环境下系统能够正确地运行。在一台服务器上的程序内部，线程可以通过系统进行线程之间的通信，实现加锁等操作。而在分布式环境下，执行事务的线程存在于不同的网络服务器中，要想实现在分布式网络下的线程协同操作，就要用到分布式锁。\n\n## 独占式非公平分布式锁\n\n### 概述\n\n独占式非公平锁采用的方式是通过创建节点，如果节点创建成功则表示加锁成功，如果创建不成功则需要等待并对节点(锁)设置watch。\n\n当节点(锁)释放后会触发watch的节点删除事件，从而重新抢占创建节点。\n\n![](zookeeper-lock/1.png)\n<!--more-->\n1. 多个客户端竞争创建 lock 临时节点\n2. 其中某个客户端成功创建 lock 节点，其他客户端对 lock 节点设置 watcher\n3. 持有锁的客户端删除 lock 节点或该客户端崩溃，由 Zookeeper 删除 lock 节点\n4. 其他客户端获得 lock 节点被删除的通知\n5. 重复上述4个步骤，直至无客户端在等待获取锁了\n\n### 代码实例\n\n**主代码**\n\n```java\npackage lock;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.curator.RetryPolicy;\nimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.CuratorFrameworkFactory;\nimport org.apache.curator.framework.recipes.cache.ChildData;\nimport org.apache.curator.framework.recipes.cache.NodeCache;\nimport org.apache.curator.framework.recipes.cache.NodeCacheListener;\nimport org.apache.curator.framework.state.ConnectionState;\nimport org.apache.curator.framework.state.ConnectionStateListener;\nimport org.apache.curator.retry.ExponentialBackoffRetry;\nimport org.apache.curator.utils.CloseableUtils;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.KeeperException;\n\nimport java.util.UUID;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\n/***\n * 使用zk实现分布式独占锁\n */\npublic class ZkOnlyLock {\n    private static String lockNameSpace = \"/mylock\";\n    public static String CONNECT_ADDR = \"localhost:2181\";\n    private static final ThreadLocal<String> threadUuid = new ThreadLocal<String>() {\n        @Override\n        protected String initialValue() {\n            return UUID.randomUUID().toString();\n        }\n    };\n    private CuratorFramework cf;\n    private String locakPath;\n\n    /***\n     *\n     * @param lockPath 锁路径\n     */\n    public ZkOnlyLock(String lockPath) {\n        this.locakPath = lockNameSpace + \"/\" + lockPath;\n        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n        cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();\n        cf.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n            @Override\n            public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {\n                if (connectionState == ConnectionState.LOST) {\n                    System.out.println(\"连接丢失\");//连接丢失\n                } else if (connectionState == ConnectionState.CONNECTED) {\n                    System.out.println(\"成功连接\");\n                } else if (connectionState == ConnectionState.RECONNECTED) {\n                    System.out.println(\"重连成功\");\n                }\n            }\n        });\n        cf.start();\n    }\n\n    public void lock() {\n        this.lock(0, null);\n    }\n\t\n    public void lock(long millisToWait, TimeUnit unit) {\n        boolean doDeleteOurPath = false;\n        for (;doDeleteOurPath == false;) {\n            try {\n                String path = cf.create()\n                        .creatingParentsIfNeeded() //自动创建父节点\n                        .withMode(CreateMode.PERSISTENT)\n                        .forPath(locakPath, threadUuid.get().getBytes());\n                if (StringUtils.isNoneBlank(path)) {\n                    System.out.println(\"线程\" + Thread.currentThread().getId() + \"获得锁\");\n                    break;\n                }\n            } catch (Exception e) {\n                if (e instanceof KeeperException.NodeExistsException) {\n                    //如果是已经存在节点了，则设置watch并阻塞\n                    NodeCache cache = new NodeCache(cf, locakPath);\n                    CountDownLatch countDownLatch = new CountDownLatch(1);\n                    cache.getListenable().addListener(new NodeCacheListener() {\n                        @Override\n                        public void nodeChanged() throws Exception {\n                            ChildData childData = cache.getCurrentData();\n                            if (childData == null) {\n                                System.out.println(\"===节点被删除，可以开始尝试创建===\");\n                                countDownLatch.countDown();\n                            }\n                        }\n                    });\n                    try {\n                        cache.start();\n                    } catch (Exception exception) {\n                        exception.printStackTrace();\n                    }\n                    try {\n                        if (unit != null) {\n                            countDownLatch.await(millisToWait, unit);\n                            doDeleteOurPath = true;\n                        } else {\n                            countDownLatch.await();\n                        }\n                        CloseableUtils.closeQuietly(cache);\n                    } catch (InterruptedException interruptedException) {\n                        interruptedException.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    /***\n     * 解锁\n     */\n    public void unlock() {\n        try {\n            String uuidData = new String(cf.getData().forPath(locakPath), \"UTF-8\");\n            //如果存的是同一个uuid则进行删除，否则不是自己加锁的\n            if (StringUtils.isNoneBlank(uuidData) && uuidData.equals(threadUuid.get())) {\n                cf.delete().forPath(locakPath);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            threadUuid.remove();\n        }\n    }\n}\n```\n\n**测试代码**\n\n```java\n/****\n     * 测试加锁\n     */\n    @Test\n    public void onlyLockTest1() {\n        ZkOnlyLock zkOnlyLock = new ZkOnlyLock(\"lock001\");\n        ExecutorService executorService = Executors.newFixedThreadPool(100);\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(() -> {\n                try {\n                    zkOnlyLock.lock();\n                    System.out.println(\"做事ing\");\n                    try {\n                        TimeUnit.SECONDS.sleep(5);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } finally {\n                    zkOnlyLock.unlock();\n                }\n            });\n        }\n    }\n\n    /***\n     * 测试超时\n     * @throws InterruptedException\n     */\n    @Test\n    public void onlyLockTest2() throws InterruptedException {\n        ZkOnlyLock zkOnlyLock = new ZkOnlyLock(\"lock001\");\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                zkOnlyLock.lock(10,TimeUnit.SECONDS);\n                System.out.println(\"====do=====\");\n                zkOnlyLock.unlock();\n            }\n        });\n        thread.start();\n        zkOnlyLock.lock();\n        TimeUnit.SECONDS.sleep(30);\n        zkOnlyLock.unlock();\n        thread.join();\n    }\n```\n\n### 缺点\n\n这种方式的锁达不到公平的效果，每次一个锁释放后其他的锁就会同时触发watch。造成同一时间点多次请求Zookeeper。有性能问题。\n\n## 独占式公平分布式锁\n\n### 概述\n\n![](zookeeper-lock/2.png)\n\n![](zookeeper-lock/3.png)\n\n1. 所有客户端创建自己的锁节点(临时顺序节点)\n2. 从 Zookeeper 端获取 /share_lock下所有的子节点\n3. 判断自己创建的锁节点是否可以获取锁(如果是第一个就是可以获取到锁)，如果可以，持有锁。否则对自己上一个节点设置watcher\n4. 持有锁的客户端删除自己的锁节点，某个客户端收到该节点被删除的通知，并获取锁\n5. 重复步骤4，直至无客户端在等待获取锁了\n\n### 代码实例\n\n```java\npackage lock;\n\nimport com.google.common.collect.Lists;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.curator.RetryPolicy;\nimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.CuratorFrameworkFactory;\nimport org.apache.curator.framework.recipes.cache.ChildData;\nimport org.apache.curator.framework.recipes.cache.NodeCache;\nimport org.apache.curator.framework.recipes.cache.NodeCacheListener;\nimport org.apache.curator.framework.state.ConnectionState;\nimport org.apache.curator.framework.state.ConnectionStateListener;\nimport org.apache.curator.retry.ExponentialBackoffRetry;\nimport org.apache.curator.utils.CloseableUtils;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.data.Stat;\n\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\n/***\n * 分布式共享锁\n */\npublic class ZkOnlyFairLock {\n    private static String lockNameSpace = \"/mylock02\";\n    public static String CONNECT_ADDR = \"localhost:2181\";\n    private CuratorFramework cf;\n    private String locakPath;\n    private String currentLockPath;\n\n    /***\n     *\n     * @param lockPath 锁路径\n     */\n    public ZkOnlyFairLock(String lockPath) {\n        this.locakPath = lockNameSpace + \"/\" + lockPath;\n        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000000, 3);\n        cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();\n        cf.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n            @Override\n            public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {\n                if (connectionState == ConnectionState.LOST) {\n                    System.out.println(\"连接丢失\");//连接丢失\n                } else if (connectionState == ConnectionState.CONNECTED) {\n                    System.out.println(\"成功连接\");\n                } else if (connectionState == ConnectionState.RECONNECTED) {\n                    System.out.println(\"重连成功\");\n                }\n            }\n        });\n        cf.start();\n    }\n\n    /***\n     * 设置watch+等待锁\n     * @param millisToWait\n     * @param unit\n     * @param path\n     * @return\n     * @throws Exception\n     */\n    public boolean waiteLock(long millisToWait, TimeUnit unit, String path) {\n        boolean haveTheLock = false;\n        boolean doDeleteOurPath = false;\n        try {\n\n            while (!haveTheLock) {\n                List<String> childNodeList = getChildrenPath();//获取到所有的节点 [lock0000000005, lock0000000006, lock0000000007]\n                String pathName = path.substring(lockNameSpace.length() + 1);\n                int nodeIndex = childNodeList.indexOf(pathName);\n                if (nodeIndex < 0) {\n                    //节点不存在，抛出异常\n                    throw new RuntimeException(\"顺序节点不存在\");\n                }\n\n                if (nodeIndex == 0) {\n                    haveTheLock = true; //获得锁\n                    System.out.println(\"path = \" + path + \" 获得锁\");\n                } else {\n                    //如果不是第一个节点则对上一个节点做监听\n                    String preNodePath = lockNameSpace.concat(\"/\").concat(childNodeList.get(nodeIndex - 1));\n                    CountDownLatch countDownLatch = new CountDownLatch(1);\n                    //可能对上一个节点做监听时，这个节点已经被删除了\n                    NodeCache cache = new NodeCache(cf, preNodePath);\n                    //对上一个节点做监听\n                    cache.getListenable().addListener(new NodeCacheListener() {\n                        @Override\n                        public void nodeChanged() throws Exception {\n                            ChildData childData = cache.getCurrentData();\n                            if (childData == null) {\n                                countDownLatch.countDown();\n                            }\n                        }\n                    });\n                    cache.start();\n                    //再次判断下上个节点存不存在，如何存在才阻塞，防止出现节点删除后才建立监控导致一直阻塞\n                    if (isExistNode(preNodePath)) {\n                        System.out.println(\"====对path=\" + preNodePath + \" 设置watch监听，并开始阻塞 -\" + path);\n                        countDownLatch.await();\n                    } else {\n                        CloseableUtils.closeQuietly(cache);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            //异常了要删除原来的节点\n            doDeleteOurPath = true;\n        } finally {\n            if (doDeleteOurPath) {\n                deleteNode(path);\n            }\n        }\n        return haveTheLock;\n    }\n\n    public void lock() throws Exception {\n        this.lock(0, null);\n    }\n\n    /***\n     * 加锁\n     */\n    public void lock(long millisToWait, TimeUnit unit) throws Exception {\n        boolean isDone = false;\n        //加锁重试次数\n        while (!isDone) {\n            String path = createNode(); //创建顺序临时节点 path = /mylock02/lock0000000005\n            this.currentLockPath = path; //记录当前的锁节点，后面解锁要用的\n            if (StringUtils.isBlank(path)) {\n                throw new RuntimeException(\"创建顺序节点失败\");\n            }\n            if (waiteLock(millisToWait, unit, path)) {\n                isDone = true;\n            }\n        }\n    }\n\n    /***\n     * 解锁\n     */\n    public void unlock() {\n        deleteNode(this.currentLockPath);\n        CloseableUtils.closeQuietly(cf);\n    }\n\n    /***\n     * 创建顺序临时节点\n     * @return\n     * @throws Exception\n     */\n    public String createNode() {\n        String s = null;\n        try {\n            s = cf.create()\n                    .creatingParentsIfNeeded() //自动创建父节点\n                    .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)\n                    .forPath(locakPath);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n\n    /***\n     * 删除节点\n     * @param path\n     */\n    public void deleteNode(String path) {\n        try {\n            if (isExistNode(path)) {\n                cf.delete().forPath(path);\n                System.out.println(\"====\" + path + \" 删除成功\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /***\n     * 判断节点是否存在\n     * @param path\n     * @return\n     */\n    public boolean isExistNode(String path) {\n        try {\n            Stat stat = cf.checkExists().forPath(path);\n            return stat == null ? false : true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    /***\n     * 获取子节点并排序\n     * @return\n     */\n    public List<String> getChildrenPath() {\n        try {\n            List<String> strings = cf.getChildren().forPath(lockNameSpace);\n            return strings.stream().sorted().collect(Collectors.toList());\n        } catch (Exception e) {\n            e.printStackTrace();\n            return Lists.newArrayList();\n        }\n    }\n\n}\n\n```\n\n**测试代码**\n\n```java\n@Test\n    public void zkOnlyFairLock01() throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(100);\n        for(int i = 0 ; i < 100; i++){\n            executorService.submit(() -> {\n                ZkOnlyFairLock zkLock = new ZkOnlyFairLock(\"lock\");\n                try {\n                    zkLock.lock();\n                    System.out.println(\"做事ing\");\n                    TimeUnit.SECONDS.sleep(2);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }finally {\n                    zkLock.unlock();\n                }\n            });\n        }\n        executorService.awaitTermination(10,TimeUnit.MINUTES);\n    }\n```\n\n## Curator提供的分布式锁\n\nCurator是Zookeeper的一个工具类，他为我们提供了简便好用的分布式锁工具。\n\n- InterProcessMutex：分布式可重入排它锁\n- InterProcessSemaphoreMutex：分布式排它锁\n- InterProcessReadWriteLock：分布式读写锁\n- InterProcessMultiLock：将多个锁作为单个实体管理的容器\n\n### 不可重入锁\n\nInterProcessSemaphoreMutex是一种不可重入的互斥锁，也就意味着即使是同一个线程也无法在持有锁的情况下再次获得锁，所以需要注意，不可重入的锁很容易在一些情况导致死锁。\n\n```java\n@Test\npublic void curtorLock001() throws InterruptedException {\n    ExecutorService executorService = Executors.newFixedThreadPool(100);\n    for(int i = 0 ; i < 10; i++){\n        executorService.submit(new Runnable() {\n            @Override\n            public void run() {\n                CuratorFramework cf = CuratorFrameworkFactory.newClient(\"localhost:2181\",new ExponentialBackoffRetry(2000,3));\n                InterProcessLock lock = new InterProcessSemaphoreMutex(cf, \"/curator/lock\");\n                try{\n                    cf.start();\n                    lock.acquire(); //只能调用一次，不可重入\n                    System.out.println(\"做事ing\");\n                    TimeUnit.SECONDS.sleep(5);\n                }catch (Exception e){\n                    e.printStackTrace();\n                }finally {\n                    try {\n                        lock.release();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n    }\n    executorService.awaitTermination(10,TimeUnit.MINUTES);\n}\n```\n\n### 可重入锁\n\n此锁可以重入，但是重入几次需要释放几次。\n\nInterProcessMutex通过在zookeeper的某路径节点下创建临时序列节点来实现分布式锁，即每个线程（跨进程的线程）获取同一把锁前，都需要在同样的路径下创建一个节点，节点名字由uuid + 递增序列组成。而通过对比自身的序列数是否在所有子节点的第一位，来判断是否成功获取到了锁。当获取锁失败时，它会添加watcher来监听前一个节点的变动情况，然后进行等待状态。直到watcher的事件生效将自己唤醒，或者超时时间异常返回。\n\n```java\n@Test\npublic void curtorLock002() throws InterruptedException {\n    ExecutorService executorService = Executors.newFixedThreadPool(100);\n    for(int i = 0 ; i < 10; i++){\n        executorService.submit(new Runnable() {\n            @Override\n            public void run() {\n                CuratorFramework cf = CuratorFrameworkFactory.newClient(\"localhost:2181\",new ExponentialBackoffRetry(2000,3));\n                InterProcessLock lock = new InterProcessMutex(cf, \"/curator/lock\");\n                try{\n                    cf.start();\n                    lock.acquire();\n                    lock.acquire();\n                    System.out.println(\"做事ing\");\n                    TimeUnit.SECONDS.sleep(5);\n                }catch (Exception e){\n                    e.printStackTrace();\n                }finally {\n                    try {\n                        lock.release();\n                        lock.release();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n    }\n    executorService.awaitTermination(10,TimeUnit.MINUTES);\n}\n```\n\n### 可重入读写锁 \n\nInterProcessReadWriteLock\n\n### 多个锁\n\nInterProcessMultiLock\n\n## zk分布式锁优缺点\n\n缺点：由于ZK是强一致性系统，对于写请求需要发送给leader同一协调，如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。\n\n优点：\n\n- 相对于Redis的实现方式，zk使用设置watch的方式，不会出现key过期导致业务还没执行完锁就自动失效的问题。\n- 由于Redis不是强一致性系统，在极端情况下会出现（clientA获取锁后，主redis复制数据到从redis过程中崩溃了，导致没有复制到从redis中，然后从redis选举出一个升级为主redis,造成新的主redis没有clientA 设置的锁，这是clientB尝试获取锁，并且能够成功获取锁，导致互斥失效）的问题。zk是强一致性系统，每次写操作都需要先发给leader，leader处理写请求，一半以上的从节点也写成功，才返回给客户端成功。\n\n## 参考\n\n- https://www.jianshu.com/p/6e20e65f301a\n- http://www.tianxiaobo.com/2018/01/20/%E5%9F%BA%E4%BA%8E-Zookeeper-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/\n- https://www.jianshu.com/p/7fe495c93290","source":"_posts/zookeeper-lock.md","raw":"---\ntitle: Zookeeper实现分布式锁（附代码）\ntags:\n  - zookeeper\ncategories:  zookeeper\ndescription : 详解Zookeeper实现分布式锁\ndate: 2020-08-27 17:06:06\n---\n\n\n\n\n## 什么是分布式锁\n\n在日常开发中，我们最熟悉也常用的分布式锁场景是在开发多线程的时候。为了协调本地应用上多个线程对某一资源的访问，就要对该资源或数值变量进行加锁，以保证在多线程环境下系统能够正确地运行。在一台服务器上的程序内部，线程可以通过系统进行线程之间的通信，实现加锁等操作。而在分布式环境下，执行事务的线程存在于不同的网络服务器中，要想实现在分布式网络下的线程协同操作，就要用到分布式锁。\n\n## 独占式非公平分布式锁\n\n### 概述\n\n独占式非公平锁采用的方式是通过创建节点，如果节点创建成功则表示加锁成功，如果创建不成功则需要等待并对节点(锁)设置watch。\n\n当节点(锁)释放后会触发watch的节点删除事件，从而重新抢占创建节点。\n\n![](zookeeper-lock/1.png)\n<!--more-->\n1. 多个客户端竞争创建 lock 临时节点\n2. 其中某个客户端成功创建 lock 节点，其他客户端对 lock 节点设置 watcher\n3. 持有锁的客户端删除 lock 节点或该客户端崩溃，由 Zookeeper 删除 lock 节点\n4. 其他客户端获得 lock 节点被删除的通知\n5. 重复上述4个步骤，直至无客户端在等待获取锁了\n\n### 代码实例\n\n**主代码**\n\n```java\npackage lock;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.curator.RetryPolicy;\nimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.CuratorFrameworkFactory;\nimport org.apache.curator.framework.recipes.cache.ChildData;\nimport org.apache.curator.framework.recipes.cache.NodeCache;\nimport org.apache.curator.framework.recipes.cache.NodeCacheListener;\nimport org.apache.curator.framework.state.ConnectionState;\nimport org.apache.curator.framework.state.ConnectionStateListener;\nimport org.apache.curator.retry.ExponentialBackoffRetry;\nimport org.apache.curator.utils.CloseableUtils;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.KeeperException;\n\nimport java.util.UUID;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\n/***\n * 使用zk实现分布式独占锁\n */\npublic class ZkOnlyLock {\n    private static String lockNameSpace = \"/mylock\";\n    public static String CONNECT_ADDR = \"localhost:2181\";\n    private static final ThreadLocal<String> threadUuid = new ThreadLocal<String>() {\n        @Override\n        protected String initialValue() {\n            return UUID.randomUUID().toString();\n        }\n    };\n    private CuratorFramework cf;\n    private String locakPath;\n\n    /***\n     *\n     * @param lockPath 锁路径\n     */\n    public ZkOnlyLock(String lockPath) {\n        this.locakPath = lockNameSpace + \"/\" + lockPath;\n        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n        cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();\n        cf.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n            @Override\n            public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {\n                if (connectionState == ConnectionState.LOST) {\n                    System.out.println(\"连接丢失\");//连接丢失\n                } else if (connectionState == ConnectionState.CONNECTED) {\n                    System.out.println(\"成功连接\");\n                } else if (connectionState == ConnectionState.RECONNECTED) {\n                    System.out.println(\"重连成功\");\n                }\n            }\n        });\n        cf.start();\n    }\n\n    public void lock() {\n        this.lock(0, null);\n    }\n\t\n    public void lock(long millisToWait, TimeUnit unit) {\n        boolean doDeleteOurPath = false;\n        for (;doDeleteOurPath == false;) {\n            try {\n                String path = cf.create()\n                        .creatingParentsIfNeeded() //自动创建父节点\n                        .withMode(CreateMode.PERSISTENT)\n                        .forPath(locakPath, threadUuid.get().getBytes());\n                if (StringUtils.isNoneBlank(path)) {\n                    System.out.println(\"线程\" + Thread.currentThread().getId() + \"获得锁\");\n                    break;\n                }\n            } catch (Exception e) {\n                if (e instanceof KeeperException.NodeExistsException) {\n                    //如果是已经存在节点了，则设置watch并阻塞\n                    NodeCache cache = new NodeCache(cf, locakPath);\n                    CountDownLatch countDownLatch = new CountDownLatch(1);\n                    cache.getListenable().addListener(new NodeCacheListener() {\n                        @Override\n                        public void nodeChanged() throws Exception {\n                            ChildData childData = cache.getCurrentData();\n                            if (childData == null) {\n                                System.out.println(\"===节点被删除，可以开始尝试创建===\");\n                                countDownLatch.countDown();\n                            }\n                        }\n                    });\n                    try {\n                        cache.start();\n                    } catch (Exception exception) {\n                        exception.printStackTrace();\n                    }\n                    try {\n                        if (unit != null) {\n                            countDownLatch.await(millisToWait, unit);\n                            doDeleteOurPath = true;\n                        } else {\n                            countDownLatch.await();\n                        }\n                        CloseableUtils.closeQuietly(cache);\n                    } catch (InterruptedException interruptedException) {\n                        interruptedException.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    /***\n     * 解锁\n     */\n    public void unlock() {\n        try {\n            String uuidData = new String(cf.getData().forPath(locakPath), \"UTF-8\");\n            //如果存的是同一个uuid则进行删除，否则不是自己加锁的\n            if (StringUtils.isNoneBlank(uuidData) && uuidData.equals(threadUuid.get())) {\n                cf.delete().forPath(locakPath);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            threadUuid.remove();\n        }\n    }\n}\n```\n\n**测试代码**\n\n```java\n/****\n     * 测试加锁\n     */\n    @Test\n    public void onlyLockTest1() {\n        ZkOnlyLock zkOnlyLock = new ZkOnlyLock(\"lock001\");\n        ExecutorService executorService = Executors.newFixedThreadPool(100);\n        for (int i = 0; i < 5; i++) {\n            executorService.execute(() -> {\n                try {\n                    zkOnlyLock.lock();\n                    System.out.println(\"做事ing\");\n                    try {\n                        TimeUnit.SECONDS.sleep(5);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } finally {\n                    zkOnlyLock.unlock();\n                }\n            });\n        }\n    }\n\n    /***\n     * 测试超时\n     * @throws InterruptedException\n     */\n    @Test\n    public void onlyLockTest2() throws InterruptedException {\n        ZkOnlyLock zkOnlyLock = new ZkOnlyLock(\"lock001\");\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                zkOnlyLock.lock(10,TimeUnit.SECONDS);\n                System.out.println(\"====do=====\");\n                zkOnlyLock.unlock();\n            }\n        });\n        thread.start();\n        zkOnlyLock.lock();\n        TimeUnit.SECONDS.sleep(30);\n        zkOnlyLock.unlock();\n        thread.join();\n    }\n```\n\n### 缺点\n\n这种方式的锁达不到公平的效果，每次一个锁释放后其他的锁就会同时触发watch。造成同一时间点多次请求Zookeeper。有性能问题。\n\n## 独占式公平分布式锁\n\n### 概述\n\n![](zookeeper-lock/2.png)\n\n![](zookeeper-lock/3.png)\n\n1. 所有客户端创建自己的锁节点(临时顺序节点)\n2. 从 Zookeeper 端获取 /share_lock下所有的子节点\n3. 判断自己创建的锁节点是否可以获取锁(如果是第一个就是可以获取到锁)，如果可以，持有锁。否则对自己上一个节点设置watcher\n4. 持有锁的客户端删除自己的锁节点，某个客户端收到该节点被删除的通知，并获取锁\n5. 重复步骤4，直至无客户端在等待获取锁了\n\n### 代码实例\n\n```java\npackage lock;\n\nimport com.google.common.collect.Lists;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.curator.RetryPolicy;\nimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.CuratorFrameworkFactory;\nimport org.apache.curator.framework.recipes.cache.ChildData;\nimport org.apache.curator.framework.recipes.cache.NodeCache;\nimport org.apache.curator.framework.recipes.cache.NodeCacheListener;\nimport org.apache.curator.framework.state.ConnectionState;\nimport org.apache.curator.framework.state.ConnectionStateListener;\nimport org.apache.curator.retry.ExponentialBackoffRetry;\nimport org.apache.curator.utils.CloseableUtils;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.data.Stat;\n\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\n/***\n * 分布式共享锁\n */\npublic class ZkOnlyFairLock {\n    private static String lockNameSpace = \"/mylock02\";\n    public static String CONNECT_ADDR = \"localhost:2181\";\n    private CuratorFramework cf;\n    private String locakPath;\n    private String currentLockPath;\n\n    /***\n     *\n     * @param lockPath 锁路径\n     */\n    public ZkOnlyFairLock(String lockPath) {\n        this.locakPath = lockNameSpace + \"/\" + lockPath;\n        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000000, 3);\n        cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();\n        cf.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n            @Override\n            public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {\n                if (connectionState == ConnectionState.LOST) {\n                    System.out.println(\"连接丢失\");//连接丢失\n                } else if (connectionState == ConnectionState.CONNECTED) {\n                    System.out.println(\"成功连接\");\n                } else if (connectionState == ConnectionState.RECONNECTED) {\n                    System.out.println(\"重连成功\");\n                }\n            }\n        });\n        cf.start();\n    }\n\n    /***\n     * 设置watch+等待锁\n     * @param millisToWait\n     * @param unit\n     * @param path\n     * @return\n     * @throws Exception\n     */\n    public boolean waiteLock(long millisToWait, TimeUnit unit, String path) {\n        boolean haveTheLock = false;\n        boolean doDeleteOurPath = false;\n        try {\n\n            while (!haveTheLock) {\n                List<String> childNodeList = getChildrenPath();//获取到所有的节点 [lock0000000005, lock0000000006, lock0000000007]\n                String pathName = path.substring(lockNameSpace.length() + 1);\n                int nodeIndex = childNodeList.indexOf(pathName);\n                if (nodeIndex < 0) {\n                    //节点不存在，抛出异常\n                    throw new RuntimeException(\"顺序节点不存在\");\n                }\n\n                if (nodeIndex == 0) {\n                    haveTheLock = true; //获得锁\n                    System.out.println(\"path = \" + path + \" 获得锁\");\n                } else {\n                    //如果不是第一个节点则对上一个节点做监听\n                    String preNodePath = lockNameSpace.concat(\"/\").concat(childNodeList.get(nodeIndex - 1));\n                    CountDownLatch countDownLatch = new CountDownLatch(1);\n                    //可能对上一个节点做监听时，这个节点已经被删除了\n                    NodeCache cache = new NodeCache(cf, preNodePath);\n                    //对上一个节点做监听\n                    cache.getListenable().addListener(new NodeCacheListener() {\n                        @Override\n                        public void nodeChanged() throws Exception {\n                            ChildData childData = cache.getCurrentData();\n                            if (childData == null) {\n                                countDownLatch.countDown();\n                            }\n                        }\n                    });\n                    cache.start();\n                    //再次判断下上个节点存不存在，如何存在才阻塞，防止出现节点删除后才建立监控导致一直阻塞\n                    if (isExistNode(preNodePath)) {\n                        System.out.println(\"====对path=\" + preNodePath + \" 设置watch监听，并开始阻塞 -\" + path);\n                        countDownLatch.await();\n                    } else {\n                        CloseableUtils.closeQuietly(cache);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            //异常了要删除原来的节点\n            doDeleteOurPath = true;\n        } finally {\n            if (doDeleteOurPath) {\n                deleteNode(path);\n            }\n        }\n        return haveTheLock;\n    }\n\n    public void lock() throws Exception {\n        this.lock(0, null);\n    }\n\n    /***\n     * 加锁\n     */\n    public void lock(long millisToWait, TimeUnit unit) throws Exception {\n        boolean isDone = false;\n        //加锁重试次数\n        while (!isDone) {\n            String path = createNode(); //创建顺序临时节点 path = /mylock02/lock0000000005\n            this.currentLockPath = path; //记录当前的锁节点，后面解锁要用的\n            if (StringUtils.isBlank(path)) {\n                throw new RuntimeException(\"创建顺序节点失败\");\n            }\n            if (waiteLock(millisToWait, unit, path)) {\n                isDone = true;\n            }\n        }\n    }\n\n    /***\n     * 解锁\n     */\n    public void unlock() {\n        deleteNode(this.currentLockPath);\n        CloseableUtils.closeQuietly(cf);\n    }\n\n    /***\n     * 创建顺序临时节点\n     * @return\n     * @throws Exception\n     */\n    public String createNode() {\n        String s = null;\n        try {\n            s = cf.create()\n                    .creatingParentsIfNeeded() //自动创建父节点\n                    .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)\n                    .forPath(locakPath);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n\n    /***\n     * 删除节点\n     * @param path\n     */\n    public void deleteNode(String path) {\n        try {\n            if (isExistNode(path)) {\n                cf.delete().forPath(path);\n                System.out.println(\"====\" + path + \" 删除成功\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /***\n     * 判断节点是否存在\n     * @param path\n     * @return\n     */\n    public boolean isExistNode(String path) {\n        try {\n            Stat stat = cf.checkExists().forPath(path);\n            return stat == null ? false : true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    /***\n     * 获取子节点并排序\n     * @return\n     */\n    public List<String> getChildrenPath() {\n        try {\n            List<String> strings = cf.getChildren().forPath(lockNameSpace);\n            return strings.stream().sorted().collect(Collectors.toList());\n        } catch (Exception e) {\n            e.printStackTrace();\n            return Lists.newArrayList();\n        }\n    }\n\n}\n\n```\n\n**测试代码**\n\n```java\n@Test\n    public void zkOnlyFairLock01() throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(100);\n        for(int i = 0 ; i < 100; i++){\n            executorService.submit(() -> {\n                ZkOnlyFairLock zkLock = new ZkOnlyFairLock(\"lock\");\n                try {\n                    zkLock.lock();\n                    System.out.println(\"做事ing\");\n                    TimeUnit.SECONDS.sleep(2);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }finally {\n                    zkLock.unlock();\n                }\n            });\n        }\n        executorService.awaitTermination(10,TimeUnit.MINUTES);\n    }\n```\n\n## Curator提供的分布式锁\n\nCurator是Zookeeper的一个工具类，他为我们提供了简便好用的分布式锁工具。\n\n- InterProcessMutex：分布式可重入排它锁\n- InterProcessSemaphoreMutex：分布式排它锁\n- InterProcessReadWriteLock：分布式读写锁\n- InterProcessMultiLock：将多个锁作为单个实体管理的容器\n\n### 不可重入锁\n\nInterProcessSemaphoreMutex是一种不可重入的互斥锁，也就意味着即使是同一个线程也无法在持有锁的情况下再次获得锁，所以需要注意，不可重入的锁很容易在一些情况导致死锁。\n\n```java\n@Test\npublic void curtorLock001() throws InterruptedException {\n    ExecutorService executorService = Executors.newFixedThreadPool(100);\n    for(int i = 0 ; i < 10; i++){\n        executorService.submit(new Runnable() {\n            @Override\n            public void run() {\n                CuratorFramework cf = CuratorFrameworkFactory.newClient(\"localhost:2181\",new ExponentialBackoffRetry(2000,3));\n                InterProcessLock lock = new InterProcessSemaphoreMutex(cf, \"/curator/lock\");\n                try{\n                    cf.start();\n                    lock.acquire(); //只能调用一次，不可重入\n                    System.out.println(\"做事ing\");\n                    TimeUnit.SECONDS.sleep(5);\n                }catch (Exception e){\n                    e.printStackTrace();\n                }finally {\n                    try {\n                        lock.release();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n    }\n    executorService.awaitTermination(10,TimeUnit.MINUTES);\n}\n```\n\n### 可重入锁\n\n此锁可以重入，但是重入几次需要释放几次。\n\nInterProcessMutex通过在zookeeper的某路径节点下创建临时序列节点来实现分布式锁，即每个线程（跨进程的线程）获取同一把锁前，都需要在同样的路径下创建一个节点，节点名字由uuid + 递增序列组成。而通过对比自身的序列数是否在所有子节点的第一位，来判断是否成功获取到了锁。当获取锁失败时，它会添加watcher来监听前一个节点的变动情况，然后进行等待状态。直到watcher的事件生效将自己唤醒，或者超时时间异常返回。\n\n```java\n@Test\npublic void curtorLock002() throws InterruptedException {\n    ExecutorService executorService = Executors.newFixedThreadPool(100);\n    for(int i = 0 ; i < 10; i++){\n        executorService.submit(new Runnable() {\n            @Override\n            public void run() {\n                CuratorFramework cf = CuratorFrameworkFactory.newClient(\"localhost:2181\",new ExponentialBackoffRetry(2000,3));\n                InterProcessLock lock = new InterProcessMutex(cf, \"/curator/lock\");\n                try{\n                    cf.start();\n                    lock.acquire();\n                    lock.acquire();\n                    System.out.println(\"做事ing\");\n                    TimeUnit.SECONDS.sleep(5);\n                }catch (Exception e){\n                    e.printStackTrace();\n                }finally {\n                    try {\n                        lock.release();\n                        lock.release();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n    }\n    executorService.awaitTermination(10,TimeUnit.MINUTES);\n}\n```\n\n### 可重入读写锁 \n\nInterProcessReadWriteLock\n\n### 多个锁\n\nInterProcessMultiLock\n\n## zk分布式锁优缺点\n\n缺点：由于ZK是强一致性系统，对于写请求需要发送给leader同一协调，如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。\n\n优点：\n\n- 相对于Redis的实现方式，zk使用设置watch的方式，不会出现key过期导致业务还没执行完锁就自动失效的问题。\n- 由于Redis不是强一致性系统，在极端情况下会出现（clientA获取锁后，主redis复制数据到从redis过程中崩溃了，导致没有复制到从redis中，然后从redis选举出一个升级为主redis,造成新的主redis没有clientA 设置的锁，这是clientB尝试获取锁，并且能够成功获取锁，导致互斥失效）的问题。zk是强一致性系统，每次写操作都需要先发给leader，leader处理写请求，一半以上的从节点也写成功，才返回给客户端成功。\n\n## 参考\n\n- https://www.jianshu.com/p/6e20e65f301a\n- http://www.tianxiaobo.com/2018/01/20/%E5%9F%BA%E4%BA%8E-Zookeeper-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/\n- https://www.jianshu.com/p/7fe495c93290","slug":"zookeeper-lock","published":1,"updated":"2021-04-08T00:47:07.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn9yvhw80050qwv22sdp6hlv","content":"<h2 id=\"什么是分布式锁\"><a href=\"#什么是分布式锁\" class=\"headerlink\" title=\"什么是分布式锁\"></a>什么是分布式锁</h2><p>在日常开发中，我们最熟悉也常用的分布式锁场景是在开发多线程的时候。为了协调本地应用上多个线程对某一资源的访问，就要对该资源或数值变量进行加锁，以保证在多线程环境下系统能够正确地运行。在一台服务器上的程序内部，线程可以通过系统进行线程之间的通信，实现加锁等操作。而在分布式环境下，执行事务的线程存在于不同的网络服务器中，要想实现在分布式网络下的线程协同操作，就要用到分布式锁。</p>\n<h2 id=\"独占式非公平分布式锁\"><a href=\"#独占式非公平分布式锁\" class=\"headerlink\" title=\"独占式非公平分布式锁\"></a>独占式非公平分布式锁</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>独占式非公平锁采用的方式是通过创建节点，如果节点创建成功则表示加锁成功，如果创建不成功则需要等待并对节点(锁)设置watch。</p>\n<p>当节点(锁)释放后会触发watch的节点删除事件，从而重新抢占创建节点。</p>\n<p><img src=\"/2020/08/27/zookeeper-lock/1.png\" alt></p>\n<a id=\"more\"></a>\n<ol>\n<li>多个客户端竞争创建 lock 临时节点</li>\n<li>其中某个客户端成功创建 lock 节点，其他客户端对 lock 节点设置 watcher</li>\n<li>持有锁的客户端删除 lock 节点或该客户端崩溃，由 Zookeeper 删除 lock 节点</li>\n<li>其他客户端获得 lock 节点被删除的通知</li>\n<li>重复上述4个步骤，直至无客户端在等待获取锁了</li>\n</ol>\n<h3 id=\"代码实例\"><a href=\"#代码实例\" class=\"headerlink\" title=\"代码实例\"></a>代码实例</h3><p><strong>主代码</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> lock<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>commons<span class=\"token punctuation\">.</span>lang3<span class=\"token punctuation\">.</span>StringUtils<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>RetryPolicy<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>CuratorFramework<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>CuratorFrameworkFactory<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>recipes<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>ChildData<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>recipes<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>NodeCache<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>recipes<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>NodeCacheListener<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>ConnectionState<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>ConnectionStateListener<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>retry<span class=\"token punctuation\">.</span>ExponentialBackoffRetry<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>CloseableUtils<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>zookeeper<span class=\"token punctuation\">.</span>CreateMode<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>zookeeper<span class=\"token punctuation\">.</span>KeeperException<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>UUID<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>CountDownLatch<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/***\n * 使用zk实现分布式独占锁\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ZkOnlyLock</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> String lockNameSpace <span class=\"token operator\">=</span> <span class=\"token string\">\"/mylock\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String CONNECT_ADDR <span class=\"token operator\">=</span> <span class=\"token string\">\"localhost:2181\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> ThreadLocal<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> threadUuid <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadLocal</span><span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token annotation punctuation\">@Override</span>\n        <span class=\"token keyword\">protected</span> String <span class=\"token function\">initialValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> CuratorFramework cf<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> String locakPath<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     *\n     * @param lockPath 锁路径\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ZkOnlyLock</span><span class=\"token punctuation\">(</span>String lockPath<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>locakPath <span class=\"token operator\">=</span> lockNameSpace <span class=\"token operator\">+</span> <span class=\"token string\">\"/\"</span> <span class=\"token operator\">+</span> lockPath<span class=\"token punctuation\">;</span>\n        RetryPolicy retryPolicy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ExponentialBackoffRetry</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cf <span class=\"token operator\">=</span> CuratorFrameworkFactory<span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">connectString</span><span class=\"token punctuation\">(</span>CONNECT_ADDR<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">sessionTimeoutMs</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">connectionTimeoutMs</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">retryPolicy</span><span class=\"token punctuation\">(</span>retryPolicy<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cf<span class=\"token punctuation\">.</span><span class=\"token function\">getConnectionStateListenable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ConnectionStateListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stateChanged</span><span class=\"token punctuation\">(</span>CuratorFramework curatorFramework<span class=\"token punctuation\">,</span> ConnectionState connectionState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>connectionState <span class=\"token operator\">==</span> ConnectionState<span class=\"token punctuation\">.</span>LOST<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"连接丢失\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//连接丢失</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>connectionState <span class=\"token operator\">==</span> ConnectionState<span class=\"token punctuation\">.</span>CONNECTED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"成功连接\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>connectionState <span class=\"token operator\">==</span> ConnectionState<span class=\"token punctuation\">.</span>RECONNECTED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"重连成功\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cf<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> millisToWait<span class=\"token punctuation\">,</span> TimeUnit unit<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">boolean</span> doDeleteOurPath <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span>doDeleteOurPath <span class=\"token operator\">==</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                String path <span class=\"token operator\">=</span> cf<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                        <span class=\"token punctuation\">.</span><span class=\"token function\">creatingParentsIfNeeded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//自动创建父节点</span>\n                        <span class=\"token punctuation\">.</span><span class=\"token function\">withMode</span><span class=\"token punctuation\">(</span>CreateMode<span class=\"token punctuation\">.</span>PERSISTENT<span class=\"token punctuation\">)</span>\n                        <span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span>locakPath<span class=\"token punctuation\">,</span> threadUuid<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getBytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>StringUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isNoneBlank</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"线程\"</span> <span class=\"token operator\">+</span> Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"获得锁\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">KeeperException<span class=\"token punctuation\">.</span>NodeExistsException</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//如果是已经存在节点了，则设置watch并阻塞</span>\n                    NodeCache cache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NodeCache</span><span class=\"token punctuation\">(</span>cf<span class=\"token punctuation\">,</span> locakPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    CountDownLatch countDownLatch <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CountDownLatch</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    cache<span class=\"token punctuation\">.</span><span class=\"token function\">getListenable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">NodeCacheListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token annotation punctuation\">@Override</span>\n                        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">nodeChanged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n                            ChildData childData <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">getCurrentData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childData <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"===节点被删除，可以开始尝试创建===\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                                countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">countDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        cache<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> exception<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        exception<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>unit <span class=\"token operator\">!=</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                            countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span>millisToWait<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            doDeleteOurPath <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                            countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        <span class=\"token punctuation\">}</span>\n                        CloseableUtils<span class=\"token punctuation\">.</span><span class=\"token function\">closeQuietly</span><span class=\"token punctuation\">(</span>cache<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> interruptedException<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        interruptedException<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 解锁\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            String uuidData <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>cf<span class=\"token punctuation\">.</span><span class=\"token function\">getData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span>locakPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"UTF-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">//如果存的是同一个uuid则进行删除，否则不是自己加锁的</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>StringUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isNoneBlank</span><span class=\"token punctuation\">(</span>uuidData<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> uuidData<span class=\"token punctuation\">.</span><span class=\"token function\">equals</span><span class=\"token punctuation\">(</span>threadUuid<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                cf<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span>locakPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            threadUuid<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>测试代码</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/****\n     * 测试加锁\n     */</span>\n    <span class=\"token annotation punctuation\">@Test</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onlyLockTest1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ZkOnlyLock zkOnlyLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ZkOnlyLock</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lock001\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ExecutorService executorService <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            executorService<span class=\"token punctuation\">.</span><span class=\"token function\">execute</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    zkOnlyLock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"做事ing\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                    zkOnlyLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 测试超时\n     * @throws InterruptedException\n     */</span>\n    <span class=\"token annotation punctuation\">@Test</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">onlyLockTest2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        ZkOnlyLock zkOnlyLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ZkOnlyLock</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lock001\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        Thread thread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                zkOnlyLock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span>TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"====do=====\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                zkOnlyLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        zkOnlyLock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">30</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        zkOnlyLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        thread<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>这种方式的锁达不到公平的效果，每次一个锁释放后其他的锁就会同时触发watch。造成同一时间点多次请求Zookeeper。有性能问题。</p>\n<h2 id=\"独占式公平分布式锁\"><a href=\"#独占式公平分布式锁\" class=\"headerlink\" title=\"独占式公平分布式锁\"></a>独占式公平分布式锁</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><img src=\"/2020/08/27/zookeeper-lock/2.png\" alt></p>\n<p><img src=\"/2020/08/27/zookeeper-lock/3.png\" alt></p>\n<ol>\n<li>所有客户端创建自己的锁节点(临时顺序节点)</li>\n<li>从 Zookeeper 端获取 /share_lock下所有的子节点</li>\n<li>判断自己创建的锁节点是否可以获取锁(如果是第一个就是可以获取到锁)，如果可以，持有锁。否则对自己上一个节点设置watcher</li>\n<li>持有锁的客户端删除自己的锁节点，某个客户端收到该节点被删除的通知，并获取锁</li>\n<li>重复步骤4，直至无客户端在等待获取锁了</li>\n</ol>\n<h3 id=\"代码实例-1\"><a href=\"#代码实例-1\" class=\"headerlink\" title=\"代码实例\"></a>代码实例</h3><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">package</span> lock<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> com<span class=\"token punctuation\">.</span>google<span class=\"token punctuation\">.</span>common<span class=\"token punctuation\">.</span>collect<span class=\"token punctuation\">.</span>Lists<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>commons<span class=\"token punctuation\">.</span>lang3<span class=\"token punctuation\">.</span>StringUtils<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>RetryPolicy<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>CuratorFramework<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>CuratorFrameworkFactory<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>recipes<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>ChildData<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>recipes<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>NodeCache<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>recipes<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>NodeCacheListener<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>ConnectionState<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>framework<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>ConnectionStateListener<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>retry<span class=\"token punctuation\">.</span>ExponentialBackoffRetry<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>curator<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>CloseableUtils<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>zookeeper<span class=\"token punctuation\">.</span>CreateMode<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> org<span class=\"token punctuation\">.</span>apache<span class=\"token punctuation\">.</span>zookeeper<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>Stat<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>List<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>CountDownLatch<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>concurrent<span class=\"token punctuation\">.</span>TimeUnit<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> java<span class=\"token punctuation\">.</span>util<span class=\"token punctuation\">.</span>stream<span class=\"token punctuation\">.</span>Collectors<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/***\n * 分布式共享锁\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ZkOnlyFairLock</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> String lockNameSpace <span class=\"token operator\">=</span> <span class=\"token string\">\"/mylock02\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> String CONNECT_ADDR <span class=\"token operator\">=</span> <span class=\"token string\">\"localhost:2181\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> CuratorFramework cf<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> String locakPath<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> String currentLockPath<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     *\n     * @param lockPath 锁路径\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">ZkOnlyFairLock</span><span class=\"token punctuation\">(</span>String lockPath<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>locakPath <span class=\"token operator\">=</span> lockNameSpace <span class=\"token operator\">+</span> <span class=\"token string\">\"/\"</span> <span class=\"token operator\">+</span> lockPath<span class=\"token punctuation\">;</span>\n        RetryPolicy retryPolicy <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ExponentialBackoffRetry</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cf <span class=\"token operator\">=</span> CuratorFrameworkFactory<span class=\"token punctuation\">.</span><span class=\"token function\">builder</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">connectString</span><span class=\"token punctuation\">(</span>CONNECT_ADDR<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">sessionTimeoutMs</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">connectionTimeoutMs</span><span class=\"token punctuation\">(</span><span class=\"token number\">5000</span><span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">retryPolicy</span><span class=\"token punctuation\">(</span>retryPolicy<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">.</span><span class=\"token function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cf<span class=\"token punctuation\">.</span><span class=\"token function\">getConnectionStateListenable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ConnectionStateListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stateChanged</span><span class=\"token punctuation\">(</span>CuratorFramework curatorFramework<span class=\"token punctuation\">,</span> ConnectionState connectionState<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>connectionState <span class=\"token operator\">==</span> ConnectionState<span class=\"token punctuation\">.</span>LOST<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"连接丢失\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//连接丢失</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>connectionState <span class=\"token operator\">==</span> ConnectionState<span class=\"token punctuation\">.</span>CONNECTED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"成功连接\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>connectionState <span class=\"token operator\">==</span> ConnectionState<span class=\"token punctuation\">.</span>RECONNECTED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"重连成功\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        cf<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 设置watch+等待锁\n     * @param millisToWait\n     * @param unit\n     * @param path\n     * @return\n     * @throws Exception\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">waiteLock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> millisToWait<span class=\"token punctuation\">,</span> TimeUnit unit<span class=\"token punctuation\">,</span> String path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">boolean</span> haveTheLock <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">boolean</span> doDeleteOurPath <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>haveTheLock<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> childNodeList <span class=\"token operator\">=</span> <span class=\"token function\">getChildrenPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//获取到所有的节点 [lock0000000005, lock0000000006, lock0000000007]</span>\n                String pathName <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span>lockNameSpace<span class=\"token punctuation\">.</span><span class=\"token function\">length</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">int</span> nodeIndex <span class=\"token operator\">=</span> childNodeList<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>pathName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nodeIndex <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//节点不存在，抛出异常</span>\n                    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"顺序节点不存在\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nodeIndex <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    haveTheLock <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//获得锁</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"path = \"</span> <span class=\"token operator\">+</span> path <span class=\"token operator\">+</span> <span class=\"token string\">\" 获得锁\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//如果不是第一个节点则对上一个节点做监听</span>\n                    String preNodePath <span class=\"token operator\">=</span> lockNameSpace<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>childNodeList<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>nodeIndex <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    CountDownLatch countDownLatch <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CountDownLatch</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//可能对上一个节点做监听时，这个节点已经被删除了</span>\n                    NodeCache cache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NodeCache</span><span class=\"token punctuation\">(</span>cf<span class=\"token punctuation\">,</span> preNodePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//对上一个节点做监听</span>\n                    cache<span class=\"token punctuation\">.</span><span class=\"token function\">getListenable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">addListener</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">NodeCacheListener</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token annotation punctuation\">@Override</span>\n                        <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">nodeChanged</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n                            ChildData childData <span class=\"token operator\">=</span> cache<span class=\"token punctuation\">.</span><span class=\"token function\">getCurrentData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>childData <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                                countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">countDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                            <span class=\"token punctuation\">}</span>\n                        <span class=\"token punctuation\">}</span>\n                    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    cache<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token comment\" spellcheck=\"true\">//再次判断下上个节点存不存在，如何存在才阻塞，防止出现节点删除后才建立监控导致一直阻塞</span>\n                    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isExistNode</span><span class=\"token punctuation\">(</span>preNodePath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"====对path=\"</span> <span class=\"token operator\">+</span> preNodePath <span class=\"token operator\">+</span> <span class=\"token string\">\" 设置watch监听，并开始阻塞 -\"</span> <span class=\"token operator\">+</span> path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        countDownLatch<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                        CloseableUtils<span class=\"token punctuation\">.</span><span class=\"token function\">closeQuietly</span><span class=\"token punctuation\">(</span>cache<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">//异常了要删除原来的节点</span>\n            doDeleteOurPath <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>doDeleteOurPath<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token function\">deleteNode</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> haveTheLock<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 加锁\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">long</span> millisToWait<span class=\"token punctuation\">,</span> TimeUnit unit<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Exception <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">boolean</span> isDone <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//加锁重试次数</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isDone<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            String path <span class=\"token operator\">=</span> <span class=\"token function\">createNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//创建顺序临时节点 path = /mylock02/lock0000000005</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentLockPath <span class=\"token operator\">=</span> path<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//记录当前的锁节点，后面解锁要用的</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>StringUtils<span class=\"token punctuation\">.</span><span class=\"token function\">isBlank</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"创建顺序节点失败\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">waiteLock</span><span class=\"token punctuation\">(</span>millisToWait<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">,</span> path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                isDone <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 解锁\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">deleteNode</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>currentLockPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        CloseableUtils<span class=\"token punctuation\">.</span><span class=\"token function\">closeQuietly</span><span class=\"token punctuation\">(</span>cf<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 创建顺序临时节点\n     * @return\n     * @throws Exception\n     */</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">createNode</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        String s <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            s <span class=\"token operator\">=</span> cf<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">creatingParentsIfNeeded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//自动创建父节点</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">withMode</span><span class=\"token punctuation\">(</span>CreateMode<span class=\"token punctuation\">.</span>EPHEMERAL_SEQUENTIAL<span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span>locakPath<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 删除节点\n     * @param path\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">deleteNode</span><span class=\"token punctuation\">(</span>String path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">isExistNode</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                cf<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"====\"</span> <span class=\"token operator\">+</span> path <span class=\"token operator\">+</span> <span class=\"token string\">\" 删除成功\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 判断节点是否存在\n     * @param path\n     * @return\n     */</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">isExistNode</span><span class=\"token punctuation\">(</span>String path<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            Stat stat <span class=\"token operator\">=</span> cf<span class=\"token punctuation\">.</span><span class=\"token function\">checkExists</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span>path<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> stat <span class=\"token operator\">==</span> null <span class=\"token operator\">?</span> <span class=\"token boolean\">false</span> <span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">/***\n     * 获取子节点并排序\n     * @return\n     */</span>\n    <span class=\"token keyword\">public</span> List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token function\">getChildrenPath</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> strings <span class=\"token operator\">=</span> cf<span class=\"token punctuation\">.</span><span class=\"token function\">getChildren</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forPath</span><span class=\"token punctuation\">(</span>lockNameSpace<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> strings<span class=\"token punctuation\">.</span><span class=\"token function\">stream</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">sorted</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">collect</span><span class=\"token punctuation\">(</span>Collectors<span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> Lists<span class=\"token punctuation\">.</span><span class=\"token function\">newArrayList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p><strong>测试代码</strong></p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">zkOnlyFairLock01</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        ExecutorService executorService <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                ZkOnlyFairLock zkLock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ZkOnlyFairLock</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lock\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    zkLock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"做事ing\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                    zkLock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">awaitTermination</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span>TimeUnit<span class=\"token punctuation\">.</span>MINUTES<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"Curator提供的分布式锁\"><a href=\"#Curator提供的分布式锁\" class=\"headerlink\" title=\"Curator提供的分布式锁\"></a>Curator提供的分布式锁</h2><p>Curator是Zookeeper的一个工具类，他为我们提供了简便好用的分布式锁工具。</p>\n<ul>\n<li>InterProcessMutex：分布式可重入排它锁</li>\n<li>InterProcessSemaphoreMutex：分布式排它锁</li>\n<li>InterProcessReadWriteLock：分布式读写锁</li>\n<li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li>\n</ul>\n<h3 id=\"不可重入锁\"><a href=\"#不可重入锁\" class=\"headerlink\" title=\"不可重入锁\"></a>不可重入锁</h3><p>InterProcessSemaphoreMutex是一种不可重入的互斥锁，也就意味着即使是同一个线程也无法在持有锁的情况下再次获得锁，所以需要注意，不可重入的锁很容易在一些情况导致死锁。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">curtorLock001</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    ExecutorService executorService <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                CuratorFramework cf <span class=\"token operator\">=</span> CuratorFrameworkFactory<span class=\"token punctuation\">.</span><span class=\"token function\">newClient</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"localhost:2181\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ExponentialBackoffRetry</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                InterProcessLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterProcessSemaphoreMutex</span><span class=\"token punctuation\">(</span>cf<span class=\"token punctuation\">,</span> <span class=\"token string\">\"/curator/lock\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n                    cf<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    lock<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//只能调用一次，不可重入</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"做事ing\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        lock<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">awaitTermination</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span>TimeUnit<span class=\"token punctuation\">.</span>MINUTES<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"可重入锁\"><a href=\"#可重入锁\" class=\"headerlink\" title=\"可重入锁\"></a>可重入锁</h3><p>此锁可以重入，但是重入几次需要释放几次。</p>\n<p>InterProcessMutex通过在zookeeper的某路径节点下创建临时序列节点来实现分布式锁，即每个线程（跨进程的线程）获取同一把锁前，都需要在同样的路径下创建一个节点，节点名字由uuid + 递增序列组成。而通过对比自身的序列数是否在所有子节点的第一位，来判断是否成功获取到了锁。当获取锁失败时，它会添加watcher来监听前一个节点的变动情况，然后进行等待状态。直到watcher的事件生效将自己唤醒，或者超时时间异常返回。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Test</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">curtorLock002</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n    ExecutorService executorService <span class=\"token operator\">=</span> Executors<span class=\"token punctuation\">.</span><span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        executorService<span class=\"token punctuation\">.</span><span class=\"token function\">submit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                CuratorFramework cf <span class=\"token operator\">=</span> CuratorFrameworkFactory<span class=\"token punctuation\">.</span><span class=\"token function\">newClient</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"localhost:2181\"</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ExponentialBackoffRetry</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                InterProcessLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">InterProcessMutex</span><span class=\"token punctuation\">(</span>cf<span class=\"token punctuation\">,</span> <span class=\"token string\">\"/curator/lock\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n                    cf<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    lock<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    lock<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"做事ing\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                        lock<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        lock<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    executorService<span class=\"token punctuation\">.</span><span class=\"token function\">awaitTermination</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">,</span>TimeUnit<span class=\"token punctuation\">.</span>MINUTES<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"可重入读写锁\"><a href=\"#可重入读写锁\" class=\"headerlink\" title=\"可重入读写锁\"></a>可重入读写锁</h3><p>InterProcessReadWriteLock</p>\n<h3 id=\"多个锁\"><a href=\"#多个锁\" class=\"headerlink\" title=\"多个锁\"></a>多个锁</h3><p>InterProcessMultiLock</p>\n<h2 id=\"zk分布式锁优缺点\"><a href=\"#zk分布式锁优缺点\" class=\"headerlink\" title=\"zk分布式锁优缺点\"></a>zk分布式锁优缺点</h2><p>缺点：由于ZK是强一致性系统，对于写请求需要发送给leader同一协调，如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。</p>\n<p>优点：</p>\n<ul>\n<li>相对于Redis的实现方式，zk使用设置watch的方式，不会出现key过期导致业务还没执行完锁就自动失效的问题。</li>\n<li>由于Redis不是强一致性系统，在极端情况下会出现（clientA获取锁后，主redis复制数据到从redis过程中崩溃了，导致没有复制到从redis中，然后从redis选举出一个升级为主redis,造成新的主redis没有clientA 设置的锁，这是clientB尝试获取锁，并且能够成功获取锁，导致互斥失效）的问题。zk是强一致性系统，每次写操作都需要先发给leader，leader处理写请求，一半以上的从节点也写成功，才返回给客户端成功。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/6e20e65f301a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/6e20e65f301a</a></li>\n<li><a href=\"http://www.tianxiaobo.com/2018/01/20/%E5%9F%BA%E4%BA%8E-Zookeeper-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">http://www.tianxiaobo.com/2018/01/20/%E5%9F%BA%E4%BA%8E-Zookeeper-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/</a></li>\n<li><a href=\"https://www.jianshu.com/p/7fe495c93290\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7fe495c93290</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"什么是分布式锁\"><a href=\"#什么是分布式锁\" class=\"headerlink\" title=\"什么是分布式锁\"></a>什么是分布式锁</h2><p>在日常开发中，我们最熟悉也常用的分布式锁场景是在开发多线程的时候。为了协调本地应用上多个线程对某一资源的访问，就要对该资源或数值变量进行加锁，以保证在多线程环境下系统能够正确地运行。在一台服务器上的程序内部，线程可以通过系统进行线程之间的通信，实现加锁等操作。而在分布式环境下，执行事务的线程存在于不同的网络服务器中，要想实现在分布式网络下的线程协同操作，就要用到分布式锁。</p>\n<h2 id=\"独占式非公平分布式锁\"><a href=\"#独占式非公平分布式锁\" class=\"headerlink\" title=\"独占式非公平分布式锁\"></a>独占式非公平分布式锁</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>独占式非公平锁采用的方式是通过创建节点，如果节点创建成功则表示加锁成功，如果创建不成功则需要等待并对节点(锁)设置watch。</p>\n<p>当节点(锁)释放后会触发watch的节点删除事件，从而重新抢占创建节点。</p>\n<p><img src=\"/2020/08/27/zookeeper-lock/1.png\" alt></p>","more":"<ol>\n<li>多个客户端竞争创建 lock 临时节点</li>\n<li>其中某个客户端成功创建 lock 节点，其他客户端对 lock 节点设置 watcher</li>\n<li>持有锁的客户端删除 lock 节点或该客户端崩溃，由 Zookeeper 删除 lock 节点</li>\n<li>其他客户端获得 lock 节点被删除的通知</li>\n<li>重复上述4个步骤，直至无客户端在等待获取锁了</li>\n</ol>\n<h3 id=\"代码实例\"><a href=\"#代码实例\" class=\"headerlink\" title=\"代码实例\"></a>代码实例</h3><p><strong>主代码</strong></p>\n<pre><code class=\"java\">package lock;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.curator.RetryPolicy;\nimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.CuratorFrameworkFactory;\nimport org.apache.curator.framework.recipes.cache.ChildData;\nimport org.apache.curator.framework.recipes.cache.NodeCache;\nimport org.apache.curator.framework.recipes.cache.NodeCacheListener;\nimport org.apache.curator.framework.state.ConnectionState;\nimport org.apache.curator.framework.state.ConnectionStateListener;\nimport org.apache.curator.retry.ExponentialBackoffRetry;\nimport org.apache.curator.utils.CloseableUtils;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.KeeperException;\n\nimport java.util.UUID;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\n\n/***\n * 使用zk实现分布式独占锁\n */\npublic class ZkOnlyLock {\n    private static String lockNameSpace = &quot;/mylock&quot;;\n    public static String CONNECT_ADDR = &quot;localhost:2181&quot;;\n    private static final ThreadLocal&lt;String&gt; threadUuid = new ThreadLocal&lt;String&gt;() {\n        @Override\n        protected String initialValue() {\n            return UUID.randomUUID().toString();\n        }\n    };\n    private CuratorFramework cf;\n    private String locakPath;\n\n    /***\n     *\n     * @param lockPath 锁路径\n     */\n    public ZkOnlyLock(String lockPath) {\n        this.locakPath = lockNameSpace + &quot;/&quot; + lockPath;\n        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n        cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();\n        cf.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n            @Override\n            public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {\n                if (connectionState == ConnectionState.LOST) {\n                    System.out.println(&quot;连接丢失&quot;);//连接丢失\n                } else if (connectionState == ConnectionState.CONNECTED) {\n                    System.out.println(&quot;成功连接&quot;);\n                } else if (connectionState == ConnectionState.RECONNECTED) {\n                    System.out.println(&quot;重连成功&quot;);\n                }\n            }\n        });\n        cf.start();\n    }\n\n    public void lock() {\n        this.lock(0, null);\n    }\n\n    public void lock(long millisToWait, TimeUnit unit) {\n        boolean doDeleteOurPath = false;\n        for (;doDeleteOurPath == false;) {\n            try {\n                String path = cf.create()\n                        .creatingParentsIfNeeded() //自动创建父节点\n                        .withMode(CreateMode.PERSISTENT)\n                        .forPath(locakPath, threadUuid.get().getBytes());\n                if (StringUtils.isNoneBlank(path)) {\n                    System.out.println(&quot;线程&quot; + Thread.currentThread().getId() + &quot;获得锁&quot;);\n                    break;\n                }\n            } catch (Exception e) {\n                if (e instanceof KeeperException.NodeExistsException) {\n                    //如果是已经存在节点了，则设置watch并阻塞\n                    NodeCache cache = new NodeCache(cf, locakPath);\n                    CountDownLatch countDownLatch = new CountDownLatch(1);\n                    cache.getListenable().addListener(new NodeCacheListener() {\n                        @Override\n                        public void nodeChanged() throws Exception {\n                            ChildData childData = cache.getCurrentData();\n                            if (childData == null) {\n                                System.out.println(&quot;===节点被删除，可以开始尝试创建===&quot;);\n                                countDownLatch.countDown();\n                            }\n                        }\n                    });\n                    try {\n                        cache.start();\n                    } catch (Exception exception) {\n                        exception.printStackTrace();\n                    }\n                    try {\n                        if (unit != null) {\n                            countDownLatch.await(millisToWait, unit);\n                            doDeleteOurPath = true;\n                        } else {\n                            countDownLatch.await();\n                        }\n                        CloseableUtils.closeQuietly(cache);\n                    } catch (InterruptedException interruptedException) {\n                        interruptedException.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    /***\n     * 解锁\n     */\n    public void unlock() {\n        try {\n            String uuidData = new String(cf.getData().forPath(locakPath), &quot;UTF-8&quot;);\n            //如果存的是同一个uuid则进行删除，否则不是自己加锁的\n            if (StringUtils.isNoneBlank(uuidData) &amp;&amp; uuidData.equals(threadUuid.get())) {\n                cf.delete().forPath(locakPath);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            threadUuid.remove();\n        }\n    }\n}</code></pre>\n<p><strong>测试代码</strong></p>\n<pre><code class=\"java\">/****\n     * 测试加锁\n     */\n    @Test\n    public void onlyLockTest1() {\n        ZkOnlyLock zkOnlyLock = new ZkOnlyLock(&quot;lock001&quot;);\n        ExecutorService executorService = Executors.newFixedThreadPool(100);\n        for (int i = 0; i &lt; 5; i++) {\n            executorService.execute(() -&gt; {\n                try {\n                    zkOnlyLock.lock();\n                    System.out.println(&quot;做事ing&quot;);\n                    try {\n                        TimeUnit.SECONDS.sleep(5);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } finally {\n                    zkOnlyLock.unlock();\n                }\n            });\n        }\n    }\n\n    /***\n     * 测试超时\n     * @throws InterruptedException\n     */\n    @Test\n    public void onlyLockTest2() throws InterruptedException {\n        ZkOnlyLock zkOnlyLock = new ZkOnlyLock(&quot;lock001&quot;);\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                zkOnlyLock.lock(10,TimeUnit.SECONDS);\n                System.out.println(&quot;====do=====&quot;);\n                zkOnlyLock.unlock();\n            }\n        });\n        thread.start();\n        zkOnlyLock.lock();\n        TimeUnit.SECONDS.sleep(30);\n        zkOnlyLock.unlock();\n        thread.join();\n    }</code></pre>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>这种方式的锁达不到公平的效果，每次一个锁释放后其他的锁就会同时触发watch。造成同一时间点多次请求Zookeeper。有性能问题。</p>\n<h2 id=\"独占式公平分布式锁\"><a href=\"#独占式公平分布式锁\" class=\"headerlink\" title=\"独占式公平分布式锁\"></a>独占式公平分布式锁</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p><img src=\"/2020/08/27/zookeeper-lock/2.png\" alt></p>\n<p><img src=\"/2020/08/27/zookeeper-lock/3.png\" alt></p>\n<ol>\n<li>所有客户端创建自己的锁节点(临时顺序节点)</li>\n<li>从 Zookeeper 端获取 /share_lock下所有的子节点</li>\n<li>判断自己创建的锁节点是否可以获取锁(如果是第一个就是可以获取到锁)，如果可以，持有锁。否则对自己上一个节点设置watcher</li>\n<li>持有锁的客户端删除自己的锁节点，某个客户端收到该节点被删除的通知，并获取锁</li>\n<li>重复步骤4，直至无客户端在等待获取锁了</li>\n</ol>\n<h3 id=\"代码实例-1\"><a href=\"#代码实例-1\" class=\"headerlink\" title=\"代码实例\"></a>代码实例</h3><pre><code class=\"java\">package lock;\n\nimport com.google.common.collect.Lists;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.curator.RetryPolicy;\nimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.CuratorFrameworkFactory;\nimport org.apache.curator.framework.recipes.cache.ChildData;\nimport org.apache.curator.framework.recipes.cache.NodeCache;\nimport org.apache.curator.framework.recipes.cache.NodeCacheListener;\nimport org.apache.curator.framework.state.ConnectionState;\nimport org.apache.curator.framework.state.ConnectionStateListener;\nimport org.apache.curator.retry.ExponentialBackoffRetry;\nimport org.apache.curator.utils.CloseableUtils;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.data.Stat;\n\nimport java.util.List;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\n/***\n * 分布式共享锁\n */\npublic class ZkOnlyFairLock {\n    private static String lockNameSpace = &quot;/mylock02&quot;;\n    public static String CONNECT_ADDR = &quot;localhost:2181&quot;;\n    private CuratorFramework cf;\n    private String locakPath;\n    private String currentLockPath;\n\n    /***\n     *\n     * @param lockPath 锁路径\n     */\n    public ZkOnlyFairLock(String lockPath) {\n        this.locakPath = lockNameSpace + &quot;/&quot; + lockPath;\n        RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000000, 3);\n        cf = CuratorFrameworkFactory.builder()\n                .connectString(CONNECT_ADDR)\n                .sessionTimeoutMs(5000)\n                .connectionTimeoutMs(5000)\n                .retryPolicy(retryPolicy)\n                .build();\n        cf.getConnectionStateListenable().addListener(new ConnectionStateListener() {\n            @Override\n            public void stateChanged(CuratorFramework curatorFramework, ConnectionState connectionState) {\n                if (connectionState == ConnectionState.LOST) {\n                    System.out.println(&quot;连接丢失&quot;);//连接丢失\n                } else if (connectionState == ConnectionState.CONNECTED) {\n                    System.out.println(&quot;成功连接&quot;);\n                } else if (connectionState == ConnectionState.RECONNECTED) {\n                    System.out.println(&quot;重连成功&quot;);\n                }\n            }\n        });\n        cf.start();\n    }\n\n    /***\n     * 设置watch+等待锁\n     * @param millisToWait\n     * @param unit\n     * @param path\n     * @return\n     * @throws Exception\n     */\n    public boolean waiteLock(long millisToWait, TimeUnit unit, String path) {\n        boolean haveTheLock = false;\n        boolean doDeleteOurPath = false;\n        try {\n\n            while (!haveTheLock) {\n                List&lt;String&gt; childNodeList = getChildrenPath();//获取到所有的节点 [lock0000000005, lock0000000006, lock0000000007]\n                String pathName = path.substring(lockNameSpace.length() + 1);\n                int nodeIndex = childNodeList.indexOf(pathName);\n                if (nodeIndex &lt; 0) {\n                    //节点不存在，抛出异常\n                    throw new RuntimeException(&quot;顺序节点不存在&quot;);\n                }\n\n                if (nodeIndex == 0) {\n                    haveTheLock = true; //获得锁\n                    System.out.println(&quot;path = &quot; + path + &quot; 获得锁&quot;);\n                } else {\n                    //如果不是第一个节点则对上一个节点做监听\n                    String preNodePath = lockNameSpace.concat(&quot;/&quot;).concat(childNodeList.get(nodeIndex - 1));\n                    CountDownLatch countDownLatch = new CountDownLatch(1);\n                    //可能对上一个节点做监听时，这个节点已经被删除了\n                    NodeCache cache = new NodeCache(cf, preNodePath);\n                    //对上一个节点做监听\n                    cache.getListenable().addListener(new NodeCacheListener() {\n                        @Override\n                        public void nodeChanged() throws Exception {\n                            ChildData childData = cache.getCurrentData();\n                            if (childData == null) {\n                                countDownLatch.countDown();\n                            }\n                        }\n                    });\n                    cache.start();\n                    //再次判断下上个节点存不存在，如何存在才阻塞，防止出现节点删除后才建立监控导致一直阻塞\n                    if (isExistNode(preNodePath)) {\n                        System.out.println(&quot;====对path=&quot; + preNodePath + &quot; 设置watch监听，并开始阻塞 -&quot; + path);\n                        countDownLatch.await();\n                    } else {\n                        CloseableUtils.closeQuietly(cache);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            //异常了要删除原来的节点\n            doDeleteOurPath = true;\n        } finally {\n            if (doDeleteOurPath) {\n                deleteNode(path);\n            }\n        }\n        return haveTheLock;\n    }\n\n    public void lock() throws Exception {\n        this.lock(0, null);\n    }\n\n    /***\n     * 加锁\n     */\n    public void lock(long millisToWait, TimeUnit unit) throws Exception {\n        boolean isDone = false;\n        //加锁重试次数\n        while (!isDone) {\n            String path = createNode(); //创建顺序临时节点 path = /mylock02/lock0000000005\n            this.currentLockPath = path; //记录当前的锁节点，后面解锁要用的\n            if (StringUtils.isBlank(path)) {\n                throw new RuntimeException(&quot;创建顺序节点失败&quot;);\n            }\n            if (waiteLock(millisToWait, unit, path)) {\n                isDone = true;\n            }\n        }\n    }\n\n    /***\n     * 解锁\n     */\n    public void unlock() {\n        deleteNode(this.currentLockPath);\n        CloseableUtils.closeQuietly(cf);\n    }\n\n    /***\n     * 创建顺序临时节点\n     * @return\n     * @throws Exception\n     */\n    public String createNode() {\n        String s = null;\n        try {\n            s = cf.create()\n                    .creatingParentsIfNeeded() //自动创建父节点\n                    .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)\n                    .forPath(locakPath);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n\n    /***\n     * 删除节点\n     * @param path\n     */\n    public void deleteNode(String path) {\n        try {\n            if (isExistNode(path)) {\n                cf.delete().forPath(path);\n                System.out.println(&quot;====&quot; + path + &quot; 删除成功&quot;);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /***\n     * 判断节点是否存在\n     * @param path\n     * @return\n     */\n    public boolean isExistNode(String path) {\n        try {\n            Stat stat = cf.checkExists().forPath(path);\n            return stat == null ? false : true;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return false;\n    }\n\n    /***\n     * 获取子节点并排序\n     * @return\n     */\n    public List&lt;String&gt; getChildrenPath() {\n        try {\n            List&lt;String&gt; strings = cf.getChildren().forPath(lockNameSpace);\n            return strings.stream().sorted().collect(Collectors.toList());\n        } catch (Exception e) {\n            e.printStackTrace();\n            return Lists.newArrayList();\n        }\n    }\n\n}\n</code></pre>\n<p><strong>测试代码</strong></p>\n<pre><code class=\"java\">@Test\n    public void zkOnlyFairLock01() throws InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(100);\n        for(int i = 0 ; i &lt; 100; i++){\n            executorService.submit(() -&gt; {\n                ZkOnlyFairLock zkLock = new ZkOnlyFairLock(&quot;lock&quot;);\n                try {\n                    zkLock.lock();\n                    System.out.println(&quot;做事ing&quot;);\n                    TimeUnit.SECONDS.sleep(2);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }finally {\n                    zkLock.unlock();\n                }\n            });\n        }\n        executorService.awaitTermination(10,TimeUnit.MINUTES);\n    }</code></pre>\n<h2 id=\"Curator提供的分布式锁\"><a href=\"#Curator提供的分布式锁\" class=\"headerlink\" title=\"Curator提供的分布式锁\"></a>Curator提供的分布式锁</h2><p>Curator是Zookeeper的一个工具类，他为我们提供了简便好用的分布式锁工具。</p>\n<ul>\n<li>InterProcessMutex：分布式可重入排它锁</li>\n<li>InterProcessSemaphoreMutex：分布式排它锁</li>\n<li>InterProcessReadWriteLock：分布式读写锁</li>\n<li>InterProcessMultiLock：将多个锁作为单个实体管理的容器</li>\n</ul>\n<h3 id=\"不可重入锁\"><a href=\"#不可重入锁\" class=\"headerlink\" title=\"不可重入锁\"></a>不可重入锁</h3><p>InterProcessSemaphoreMutex是一种不可重入的互斥锁，也就意味着即使是同一个线程也无法在持有锁的情况下再次获得锁，所以需要注意，不可重入的锁很容易在一些情况导致死锁。</p>\n<pre><code class=\"java\">@Test\npublic void curtorLock001() throws InterruptedException {\n    ExecutorService executorService = Executors.newFixedThreadPool(100);\n    for(int i = 0 ; i &lt; 10; i++){\n        executorService.submit(new Runnable() {\n            @Override\n            public void run() {\n                CuratorFramework cf = CuratorFrameworkFactory.newClient(&quot;localhost:2181&quot;,new ExponentialBackoffRetry(2000,3));\n                InterProcessLock lock = new InterProcessSemaphoreMutex(cf, &quot;/curator/lock&quot;);\n                try{\n                    cf.start();\n                    lock.acquire(); //只能调用一次，不可重入\n                    System.out.println(&quot;做事ing&quot;);\n                    TimeUnit.SECONDS.sleep(5);\n                }catch (Exception e){\n                    e.printStackTrace();\n                }finally {\n                    try {\n                        lock.release();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n    }\n    executorService.awaitTermination(10,TimeUnit.MINUTES);\n}</code></pre>\n<h3 id=\"可重入锁\"><a href=\"#可重入锁\" class=\"headerlink\" title=\"可重入锁\"></a>可重入锁</h3><p>此锁可以重入，但是重入几次需要释放几次。</p>\n<p>InterProcessMutex通过在zookeeper的某路径节点下创建临时序列节点来实现分布式锁，即每个线程（跨进程的线程）获取同一把锁前，都需要在同样的路径下创建一个节点，节点名字由uuid + 递增序列组成。而通过对比自身的序列数是否在所有子节点的第一位，来判断是否成功获取到了锁。当获取锁失败时，它会添加watcher来监听前一个节点的变动情况，然后进行等待状态。直到watcher的事件生效将自己唤醒，或者超时时间异常返回。</p>\n<pre><code class=\"java\">@Test\npublic void curtorLock002() throws InterruptedException {\n    ExecutorService executorService = Executors.newFixedThreadPool(100);\n    for(int i = 0 ; i &lt; 10; i++){\n        executorService.submit(new Runnable() {\n            @Override\n            public void run() {\n                CuratorFramework cf = CuratorFrameworkFactory.newClient(&quot;localhost:2181&quot;,new ExponentialBackoffRetry(2000,3));\n                InterProcessLock lock = new InterProcessMutex(cf, &quot;/curator/lock&quot;);\n                try{\n                    cf.start();\n                    lock.acquire();\n                    lock.acquire();\n                    System.out.println(&quot;做事ing&quot;);\n                    TimeUnit.SECONDS.sleep(5);\n                }catch (Exception e){\n                    e.printStackTrace();\n                }finally {\n                    try {\n                        lock.release();\n                        lock.release();\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n    }\n    executorService.awaitTermination(10,TimeUnit.MINUTES);\n}</code></pre>\n<h3 id=\"可重入读写锁\"><a href=\"#可重入读写锁\" class=\"headerlink\" title=\"可重入读写锁\"></a>可重入读写锁</h3><p>InterProcessReadWriteLock</p>\n<h3 id=\"多个锁\"><a href=\"#多个锁\" class=\"headerlink\" title=\"多个锁\"></a>多个锁</h3><p>InterProcessMultiLock</p>\n<h2 id=\"zk分布式锁优缺点\"><a href=\"#zk分布式锁优缺点\" class=\"headerlink\" title=\"zk分布式锁优缺点\"></a>zk分布式锁优缺点</h2><p>缺点：由于ZK是强一致性系统，对于写请求需要发送给leader同一协调，如果有较多的客户端频繁的申请加锁、释放锁，对于 ZK 集群的压力会比较大。</p>\n<p>优点：</p>\n<ul>\n<li>相对于Redis的实现方式，zk使用设置watch的方式，不会出现key过期导致业务还没执行完锁就自动失效的问题。</li>\n<li>由于Redis不是强一致性系统，在极端情况下会出现（clientA获取锁后，主redis复制数据到从redis过程中崩溃了，导致没有复制到从redis中，然后从redis选举出一个升级为主redis,造成新的主redis没有clientA 设置的锁，这是clientB尝试获取锁，并且能够成功获取锁，导致互斥失效）的问题。zk是强一致性系统，每次写操作都需要先发给leader，leader处理写请求，一半以上的从节点也写成功，才返回给客户端成功。</li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/6e20e65f301a\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/6e20e65f301a</a></li>\n<li><a href=\"http://www.tianxiaobo.com/2018/01/20/%E5%9F%BA%E4%BA%8E-Zookeeper-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">http://www.tianxiaobo.com/2018/01/20/%E5%9F%BA%E4%BA%8E-Zookeeper-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/</a></li>\n<li><a href=\"https://www.jianshu.com/p/7fe495c93290\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/7fe495c93290</a></li>\n</ul>"},{"title":"创建你的第一条substrate链","description":"创建你的第一条substrate链","date":"2020-10-30T05:53:30.000Z","_content":"### 教程\nwiki : https://substrate.dev/docs/zh-CN/tutorials/create-your-first-substrate-chain/interact\n\n教程 : https://zhuanlan.zhihu.com/p/342576492\n\nubantu系统版本 : ubuntu-20.04.2.0-desktop-amd64.iso\n\n### vbox安装ubantu问题\n\n**ifconfig命令不可用**\n\n```\nsudo apt install net-tools\n```\n\n**允许root用户登录**\n\nhttp://www.5sharing.com/m/view.php?aid=1541\n\n**ubantu使用root登录**\n\nubantu默认不能使用root登录，所以先要设置下root用户\n\n```\nsudo passwd root #为root修改密码，第一次安装ubanto时候做\nsu root #切换到root用户\n```\n\n**ubantu使用xshell登录不上**\n\n原因是由于xshell远程连接ubuntu是通过ssh协议的，所以，需要给ubuntu安装ssh服务器。\n\n```\nsudo apt-get install openssh-server\nsudo service ssh restart #重启服务\n```\n\n**Ubantu下root账户无法使用xshell**\n\n```\n修改 /etc/ssh/sshd_config 文件把PermitRootLogin Prohibit-password 添加#注释掉\n新添加：PermitRootLogin yes\n重启ssh服务 /etc/init.d/ssh restart\n重新使用root连接\n```\n\n**Ubantu开发所有端口**\n\n```\niptables -P INPUT ACCEPT\niptables -P FORWARD ACCEPT\niptables -P OUTPUT ACCEPT\niptables -F\niptables-save\napt-get install iptables-persistent\nnetfilter-persistent save\nnetfilter-persistent reload\n```\n\n**Ubantu在vbox上调整分辨率**\n\n1. 设备 --> 安装增强功能\n2. cd /media 目录下执行 sudo sh VBoxLinuxAdditions.run\n3. 重启sudo reboot 就可以设置分辨率了\n\n### Substrate安装\n\n**安装最新版NodeJs**\n\n可以参考 : https://developer.aliyun.com/article/760687\n\n```\ncurl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -\nsudo apt install nodejs\n#验证版本\nnode --version\nnpm --version\nnpm config set registry http://registry.npm.taobao.org/ #设置淘宝镜像\n```\n\n**安装yarn**\n\n```\ncurl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -\necho \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list\nsudo apt update\nsudo apt install yarn\n```\n\n**安装substrate依赖**\n\n```\ncurl https://getsubstrate.io -sSf | bash -s -- --fast  #设置--fast可以不设置\n```\n\n","source":"_posts/blockchain-1.md","raw":"---\ntitle: 创建你的第一条substrate链\ntags:\n  - 区块链\ncategories:  区块链\ndescription : 创建你的第一条substrate链\ndate: 2020-10-30 13:53:30\n---\n### 教程\nwiki : https://substrate.dev/docs/zh-CN/tutorials/create-your-first-substrate-chain/interact\n\n教程 : https://zhuanlan.zhihu.com/p/342576492\n\nubantu系统版本 : ubuntu-20.04.2.0-desktop-amd64.iso\n\n### vbox安装ubantu问题\n\n**ifconfig命令不可用**\n\n```\nsudo apt install net-tools\n```\n\n**允许root用户登录**\n\nhttp://www.5sharing.com/m/view.php?aid=1541\n\n**ubantu使用root登录**\n\nubantu默认不能使用root登录，所以先要设置下root用户\n\n```\nsudo passwd root #为root修改密码，第一次安装ubanto时候做\nsu root #切换到root用户\n```\n\n**ubantu使用xshell登录不上**\n\n原因是由于xshell远程连接ubuntu是通过ssh协议的，所以，需要给ubuntu安装ssh服务器。\n\n```\nsudo apt-get install openssh-server\nsudo service ssh restart #重启服务\n```\n\n**Ubantu下root账户无法使用xshell**\n\n```\n修改 /etc/ssh/sshd_config 文件把PermitRootLogin Prohibit-password 添加#注释掉\n新添加：PermitRootLogin yes\n重启ssh服务 /etc/init.d/ssh restart\n重新使用root连接\n```\n\n**Ubantu开发所有端口**\n\n```\niptables -P INPUT ACCEPT\niptables -P FORWARD ACCEPT\niptables -P OUTPUT ACCEPT\niptables -F\niptables-save\napt-get install iptables-persistent\nnetfilter-persistent save\nnetfilter-persistent reload\n```\n\n**Ubantu在vbox上调整分辨率**\n\n1. 设备 --> 安装增强功能\n2. cd /media 目录下执行 sudo sh VBoxLinuxAdditions.run\n3. 重启sudo reboot 就可以设置分辨率了\n\n### Substrate安装\n\n**安装最新版NodeJs**\n\n可以参考 : https://developer.aliyun.com/article/760687\n\n```\ncurl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -\nsudo apt install nodejs\n#验证版本\nnode --version\nnpm --version\nnpm config set registry http://registry.npm.taobao.org/ #设置淘宝镜像\n```\n\n**安装yarn**\n\n```\ncurl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -\necho \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list\nsudo apt update\nsudo apt install yarn\n```\n\n**安装substrate依赖**\n\n```\ncurl https://getsubstrate.io -sSf | bash -s -- --fast  #设置--fast可以不设置\n```\n\n","slug":"blockchain-1","published":1,"updated":"2021-06-07T03:20:15.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpxmxgrw0000h8v2egzj7693","content":"<h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><p>wiki : <a href=\"https://substrate.dev/docs/zh-CN/tutorials/create-your-first-substrate-chain/interact\" target=\"_blank\" rel=\"noopener\">https://substrate.dev/docs/zh-CN/tutorials/create-your-first-substrate-chain/interact</a></p>\n<p>教程 : <a href=\"https://zhuanlan.zhihu.com/p/342576492\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/342576492</a></p>\n<p>ubantu系统版本 : ubuntu-20.04.2.0-desktop-amd64.iso</p>\n<h3 id=\"vbox安装ubantu问题\"><a href=\"#vbox安装ubantu问题\" class=\"headerlink\" title=\"vbox安装ubantu问题\"></a>vbox安装ubantu问题</h3><p><strong>ifconfig命令不可用</strong></p>\n<pre><code>sudo apt install net-tools</code></pre><p><strong>允许root用户登录</strong></p>\n<p><a href=\"http://www.5sharing.com/m/view.php?aid=1541\" target=\"_blank\" rel=\"noopener\">http://www.5sharing.com/m/view.php?aid=1541</a></p>\n<p><strong>ubantu使用root登录</strong></p>\n<p>ubantu默认不能使用root登录，所以先要设置下root用户</p>\n<pre><code>sudo passwd root #为root修改密码，第一次安装ubanto时候做\nsu root #切换到root用户</code></pre><p><strong>ubantu使用xshell登录不上</strong></p>\n<p>原因是由于xshell远程连接ubuntu是通过ssh协议的，所以，需要给ubuntu安装ssh服务器。</p>\n<pre><code>sudo apt-get install openssh-server\nsudo service ssh restart #重启服务</code></pre><p><strong>Ubantu下root账户无法使用xshell</strong></p>\n<pre><code>修改 /etc/ssh/sshd_config 文件把PermitRootLogin Prohibit-password 添加#注释掉\n新添加：PermitRootLogin yes\n重启ssh服务 /etc/init.d/ssh restart\n重新使用root连接</code></pre><p><strong>Ubantu开发所有端口</strong></p>\n<pre><code>iptables -P INPUT ACCEPT\niptables -P FORWARD ACCEPT\niptables -P OUTPUT ACCEPT\niptables -F\niptables-save\napt-get install iptables-persistent\nnetfilter-persistent save\nnetfilter-persistent reload</code></pre><p><strong>Ubantu在vbox上调整分辨率</strong></p>\n<ol>\n<li>设备 –&gt; 安装增强功能</li>\n<li>cd /media 目录下执行 sudo sh VBoxLinuxAdditions.run</li>\n<li>重启sudo reboot 就可以设置分辨率了</li>\n</ol>\n<h3 id=\"Substrate安装\"><a href=\"#Substrate安装\" class=\"headerlink\" title=\"Substrate安装\"></a>Substrate安装</h3><p><strong>安装最新版NodeJs</strong></p>\n<p>可以参考 : <a href=\"https://developer.aliyun.com/article/760687\" target=\"_blank\" rel=\"noopener\">https://developer.aliyun.com/article/760687</a></p>\n<pre><code>curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -\nsudo apt install nodejs\n#验证版本\nnode --version\nnpm --version\nnpm config set registry http://registry.npm.taobao.org/ #设置淘宝镜像</code></pre><p><strong>安装yarn</strong></p>\n<pre><code>curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -\necho &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list\nsudo apt update\nsudo apt install yarn</code></pre><p><strong>安装substrate依赖</strong></p>\n<pre><code>curl https://getsubstrate.io -sSf | bash -s -- --fast  #设置--fast可以不设置</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"教程\"><a href=\"#教程\" class=\"headerlink\" title=\"教程\"></a>教程</h3><p>wiki : <a href=\"https://substrate.dev/docs/zh-CN/tutorials/create-your-first-substrate-chain/interact\" target=\"_blank\" rel=\"noopener\">https://substrate.dev/docs/zh-CN/tutorials/create-your-first-substrate-chain/interact</a></p>\n<p>教程 : <a href=\"https://zhuanlan.zhihu.com/p/342576492\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/342576492</a></p>\n<p>ubantu系统版本 : ubuntu-20.04.2.0-desktop-amd64.iso</p>\n<h3 id=\"vbox安装ubantu问题\"><a href=\"#vbox安装ubantu问题\" class=\"headerlink\" title=\"vbox安装ubantu问题\"></a>vbox安装ubantu问题</h3><p><strong>ifconfig命令不可用</strong></p>\n<pre><code>sudo apt install net-tools</code></pre><p><strong>允许root用户登录</strong></p>\n<p><a href=\"http://www.5sharing.com/m/view.php?aid=1541\" target=\"_blank\" rel=\"noopener\">http://www.5sharing.com/m/view.php?aid=1541</a></p>\n<p><strong>ubantu使用root登录</strong></p>\n<p>ubantu默认不能使用root登录，所以先要设置下root用户</p>\n<pre><code>sudo passwd root #为root修改密码，第一次安装ubanto时候做\nsu root #切换到root用户</code></pre><p><strong>ubantu使用xshell登录不上</strong></p>\n<p>原因是由于xshell远程连接ubuntu是通过ssh协议的，所以，需要给ubuntu安装ssh服务器。</p>\n<pre><code>sudo apt-get install openssh-server\nsudo service ssh restart #重启服务</code></pre><p><strong>Ubantu下root账户无法使用xshell</strong></p>\n<pre><code>修改 /etc/ssh/sshd_config 文件把PermitRootLogin Prohibit-password 添加#注释掉\n新添加：PermitRootLogin yes\n重启ssh服务 /etc/init.d/ssh restart\n重新使用root连接</code></pre><p><strong>Ubantu开发所有端口</strong></p>\n<pre><code>iptables -P INPUT ACCEPT\niptables -P FORWARD ACCEPT\niptables -P OUTPUT ACCEPT\niptables -F\niptables-save\napt-get install iptables-persistent\nnetfilter-persistent save\nnetfilter-persistent reload</code></pre><p><strong>Ubantu在vbox上调整分辨率</strong></p>\n<ol>\n<li>设备 –&gt; 安装增强功能</li>\n<li>cd /media 目录下执行 sudo sh VBoxLinuxAdditions.run</li>\n<li>重启sudo reboot 就可以设置分辨率了</li>\n</ol>\n<h3 id=\"Substrate安装\"><a href=\"#Substrate安装\" class=\"headerlink\" title=\"Substrate安装\"></a>Substrate安装</h3><p><strong>安装最新版NodeJs</strong></p>\n<p>可以参考 : <a href=\"https://developer.aliyun.com/article/760687\" target=\"_blank\" rel=\"noopener\">https://developer.aliyun.com/article/760687</a></p>\n<pre><code>curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -\nsudo apt install nodejs\n#验证版本\nnode --version\nnpm --version\nnpm config set registry http://registry.npm.taobao.org/ #设置淘宝镜像</code></pre><p><strong>安装yarn</strong></p>\n<pre><code>curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -\necho &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list\nsudo apt update\nsudo apt install yarn</code></pre><p><strong>安装substrate依赖</strong></p>\n<pre><code>curl https://getsubstrate.io -sSf | bash -s -- --fast  #设置--fast可以不设置</code></pre>"},{"title":"influxdb学习(一)","description":"influxdb学习(一)","date":"2021-02-10T01:05:24.000Z","_content":"\n### 核心概念\n\n```\n> insert cpu_usage,host=server01,location=cn-sz user=23.0,system=57.0\n> select * from cpu_usage\nname: cpu_usage\ntime             host     location system user\n----             ----     -------- ------ ----\n1557834774258860710 server01 cn-sz    55     25\n```\n\n- **时间（Time）：**如代码清单1-3中的“1557834774258860710”，表示数据生成时的时间戳，与MySQL不同的是，在InfluxDB中，时间几乎可以看作主键的代名词。\n- **表（Measurement）：**如代码清单1-3中的“cpu_usage”，表示一组有关联的时序数据，类似于MySQL中表（Table）的概念。\n- **标签（Tag）：**如代码清单1-3中的“host=server01”和“location=cn-sz”，用于创建索引，提升查询性能，一般存放的是标示数据点来源的属性信息，在代码清单1-3中，host和location分别是表中的两个标签键，对应的标签值分别为server01和cn-sz。\n- **指标（Field）：**如代码清单1-3中的“user=23.0”和“system=57.0”，一般存放的是具体的时序数据，即随着时间戳的变化而变化的数据，与标签不同的是，未对指标数据创建索引，在代码清单1-3中，user和system分别是表中的两个指标键，对应的指标值分别为23.0和57.0。\n- **时序数据记录（Point）：**如代码清单1-3中的“1557834774258860710 server01 cn-sz 55 25”，表示一条具体的时序数据记录，由时序（Series）和时间戳（Timestamp）唯一标识，类似于MySQL中的一行记录。 \n- **保留策略（Retention Policy）：**定义InfluxDB的数据保留时长和数据存储的副本数，通过设置合理的保存时间（Duration） 和副本数（Replication），在提升数据存储可用性的同时，避免数据爆炸。\n- **时间序列线（Series）：**表示表名、保留策略、标签集都相同的一组数据。","source":"_posts/influxdb-1.md","raw":"---\ntitle: influxdb学习(一)\ntags:\n  - influxdb\ncategories:  influxdb\ndescription : influxdb学习(一)\ndate: 2021-02-10 09:05:24\n---\n\n### 核心概念\n\n```\n> insert cpu_usage,host=server01,location=cn-sz user=23.0,system=57.0\n> select * from cpu_usage\nname: cpu_usage\ntime             host     location system user\n----             ----     -------- ------ ----\n1557834774258860710 server01 cn-sz    55     25\n```\n\n- **时间（Time）：**如代码清单1-3中的“1557834774258860710”，表示数据生成时的时间戳，与MySQL不同的是，在InfluxDB中，时间几乎可以看作主键的代名词。\n- **表（Measurement）：**如代码清单1-3中的“cpu_usage”，表示一组有关联的时序数据，类似于MySQL中表（Table）的概念。\n- **标签（Tag）：**如代码清单1-3中的“host=server01”和“location=cn-sz”，用于创建索引，提升查询性能，一般存放的是标示数据点来源的属性信息，在代码清单1-3中，host和location分别是表中的两个标签键，对应的标签值分别为server01和cn-sz。\n- **指标（Field）：**如代码清单1-3中的“user=23.0”和“system=57.0”，一般存放的是具体的时序数据，即随着时间戳的变化而变化的数据，与标签不同的是，未对指标数据创建索引，在代码清单1-3中，user和system分别是表中的两个指标键，对应的指标值分别为23.0和57.0。\n- **时序数据记录（Point）：**如代码清单1-3中的“1557834774258860710 server01 cn-sz 55 25”，表示一条具体的时序数据记录，由时序（Series）和时间戳（Timestamp）唯一标识，类似于MySQL中的一行记录。 \n- **保留策略（Retention Policy）：**定义InfluxDB的数据保留时长和数据存储的副本数，通过设置合理的保存时间（Duration） 和副本数（Replication），在提升数据存储可用性的同时，避免数据爆炸。\n- **时间序列线（Series）：**表示表名、保留策略、标签集都相同的一组数据。","slug":"influxdb-1","published":1,"updated":"2021-04-30T01:08:11.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpxmxgs00001h8v2bwk7a7ve","content":"<h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><pre><code>&gt; insert cpu_usage,host=server01,location=cn-sz user=23.0,system=57.0\n&gt; select * from cpu_usage\nname: cpu_usage\ntime             host     location system user\n----             ----     -------- ------ ----\n1557834774258860710 server01 cn-sz    55     25</code></pre><ul>\n<li><strong>时间（Time）：</strong>如代码清单1-3中的“1557834774258860710”，表示数据生成时的时间戳，与MySQL不同的是，在InfluxDB中，时间几乎可以看作主键的代名词。</li>\n<li><strong>表（Measurement）：</strong>如代码清单1-3中的“cpu_usage”，表示一组有关联的时序数据，类似于MySQL中表（Table）的概念。</li>\n<li><strong>标签（Tag）：</strong>如代码清单1-3中的“host=server01”和“location=cn-sz”，用于创建索引，提升查询性能，一般存放的是标示数据点来源的属性信息，在代码清单1-3中，host和location分别是表中的两个标签键，对应的标签值分别为server01和cn-sz。</li>\n<li><strong>指标（Field）：</strong>如代码清单1-3中的“user=23.0”和“system=57.0”，一般存放的是具体的时序数据，即随着时间戳的变化而变化的数据，与标签不同的是，未对指标数据创建索引，在代码清单1-3中，user和system分别是表中的两个指标键，对应的指标值分别为23.0和57.0。</li>\n<li><strong>时序数据记录（Point）：</strong>如代码清单1-3中的“1557834774258860710 server01 cn-sz 55 25”，表示一条具体的时序数据记录，由时序（Series）和时间戳（Timestamp）唯一标识，类似于MySQL中的一行记录。 </li>\n<li><strong>保留策略（Retention Policy）：</strong>定义InfluxDB的数据保留时长和数据存储的副本数，通过设置合理的保存时间（Duration） 和副本数（Replication），在提升数据存储可用性的同时，避免数据爆炸。</li>\n<li><strong>时间序列线（Series）：</strong>表示表名、保留策略、标签集都相同的一组数据。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h3><pre><code>&gt; insert cpu_usage,host=server01,location=cn-sz user=23.0,system=57.0\n&gt; select * from cpu_usage\nname: cpu_usage\ntime             host     location system user\n----             ----     -------- ------ ----\n1557834774258860710 server01 cn-sz    55     25</code></pre><ul>\n<li><strong>时间（Time）：</strong>如代码清单1-3中的“1557834774258860710”，表示数据生成时的时间戳，与MySQL不同的是，在InfluxDB中，时间几乎可以看作主键的代名词。</li>\n<li><strong>表（Measurement）：</strong>如代码清单1-3中的“cpu_usage”，表示一组有关联的时序数据，类似于MySQL中表（Table）的概念。</li>\n<li><strong>标签（Tag）：</strong>如代码清单1-3中的“host=server01”和“location=cn-sz”，用于创建索引，提升查询性能，一般存放的是标示数据点来源的属性信息，在代码清单1-3中，host和location分别是表中的两个标签键，对应的标签值分别为server01和cn-sz。</li>\n<li><strong>指标（Field）：</strong>如代码清单1-3中的“user=23.0”和“system=57.0”，一般存放的是具体的时序数据，即随着时间戳的变化而变化的数据，与标签不同的是，未对指标数据创建索引，在代码清单1-3中，user和system分别是表中的两个指标键，对应的指标值分别为23.0和57.0。</li>\n<li><strong>时序数据记录（Point）：</strong>如代码清单1-3中的“1557834774258860710 server01 cn-sz 55 25”，表示一条具体的时序数据记录，由时序（Series）和时间戳（Timestamp）唯一标识，类似于MySQL中的一行记录。 </li>\n<li><strong>保留策略（Retention Policy）：</strong>定义InfluxDB的数据保留时长和数据存储的副本数，通过设置合理的保存时间（Duration） 和副本数（Replication），在提升数据存储可用性的同时，避免数据爆炸。</li>\n<li><strong>时间序列线（Series）：</strong>表示表名、保留策略、标签集都相同的一组数据。</li>\n</ul>\n"},{"title":"ElasticSearch常见问题汇总(0)","date":"2021-04-24T11:45:46.000Z","description":"ElasticSearch常见问题汇总","_content":"\n## match/term等区别\n\n**Elasticsearch中 match、match_phrase、query_string和term的区别**\n\n首先建立一个索引，结果如下\n\n```json\nPUT my_index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"name\" : {\"type\": \"keyword\"}, //name是keyword类型，是不分词的\n      \"desc\" : {\"type\": \"text\"}  // desc 是text类型，是会分词的\n    }\n  }\n}\n//插入一条数据\nPOST my_index/_doc/1\n{\n  \"name\" : \"washing machin\",\n  \"desc\" : \"I wrote an Elasticsearch article, which I think is quite easy to understand, and I hope it will be helpful for getting started\"\n}\n```\n\n**term查询**\n\nterm查询指的是完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇，指的是 :\n\n- 当查keyword类型时，由于keyword类型不会分词，所以需要完全匹配\n- 当查textt类型时,text会分词，而term不分词，所以term查询的条件必须是text字段分词后的某一个\n\n```json\nGET my_index/_search\n{\n  \"query\": {\n    \"term\": {\n      \"name\": \"washing\"\n    }\n  }\n}\n//没值\nGET my_index/_search\n{\n  \"query\": {\n    \"term\": {\n      \"name\": \"washing machin\"\n    }\n  }\n}\n//有值 查出来数据为空,因为name是keyword类型，name是不会被分词的，所以他的值就是washing machin，因为term是完全匹配，所以必须是查washing machin才有值\n\nGET my_index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"washing\"\n    }\n  }\n}\n//没值，因为keyword是不会被分词的，where name = 'washing'。显然是查不到的\n\nGET my_index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"washing machin\"\n    }\n  }\n}\n//有值，where name = 'washing machin'查得到\n\n```\n\n```json\nGET my_index/_search\n{\n  \"query\": {\n    \"term\": {\n      \"desc\": \"Elasticsearch\"\n    }\n  }\n}\n//有值，desc是text类型，分词后包含Elasticsearch这个项。我们可以使用分词测试测试下是否包含Elasticsearch这个项\n\nGET my_index/_analyze\n{\n  \"analyzer\": \"standard\",\n  \"text\": \"I wrote an Elasticsearch article, which I think is quite easy to understand, and I hope it will be helpful for getting started\"\n}\n\nGET my_index/_search\n{\n  \"query\": {\n    \"term\": {\n      \"desc\": \"an Elasticsearch article\"\n    }\n  }\n}\n//如果查an Elasticsearch article 则没有值，因为term是完全匹配，相当于MySQL中的=\n\nGET my_index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"desc\": \"an Elasticsearch article\"\n    }\n  }\n}\n//如果使用match查询text类型，由于text是会被分词的，所以相当于where desc = 'an' or desc = 'Elasticsearch' or desc = 'article'.只要包含一个分词项就匹配\n```\n\n","source":"_posts/elasticsearch-01.md","raw":"---\ntitle: ElasticSearch常见问题汇总(0)\ndate: 2021-04-24 19:45:46\ntags:\n - ElasticSearch\ncategories:  ElasticSearch\ndescription : ElasticSearch常见问题汇总\n---\n\n## match/term等区别\n\n**Elasticsearch中 match、match_phrase、query_string和term的区别**\n\n首先建立一个索引，结果如下\n\n```json\nPUT my_index\n{\n  \"mappings\": {\n    \"properties\": {\n      \"name\" : {\"type\": \"keyword\"}, //name是keyword类型，是不分词的\n      \"desc\" : {\"type\": \"text\"}  // desc 是text类型，是会分词的\n    }\n  }\n}\n//插入一条数据\nPOST my_index/_doc/1\n{\n  \"name\" : \"washing machin\",\n  \"desc\" : \"I wrote an Elasticsearch article, which I think is quite easy to understand, and I hope it will be helpful for getting started\"\n}\n```\n\n**term查询**\n\nterm查询指的是完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇，指的是 :\n\n- 当查keyword类型时，由于keyword类型不会分词，所以需要完全匹配\n- 当查textt类型时,text会分词，而term不分词，所以term查询的条件必须是text字段分词后的某一个\n\n```json\nGET my_index/_search\n{\n  \"query\": {\n    \"term\": {\n      \"name\": \"washing\"\n    }\n  }\n}\n//没值\nGET my_index/_search\n{\n  \"query\": {\n    \"term\": {\n      \"name\": \"washing machin\"\n    }\n  }\n}\n//有值 查出来数据为空,因为name是keyword类型，name是不会被分词的，所以他的值就是washing machin，因为term是完全匹配，所以必须是查washing machin才有值\n\nGET my_index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"washing\"\n    }\n  }\n}\n//没值，因为keyword是不会被分词的，where name = 'washing'。显然是查不到的\n\nGET my_index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"washing machin\"\n    }\n  }\n}\n//有值，where name = 'washing machin'查得到\n\n```\n\n```json\nGET my_index/_search\n{\n  \"query\": {\n    \"term\": {\n      \"desc\": \"Elasticsearch\"\n    }\n  }\n}\n//有值，desc是text类型，分词后包含Elasticsearch这个项。我们可以使用分词测试测试下是否包含Elasticsearch这个项\n\nGET my_index/_analyze\n{\n  \"analyzer\": \"standard\",\n  \"text\": \"I wrote an Elasticsearch article, which I think is quite easy to understand, and I hope it will be helpful for getting started\"\n}\n\nGET my_index/_search\n{\n  \"query\": {\n    \"term\": {\n      \"desc\": \"an Elasticsearch article\"\n    }\n  }\n}\n//如果查an Elasticsearch article 则没有值，因为term是完全匹配，相当于MySQL中的=\n\nGET my_index/_search\n{\n  \"query\": {\n    \"match\": {\n      \"desc\": \"an Elasticsearch article\"\n    }\n  }\n}\n//如果使用match查询text类型，由于text是会被分词的，所以相当于where desc = 'an' or desc = 'Elasticsearch' or desc = 'article'.只要包含一个分词项就匹配\n```\n\n","slug":"elasticsearch-01","published":1,"updated":"2021-04-24T12:29:15.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpxmxgsh0004h8v2a6axbhhq","content":"<h2 id=\"match-term等区别\"><a href=\"#match-term等区别\" class=\"headerlink\" title=\"match/term等区别\"></a>match/term等区别</h2><p><strong>Elasticsearch中 match、match_phrase、query_string和term的区别</strong></p>\n<p>首先建立一个索引，结果如下</p>\n<pre class=\" language-json\"><code class=\"language-json\">PUT my_index\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"mappings\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"properties\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"name\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"keyword\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> //name是keyword类型，是不分词的\n      <span class=\"token property\">\"desc\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token property\">\"type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"text\"</span><span class=\"token punctuation\">}</span>  // desc 是text类型，是会分词的\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n//插入一条数据\nPOST my_index/_doc/<span class=\"token number\">1</span>\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"name\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"washing machin\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"desc\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"I wrote an Elasticsearch article, which I think is quite easy to understand, and I hope it will be helpful for getting started\"</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>term查询</strong></p>\n<p>term查询指的是完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇，指的是 :</p>\n<ul>\n<li>当查keyword类型时，由于keyword类型不会分词，所以需要完全匹配</li>\n<li>当查textt类型时,text会分词，而term不分词，所以term查询的条件必须是text字段分词后的某一个</li>\n</ul>\n<pre class=\" language-json\"><code class=\"language-json\">GET my_index/_search\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"query\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"term\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"washing\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n//没值\nGET my_index/_search\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"query\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"term\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"washing machin\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n//有值 查出来数据为空<span class=\"token punctuation\">,</span>因为name是keyword类型，name是不会被分词的，所以他的值就是washing machin，因为term是完全匹配，所以必须是查washing machin才有值\n\nGET my_index/_search\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"query\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"match\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"washing\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n//没值，因为keyword是不会被分词的，where name = 'washing'。显然是查不到的\n\nGET my_index/_search\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"query\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"match\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"washing machin\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n//有值，where name = 'washing machin'查得到\n</code></pre>\n<pre class=\" language-json\"><code class=\"language-json\">GET my_index/_search\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"query\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"term\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"desc\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Elasticsearch\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n//有值，desc是text类型，分词后包含Elasticsearch这个项。我们可以使用分词测试测试下是否包含Elasticsearch这个项\n\nGET my_index/_analyze\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"analyzer\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"standard\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"text\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"I wrote an Elasticsearch article, which I think is quite easy to understand, and I hope it will be helpful for getting started\"</span>\n<span class=\"token punctuation\">}</span>\n\nGET my_index/_search\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"query\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"term\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"desc\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"an Elasticsearch article\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n//如果查an Elasticsearch article 则没有值，因为term是完全匹配，相当于MySQL中的=\n\nGET my_index/_search\n<span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"query\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"match\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"desc\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"an Elasticsearch article\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n//如果使用match查询text类型，由于text是会被分词的，所以相当于where desc = 'an' or desc = 'Elasticsearch' or desc = 'article'.只要包含一个分词项就匹配</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"match-term等区别\"><a href=\"#match-term等区别\" class=\"headerlink\" title=\"match/term等区别\"></a>match/term等区别</h2><p><strong>Elasticsearch中 match、match_phrase、query_string和term的区别</strong></p>\n<p>首先建立一个索引，结果如下</p>\n<pre><code class=\"json\">PUT my_index\n{\n  &quot;mappings&quot;: {\n    &quot;properties&quot;: {\n      &quot;name&quot; : {&quot;type&quot;: &quot;keyword&quot;}, //name是keyword类型，是不分词的\n      &quot;desc&quot; : {&quot;type&quot;: &quot;text&quot;}  // desc 是text类型，是会分词的\n    }\n  }\n}\n//插入一条数据\nPOST my_index/_doc/1\n{\n  &quot;name&quot; : &quot;washing machin&quot;,\n  &quot;desc&quot; : &quot;I wrote an Elasticsearch article, which I think is quite easy to understand, and I hope it will be helpful for getting started&quot;\n}</code></pre>\n<p><strong>term查询</strong></p>\n<p>term查询指的是完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇，指的是 :</p>\n<ul>\n<li>当查keyword类型时，由于keyword类型不会分词，所以需要完全匹配</li>\n<li>当查textt类型时,text会分词，而term不分词，所以term查询的条件必须是text字段分词后的某一个</li>\n</ul>\n<pre><code class=\"json\">GET my_index/_search\n{\n  &quot;query&quot;: {\n    &quot;term&quot;: {\n      &quot;name&quot;: &quot;washing&quot;\n    }\n  }\n}\n//没值\nGET my_index/_search\n{\n  &quot;query&quot;: {\n    &quot;term&quot;: {\n      &quot;name&quot;: &quot;washing machin&quot;\n    }\n  }\n}\n//有值 查出来数据为空,因为name是keyword类型，name是不会被分词的，所以他的值就是washing machin，因为term是完全匹配，所以必须是查washing machin才有值\n\nGET my_index/_search\n{\n  &quot;query&quot;: {\n    &quot;match&quot;: {\n      &quot;name&quot;: &quot;washing&quot;\n    }\n  }\n}\n//没值，因为keyword是不会被分词的，where name = &#39;washing&#39;。显然是查不到的\n\nGET my_index/_search\n{\n  &quot;query&quot;: {\n    &quot;match&quot;: {\n      &quot;name&quot;: &quot;washing machin&quot;\n    }\n  }\n}\n//有值，where name = &#39;washing machin&#39;查得到\n</code></pre>\n<pre><code class=\"json\">GET my_index/_search\n{\n  &quot;query&quot;: {\n    &quot;term&quot;: {\n      &quot;desc&quot;: &quot;Elasticsearch&quot;\n    }\n  }\n}\n//有值，desc是text类型，分词后包含Elasticsearch这个项。我们可以使用分词测试测试下是否包含Elasticsearch这个项\n\nGET my_index/_analyze\n{\n  &quot;analyzer&quot;: &quot;standard&quot;,\n  &quot;text&quot;: &quot;I wrote an Elasticsearch article, which I think is quite easy to understand, and I hope it will be helpful for getting started&quot;\n}\n\nGET my_index/_search\n{\n  &quot;query&quot;: {\n    &quot;term&quot;: {\n      &quot;desc&quot;: &quot;an Elasticsearch article&quot;\n    }\n  }\n}\n//如果查an Elasticsearch article 则没有值，因为term是完全匹配，相当于MySQL中的=\n\nGET my_index/_search\n{\n  &quot;query&quot;: {\n    &quot;match&quot;: {\n      &quot;desc&quot;: &quot;an Elasticsearch article&quot;\n    }\n  }\n}\n//如果使用match查询text类型，由于text是会被分词的，所以相当于where desc = &#39;an&#39; or desc = &#39;Elasticsearch&#39; or desc = &#39;article&#39;.只要包含一个分词项就匹配</code></pre>\n"},{"title":"GoLang指针","description":null,"date":"2021-11-12T09:14:00.000Z","_content":"### 什么是指针，指针变量，指针类型？\n任何程序数据载入内存后，在内存中都有他们的地址，这个就是**指针**。\n\n为了保存一个数据在内存中的地址，需要**指针变量**。\n\nGo语言中的值类型(int、float、bool、string、array、struct)都有对应的指针类型，如：`*int`、`*int64`、`*string`等。所以指针类型里面存放的值就是指针，也就是地址。\n\n下面看个列子，图文结合的理解一下。\n\n```go\nfunc main(){\n    a := 10\n    b := &a\n    fmt.Printf(\"a:%d ptr:%p\\n\", a , &a)\n    fmt.Printf(\"b:%p type:%T\\n\", b, b)\n    fmt.Println(&b)\n    // 结果\n    // a:10 ptr:0xc000054080\n    // b:0xc000054080 type:*int\n    // 0xc000080018\n}\n```\n\n![](go-pointer/1.png)\n\n如上图，把内存区域理解成上面的一个一个连续的小方格。方格里面是用来存储数据的。每个方格都是一个物理地址。\n\n- 当执行 `a := 10` 时，数值10被存放到了物理地址为`0xc00054080`的方格上。变量a引用了这个方格，所以我们程序访问a时就能定位到这个方格，由于变量a里面存的是10这个数值，所以他是一个数值类型的变量。\n- 当执行`b := &a`时，因为在go语言中，`&a`表示的意思是取变量a指向的物理地址（也就是存储10对应的物理地址）。所以执行这条代码时会在内存的其他方格，假设在`0xc00080018`这个方格上，就会存储&a,也就是`0xc00054080`这个数据。我之所以称它为`这个数据`，是因为他不是我们平常经常存的数值类型，布尔类型等，他就是一个物理地址，所以我们称他是一个`指针类型`。而b就表示是一个`指针变量`。\n- 因为上面我们说过go语言中&表示取变量指向的物理地址。所以&b的值就是`0cx00080018`这个物理地址了。\n\n### golang中的值传递和引用传递\n\n先来看看两者的概念 :\n\n- 值传递 ： 方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\n- 引用传递： 方法调用时传递的引用的地址，也就是变量所对应的内存空间的地址。\n\n#### 例子1\n\n```go\nfunc TestOther1(t *testing.T) {\n\tvar a int64 = 10\n\tfmt.Printf(\"变量a对应的地址 %p\\n\", &a)\n\tmodifiedNumber(a)\n\tfmt.Printf(\"最终a的值 %d\", a)\n}\nfunc modifiedNumber(c int64) {\n\tfmt.Printf(\"变量c对应的地址 %p\\n\", &c)\n\tc = 100\n}\n//变量a对应的地址 0xc00009e298\n//变量c对应的地址 0xc00009e2a0\n//最终a的值 10\n```\n\n![](go-pointer/2.png)\n\n看图分析 ，基本类型例如int64等类型采用的是`值传递`，也就是说变量c复制了变量a存储在方格`0xc0009e298`里面的值10，然后存到了另外一个方格`0xc0009e2a0`。那变量c值的变化不影响变量a。\n\n#### 例子2\n\n```go\nfunc TestOther2(t *testing.T) {\n\tvar a int64 = 10\n\tfmt.Printf(\"变量a对应的地址 %p\", &a)\n\tfmt.Println()\n\tmodifiedNumber2(&a) // args就是实际参数\n\tfmt.Printf(\"最终a的值 %d\", a)\n\tfmt.Println()\n}\nfunc modifiedNumber2(c *int64) { //这里定义的args就是形式参数\n\tfmt.Printf(\"变量c存储的值 %v\" , c)\n\tfmt.Println()\n\t*c = 100\n}\n//变量a对应的地址 0xc00000a348\n//变量c存储的值 0xc00000a348\n//最终a的值 100\n```\n\n![](go-pointer/3.png)\n\n如图所示，c是一个指针类型，c存放的是a的物理地址`0xc00000a348`。当执行`*c = 100`时候，*c在go中代表c变量中存储的物理地址`0xc00000a348`对应的方格它存的值。所以当 *c =100时，就会更改`0xc000003a68`这个物理地址里面存的数，所以变量a的值最终变成了100。所以对于指针类型来说，它也是值传递，它拷贝了一份变量a对应的物理地址。本身变量c是一个指针类型，它存物理地址没毛病。所以总的来说，指针类型也是通过值传递的。\n\n总结 ： golang中形参实参传递都是用的值传递。","source":"_posts/go-pointer.md","raw":"---\ntitle: GoLang指针\ntags:\n  - GoLang\ncategories: \n  - GoLang\ndescription : \ndate: 2021-11-12 17:14:00\n---\n### 什么是指针，指针变量，指针类型？\n任何程序数据载入内存后，在内存中都有他们的地址，这个就是**指针**。\n\n为了保存一个数据在内存中的地址，需要**指针变量**。\n\nGo语言中的值类型(int、float、bool、string、array、struct)都有对应的指针类型，如：`*int`、`*int64`、`*string`等。所以指针类型里面存放的值就是指针，也就是地址。\n\n下面看个列子，图文结合的理解一下。\n\n```go\nfunc main(){\n    a := 10\n    b := &a\n    fmt.Printf(\"a:%d ptr:%p\\n\", a , &a)\n    fmt.Printf(\"b:%p type:%T\\n\", b, b)\n    fmt.Println(&b)\n    // 结果\n    // a:10 ptr:0xc000054080\n    // b:0xc000054080 type:*int\n    // 0xc000080018\n}\n```\n\n![](go-pointer/1.png)\n\n如上图，把内存区域理解成上面的一个一个连续的小方格。方格里面是用来存储数据的。每个方格都是一个物理地址。\n\n- 当执行 `a := 10` 时，数值10被存放到了物理地址为`0xc00054080`的方格上。变量a引用了这个方格，所以我们程序访问a时就能定位到这个方格，由于变量a里面存的是10这个数值，所以他是一个数值类型的变量。\n- 当执行`b := &a`时，因为在go语言中，`&a`表示的意思是取变量a指向的物理地址（也就是存储10对应的物理地址）。所以执行这条代码时会在内存的其他方格，假设在`0xc00080018`这个方格上，就会存储&a,也就是`0xc00054080`这个数据。我之所以称它为`这个数据`，是因为他不是我们平常经常存的数值类型，布尔类型等，他就是一个物理地址，所以我们称他是一个`指针类型`。而b就表示是一个`指针变量`。\n- 因为上面我们说过go语言中&表示取变量指向的物理地址。所以&b的值就是`0cx00080018`这个物理地址了。\n\n### golang中的值传递和引用传递\n\n先来看看两者的概念 :\n\n- 值传递 ： 方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。\n- 引用传递： 方法调用时传递的引用的地址，也就是变量所对应的内存空间的地址。\n\n#### 例子1\n\n```go\nfunc TestOther1(t *testing.T) {\n\tvar a int64 = 10\n\tfmt.Printf(\"变量a对应的地址 %p\\n\", &a)\n\tmodifiedNumber(a)\n\tfmt.Printf(\"最终a的值 %d\", a)\n}\nfunc modifiedNumber(c int64) {\n\tfmt.Printf(\"变量c对应的地址 %p\\n\", &c)\n\tc = 100\n}\n//变量a对应的地址 0xc00009e298\n//变量c对应的地址 0xc00009e2a0\n//最终a的值 10\n```\n\n![](go-pointer/2.png)\n\n看图分析 ，基本类型例如int64等类型采用的是`值传递`，也就是说变量c复制了变量a存储在方格`0xc0009e298`里面的值10，然后存到了另外一个方格`0xc0009e2a0`。那变量c值的变化不影响变量a。\n\n#### 例子2\n\n```go\nfunc TestOther2(t *testing.T) {\n\tvar a int64 = 10\n\tfmt.Printf(\"变量a对应的地址 %p\", &a)\n\tfmt.Println()\n\tmodifiedNumber2(&a) // args就是实际参数\n\tfmt.Printf(\"最终a的值 %d\", a)\n\tfmt.Println()\n}\nfunc modifiedNumber2(c *int64) { //这里定义的args就是形式参数\n\tfmt.Printf(\"变量c存储的值 %v\" , c)\n\tfmt.Println()\n\t*c = 100\n}\n//变量a对应的地址 0xc00000a348\n//变量c存储的值 0xc00000a348\n//最终a的值 100\n```\n\n![](go-pointer/3.png)\n\n如图所示，c是一个指针类型，c存放的是a的物理地址`0xc00000a348`。当执行`*c = 100`时候，*c在go中代表c变量中存储的物理地址`0xc00000a348`对应的方格它存的值。所以当 *c =100时，就会更改`0xc000003a68`这个物理地址里面存的数，所以变量a的值最终变成了100。所以对于指针类型来说，它也是值传递，它拷贝了一份变量a对应的物理地址。本身变量c是一个指针类型，它存物理地址没毛病。所以总的来说，指针类型也是通过值传递的。\n\n总结 ： golang中形参实参传递都是用的值传递。","slug":"go-pointer","published":1,"updated":"2021-11-19T07:17:06.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwbpt4if0000zsv295atdo8q","content":"<h3 id=\"什么是指针，指针变量，指针类型？\"><a href=\"#什么是指针，指针变量，指针类型？\" class=\"headerlink\" title=\"什么是指针，指针变量，指针类型？\"></a>什么是指针，指针变量，指针类型？</h3><p>任何程序数据载入内存后，在内存中都有他们的地址，这个就是<strong>指针</strong>。</p>\n<p>为了保存一个数据在内存中的地址，需要<strong>指针变量</strong>。</p>\n<p>Go语言中的值类型(int、float、bool、string、array、struct)都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。所以指针类型里面存放的值就是指针，也就是地址。</p>\n<p>下面看个列子，图文结合的理解一下。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">:=</span> <span class=\"token number\">10</span>\n    b <span class=\"token operator\">:=</span> <span class=\"token operator\">&amp;</span>a\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a:%d ptr:%p\\n\"</span><span class=\"token punctuation\">,</span> a <span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b:%p type:%T\\n\"</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// a:10 ptr:0xc000054080</span>\n    <span class=\"token comment\" spellcheck=\"true\">// b:0xc000054080 type:*int</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 0xc000080018</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><img src=\"/2021/11/12/go-pointer/1.png\" alt></p>\n<p>如上图，把内存区域理解成上面的一个一个连续的小方格。方格里面是用来存储数据的。每个方格都是一个物理地址。</p>\n<ul>\n<li>当执行 <code>a := 10</code> 时，数值10被存放到了物理地址为<code>0xc00054080</code>的方格上。变量a引用了这个方格，所以我们程序访问a时就能定位到这个方格，由于变量a里面存的是10这个数值，所以他是一个数值类型的变量。</li>\n<li>当执行<code>b := &amp;a</code>时，因为在go语言中，<code>&amp;a</code>表示的意思是取变量a指向的物理地址（也就是存储10对应的物理地址）。所以执行这条代码时会在内存的其他方格，假设在<code>0xc00080018</code>这个方格上，就会存储&amp;a,也就是<code>0xc00054080</code>这个数据。我之所以称它为<code>这个数据</code>，是因为他不是我们平常经常存的数值类型，布尔类型等，他就是一个物理地址，所以我们称他是一个<code>指针类型</code>。而b就表示是一个<code>指针变量</code>。</li>\n<li>因为上面我们说过go语言中&amp;表示取变量指向的物理地址。所以&amp;b的值就是<code>0cx00080018</code>这个物理地址了。</li>\n</ul>\n<h3 id=\"golang中的值传递和引用传递\"><a href=\"#golang中的值传递和引用传递\" class=\"headerlink\" title=\"golang中的值传递和引用传递\"></a>golang中的值传递和引用传递</h3><p>先来看看两者的概念 :</p>\n<ul>\n<li>值传递 ： 方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li>\n<li>引用传递： 方法调用时传递的引用的地址，也就是变量所对应的内存空间的地址。</li>\n</ul>\n<h4 id=\"例子1\"><a href=\"#例子1\" class=\"headerlink\" title=\"例子1\"></a>例子1</h4><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">TestOther1</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> a <span class=\"token builtin\">int64</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"变量a对应的地址 %p\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">modifiedNumber</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"最终a的值 %d\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">modifiedNumber</span><span class=\"token punctuation\">(</span>c <span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"变量c对应的地址 %p\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>c<span class=\"token punctuation\">)</span>\n    c <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//变量a对应的地址 0xc00009e298</span>\n<span class=\"token comment\" spellcheck=\"true\">//变量c对应的地址 0xc00009e2a0</span>\n<span class=\"token comment\" spellcheck=\"true\">//最终a的值 10</span></code></pre>\n<p><img src=\"/2021/11/12/go-pointer/2.png\" alt></p>\n<p>看图分析 ，基本类型例如int64等类型采用的是<code>值传递</code>，也就是说变量c复制了变量a存储在方格<code>0xc0009e298</code>里面的值10，然后存到了另外一个方格<code>0xc0009e2a0</code>。那变量c值的变化不影响变量a。</p>\n<h4 id=\"例子2\"><a href=\"#例子2\" class=\"headerlink\" title=\"例子2\"></a>例子2</h4><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">TestOther2</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> a <span class=\"token builtin\">int64</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"变量a对应的地址 %p\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">modifiedNumber2</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// args就是实际参数</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"最终a的值 %d\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token function\">modifiedNumber2</span><span class=\"token punctuation\">(</span>c <span class=\"token operator\">*</span><span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//这里定义的args就是形式参数</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"变量c存储的值 %v\"</span> <span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">*</span>c <span class=\"token operator\">=</span> <span class=\"token number\">100</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//变量a对应的地址 0xc00000a348</span>\n<span class=\"token comment\" spellcheck=\"true\">//变量c存储的值 0xc00000a348</span>\n<span class=\"token comment\" spellcheck=\"true\">//最终a的值 100</span></code></pre>\n<p><img src=\"/2021/11/12/go-pointer/3.png\" alt></p>\n<p>如图所示，c是一个指针类型，c存放的是a的物理地址<code>0xc00000a348</code>。当执行<code>*c = 100</code>时候，*c在go中代表c变量中存储的物理地址<code>0xc00000a348</code>对应的方格它存的值。所以当 *c =100时，就会更改<code>0xc000003a68</code>这个物理地址里面存的数，所以变量a的值最终变成了100。所以对于指针类型来说，它也是值传递，它拷贝了一份变量a对应的物理地址。本身变量c是一个指针类型，它存物理地址没毛病。所以总的来说，指针类型也是通过值传递的。</p>\n<p>总结 ： golang中形参实参传递都是用的值传递。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是指针，指针变量，指针类型？\"><a href=\"#什么是指针，指针变量，指针类型？\" class=\"headerlink\" title=\"什么是指针，指针变量，指针类型？\"></a>什么是指针，指针变量，指针类型？</h3><p>任何程序数据载入内存后，在内存中都有他们的地址，这个就是<strong>指针</strong>。</p>\n<p>为了保存一个数据在内存中的地址，需要<strong>指针变量</strong>。</p>\n<p>Go语言中的值类型(int、float、bool、string、array、struct)都有对应的指针类型，如：<code>*int</code>、<code>*int64</code>、<code>*string</code>等。所以指针类型里面存放的值就是指针，也就是地址。</p>\n<p>下面看个列子，图文结合的理解一下。</p>\n<pre><code class=\"go\">func main(){\n    a := 10\n    b := &amp;a\n    fmt.Printf(&quot;a:%d ptr:%p\\n&quot;, a , &amp;a)\n    fmt.Printf(&quot;b:%p type:%T\\n&quot;, b, b)\n    fmt.Println(&amp;b)\n    // 结果\n    // a:10 ptr:0xc000054080\n    // b:0xc000054080 type:*int\n    // 0xc000080018\n}</code></pre>\n<p><img src=\"/2021/11/12/go-pointer/1.png\" alt></p>\n<p>如上图，把内存区域理解成上面的一个一个连续的小方格。方格里面是用来存储数据的。每个方格都是一个物理地址。</p>\n<ul>\n<li>当执行 <code>a := 10</code> 时，数值10被存放到了物理地址为<code>0xc00054080</code>的方格上。变量a引用了这个方格，所以我们程序访问a时就能定位到这个方格，由于变量a里面存的是10这个数值，所以他是一个数值类型的变量。</li>\n<li>当执行<code>b := &amp;a</code>时，因为在go语言中，<code>&amp;a</code>表示的意思是取变量a指向的物理地址（也就是存储10对应的物理地址）。所以执行这条代码时会在内存的其他方格，假设在<code>0xc00080018</code>这个方格上，就会存储&amp;a,也就是<code>0xc00054080</code>这个数据。我之所以称它为<code>这个数据</code>，是因为他不是我们平常经常存的数值类型，布尔类型等，他就是一个物理地址，所以我们称他是一个<code>指针类型</code>。而b就表示是一个<code>指针变量</code>。</li>\n<li>因为上面我们说过go语言中&amp;表示取变量指向的物理地址。所以&amp;b的值就是<code>0cx00080018</code>这个物理地址了。</li>\n</ul>\n<h3 id=\"golang中的值传递和引用传递\"><a href=\"#golang中的值传递和引用传递\" class=\"headerlink\" title=\"golang中的值传递和引用传递\"></a>golang中的值传递和引用传递</h3><p>先来看看两者的概念 :</p>\n<ul>\n<li>值传递 ： 方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li>\n<li>引用传递： 方法调用时传递的引用的地址，也就是变量所对应的内存空间的地址。</li>\n</ul>\n<h4 id=\"例子1\"><a href=\"#例子1\" class=\"headerlink\" title=\"例子1\"></a>例子1</h4><pre><code class=\"go\">func TestOther1(t *testing.T) {\n    var a int64 = 10\n    fmt.Printf(&quot;变量a对应的地址 %p\\n&quot;, &amp;a)\n    modifiedNumber(a)\n    fmt.Printf(&quot;最终a的值 %d&quot;, a)\n}\nfunc modifiedNumber(c int64) {\n    fmt.Printf(&quot;变量c对应的地址 %p\\n&quot;, &amp;c)\n    c = 100\n}\n//变量a对应的地址 0xc00009e298\n//变量c对应的地址 0xc00009e2a0\n//最终a的值 10</code></pre>\n<p><img src=\"/2021/11/12/go-pointer/2.png\" alt></p>\n<p>看图分析 ，基本类型例如int64等类型采用的是<code>值传递</code>，也就是说变量c复制了变量a存储在方格<code>0xc0009e298</code>里面的值10，然后存到了另外一个方格<code>0xc0009e2a0</code>。那变量c值的变化不影响变量a。</p>\n<h4 id=\"例子2\"><a href=\"#例子2\" class=\"headerlink\" title=\"例子2\"></a>例子2</h4><pre><code class=\"go\">func TestOther2(t *testing.T) {\n    var a int64 = 10\n    fmt.Printf(&quot;变量a对应的地址 %p&quot;, &amp;a)\n    fmt.Println()\n    modifiedNumber2(&amp;a) // args就是实际参数\n    fmt.Printf(&quot;最终a的值 %d&quot;, a)\n    fmt.Println()\n}\nfunc modifiedNumber2(c *int64) { //这里定义的args就是形式参数\n    fmt.Printf(&quot;变量c存储的值 %v&quot; , c)\n    fmt.Println()\n    *c = 100\n}\n//变量a对应的地址 0xc00000a348\n//变量c存储的值 0xc00000a348\n//最终a的值 100</code></pre>\n<p><img src=\"/2021/11/12/go-pointer/3.png\" alt></p>\n<p>如图所示，c是一个指针类型，c存放的是a的物理地址<code>0xc00000a348</code>。当执行<code>*c = 100</code>时候，*c在go中代表c变量中存储的物理地址<code>0xc00000a348</code>对应的方格它存的值。所以当 *c =100时，就会更改<code>0xc000003a68</code>这个物理地址里面存的数，所以变量a的值最终变成了100。所以对于指针类型来说，它也是值传递，它拷贝了一份变量a对应的物理地址。本身变量c是一个指针类型，它存物理地址没毛病。所以总的来说，指针类型也是通过值传递的。</p>\n<p>总结 ： golang中形参实参传递都是用的值传递。</p>\n"},{"title":"Docker学习笔记","description":"Docker学习笔记","date":"2019-07-18T02:00:00.000Z","_content":"### Docker安装\n\n```sh\n#卸载\nyum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine\n\n#需要的安装包\nyum install -y yum-utils\n\n#国内镜像源\nyum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n#更新yum软件包索引 \nyum makecache fast\n\n#安装docker相关的 docker-ce 社区版 而ee是企业版 \nyum install docker-ce docker-ce-cli containerd.io\n\n#使用docker version查看是否按照成功 \ndocker version\n\n```\n\n### Docker镜像常用命令\n\n```shell\ndocker image pull xxx #从仓库拉取镜像\ndocker images #查看所有镜像\ndocker image inspect xxx #查看镜像具体信息\ndocker rmi xxx #删除镜像  docker rmi $(docker images -aq) 删除所有镜像\ndocker build -f Dockerfile -t 镜像名:[tag] . #构建一个镜像\n```\n\n### Docker容器常用命令\n\n```shell\n#从image创建容器并启动\ndocker run [可选参数] image | docker container run [可选参数] image\n#参书说明 \n--name=\"Name\" 容器名字 tomcat01 tomcat02 用来区分容器 \n-d 后台方式运行 \n-it 使用交互方式运行，进入容器查看内容 \n-p 指定容器的端口 -p 8080(宿主机):8080(容器) \n-P(大写) 随机指定端口\n\n#进入容器\ndocker -it 容器id/名称 /bin/bash\n#停止，启动，重启，kill容器\ndocker stop/start/restart/kill 容器id/名称\n#删除容器，此容器必须没在运行\ndocker rm 容器id/名称\n#查看容器\ndocker inspect 容器id/名称\n```\n\n\n\n### Docker-Compose常用命令\n\n```shell\n#用于部署一个 Compose 应用,默认情况下该命令会读取名为 docker-compose.yml 或 docker-compose.yaml 的文件\n#如果名字不是上面两个，则使用-f指定\ndocker-compose up\n\n#停止 Compose 应用相关的所有容器，但不会删除它们。\ndocker-compose stop\n\n#用于删除已停止的 Compose 应用\ndocker-compose rm\n\n#重启已停止的 Compose 应用\ndocker-compose restart\n\n#用于列出 Compose 应用中的各个容器\ndocker-compose ps\n\n#输出内容包括当前状态、容器运行的命令以及网络端口，但是不会删除卷和镜像\ndocker-compose down\n```\n\n","source":"_posts/docker-study.md","raw":"---\ntitle: Docker学习笔记\ntags:\n  - Docker\ncategories:  Docker\ndescription : Docker学习笔记\ndate: 2019-07-18 10:00:00\n---\n### Docker安装\n\n```sh\n#卸载\nyum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine\n\n#需要的安装包\nyum install -y yum-utils\n\n#国内镜像源\nyum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n#更新yum软件包索引 \nyum makecache fast\n\n#安装docker相关的 docker-ce 社区版 而ee是企业版 \nyum install docker-ce docker-ce-cli containerd.io\n\n#使用docker version查看是否按照成功 \ndocker version\n\n```\n\n### Docker镜像常用命令\n\n```shell\ndocker image pull xxx #从仓库拉取镜像\ndocker images #查看所有镜像\ndocker image inspect xxx #查看镜像具体信息\ndocker rmi xxx #删除镜像  docker rmi $(docker images -aq) 删除所有镜像\ndocker build -f Dockerfile -t 镜像名:[tag] . #构建一个镜像\n```\n\n### Docker容器常用命令\n\n```shell\n#从image创建容器并启动\ndocker run [可选参数] image | docker container run [可选参数] image\n#参书说明 \n--name=\"Name\" 容器名字 tomcat01 tomcat02 用来区分容器 \n-d 后台方式运行 \n-it 使用交互方式运行，进入容器查看内容 \n-p 指定容器的端口 -p 8080(宿主机):8080(容器) \n-P(大写) 随机指定端口\n\n#进入容器\ndocker -it 容器id/名称 /bin/bash\n#停止，启动，重启，kill容器\ndocker stop/start/restart/kill 容器id/名称\n#删除容器，此容器必须没在运行\ndocker rm 容器id/名称\n#查看容器\ndocker inspect 容器id/名称\n```\n\n\n\n### Docker-Compose常用命令\n\n```shell\n#用于部署一个 Compose 应用,默认情况下该命令会读取名为 docker-compose.yml 或 docker-compose.yaml 的文件\n#如果名字不是上面两个，则使用-f指定\ndocker-compose up\n\n#停止 Compose 应用相关的所有容器，但不会删除它们。\ndocker-compose stop\n\n#用于删除已停止的 Compose 应用\ndocker-compose rm\n\n#重启已停止的 Compose 应用\ndocker-compose restart\n\n#用于列出 Compose 应用中的各个容器\ndocker-compose ps\n\n#输出内容包括当前状态、容器运行的命令以及网络端口，但是不会删除卷和镜像\ndocker-compose down\n```\n\n","slug":"docker-study","published":1,"updated":"2021-10-09T13:35:50.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwbpt4ij0001zsv21ijs980z","content":"<h3 id=\"Docker安装\"><a href=\"#Docker安装\" class=\"headerlink\" title=\"Docker安装\"></a>Docker安装</h3><pre class=\" language-sh\"><code class=\"language-sh\">#卸载\nyum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine\n\n#需要的安装包\nyum install -y yum-utils\n\n#国内镜像源\nyum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n#更新yum软件包索引 \nyum makecache fast\n\n#安装docker相关的 docker-ce 社区版 而ee是企业版 \nyum install docker-ce docker-ce-cli containerd.io\n\n#使用docker version查看是否按照成功 \ndocker version\n</code></pre>\n<h3 id=\"Docker镜像常用命令\"><a href=\"#Docker镜像常用命令\" class=\"headerlink\" title=\"Docker镜像常用命令\"></a>Docker镜像常用命令</h3><pre class=\" language-shell\"><code class=\"language-shell\">docker image pull xxx #从仓库拉取镜像\ndocker images #查看所有镜像\ndocker image inspect xxx #查看镜像具体信息\ndocker rmi xxx #删除镜像  docker rmi $(docker images -aq) 删除所有镜像\ndocker build -f Dockerfile -t 镜像名:[tag] . #构建一个镜像</code></pre>\n<h3 id=\"Docker容器常用命令\"><a href=\"#Docker容器常用命令\" class=\"headerlink\" title=\"Docker容器常用命令\"></a>Docker容器常用命令</h3><pre class=\" language-shell\"><code class=\"language-shell\">#从image创建容器并启动\ndocker run [可选参数] image | docker container run [可选参数] image\n#参书说明 \n--name=\"Name\" 容器名字 tomcat01 tomcat02 用来区分容器 \n-d 后台方式运行 \n-it 使用交互方式运行，进入容器查看内容 \n-p 指定容器的端口 -p 8080(宿主机):8080(容器) \n-P(大写) 随机指定端口\n\n#进入容器\ndocker -it 容器id/名称 /bin/bash\n#停止，启动，重启，kill容器\ndocker stop/start/restart/kill 容器id/名称\n#删除容器，此容器必须没在运行\ndocker rm 容器id/名称\n#查看容器\ndocker inspect 容器id/名称</code></pre>\n<h3 id=\"Docker-Compose常用命令\"><a href=\"#Docker-Compose常用命令\" class=\"headerlink\" title=\"Docker-Compose常用命令\"></a>Docker-Compose常用命令</h3><pre class=\" language-shell\"><code class=\"language-shell\">#用于部署一个 Compose 应用,默认情况下该命令会读取名为 docker-compose.yml 或 docker-compose.yaml 的文件\n#如果名字不是上面两个，则使用-f指定\ndocker-compose up\n\n#停止 Compose 应用相关的所有容器，但不会删除它们。\ndocker-compose stop\n\n#用于删除已停止的 Compose 应用\ndocker-compose rm\n\n#重启已停止的 Compose 应用\ndocker-compose restart\n\n#用于列出 Compose 应用中的各个容器\ndocker-compose ps\n\n#输出内容包括当前状态、容器运行的命令以及网络端口，但是不会删除卷和镜像\ndocker-compose down</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Docker安装\"><a href=\"#Docker安装\" class=\"headerlink\" title=\"Docker安装\"></a>Docker安装</h3><pre><code class=\"sh\">#卸载\nyum remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine\n\n#需要的安装包\nyum install -y yum-utils\n\n#国内镜像源\nyum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n#更新yum软件包索引 \nyum makecache fast\n\n#安装docker相关的 docker-ce 社区版 而ee是企业版 \nyum install docker-ce docker-ce-cli containerd.io\n\n#使用docker version查看是否按照成功 \ndocker version\n</code></pre>\n<h3 id=\"Docker镜像常用命令\"><a href=\"#Docker镜像常用命令\" class=\"headerlink\" title=\"Docker镜像常用命令\"></a>Docker镜像常用命令</h3><pre><code class=\"shell\">docker image pull xxx #从仓库拉取镜像\ndocker images #查看所有镜像\ndocker image inspect xxx #查看镜像具体信息\ndocker rmi xxx #删除镜像  docker rmi $(docker images -aq) 删除所有镜像\ndocker build -f Dockerfile -t 镜像名:[tag] . #构建一个镜像</code></pre>\n<h3 id=\"Docker容器常用命令\"><a href=\"#Docker容器常用命令\" class=\"headerlink\" title=\"Docker容器常用命令\"></a>Docker容器常用命令</h3><pre><code class=\"shell\">#从image创建容器并启动\ndocker run [可选参数] image | docker container run [可选参数] image\n#参书说明 \n--name=&quot;Name&quot; 容器名字 tomcat01 tomcat02 用来区分容器 \n-d 后台方式运行 \n-it 使用交互方式运行，进入容器查看内容 \n-p 指定容器的端口 -p 8080(宿主机):8080(容器) \n-P(大写) 随机指定端口\n\n#进入容器\ndocker -it 容器id/名称 /bin/bash\n#停止，启动，重启，kill容器\ndocker stop/start/restart/kill 容器id/名称\n#删除容器，此容器必须没在运行\ndocker rm 容器id/名称\n#查看容器\ndocker inspect 容器id/名称</code></pre>\n<h3 id=\"Docker-Compose常用命令\"><a href=\"#Docker-Compose常用命令\" class=\"headerlink\" title=\"Docker-Compose常用命令\"></a>Docker-Compose常用命令</h3><pre><code class=\"shell\">#用于部署一个 Compose 应用,默认情况下该命令会读取名为 docker-compose.yml 或 docker-compose.yaml 的文件\n#如果名字不是上面两个，则使用-f指定\ndocker-compose up\n\n#停止 Compose 应用相关的所有容器，但不会删除它们。\ndocker-compose stop\n\n#用于删除已停止的 Compose 应用\ndocker-compose rm\n\n#重启已停止的 Compose 应用\ndocker-compose restart\n\n#用于列出 Compose 应用中的各个容器\ndocker-compose ps\n\n#输出内容包括当前状态、容器运行的命令以及网络端口，但是不会删除卷和镜像\ndocker-compose down</code></pre>\n"},{"title":"Docker实战测试","description":"Docker实战测试","date":"2019-07-18T02:00:00.000Z","_content":"### Docker搭建Redis集群\n\n***1.创建Docker自定义网络***\n\n```shell\ndocker network create redis-cluster-net #创建自定义网络保证集群内的Redis能通过容器名ping得通\n[root@localhost ~]# docker network inspect redis-cluster-net #查看创建的自定义网络的GateWay\n\"IPAM\": {\n            \"Driver\": \"default\",\n            \"Options\": {},\n            \"Config\": [\n                {\n                    \"Subnet\": \"172.20.0.0/16\",\n                    \"Gateway\": \"172.20.0.1\"\n                }\n            ]\n}\n```\n\n***2.通过创建6个Redis对应的数据卷（data和redis.conf）***\n\n```shell\nfor port in $(seq 1 6);\\\ndo \\\nmkdir -p /home/project/redis/node-${port}/conf \ntouch /home/project/redis/node-${port}/conf/redis.conf \ncat << EOF >> /home/project/redis/node-${port}/conf/redis.conf \nport 6379 \nbind 0.0.0.0\ncluster-enabled yes \ncluster-config-file nodes.conf \ncluster-node-timeout 5000 \ncluster-announce-ip 172.20.0.1${port} \ncluster-announce-port 6379 \ncluster-announce-bus-port 16379 \nappendonly yes\nEOF\ndone\n```\n\n***3.启动6个redis***\n\n```shell\n下面几步可以通过脚本来做，为了容易理解，我先不用脚本\n\ndocker run -p 6371:6379 -p 16671:16379 --name redis-1 -v /home/project/redis/node-1/data:/data -v /home/project/redis/node-1/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6372:6379 -p 16672:16379 --name redis-2 -v /home/project/redis/node-2/data:/data -v /home/project/redis/node-2/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6373:6379 -p 16673:16379 --name redis-3 -v /home/project/redis/node-3/data:/data -v /home/project/redis/node-3/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6374:6379 -p 16674:16379 --name redis-4 -v /home/project/redis/node-4/data:/data -v /home/project/redis/node-4/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6375:6379 -p 16675:16379 --name redis-5 -v /home/project/redis/node-5/data:/data -v /home/project/redis/node-5/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6376:6379 -p 16676:16379 --name redis-6 -v /home/project/redis/node-6/data:/data -v /home/project/redis/node-6/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n```\n\n结果如下，6台redis都已启动，且能相互ping通\n\n```shell\n[root@localhost ~]# docker ps\nCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS                                                                                      NAMES\n9547f6533dd7   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   13 minutes ago   Up 13 minutes   0.0.0.0:6376->6379/tcp, :::6376->6379/tcp, 0.0.0.0:16676->16379/tcp, :::16676->16379/tcp   redis-6\n379c980981ae   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6375->6379/tcp, :::6375->6379/tcp, 0.0.0.0:16675->16379/tcp, :::16675->16379/tcp   redis-5\nd61aaa73d81d   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6374->6379/tcp, :::6374->6379/tcp, 0.0.0.0:16674->16379/tcp, :::16674->16379/tcp   redis-4\n314127dbe25d   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6373->6379/tcp, :::6373->6379/tcp, 0.0.0.0:16673->16379/tcp, :::16673->16379/tcp   redis-3\nad87d3457967   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6372->6379/tcp, :::6372->6379/tcp, 0.0.0.0:16672->16379/tcp, :::16672->16379/tcp   redis-2\n67031339409f   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   15 minutes ago   Up 15 minutes   0.0.0.0:6371->6379/tcp, :::6371->6379/tcp, 0.0.0.0:16671->16379/tcp, :::16671->16379/tcp   redis-1\n```\n***4.设置集群***\n```shell\n#首先进入其中一个redis\ndocker exec -it redis-1 /bin/sh #redis默认没有bash\n#配置集群\nredis-cli --cluster create 172.20.0.11:6379 172.20.0.12:6379 172.20.0.13:6379 172.20.0.14:6379 172.20.0.15:6379 172.20.0.16:6379 --cluster-replicas 1\n#接下去就是按照redis集群搭建的提示进行处理了\n```\n\n\n","source":"_posts/docker-redis.md","raw":"---\ntitle: Docker实战测试\ntags:\n  - Docker\ncategories:  Docker\ndescription : Docker实战测试\ndate: 2019-07-18 10:00:00\n---\n### Docker搭建Redis集群\n\n***1.创建Docker自定义网络***\n\n```shell\ndocker network create redis-cluster-net #创建自定义网络保证集群内的Redis能通过容器名ping得通\n[root@localhost ~]# docker network inspect redis-cluster-net #查看创建的自定义网络的GateWay\n\"IPAM\": {\n            \"Driver\": \"default\",\n            \"Options\": {},\n            \"Config\": [\n                {\n                    \"Subnet\": \"172.20.0.0/16\",\n                    \"Gateway\": \"172.20.0.1\"\n                }\n            ]\n}\n```\n\n***2.通过创建6个Redis对应的数据卷（data和redis.conf）***\n\n```shell\nfor port in $(seq 1 6);\\\ndo \\\nmkdir -p /home/project/redis/node-${port}/conf \ntouch /home/project/redis/node-${port}/conf/redis.conf \ncat << EOF >> /home/project/redis/node-${port}/conf/redis.conf \nport 6379 \nbind 0.0.0.0\ncluster-enabled yes \ncluster-config-file nodes.conf \ncluster-node-timeout 5000 \ncluster-announce-ip 172.20.0.1${port} \ncluster-announce-port 6379 \ncluster-announce-bus-port 16379 \nappendonly yes\nEOF\ndone\n```\n\n***3.启动6个redis***\n\n```shell\n下面几步可以通过脚本来做，为了容易理解，我先不用脚本\n\ndocker run -p 6371:6379 -p 16671:16379 --name redis-1 -v /home/project/redis/node-1/data:/data -v /home/project/redis/node-1/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6372:6379 -p 16672:16379 --name redis-2 -v /home/project/redis/node-2/data:/data -v /home/project/redis/node-2/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6373:6379 -p 16673:16379 --name redis-3 -v /home/project/redis/node-3/data:/data -v /home/project/redis/node-3/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6374:6379 -p 16674:16379 --name redis-4 -v /home/project/redis/node-4/data:/data -v /home/project/redis/node-4/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6375:6379 -p 16675:16379 --name redis-5 -v /home/project/redis/node-5/data:/data -v /home/project/redis/node-5/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6376:6379 -p 16676:16379 --name redis-6 -v /home/project/redis/node-6/data:/data -v /home/project/redis/node-6/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n```\n\n结果如下，6台redis都已启动，且能相互ping通\n\n```shell\n[root@localhost ~]# docker ps\nCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS                                                                                      NAMES\n9547f6533dd7   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   13 minutes ago   Up 13 minutes   0.0.0.0:6376->6379/tcp, :::6376->6379/tcp, 0.0.0.0:16676->16379/tcp, :::16676->16379/tcp   redis-6\n379c980981ae   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6375->6379/tcp, :::6375->6379/tcp, 0.0.0.0:16675->16379/tcp, :::16675->16379/tcp   redis-5\nd61aaa73d81d   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6374->6379/tcp, :::6374->6379/tcp, 0.0.0.0:16674->16379/tcp, :::16674->16379/tcp   redis-4\n314127dbe25d   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6373->6379/tcp, :::6373->6379/tcp, 0.0.0.0:16673->16379/tcp, :::16673->16379/tcp   redis-3\nad87d3457967   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6372->6379/tcp, :::6372->6379/tcp, 0.0.0.0:16672->16379/tcp, :::16672->16379/tcp   redis-2\n67031339409f   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   15 minutes ago   Up 15 minutes   0.0.0.0:6371->6379/tcp, :::6371->6379/tcp, 0.0.0.0:16671->16379/tcp, :::16671->16379/tcp   redis-1\n```\n***4.设置集群***\n```shell\n#首先进入其中一个redis\ndocker exec -it redis-1 /bin/sh #redis默认没有bash\n#配置集群\nredis-cli --cluster create 172.20.0.11:6379 172.20.0.12:6379 172.20.0.13:6379 172.20.0.14:6379 172.20.0.15:6379 172.20.0.16:6379 --cluster-replicas 1\n#接下去就是按照redis集群搭建的提示进行处理了\n```\n\n\n","slug":"docker-redis","published":1,"updated":"2021-06-18T01:15:27.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwbpt4iw0004zsv28b8xhers","content":"<h3 id=\"Docker搭建Redis集群\"><a href=\"#Docker搭建Redis集群\" class=\"headerlink\" title=\"Docker搭建Redis集群\"></a>Docker搭建Redis集群</h3><p><strong><em>1.创建Docker自定义网络</em></strong></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">docker network create redis-cluster-net #创建自定义网络保证集群内的Redis能通过容器名ping得通\n[root@localhost ~]# docker network inspect redis-cluster-net #查看创建的自定义网络的GateWay\n\"IPAM\": {\n            \"Driver\": \"default\",\n            \"Options\": {},\n            \"Config\": [\n                {\n                    \"Subnet\": \"172.20.0.0/16\",\n                    \"Gateway\": \"172.20.0.1\"\n                }\n            ]\n}</code></pre>\n<p><strong><em>2.通过创建6个Redis对应的数据卷（data和redis.conf）</em></strong></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">for port in $(seq 1 6);\\\ndo \\\nmkdir -p /home/project/redis/node-${port}/conf \ntouch /home/project/redis/node-${port}/conf/redis.conf \ncat << EOF >> /home/project/redis/node-${port}/conf/redis.conf \nport 6379 \nbind 0.0.0.0\ncluster-enabled yes \ncluster-config-file nodes.conf \ncluster-node-timeout 5000 \ncluster-announce-ip 172.20.0.1${port} \ncluster-announce-port 6379 \ncluster-announce-bus-port 16379 \nappendonly yes\nEOF\ndone</code></pre>\n<p><strong><em>3.启动6个redis</em></strong></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">下面几步可以通过脚本来做，为了容易理解，我先不用脚本\n\ndocker run -p 6371:6379 -p 16671:16379 --name redis-1 -v /home/project/redis/node-1/data:/data -v /home/project/redis/node-1/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6372:6379 -p 16672:16379 --name redis-2 -v /home/project/redis/node-2/data:/data -v /home/project/redis/node-2/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6373:6379 -p 16673:16379 --name redis-3 -v /home/project/redis/node-3/data:/data -v /home/project/redis/node-3/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6374:6379 -p 16674:16379 --name redis-4 -v /home/project/redis/node-4/data:/data -v /home/project/redis/node-4/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6375:6379 -p 16675:16379 --name redis-5 -v /home/project/redis/node-5/data:/data -v /home/project/redis/node-5/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6376:6379 -p 16676:16379 --name redis-6 -v /home/project/redis/node-6/data:/data -v /home/project/redis/node-6/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</code></pre>\n<p>结果如下，6台redis都已启动，且能相互ping通</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">[root@localhost ~]# docker ps\nCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS                                                                                      NAMES\n9547f6533dd7   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   13 minutes ago   Up 13 minutes   0.0.0.0:6376->6379/tcp, :::6376->6379/tcp, 0.0.0.0:16676->16379/tcp, :::16676->16379/tcp   redis-6\n379c980981ae   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6375->6379/tcp, :::6375->6379/tcp, 0.0.0.0:16675->16379/tcp, :::16675->16379/tcp   redis-5\nd61aaa73d81d   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6374->6379/tcp, :::6374->6379/tcp, 0.0.0.0:16674->16379/tcp, :::16674->16379/tcp   redis-4\n314127dbe25d   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6373->6379/tcp, :::6373->6379/tcp, 0.0.0.0:16673->16379/tcp, :::16673->16379/tcp   redis-3\nad87d3457967   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   14 minutes ago   Up 14 minutes   0.0.0.0:6372->6379/tcp, :::6372->6379/tcp, 0.0.0.0:16672->16379/tcp, :::16672->16379/tcp   redis-2\n67031339409f   redis:5.0.9-alpine3.11   \"docker-entrypoint.s…\"   15 minutes ago   Up 15 minutes   0.0.0.0:6371->6379/tcp, :::6371->6379/tcp, 0.0.0.0:16671->16379/tcp, :::16671->16379/tcp   redis-1</code></pre>\n<p><strong><em>4.设置集群</em></strong></p>\n<pre class=\" language-shell\"><code class=\"language-shell\">#首先进入其中一个redis\ndocker exec -it redis-1 /bin/sh #redis默认没有bash\n#配置集群\nredis-cli --cluster create 172.20.0.11:6379 172.20.0.12:6379 172.20.0.13:6379 172.20.0.14:6379 172.20.0.15:6379 172.20.0.16:6379 --cluster-replicas 1\n#接下去就是按照redis集群搭建的提示进行处理了</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Docker搭建Redis集群\"><a href=\"#Docker搭建Redis集群\" class=\"headerlink\" title=\"Docker搭建Redis集群\"></a>Docker搭建Redis集群</h3><p><strong><em>1.创建Docker自定义网络</em></strong></p>\n<pre><code class=\"shell\">docker network create redis-cluster-net #创建自定义网络保证集群内的Redis能通过容器名ping得通\n[root@localhost ~]# docker network inspect redis-cluster-net #查看创建的自定义网络的GateWay\n&quot;IPAM&quot;: {\n            &quot;Driver&quot;: &quot;default&quot;,\n            &quot;Options&quot;: {},\n            &quot;Config&quot;: [\n                {\n                    &quot;Subnet&quot;: &quot;172.20.0.0/16&quot;,\n                    &quot;Gateway&quot;: &quot;172.20.0.1&quot;\n                }\n            ]\n}</code></pre>\n<p><strong><em>2.通过创建6个Redis对应的数据卷（data和redis.conf）</em></strong></p>\n<pre><code class=\"shell\">for port in $(seq 1 6);\\\ndo \\\nmkdir -p /home/project/redis/node-${port}/conf \ntouch /home/project/redis/node-${port}/conf/redis.conf \ncat &lt;&lt; EOF &gt;&gt; /home/project/redis/node-${port}/conf/redis.conf \nport 6379 \nbind 0.0.0.0\ncluster-enabled yes \ncluster-config-file nodes.conf \ncluster-node-timeout 5000 \ncluster-announce-ip 172.20.0.1${port} \ncluster-announce-port 6379 \ncluster-announce-bus-port 16379 \nappendonly yes\nEOF\ndone</code></pre>\n<p><strong><em>3.启动6个redis</em></strong></p>\n<pre><code class=\"shell\">下面几步可以通过脚本来做，为了容易理解，我先不用脚本\n\ndocker run -p 6371:6379 -p 16671:16379 --name redis-1 -v /home/project/redis/node-1/data:/data -v /home/project/redis/node-1/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.11 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6372:6379 -p 16672:16379 --name redis-2 -v /home/project/redis/node-2/data:/data -v /home/project/redis/node-2/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.12 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6373:6379 -p 16673:16379 --name redis-3 -v /home/project/redis/node-3/data:/data -v /home/project/redis/node-3/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.13 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6374:6379 -p 16674:16379 --name redis-4 -v /home/project/redis/node-4/data:/data -v /home/project/redis/node-4/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.14 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6375:6379 -p 16675:16379 --name redis-5 -v /home/project/redis/node-5/data:/data -v /home/project/redis/node-5/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.15 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf\n\n\ndocker run -p 6376:6379 -p 16676:16379 --name redis-6 -v /home/project/redis/node-6/data:/data -v /home/project/redis/node-6/conf/redis.conf:/etc/redis/redis.conf -d --net redis-cluster-net --ip 172.20.0.16 redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf</code></pre>\n<p>结果如下，6台redis都已启动，且能相互ping通</p>\n<pre><code class=\"shell\">[root@localhost ~]# docker ps\nCONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS          PORTS                                                                                      NAMES\n9547f6533dd7   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   13 minutes ago   Up 13 minutes   0.0.0.0:6376-&gt;6379/tcp, :::6376-&gt;6379/tcp, 0.0.0.0:16676-&gt;16379/tcp, :::16676-&gt;16379/tcp   redis-6\n379c980981ae   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   14 minutes ago   Up 14 minutes   0.0.0.0:6375-&gt;6379/tcp, :::6375-&gt;6379/tcp, 0.0.0.0:16675-&gt;16379/tcp, :::16675-&gt;16379/tcp   redis-5\nd61aaa73d81d   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   14 minutes ago   Up 14 minutes   0.0.0.0:6374-&gt;6379/tcp, :::6374-&gt;6379/tcp, 0.0.0.0:16674-&gt;16379/tcp, :::16674-&gt;16379/tcp   redis-4\n314127dbe25d   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   14 minutes ago   Up 14 minutes   0.0.0.0:6373-&gt;6379/tcp, :::6373-&gt;6379/tcp, 0.0.0.0:16673-&gt;16379/tcp, :::16673-&gt;16379/tcp   redis-3\nad87d3457967   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   14 minutes ago   Up 14 minutes   0.0.0.0:6372-&gt;6379/tcp, :::6372-&gt;6379/tcp, 0.0.0.0:16672-&gt;16379/tcp, :::16672-&gt;16379/tcp   redis-2\n67031339409f   redis:5.0.9-alpine3.11   &quot;docker-entrypoint.s…&quot;   15 minutes ago   Up 15 minutes   0.0.0.0:6371-&gt;6379/tcp, :::6371-&gt;6379/tcp, 0.0.0.0:16671-&gt;16379/tcp, :::16671-&gt;16379/tcp   redis-1</code></pre>\n<p><strong><em>4.设置集群</em></strong></p>\n<pre><code class=\"shell\">#首先进入其中一个redis\ndocker exec -it redis-1 /bin/sh #redis默认没有bash\n#配置集群\nredis-cli --cluster create 172.20.0.11:6379 172.20.0.12:6379 172.20.0.13:6379 172.20.0.14:6379 172.20.0.15:6379 172.20.0.16:6379 --cluster-replicas 1\n#接下去就是按照redis集群搭建的提示进行处理了</code></pre>\n"},{"title":"Rust学习笔记","description":"Rust学习笔记","date":"2020-08-13T16:00:00.000Z","_content":"\n### 笔记\n\n***自定义类型如何打印输出？***\n\n自定义的类型如果要进行:?打印输出，需要实现`fmt::Debug`的`trait`。也可以在类型上加`#[derive(Debug)]`\n\n```rust\nfn main(){\n    #[derive(Debug)]\n\tstruct UnPrintable(i32);\n\tprintln!(\"{:?}\", DebugPrintable(13));\n    #[derive(Debug)]\n    struct Person<'a> {\n        name: &'a str,\n        age: u8\n    }\n    let name = \"Peter\";\n    let age = 27;\n    let peter = Person { name, age };\n    // 美化打印\n    println!(\"{:#?}\", peter);\n}\n```\n\n***消除变量未使用告警***\n\n```rust\nlet immutable_binding = 1;  //定义了这个变量，但是没有使用，编译时会告警\nlet _immutable_binding = 1; //但是如果变量名前面加_ 则不会告警\n```\n\n***Rust不提供原生类型的隐式转换，如果要转换可以通过as显式转换***\n\n```rust\nlet decimal = 65.4321_f32;\n// 错误！不提供隐式转换\nlet integer: u8 = decimal;\n// 改正 ^ 注释掉这一行\n// 可以显式转换\nlet integer = decimal as u8;\n```\n\n***结构体的类型转换***\n\n- From 和 Into\n- TryFrom 和 TryInto 类似于From和Into，只是这组返回的是Result类型\n- ToString 和 FromStr 可以把任何类型转换成string\n\n```rust\nuse std::convert::From;\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n// 实现了From<i32>表示i32类型可以通过into()方法转换成Number类型\n// i32转Number let num: Number = 5.into();\nimpl From<i32> for Number {\n    fn from(item: i32) -> Self {\n        Number { value: item }\n    }\n}\nfn main(){\n    let int: i32 = 5;\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n```\n\n```rust\nuse std::convert::TryFrom;\nuse std::convert::TryInto;\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\nimpl TryFrom<i32> for EvenNumber {\n    type Error = ();\n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\nfn main(){\n    let result: Result<EvenNumber, ()> = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result<EvenNumber, ()> = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n```\n\n***Rust中几种迭代方法***\n\n- iter() , 在每次迭代中借用集合中的一个元素。这样集合本身不会被改变，循环之后仍 可以使用。\n- into_iter() , 会消耗集合。在每次迭代中，集合中的数据本身会被提供。一旦集合被消 耗了，之后就无法再使用了，因为它已经在循环中被 “移除”（move）了。\n- iter_mut() , 可变地（mutably）借用集合中的每个元素，从而允许集合被就地修改。\n\n***Rust闭包move***\n\nmove的作用是`将所引用的变量的所有权转移至闭包内`。不带move则不会转移所有权。\n\n```rust\nfn main() {\n    struct Point {\n        x: i64,\n        y: i64,\n    }\n    if true {\n        let mut p = Point { x: 25, y: 25 };\n        println!(\"p address: {:p}\", &p);\n        (|| {\n            println!(\"不带move闭包，p address: {:p}\", &p);\n        })();\n        println!(\"p address: {:p}\", &p);\n        println!(\"------------------------------\");\n    }\n    if true {\n        let mut p = Point { x: 25, y: 25 };\n        println!(\"p address: {:p}\", &p);\n        (move || {\n            println!(\"带move闭包，p address: {:p}\", &p);\n        })();\n        //println!(\"p address: {:p}\", &p);//error[E0382]: borrow of moved value: `p`\n    }\n}\n```\n\n***Rust条件编译***\n\n条件编译可能通过两种不同的操作符实现：\n\n- cfg 属性：在属性位置中使用 #[cfg(...)]\n- cfg! 宏：在布尔表达式中使用 cfg!(...)\n\n`#[cfg(xxx)]` 和 `#[cfg(not(xxx))]`必须是一组，不然编译报错。也挺好理解的，既然是条件编译，如果没有所有条件都满足就会编译报错。\n\n```rust\n// 这个函数仅当目标系统是 Linux 的时候才会编译\n#[cfg(target_os = \"linux\")]\nfn are_you_on_linux() {\n    println!(\"You are running linux!\")\n}\n// 而这个函数仅当目标系统不是Linux时才会编译\n#[cfg(not(target_os = \"linux\"))]\nfn are_you_on_linux() {\n    println!(\"You are *not* running linux!\")\n}\npub fn demo13(){\n    are_you_on_linux();\n}\n```\n\n`target_os`是系统提供的，如果我们要用自定义的条件编译，需要通过`--cfg xxx`指定。\n\n```rust\n#[cfg(some_condition)]\nfn conditional_function() {\n    println!(\"condition met!\")\n}\n#[cfg(not(some_condition))]\nfn conditional_function() {\n    println!(\"condition met not !\")\n}\nfn main() {\n    conditional_function();\n}\n//运行 rustc --cfg some_condition xxx.rs && ./custom\n```\n\n***Rust特征(trait)中泛型参数和关联类型区别***\n\ntrait 中的泛型与关联类型，有如下区别：\n\n- 如果 trait 中包含泛型参数，那么，可以对同一个目标类型，多次 impl 此 trait，每次提供不同的泛型参数。而关联类型方式只允许对目标类型实现一次。\n- 如果 trait 中包含泛型参数，那么在具体方法调用的时候，必须加以类型标注以明确使用的是哪一个具体的实现。而关联类型方式具体调用时不需要标注类型（因为不存在模棱两可的情况）。\n\n```rust\npub trait Converter<T> {\n    fn convert(&self) -> T;\n}\nstruct MyInt;\nimpl Converter<i32> for MyInt {\n    fn convert(&self) -> i32 {\n        42\n    }\n}\nfn main(){\n    let my_int = MyInt;\n    let output: i32 = my_int.convert();\n    println!(\"output is: {}\", output);\n    \n    let output: f32 = my_int.convert(); //报错，因为必须为MyInt也实现Converter<f32>的trait才行\n    println!(\"output is: {}\", output);\n}\n```\n\n***如何返回trait类型***\n\n下面的代码编译错误，原因是 ：所有函数都必须返回一个具体类型。与其他语言不同，如果你有个像 `Animal` 那样的的 trait，则不能编写返回 `Animal` 的函数，因为其不同的实现将需要不同的内存量。\n\n解决方法是使用 `Box + dyn`\n\n```rust\nstruct Sheep {}\nstruct Cow {}\ntrait Animal {\n    fn noise(&self) -> &'static str;\n}\nimpl Animal for Sheep {\n    fn noise(&self) -> &'static str {\n            \"baaaaah!\"\n    }\n}\nimpl Animal for Cow {\n    fn noise(&self) -> &'static str {\n        \"moooooo!\"\n    }\n}\nfn random_animal(random_number: f64) -> impl Animal {\n    if random_number < 0.5 {\n    \tSheep {}\n    }else{\n\t    Cow {}\n    }\n}\nfn random_animal_2(random_number: f64) -> Box<dyn Animal> {\n    if random_number < 0.5 {\n        Box::new(Sheep {})\n    }else {\n        Box::new(Cow {})\n    }\n}\nfn main {\n    let random_number = 0.234;\n    let animal = random_animal_2(random_number);\n    println!(\"You've randomly chosen an animal, and it says {}\", animal.noise());\n}\n```\n\n***Option<T>枚举类型 和 unwrap方法***\n\n- `Some(T)` : 找到一个属于 `T` 类型的元素\n- `None` : 找不到相应元素\n\n```rust\nfn give_commoner(gift: Option<&str>) {\n    match gift {\n        Some(\"snake\") => println!(\"Yuck! I'm throwing that snake in a fire.\"),\n        Some(inner)   => println!(\"{}? How nice.\", inner),\n        None          => println!(\"No gift? Oh well.\"),\n    }\n}\nfn give_princess(gift: Option<&str>) {\n    // `unwrap` 在接收到 `None` 时将返回 `panic`。\n    let inside = gift.unwarp();\n    if inside == \"snake\" { \n        panic!(\"AAAaaaaa!!!!\");\n    }\n    println!(\"I love {}s!!!!!\", inside);\n}\nfn main(){\n\tlet food  = Some(\"chicken\");\n    let snake = Some(\"snake\");\n    let void  = None;\n    give_commoner(food);\n    give_commoner(snake);\n    give_commoner(void);\n\n    let bird = Some(\"robin\");\n    let nothing = None;\n    give_princess(bird);\n    give_princess(nothing);\n}\n```\n\n使用`?`解开`Option`\n\n- 如果 `current_age` 是 `None`，这将返回 `None`。\n- 如果 `current_age` 是 `Some`，内部的 `u8` 将赋值给 `next_age`。\n\n```rust\nfn next_birthday(current_age: Option<u8>) -> Option<String> {\n    let next_age: u8 = current_age?;\n    Some(format!(\"Next year I will be {}\", next_age))\n}\n```\n\n### 附录\n\n| 代码                                       | 说明                                                 |\n| ------------------------------------------ | ---------------------------------------------------- |\n| #[derive(Debug)]                           | 自动实现`Debug`特征                                  |\n| #![allow(dead_code)]                       | 该属性用于隐藏对未使用代码的警告                     |\n| #![allow(overflowing_literals)]            | 不显示类型转换产生的溢出警告                         |\n| 1..10                                      | 表示从1取到10，10不包括                              |\n| 1..=10                                     | 表示从1取到10，10包括                                |\n| move                                       | 关键字move的作用是将所引用的变量的所有权转移至闭包内 |\n| \\#[derive(RustcDecodable, RustcEncodable)] | 序列化和反序列化                                     |\n\n","source":"_posts/rust-node-1.md","raw":"---\ntitle: Rust学习笔记\ntags:\n  - rust\ncategories: rust\ndescription : Rust学习笔记\ndate: 2020-08-14\n---\n\n### 笔记\n\n***自定义类型如何打印输出？***\n\n自定义的类型如果要进行:?打印输出，需要实现`fmt::Debug`的`trait`。也可以在类型上加`#[derive(Debug)]`\n\n```rust\nfn main(){\n    #[derive(Debug)]\n\tstruct UnPrintable(i32);\n\tprintln!(\"{:?}\", DebugPrintable(13));\n    #[derive(Debug)]\n    struct Person<'a> {\n        name: &'a str,\n        age: u8\n    }\n    let name = \"Peter\";\n    let age = 27;\n    let peter = Person { name, age };\n    // 美化打印\n    println!(\"{:#?}\", peter);\n}\n```\n\n***消除变量未使用告警***\n\n```rust\nlet immutable_binding = 1;  //定义了这个变量，但是没有使用，编译时会告警\nlet _immutable_binding = 1; //但是如果变量名前面加_ 则不会告警\n```\n\n***Rust不提供原生类型的隐式转换，如果要转换可以通过as显式转换***\n\n```rust\nlet decimal = 65.4321_f32;\n// 错误！不提供隐式转换\nlet integer: u8 = decimal;\n// 改正 ^ 注释掉这一行\n// 可以显式转换\nlet integer = decimal as u8;\n```\n\n***结构体的类型转换***\n\n- From 和 Into\n- TryFrom 和 TryInto 类似于From和Into，只是这组返回的是Result类型\n- ToString 和 FromStr 可以把任何类型转换成string\n\n```rust\nuse std::convert::From;\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n// 实现了From<i32>表示i32类型可以通过into()方法转换成Number类型\n// i32转Number let num: Number = 5.into();\nimpl From<i32> for Number {\n    fn from(item: i32) -> Self {\n        Number { value: item }\n    }\n}\nfn main(){\n    let int: i32 = 5;\n    let num: Number = int.into();\n    println!(\"My number is {:?}\", num);\n}\n```\n\n```rust\nuse std::convert::TryFrom;\nuse std::convert::TryInto;\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\nimpl TryFrom<i32> for EvenNumber {\n    type Error = ();\n    fn try_from(value: i32) -> Result<Self, Self::Error> {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\nfn main(){\n    let result: Result<EvenNumber, ()> = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result<EvenNumber, ()> = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}\n```\n\n***Rust中几种迭代方法***\n\n- iter() , 在每次迭代中借用集合中的一个元素。这样集合本身不会被改变，循环之后仍 可以使用。\n- into_iter() , 会消耗集合。在每次迭代中，集合中的数据本身会被提供。一旦集合被消 耗了，之后就无法再使用了，因为它已经在循环中被 “移除”（move）了。\n- iter_mut() , 可变地（mutably）借用集合中的每个元素，从而允许集合被就地修改。\n\n***Rust闭包move***\n\nmove的作用是`将所引用的变量的所有权转移至闭包内`。不带move则不会转移所有权。\n\n```rust\nfn main() {\n    struct Point {\n        x: i64,\n        y: i64,\n    }\n    if true {\n        let mut p = Point { x: 25, y: 25 };\n        println!(\"p address: {:p}\", &p);\n        (|| {\n            println!(\"不带move闭包，p address: {:p}\", &p);\n        })();\n        println!(\"p address: {:p}\", &p);\n        println!(\"------------------------------\");\n    }\n    if true {\n        let mut p = Point { x: 25, y: 25 };\n        println!(\"p address: {:p}\", &p);\n        (move || {\n            println!(\"带move闭包，p address: {:p}\", &p);\n        })();\n        //println!(\"p address: {:p}\", &p);//error[E0382]: borrow of moved value: `p`\n    }\n}\n```\n\n***Rust条件编译***\n\n条件编译可能通过两种不同的操作符实现：\n\n- cfg 属性：在属性位置中使用 #[cfg(...)]\n- cfg! 宏：在布尔表达式中使用 cfg!(...)\n\n`#[cfg(xxx)]` 和 `#[cfg(not(xxx))]`必须是一组，不然编译报错。也挺好理解的，既然是条件编译，如果没有所有条件都满足就会编译报错。\n\n```rust\n// 这个函数仅当目标系统是 Linux 的时候才会编译\n#[cfg(target_os = \"linux\")]\nfn are_you_on_linux() {\n    println!(\"You are running linux!\")\n}\n// 而这个函数仅当目标系统不是Linux时才会编译\n#[cfg(not(target_os = \"linux\"))]\nfn are_you_on_linux() {\n    println!(\"You are *not* running linux!\")\n}\npub fn demo13(){\n    are_you_on_linux();\n}\n```\n\n`target_os`是系统提供的，如果我们要用自定义的条件编译，需要通过`--cfg xxx`指定。\n\n```rust\n#[cfg(some_condition)]\nfn conditional_function() {\n    println!(\"condition met!\")\n}\n#[cfg(not(some_condition))]\nfn conditional_function() {\n    println!(\"condition met not !\")\n}\nfn main() {\n    conditional_function();\n}\n//运行 rustc --cfg some_condition xxx.rs && ./custom\n```\n\n***Rust特征(trait)中泛型参数和关联类型区别***\n\ntrait 中的泛型与关联类型，有如下区别：\n\n- 如果 trait 中包含泛型参数，那么，可以对同一个目标类型，多次 impl 此 trait，每次提供不同的泛型参数。而关联类型方式只允许对目标类型实现一次。\n- 如果 trait 中包含泛型参数，那么在具体方法调用的时候，必须加以类型标注以明确使用的是哪一个具体的实现。而关联类型方式具体调用时不需要标注类型（因为不存在模棱两可的情况）。\n\n```rust\npub trait Converter<T> {\n    fn convert(&self) -> T;\n}\nstruct MyInt;\nimpl Converter<i32> for MyInt {\n    fn convert(&self) -> i32 {\n        42\n    }\n}\nfn main(){\n    let my_int = MyInt;\n    let output: i32 = my_int.convert();\n    println!(\"output is: {}\", output);\n    \n    let output: f32 = my_int.convert(); //报错，因为必须为MyInt也实现Converter<f32>的trait才行\n    println!(\"output is: {}\", output);\n}\n```\n\n***如何返回trait类型***\n\n下面的代码编译错误，原因是 ：所有函数都必须返回一个具体类型。与其他语言不同，如果你有个像 `Animal` 那样的的 trait，则不能编写返回 `Animal` 的函数，因为其不同的实现将需要不同的内存量。\n\n解决方法是使用 `Box + dyn`\n\n```rust\nstruct Sheep {}\nstruct Cow {}\ntrait Animal {\n    fn noise(&self) -> &'static str;\n}\nimpl Animal for Sheep {\n    fn noise(&self) -> &'static str {\n            \"baaaaah!\"\n    }\n}\nimpl Animal for Cow {\n    fn noise(&self) -> &'static str {\n        \"moooooo!\"\n    }\n}\nfn random_animal(random_number: f64) -> impl Animal {\n    if random_number < 0.5 {\n    \tSheep {}\n    }else{\n\t    Cow {}\n    }\n}\nfn random_animal_2(random_number: f64) -> Box<dyn Animal> {\n    if random_number < 0.5 {\n        Box::new(Sheep {})\n    }else {\n        Box::new(Cow {})\n    }\n}\nfn main {\n    let random_number = 0.234;\n    let animal = random_animal_2(random_number);\n    println!(\"You've randomly chosen an animal, and it says {}\", animal.noise());\n}\n```\n\n***Option<T>枚举类型 和 unwrap方法***\n\n- `Some(T)` : 找到一个属于 `T` 类型的元素\n- `None` : 找不到相应元素\n\n```rust\nfn give_commoner(gift: Option<&str>) {\n    match gift {\n        Some(\"snake\") => println!(\"Yuck! I'm throwing that snake in a fire.\"),\n        Some(inner)   => println!(\"{}? How nice.\", inner),\n        None          => println!(\"No gift? Oh well.\"),\n    }\n}\nfn give_princess(gift: Option<&str>) {\n    // `unwrap` 在接收到 `None` 时将返回 `panic`。\n    let inside = gift.unwarp();\n    if inside == \"snake\" { \n        panic!(\"AAAaaaaa!!!!\");\n    }\n    println!(\"I love {}s!!!!!\", inside);\n}\nfn main(){\n\tlet food  = Some(\"chicken\");\n    let snake = Some(\"snake\");\n    let void  = None;\n    give_commoner(food);\n    give_commoner(snake);\n    give_commoner(void);\n\n    let bird = Some(\"robin\");\n    let nothing = None;\n    give_princess(bird);\n    give_princess(nothing);\n}\n```\n\n使用`?`解开`Option`\n\n- 如果 `current_age` 是 `None`，这将返回 `None`。\n- 如果 `current_age` 是 `Some`，内部的 `u8` 将赋值给 `next_age`。\n\n```rust\nfn next_birthday(current_age: Option<u8>) -> Option<String> {\n    let next_age: u8 = current_age?;\n    Some(format!(\"Next year I will be {}\", next_age))\n}\n```\n\n### 附录\n\n| 代码                                       | 说明                                                 |\n| ------------------------------------------ | ---------------------------------------------------- |\n| #[derive(Debug)]                           | 自动实现`Debug`特征                                  |\n| #![allow(dead_code)]                       | 该属性用于隐藏对未使用代码的警告                     |\n| #![allow(overflowing_literals)]            | 不显示类型转换产生的溢出警告                         |\n| 1..10                                      | 表示从1取到10，10不包括                              |\n| 1..=10                                     | 表示从1取到10，10包括                                |\n| move                                       | 关键字move的作用是将所引用的变量的所有权转移至闭包内 |\n| \\#[derive(RustcDecodable, RustcEncodable)] | 序列化和反序列化                                     |\n\n","slug":"rust-node-1","published":1,"updated":"2021-06-21T06:33:02.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwbpt4ix0005zsv2e2f62itu","content":"<h3 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h3><p><strong><em>自定义类型如何打印输出？</em></strong></p>\n<p>自定义的类型如果要进行:?打印输出，需要实现<code>fmt::Debug</code>的<code>trait</code>。也可以在类型上加<code>#[derive(Debug)]</code></p>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token attribute attr-name\">#[derive(Debug)]</span>\n    <span class=\"token keyword\">struct</span> <span class=\"token function\">UnPrintable</span><span class=\"token punctuation\">(</span>i32<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{:?}\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">DebugPrintable</span><span class=\"token punctuation\">(</span><span class=\"token number\">13</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token attribute attr-name\">#[derive(Debug)]</span>\n    <span class=\"token keyword\">struct</span> Person<span class=\"token operator\">&lt;</span>'a<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        name<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span>'a str<span class=\"token punctuation\">,</span>\n        age<span class=\"token punctuation\">:</span> u8\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">let</span> name <span class=\"token operator\">=</span> <span class=\"token string\">\"Peter\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> age <span class=\"token operator\">=</span> <span class=\"token number\">27</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> peter <span class=\"token operator\">=</span> Person <span class=\"token punctuation\">{</span> name<span class=\"token punctuation\">,</span> age <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 美化打印</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{:#?}\"</span><span class=\"token punctuation\">,</span> peter<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong><em>消除变量未使用告警</em></strong></p>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> immutable_binding <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//定义了这个变量，但是没有使用，编译时会告警</span>\n<span class=\"token keyword\">let</span> _immutable_binding <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//但是如果变量名前面加_ 则不会告警</span></code></pre>\n<p><strong><em>Rust不提供原生类型的隐式转换，如果要转换可以通过as显式转换</em></strong></p>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> decimal <span class=\"token operator\">=</span> <span class=\"token number\">65.4321_f32</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 错误！不提供隐式转换</span>\n<span class=\"token keyword\">let</span> integer<span class=\"token punctuation\">:</span> u8 <span class=\"token operator\">=</span> decimal<span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">// 改正 ^ 注释掉这一行</span>\n<span class=\"token comment\" spellcheck=\"true\">// 可以显式转换</span>\n<span class=\"token keyword\">let</span> integer <span class=\"token operator\">=</span> decimal <span class=\"token keyword\">as</span> u8<span class=\"token punctuation\">;</span></code></pre>\n<p><strong><em>结构体的类型转换</em></strong></p>\n<ul>\n<li>From 和 Into</li>\n<li>TryFrom 和 TryInto 类似于From和Into，只是这组返回的是Result类型</li>\n<li>ToString 和 FromStr 可以把任何类型转换成string</li>\n</ul>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>convert<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>From<span class=\"token punctuation\">;</span>\n<span class=\"token attribute attr-name\">#[derive(Debug)]</span>\n<span class=\"token keyword\">struct</span> Number <span class=\"token punctuation\">{</span>\n    value<span class=\"token punctuation\">:</span> i32<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 实现了From&lt;i32>表示i32类型可以通过into()方法转换成Number类型</span>\n<span class=\"token comment\" spellcheck=\"true\">// i32转Number let num: Number = 5.into();</span>\n<span class=\"token keyword\">impl</span> From<span class=\"token operator\">&lt;</span>i32<span class=\"token operator\">></span> <span class=\"token keyword\">for</span> Number <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">from</span><span class=\"token punctuation\">(</span>item<span class=\"token punctuation\">:</span> i32<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> Self <span class=\"token punctuation\">{</span>\n        Number <span class=\"token punctuation\">{</span> value<span class=\"token punctuation\">:</span> item <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> int<span class=\"token punctuation\">:</span> i32 <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> num<span class=\"token punctuation\">:</span> Number <span class=\"token operator\">=</span> int<span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"My number is {:?}\"</span><span class=\"token punctuation\">,</span> num<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>convert<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>TryFrom<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">use</span> std<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>convert<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>TryInto<span class=\"token punctuation\">;</span>\n<span class=\"token attribute attr-name\">#[derive(Debug, PartialEq)]</span>\n<span class=\"token keyword\">struct</span> <span class=\"token function\">EvenNumber</span><span class=\"token punctuation\">(</span>i32<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">impl</span> TryFrom<span class=\"token operator\">&lt;</span>i32<span class=\"token operator\">></span> <span class=\"token keyword\">for</span> EvenNumber <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span> Error <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">try_from</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">:</span> i32<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> Result<span class=\"token operator\">&lt;</span>Self<span class=\"token punctuation\">,</span> Self<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>Error<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> value <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token function\">EvenNumber</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">Err</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> result<span class=\"token punctuation\">:</span> Result<span class=\"token operator\">&lt;</span>EvenNumber<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token number\">8i32</span><span class=\"token punctuation\">.</span><span class=\"token function\">try_into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">assert_eq!</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token function\">Ok</span><span class=\"token punctuation\">(</span><span class=\"token function\">EvenNumber</span><span class=\"token punctuation\">(</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> result<span class=\"token punctuation\">:</span> Result<span class=\"token operator\">&lt;</span>EvenNumber<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token number\">5i32</span><span class=\"token punctuation\">.</span><span class=\"token function\">try_into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">assert_eq!</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">,</span> <span class=\"token function\">Err</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong><em>Rust中几种迭代方法</em></strong></p>\n<ul>\n<li>iter() , 在每次迭代中借用集合中的一个元素。这样集合本身不会被改变，循环之后仍 可以使用。</li>\n<li>into_iter() , 会消耗集合。在每次迭代中，集合中的数据本身会被提供。一旦集合被消 耗了，之后就无法再使用了，因为它已经在循环中被 “移除”（move）了。</li>\n<li>iter_mut() , 可变地（mutably）借用集合中的每个元素，从而允许集合被就地修改。</li>\n</ul>\n<p><strong><em>Rust闭包move</em></strong></p>\n<p>move的作用是<code>将所引用的变量的所有权转移至闭包内</code>。不带move则不会转移所有权。</p>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">struct</span> Point <span class=\"token punctuation\">{</span>\n        x<span class=\"token punctuation\">:</span> i64<span class=\"token punctuation\">,</span>\n        y<span class=\"token punctuation\">:</span> i64<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token keyword\">true</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> p <span class=\"token operator\">=</span> Point <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token number\">25</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p address: {:p}\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">(</span><span class=\"token closure-params\"><span class=\"token punctuation\">|</span><span class=\"token punctuation\">|</span></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"不带move闭包，p address: {:p}\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p address: {:p}\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"------------------------------\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span> <span class=\"token keyword\">true</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> p <span class=\"token operator\">=</span> Point <span class=\"token punctuation\">{</span> x<span class=\"token punctuation\">:</span> <span class=\"token number\">25</span><span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">:</span> <span class=\"token number\">25</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p address: {:p}\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">move</span> <span class=\"token closure-params\"><span class=\"token punctuation\">|</span><span class=\"token punctuation\">|</span></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"带move闭包，p address: {:p}\"</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">//println!(\"p address: {:p}\", &amp;p);//error[E0382]: borrow of moved value: `p`</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong><em>Rust条件编译</em></strong></p>\n<p>条件编译可能通过两种不同的操作符实现：</p>\n<ul>\n<li>cfg 属性：在属性位置中使用 #[cfg(…)]</li>\n<li>cfg! 宏：在布尔表达式中使用 cfg!(…)</li>\n</ul>\n<p><code>#[cfg(xxx)]</code> 和 <code>#[cfg(not(xxx))]</code>必须是一组，不然编译报错。也挺好理解的，既然是条件编译，如果没有所有条件都满足就会编译报错。</p>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token comment\" spellcheck=\"true\">// 这个函数仅当目标系统是 Linux 的时候才会编译</span>\n#<span class=\"token punctuation\">[</span><span class=\"token function\">cfg</span><span class=\"token punctuation\">(</span>target_os <span class=\"token operator\">=</span> <span class=\"token string\">\"linux\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">are_you_on_linux</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You are running linux!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 而这个函数仅当目标系统不是Linux时才会编译</span>\n#<span class=\"token punctuation\">[</span><span class=\"token function\">cfg</span><span class=\"token punctuation\">(</span><span class=\"token function\">not</span><span class=\"token punctuation\">(</span>target_os <span class=\"token operator\">=</span> <span class=\"token string\">\"linux\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">are_you_on_linux</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You are *not* running linux!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function\">demo13</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">are_you_on_linux</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>target_os</code>是系统提供的，如果我们要用自定义的条件编译，需要通过<code>--cfg xxx</code>指定。</p>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[cfg(some_condition)]</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">conditional_function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"condition met!\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token attribute attr-name\">#[cfg(not(some_condition))]</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">conditional_function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"condition met not !\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">conditional_function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//运行 rustc --cfg some_condition xxx.rs &amp;&amp; ./custom</span></code></pre>\n<p><strong><em>Rust特征(trait)中泛型参数和关联类型区别</em></strong></p>\n<p>trait 中的泛型与关联类型，有如下区别：</p>\n<ul>\n<li>如果 trait 中包含泛型参数，那么，可以对同一个目标类型，多次 impl 此 trait，每次提供不同的泛型参数。而关联类型方式只允许对目标类型实现一次。</li>\n<li>如果 trait 中包含泛型参数，那么在具体方法调用的时候，必须加以类型标注以明确使用的是哪一个具体的实现。而关联类型方式具体调用时不需要标注类型（因为不存在模棱两可的情况）。</li>\n</ul>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">trait</span> Converter<span class=\"token operator\">&lt;</span>T<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> T<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">struct</span> MyInt<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">impl</span> Converter<span class=\"token operator\">&lt;</span>i32<span class=\"token operator\">></span> <span class=\"token keyword\">for</span> MyInt <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> i32 <span class=\"token punctuation\">{</span>\n        <span class=\"token number\">42</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> my_int <span class=\"token operator\">=</span> MyInt<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> output<span class=\"token punctuation\">:</span> i32 <span class=\"token operator\">=</span> my_int<span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"output is: {}\"</span><span class=\"token punctuation\">,</span> output<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> output<span class=\"token punctuation\">:</span> f32 <span class=\"token operator\">=</span> my_int<span class=\"token punctuation\">.</span><span class=\"token function\">convert</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//报错，因为必须为MyInt也实现Converter&lt;f32>的trait才行</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"output is: {}\"</span><span class=\"token punctuation\">,</span> output<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong><em>如何返回trait类型</em></strong></p>\n<p>下面的代码编译错误，原因是 ：所有函数都必须返回一个具体类型。与其他语言不同，如果你有个像 <code>Animal</code> 那样的的 trait，则不能编写返回 <code>Animal</code> 的函数，因为其不同的实现将需要不同的内存量。</p>\n<p>解决方法是使用 <code>Box + dyn</code></p>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">struct</span> Sheep <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">struct</span> Cow <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">trait</span> Animal <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">noise</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span>'<span class=\"token keyword\">static</span> str<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">impl</span> Animal <span class=\"token keyword\">for</span> Sheep <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">noise</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span>'<span class=\"token keyword\">static</span> str <span class=\"token punctuation\">{</span>\n            <span class=\"token string\">\"baaaaah!\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">impl</span> Animal <span class=\"token keyword\">for</span> Cow <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function\">noise</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token operator\">&amp;</span>'<span class=\"token keyword\">static</span> str <span class=\"token punctuation\">{</span>\n        <span class=\"token string\">\"moooooo!\"</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">random_animal</span><span class=\"token punctuation\">(</span>random_number<span class=\"token punctuation\">:</span> f64<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">impl</span> Animal <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> random_number <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.5</span> <span class=\"token punctuation\">{</span>\n        Sheep <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        Cow <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">random_animal_2</span><span class=\"token punctuation\">(</span>random_number<span class=\"token punctuation\">:</span> f64<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> Box<span class=\"token operator\">&lt;</span>dyn Animal<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> random_number <span class=\"token operator\">&lt;</span> <span class=\"token number\">0.5</span> <span class=\"token punctuation\">{</span>\n        Box<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>Sheep <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        Box<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>Cow <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> main <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> random_number <span class=\"token operator\">=</span> <span class=\"token number\">0.234</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> animal <span class=\"token operator\">=</span> <span class=\"token function\">random_animal_2</span><span class=\"token punctuation\">(</span>random_number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"You've randomly chosen an animal, and it says {}\"</span><span class=\"token punctuation\">,</span> animal<span class=\"token punctuation\">.</span><span class=\"token function\">noise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong><em>Option<T>枚举类型 和 unwrap方法</T></em></strong></p>\n<ul>\n<li><code>Some(T)</code> : 找到一个属于 <code>T</code> 类型的元素</li>\n<li><code>None</code> : 找不到相应元素</li>\n</ul>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">give_commoner</span><span class=\"token punctuation\">(</span>gift<span class=\"token punctuation\">:</span> Option<span class=\"token operator\">&lt;</span><span class=\"token operator\">&amp;</span>str<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">match</span> gift <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">Some</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"snake\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Yuck! I'm throwing that snake in a fire.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token function\">Some</span><span class=\"token punctuation\">(</span>inner<span class=\"token punctuation\">)</span>   <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}? How nice.\"</span><span class=\"token punctuation\">,</span> inner<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        None          <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"No gift? Oh well.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">give_princess</span><span class=\"token punctuation\">(</span>gift<span class=\"token punctuation\">:</span> Option<span class=\"token operator\">&lt;</span><span class=\"token operator\">&amp;</span>str<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// `unwrap` 在接收到 `None` 时将返回 `panic`。</span>\n    <span class=\"token keyword\">let</span> inside <span class=\"token operator\">=</span> gift<span class=\"token punctuation\">.</span><span class=\"token function\">unwarp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> inside <span class=\"token operator\">==</span> <span class=\"token string\">\"snake\"</span> <span class=\"token punctuation\">{</span> \n        <span class=\"token function\">panic!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"AAAaaaaa!!!!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I love {}s!!!!!\"</span><span class=\"token punctuation\">,</span> inside<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">fn</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> food  <span class=\"token operator\">=</span> <span class=\"token function\">Some</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"chicken\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> snake <span class=\"token operator\">=</span> <span class=\"token function\">Some</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"snake\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> void  <span class=\"token operator\">=</span> None<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">give_commoner</span><span class=\"token punctuation\">(</span>food<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">give_commoner</span><span class=\"token punctuation\">(</span>snake<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">give_commoner</span><span class=\"token punctuation\">(</span>void<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> bird <span class=\"token operator\">=</span> <span class=\"token function\">Some</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"robin\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> nothing <span class=\"token operator\">=</span> None<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">give_princess</span><span class=\"token punctuation\">(</span>bird<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">give_princess</span><span class=\"token punctuation\">(</span>nothing<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>使用<code>?</code>解开<code>Option</code></p>\n<ul>\n<li>如果 <code>current_age</code> 是 <code>None</code>，这将返回 <code>None</code>。</li>\n<li>如果 <code>current_age</code> 是 <code>Some</code>，内部的 <code>u8</code> 将赋值给 <code>next_age</code>。</li>\n</ul>\n<pre class=\" language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function\">next_birthday</span><span class=\"token punctuation\">(</span>current_age<span class=\"token punctuation\">:</span> Option<span class=\"token operator\">&lt;</span>u8<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> Option<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> next_age<span class=\"token punctuation\">:</span> u8 <span class=\"token operator\">=</span> current_age?<span class=\"token punctuation\">;</span>\n    <span class=\"token function\">Some</span><span class=\"token punctuation\">(</span><span class=\"token function\">format!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Next year I will be {}\"</span><span class=\"token punctuation\">,</span> next_age<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>#[derive(Debug)]</td>\n<td>自动实现<code>Debug</code>特征</td>\n</tr>\n<tr>\n<td>#![allow(dead_code)]</td>\n<td>该属性用于隐藏对未使用代码的警告</td>\n</tr>\n<tr>\n<td>#![allow(overflowing_literals)]</td>\n<td>不显示类型转换产生的溢出警告</td>\n</tr>\n<tr>\n<td>1..10</td>\n<td>表示从1取到10，10不包括</td>\n</tr>\n<tr>\n<td>1..=10</td>\n<td>表示从1取到10，10包括</td>\n</tr>\n<tr>\n<td>move</td>\n<td>关键字move的作用是将所引用的变量的所有权转移至闭包内</td>\n</tr>\n<tr>\n<td>#[derive(RustcDecodable, RustcEncodable)]</td>\n<td>序列化和反序列化</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"笔记\"><a href=\"#笔记\" class=\"headerlink\" title=\"笔记\"></a>笔记</h3><p><strong><em>自定义类型如何打印输出？</em></strong></p>\n<p>自定义的类型如果要进行:?打印输出，需要实现<code>fmt::Debug</code>的<code>trait</code>。也可以在类型上加<code>#[derive(Debug)]</code></p>\n<pre><code class=\"rust\">fn main(){\n    #[derive(Debug)]\n    struct UnPrintable(i32);\n    println!(&quot;{:?}&quot;, DebugPrintable(13));\n    #[derive(Debug)]\n    struct Person&lt;&#39;a&gt; {\n        name: &amp;&#39;a str,\n        age: u8\n    }\n    let name = &quot;Peter&quot;;\n    let age = 27;\n    let peter = Person { name, age };\n    // 美化打印\n    println!(&quot;{:#?}&quot;, peter);\n}</code></pre>\n<p><strong><em>消除变量未使用告警</em></strong></p>\n<pre><code class=\"rust\">let immutable_binding = 1;  //定义了这个变量，但是没有使用，编译时会告警\nlet _immutable_binding = 1; //但是如果变量名前面加_ 则不会告警</code></pre>\n<p><strong><em>Rust不提供原生类型的隐式转换，如果要转换可以通过as显式转换</em></strong></p>\n<pre><code class=\"rust\">let decimal = 65.4321_f32;\n// 错误！不提供隐式转换\nlet integer: u8 = decimal;\n// 改正 ^ 注释掉这一行\n// 可以显式转换\nlet integer = decimal as u8;</code></pre>\n<p><strong><em>结构体的类型转换</em></strong></p>\n<ul>\n<li>From 和 Into</li>\n<li>TryFrom 和 TryInto 类似于From和Into，只是这组返回的是Result类型</li>\n<li>ToString 和 FromStr 可以把任何类型转换成string</li>\n</ul>\n<pre><code class=\"rust\">use std::convert::From;\n#[derive(Debug)]\nstruct Number {\n    value: i32,\n}\n// 实现了From&lt;i32&gt;表示i32类型可以通过into()方法转换成Number类型\n// i32转Number let num: Number = 5.into();\nimpl From&lt;i32&gt; for Number {\n    fn from(item: i32) -&gt; Self {\n        Number { value: item }\n    }\n}\nfn main(){\n    let int: i32 = 5;\n    let num: Number = int.into();\n    println!(&quot;My number is {:?}&quot;, num);\n}</code></pre>\n<pre><code class=\"rust\">use std::convert::TryFrom;\nuse std::convert::TryInto;\n#[derive(Debug, PartialEq)]\nstruct EvenNumber(i32);\nimpl TryFrom&lt;i32&gt; for EvenNumber {\n    type Error = ();\n    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {\n        if value % 2 == 0 {\n            Ok(EvenNumber(value))\n        } else {\n            Err(())\n        }\n    }\n}\nfn main(){\n    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();\n    assert_eq!(result, Ok(EvenNumber(8)));\n    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();\n    assert_eq!(result, Err(()));\n}</code></pre>\n<p><strong><em>Rust中几种迭代方法</em></strong></p>\n<ul>\n<li>iter() , 在每次迭代中借用集合中的一个元素。这样集合本身不会被改变，循环之后仍 可以使用。</li>\n<li>into_iter() , 会消耗集合。在每次迭代中，集合中的数据本身会被提供。一旦集合被消 耗了，之后就无法再使用了，因为它已经在循环中被 “移除”（move）了。</li>\n<li>iter_mut() , 可变地（mutably）借用集合中的每个元素，从而允许集合被就地修改。</li>\n</ul>\n<p><strong><em>Rust闭包move</em></strong></p>\n<p>move的作用是<code>将所引用的变量的所有权转移至闭包内</code>。不带move则不会转移所有权。</p>\n<pre><code class=\"rust\">fn main() {\n    struct Point {\n        x: i64,\n        y: i64,\n    }\n    if true {\n        let mut p = Point { x: 25, y: 25 };\n        println!(&quot;p address: {:p}&quot;, &amp;p);\n        (|| {\n            println!(&quot;不带move闭包，p address: {:p}&quot;, &amp;p);\n        })();\n        println!(&quot;p address: {:p}&quot;, &amp;p);\n        println!(&quot;------------------------------&quot;);\n    }\n    if true {\n        let mut p = Point { x: 25, y: 25 };\n        println!(&quot;p address: {:p}&quot;, &amp;p);\n        (move || {\n            println!(&quot;带move闭包，p address: {:p}&quot;, &amp;p);\n        })();\n        //println!(&quot;p address: {:p}&quot;, &amp;p);//error[E0382]: borrow of moved value: `p`\n    }\n}</code></pre>\n<p><strong><em>Rust条件编译</em></strong></p>\n<p>条件编译可能通过两种不同的操作符实现：</p>\n<ul>\n<li>cfg 属性：在属性位置中使用 #[cfg(…)]</li>\n<li>cfg! 宏：在布尔表达式中使用 cfg!(…)</li>\n</ul>\n<p><code>#[cfg(xxx)]</code> 和 <code>#[cfg(not(xxx))]</code>必须是一组，不然编译报错。也挺好理解的，既然是条件编译，如果没有所有条件都满足就会编译报错。</p>\n<pre><code class=\"rust\">// 这个函数仅当目标系统是 Linux 的时候才会编译\n#[cfg(target_os = &quot;linux&quot;)]\nfn are_you_on_linux() {\n    println!(&quot;You are running linux!&quot;)\n}\n// 而这个函数仅当目标系统不是Linux时才会编译\n#[cfg(not(target_os = &quot;linux&quot;))]\nfn are_you_on_linux() {\n    println!(&quot;You are *not* running linux!&quot;)\n}\npub fn demo13(){\n    are_you_on_linux();\n}</code></pre>\n<p><code>target_os</code>是系统提供的，如果我们要用自定义的条件编译，需要通过<code>--cfg xxx</code>指定。</p>\n<pre><code class=\"rust\">#[cfg(some_condition)]\nfn conditional_function() {\n    println!(&quot;condition met!&quot;)\n}\n#[cfg(not(some_condition))]\nfn conditional_function() {\n    println!(&quot;condition met not !&quot;)\n}\nfn main() {\n    conditional_function();\n}\n//运行 rustc --cfg some_condition xxx.rs &amp;&amp; ./custom</code></pre>\n<p><strong><em>Rust特征(trait)中泛型参数和关联类型区别</em></strong></p>\n<p>trait 中的泛型与关联类型，有如下区别：</p>\n<ul>\n<li>如果 trait 中包含泛型参数，那么，可以对同一个目标类型，多次 impl 此 trait，每次提供不同的泛型参数。而关联类型方式只允许对目标类型实现一次。</li>\n<li>如果 trait 中包含泛型参数，那么在具体方法调用的时候，必须加以类型标注以明确使用的是哪一个具体的实现。而关联类型方式具体调用时不需要标注类型（因为不存在模棱两可的情况）。</li>\n</ul>\n<pre><code class=\"rust\">pub trait Converter&lt;T&gt; {\n    fn convert(&amp;self) -&gt; T;\n}\nstruct MyInt;\nimpl Converter&lt;i32&gt; for MyInt {\n    fn convert(&amp;self) -&gt; i32 {\n        42\n    }\n}\nfn main(){\n    let my_int = MyInt;\n    let output: i32 = my_int.convert();\n    println!(&quot;output is: {}&quot;, output);\n\n    let output: f32 = my_int.convert(); //报错，因为必须为MyInt也实现Converter&lt;f32&gt;的trait才行\n    println!(&quot;output is: {}&quot;, output);\n}</code></pre>\n<p><strong><em>如何返回trait类型</em></strong></p>\n<p>下面的代码编译错误，原因是 ：所有函数都必须返回一个具体类型。与其他语言不同，如果你有个像 <code>Animal</code> 那样的的 trait，则不能编写返回 <code>Animal</code> 的函数，因为其不同的实现将需要不同的内存量。</p>\n<p>解决方法是使用 <code>Box + dyn</code></p>\n<pre><code class=\"rust\">struct Sheep {}\nstruct Cow {}\ntrait Animal {\n    fn noise(&amp;self) -&gt; &amp;&#39;static str;\n}\nimpl Animal for Sheep {\n    fn noise(&amp;self) -&gt; &amp;&#39;static str {\n            &quot;baaaaah!&quot;\n    }\n}\nimpl Animal for Cow {\n    fn noise(&amp;self) -&gt; &amp;&#39;static str {\n        &quot;moooooo!&quot;\n    }\n}\nfn random_animal(random_number: f64) -&gt; impl Animal {\n    if random_number &lt; 0.5 {\n        Sheep {}\n    }else{\n        Cow {}\n    }\n}\nfn random_animal_2(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {\n    if random_number &lt; 0.5 {\n        Box::new(Sheep {})\n    }else {\n        Box::new(Cow {})\n    }\n}\nfn main {\n    let random_number = 0.234;\n    let animal = random_animal_2(random_number);\n    println!(&quot;You&#39;ve randomly chosen an animal, and it says {}&quot;, animal.noise());\n}</code></pre>\n<p><strong><em>Option<T>枚举类型 和 unwrap方法</T></em></strong></p>\n<ul>\n<li><code>Some(T)</code> : 找到一个属于 <code>T</code> 类型的元素</li>\n<li><code>None</code> : 找不到相应元素</li>\n</ul>\n<pre><code class=\"rust\">fn give_commoner(gift: Option&lt;&amp;str&gt;) {\n    match gift {\n        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I&#39;m throwing that snake in a fire.&quot;),\n        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),\n        None          =&gt; println!(&quot;No gift? Oh well.&quot;),\n    }\n}\nfn give_princess(gift: Option&lt;&amp;str&gt;) {\n    // `unwrap` 在接收到 `None` 时将返回 `panic`。\n    let inside = gift.unwarp();\n    if inside == &quot;snake&quot; { \n        panic!(&quot;AAAaaaaa!!!!&quot;);\n    }\n    println!(&quot;I love {}s!!!!!&quot;, inside);\n}\nfn main(){\n    let food  = Some(&quot;chicken&quot;);\n    let snake = Some(&quot;snake&quot;);\n    let void  = None;\n    give_commoner(food);\n    give_commoner(snake);\n    give_commoner(void);\n\n    let bird = Some(&quot;robin&quot;);\n    let nothing = None;\n    give_princess(bird);\n    give_princess(nothing);\n}</code></pre>\n<p>使用<code>?</code>解开<code>Option</code></p>\n<ul>\n<li>如果 <code>current_age</code> 是 <code>None</code>，这将返回 <code>None</code>。</li>\n<li>如果 <code>current_age</code> 是 <code>Some</code>，内部的 <code>u8</code> 将赋值给 <code>next_age</code>。</li>\n</ul>\n<pre><code class=\"rust\">fn next_birthday(current_age: Option&lt;u8&gt;) -&gt; Option&lt;String&gt; {\n    let next_age: u8 = current_age?;\n    Some(format!(&quot;Next year I will be {}&quot;, next_age))\n}</code></pre>\n<h3 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h3><table>\n<thead>\n<tr>\n<th>代码</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>#[derive(Debug)]</td>\n<td>自动实现<code>Debug</code>特征</td>\n</tr>\n<tr>\n<td>#![allow(dead_code)]</td>\n<td>该属性用于隐藏对未使用代码的警告</td>\n</tr>\n<tr>\n<td>#![allow(overflowing_literals)]</td>\n<td>不显示类型转换产生的溢出警告</td>\n</tr>\n<tr>\n<td>1..10</td>\n<td>表示从1取到10，10不包括</td>\n</tr>\n<tr>\n<td>1..=10</td>\n<td>表示从1取到10，10包括</td>\n</tr>\n<tr>\n<td>move</td>\n<td>关键字move的作用是将所引用的变量的所有权转移至闭包内</td>\n</tr>\n<tr>\n<td>#[derive(RustcDecodable, RustcEncodable)]</td>\n<td>序列化和反序列化</td>\n</tr>\n</tbody></table>\n"},{"title":"GoLang学习笔记备忘","description":null,"date":"2021-05-18T09:14:00.000Z","_content":"### 什么时候用指针？\n\n- 不要对 map、slice、channel 这类引用类型使用指针；\n- 如果需要修改方法接收者内部的数据或者状态时，需要使用指针；\n- 如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数；\n- 如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针；\n- 像 int、bool 这样的小数据类型没必要使用指针；\n- 如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全；\n- 指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂。\n\n### slice切片类型结构\n\n```go\ntype Slice struct {\n\tData unsafe.Pointer\t // 指向底层数组的指针\n\tLen  int\t\t\t // 切片的已存储的长度\n\tCap  int\t\t\t // 切片的容量\n}\n```\n\n![](go-study-01/1.png)\n\n```go\nfunc TestSlice(t *testing.T) {\n\ta := [8]int{0, 1, 2, 3, 4, 5, 6, 7}\n\ts1 := a[0:5]\n\tfmt.Printf(\"切片的len = %d, cap = %d \\n\", len(s1) , cap(s1))\n    s2 := a[3:5]\n\tfmt.Printf(\"切片的len = %d, cap = %d \\n\", len(s2) , cap(s2))\n    s1 = append(s1,16)\n\tfmt.Println(a)\n}\n//打印结果\n//切片的len = 5, cap = 8 \n//切片的len = 2, cap = 5 \n//[0 1 2 3 4 16 6 7]\n```\n\n切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。如图\n\n- s1字段中`Data unsafe.Pointer`记录了数组a的下标为0的地址。s1字段中`Data unsafe.Pointer`记录了数组a的下标为3的地址。\n- 切片的长度是`左闭右开`的，容量是从指向的起始位置开始算，例如s1指向是下标0，按照容量是数组剩余大小的话，cap = 8， 同理s2的cap = 5。\n- s1 = append(s1,16)执行时，因为切片会操作原来的数组，所以这时候打印数组a时，数组a下标为6的值会变成16。\n\n上面我们说s1 = append(s1,16)时，s1会操作底层的数组。下面还有一种情况并不会修改到底层数组，我们具体来看个图。\n\n![](go-study-01/2.png)\n\n```go\nfunc TestSlice(t *testing.T) {\n    a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}\n\ts3 := a[6:]\n    s3 = append(s3,19)\n    fmt.println(a)\n}\n// 打印结果 ： [0 1 2 3 4 5 6 7]\n```\n\n上面执行s3 = append(s3,19)后，数组并没有我们想象中的发生改变，原因是此时s3的容量=长度，如果append增加元素时需要扩容，而扩容就会导致s3指向新的数组。\n\n### make和new的区别\n\nnew 是 Golang 的内建函数，用于分配内存和初始化默认值。\n\n```go\nfunc new(Type) *Type\n```\n\n几个重要的点 : \n\n- 传入的是一个类型。\n- 返回的是一个指针类型。\n- 其值会被分配成初始值。\n\n```go\nfunc TestNew(t *testing.T) {\n\ta := new(int64)\n\tfmt.Printf(\"指针变量a的类型: %T  指针变量a指向的值: %v 指针变量a的值: %v \\n\", a, *a, a)\n    // 指针变量a的类型: *int64  指针变量a指向的值: 0 指针变量a的值: 0xc00000a300 \n}\n```\n\n![](go-study-01/3.png)\n\n如图所示，new出来的是一个指针类型，指向了初始化的值对应的物理地址。\n\nmake是Golang的内建函数，**只用于slice,map,channel**的内存分配和初始化。\n\n```go\nfunc make(t Type, size ...IntegerType) Type\n```\n\n可以看到，返回的是一个类型，而不是指针类型。\n\n### new和make初始化切片例子详解\n\n下面通过一个例子具体来看下make和new初始化切片的情况。\n\n假设有如下代码，此时我只是证明了一个int类型的切片，那么此时这个切片结构的data = nil , len = 0 , cap = 0.\n\n```go\nvar ints []int\t\t#声明一个切片类型\n```\n\n当我们使用make函数为其分配内存时\n\n```go\nints := make([]int , 2 ,5)\nints = append(ints, 16)\n```\n\n此时make会帮我们**开辟这个切片的底层数组**，且存储两个元素，如下图，绿色表示已经存储了两个元素。当继续执行append时，就会在第三个方格中继续存入。\n\n![](go-study-01/4.png)\n\n如果是使用new分配的话，我们再来看一下，还是上面的代码\n\n```go\nints := new([]int)\n(*ints)[0] = 1\t\t// 此时这一句会报错\n*ints = append(*ints , 1)\nfmt.Println(*ints)\n```\n\n由于new只是分配内存和初始化0值，并不会像make那样为其分配内存。所以此时ints是一个指针类型，指向了切片这个结构，且这个切片的data = nil , len = 0 , cap = 0 。\n\n![](go-study-01/5.png)\n\n当用new初始化后执行`(*ints)[0] = 1`是会报错的，因为此时data还没有指向数组。如果要分配数组，我们可以用append方法，这个方法是可以帮我们自动创建底层数组的。所以执行`*ints = append(*ints , 1)`是可以行得通的。\n\n### slice切片的扩容\n\nappend是如果容量不够，slice会自动扩容。扩容的原理其实是新建一个底层数组，先将之前数组的元素复制过来，再将新元素追加到后面，然后返回新的 slice，底层数组改变。\n\n```go\nfunc TestSlice(t *testing.T) {\n\tints := []int{1,2}\n\tfmt.Printf(\"切片ints len = %d , cap = %d \\n\" , len(ints) , cap(ints))\n\tints = append(ints,3,4,5)\n\tfmt.Printf(\"切片ints len = %d , cap = %d \\n\" , len(ints) , cap(ints))\n}\n//切片ints len = 2 , cap = 2 \n//切片ints len = 5 , cap = 6\n```\n\nslice的扩容预估规则是怎么样的呢，我们假设原来的容量为oldCap，最小容量为cap。例如上面的代码，刚开始oldCap=2，append()后要求最小容量是5，即cap = 5。\n\n- 如果 oldCap * 2 < cap ，即假设我把原来的容量扩容2倍后小于所需最小容量，则将newCap = cap。\n- 否则在细分\n  - oldLen < 1024   则  newCap = cap\n  - oldLen >= 1024 则 扩容1/4 ， 即 newCap = oldCap * 1.25","source":"_posts/go-study-01.md","raw":"---\ntitle: GoLang学习笔记备忘\ntags:\n  - GoLang\ncategories: \n  - GoLang\ndescription : \ndate: 2021-05-18 17:14:00\n---\n### 什么时候用指针？\n\n- 不要对 map、slice、channel 这类引用类型使用指针；\n- 如果需要修改方法接收者内部的数据或者状态时，需要使用指针；\n- 如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数；\n- 如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针；\n- 像 int、bool 这样的小数据类型没必要使用指针；\n- 如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全；\n- 指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂。\n\n### slice切片类型结构\n\n```go\ntype Slice struct {\n\tData unsafe.Pointer\t // 指向底层数组的指针\n\tLen  int\t\t\t // 切片的已存储的长度\n\tCap  int\t\t\t // 切片的容量\n}\n```\n\n![](go-study-01/1.png)\n\n```go\nfunc TestSlice(t *testing.T) {\n\ta := [8]int{0, 1, 2, 3, 4, 5, 6, 7}\n\ts1 := a[0:5]\n\tfmt.Printf(\"切片的len = %d, cap = %d \\n\", len(s1) , cap(s1))\n    s2 := a[3:5]\n\tfmt.Printf(\"切片的len = %d, cap = %d \\n\", len(s2) , cap(s2))\n    s1 = append(s1,16)\n\tfmt.Println(a)\n}\n//打印结果\n//切片的len = 5, cap = 8 \n//切片的len = 2, cap = 5 \n//[0 1 2 3 4 16 6 7]\n```\n\n切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。如图\n\n- s1字段中`Data unsafe.Pointer`记录了数组a的下标为0的地址。s1字段中`Data unsafe.Pointer`记录了数组a的下标为3的地址。\n- 切片的长度是`左闭右开`的，容量是从指向的起始位置开始算，例如s1指向是下标0，按照容量是数组剩余大小的话，cap = 8， 同理s2的cap = 5。\n- s1 = append(s1,16)执行时，因为切片会操作原来的数组，所以这时候打印数组a时，数组a下标为6的值会变成16。\n\n上面我们说s1 = append(s1,16)时，s1会操作底层的数组。下面还有一种情况并不会修改到底层数组，我们具体来看个图。\n\n![](go-study-01/2.png)\n\n```go\nfunc TestSlice(t *testing.T) {\n    a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}\n\ts3 := a[6:]\n    s3 = append(s3,19)\n    fmt.println(a)\n}\n// 打印结果 ： [0 1 2 3 4 5 6 7]\n```\n\n上面执行s3 = append(s3,19)后，数组并没有我们想象中的发生改变，原因是此时s3的容量=长度，如果append增加元素时需要扩容，而扩容就会导致s3指向新的数组。\n\n### make和new的区别\n\nnew 是 Golang 的内建函数，用于分配内存和初始化默认值。\n\n```go\nfunc new(Type) *Type\n```\n\n几个重要的点 : \n\n- 传入的是一个类型。\n- 返回的是一个指针类型。\n- 其值会被分配成初始值。\n\n```go\nfunc TestNew(t *testing.T) {\n\ta := new(int64)\n\tfmt.Printf(\"指针变量a的类型: %T  指针变量a指向的值: %v 指针变量a的值: %v \\n\", a, *a, a)\n    // 指针变量a的类型: *int64  指针变量a指向的值: 0 指针变量a的值: 0xc00000a300 \n}\n```\n\n![](go-study-01/3.png)\n\n如图所示，new出来的是一个指针类型，指向了初始化的值对应的物理地址。\n\nmake是Golang的内建函数，**只用于slice,map,channel**的内存分配和初始化。\n\n```go\nfunc make(t Type, size ...IntegerType) Type\n```\n\n可以看到，返回的是一个类型，而不是指针类型。\n\n### new和make初始化切片例子详解\n\n下面通过一个例子具体来看下make和new初始化切片的情况。\n\n假设有如下代码，此时我只是证明了一个int类型的切片，那么此时这个切片结构的data = nil , len = 0 , cap = 0.\n\n```go\nvar ints []int\t\t#声明一个切片类型\n```\n\n当我们使用make函数为其分配内存时\n\n```go\nints := make([]int , 2 ,5)\nints = append(ints, 16)\n```\n\n此时make会帮我们**开辟这个切片的底层数组**，且存储两个元素，如下图，绿色表示已经存储了两个元素。当继续执行append时，就会在第三个方格中继续存入。\n\n![](go-study-01/4.png)\n\n如果是使用new分配的话，我们再来看一下，还是上面的代码\n\n```go\nints := new([]int)\n(*ints)[0] = 1\t\t// 此时这一句会报错\n*ints = append(*ints , 1)\nfmt.Println(*ints)\n```\n\n由于new只是分配内存和初始化0值，并不会像make那样为其分配内存。所以此时ints是一个指针类型，指向了切片这个结构，且这个切片的data = nil , len = 0 , cap = 0 。\n\n![](go-study-01/5.png)\n\n当用new初始化后执行`(*ints)[0] = 1`是会报错的，因为此时data还没有指向数组。如果要分配数组，我们可以用append方法，这个方法是可以帮我们自动创建底层数组的。所以执行`*ints = append(*ints , 1)`是可以行得通的。\n\n### slice切片的扩容\n\nappend是如果容量不够，slice会自动扩容。扩容的原理其实是新建一个底层数组，先将之前数组的元素复制过来，再将新元素追加到后面，然后返回新的 slice，底层数组改变。\n\n```go\nfunc TestSlice(t *testing.T) {\n\tints := []int{1,2}\n\tfmt.Printf(\"切片ints len = %d , cap = %d \\n\" , len(ints) , cap(ints))\n\tints = append(ints,3,4,5)\n\tfmt.Printf(\"切片ints len = %d , cap = %d \\n\" , len(ints) , cap(ints))\n}\n//切片ints len = 2 , cap = 2 \n//切片ints len = 5 , cap = 6\n```\n\nslice的扩容预估规则是怎么样的呢，我们假设原来的容量为oldCap，最小容量为cap。例如上面的代码，刚开始oldCap=2，append()后要求最小容量是5，即cap = 5。\n\n- 如果 oldCap * 2 < cap ，即假设我把原来的容量扩容2倍后小于所需最小容量，则将newCap = cap。\n- 否则在细分\n  - oldLen < 1024   则  newCap = cap\n  - oldLen >= 1024 则 扩容1/4 ， 即 newCap = oldCap * 1.25","slug":"go-study-01","published":1,"updated":"2021-11-23T06:25:51.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwbpt4ix0006zsv22qoidjh9","content":"<h3 id=\"什么时候用指针？\"><a href=\"#什么时候用指针？\" class=\"headerlink\" title=\"什么时候用指针？\"></a>什么时候用指针？</h3><ul>\n<li>不要对 map、slice、channel 这类引用类型使用指针；</li>\n<li>如果需要修改方法接收者内部的数据或者状态时，需要使用指针；</li>\n<li>如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数；</li>\n<li>如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针；</li>\n<li>像 int、bool 这样的小数据类型没必要使用指针；</li>\n<li>如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全；</li>\n<li>指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂。</li>\n</ul>\n<h3 id=\"slice切片类型结构\"><a href=\"#slice切片类型结构\" class=\"headerlink\" title=\"slice切片类型结构\"></a>slice切片类型结构</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Slice <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Data unsafe<span class=\"token punctuation\">.</span>Pointer     <span class=\"token comment\" spellcheck=\"true\">// 指向底层数组的指针</span>\n    Len  <span class=\"token builtin\">int</span>             <span class=\"token comment\" spellcheck=\"true\">// 切片的已存储的长度</span>\n    Cap  <span class=\"token builtin\">int</span>             <span class=\"token comment\" spellcheck=\"true\">// 切片的容量</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><img src=\"/2021/05/18/go-study-01/1.png\" alt></p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">TestSlice</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">}</span>\n    s1 <span class=\"token operator\">:=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"切片的len = %d, cap = %d \\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">,</span> <span class=\"token function\">cap</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    s2 <span class=\"token operator\">:=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">:</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"切片的len = %d, cap = %d \\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">,</span> <span class=\"token function\">cap</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    s1 <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">,</span><span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//打印结果</span>\n<span class=\"token comment\" spellcheck=\"true\">//切片的len = 5, cap = 8 </span>\n<span class=\"token comment\" spellcheck=\"true\">//切片的len = 2, cap = 5 </span>\n<span class=\"token comment\" spellcheck=\"true\">//[0 1 2 3 4 16 6 7]</span></code></pre>\n<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。如图</p>\n<ul>\n<li>s1字段中<code>Data unsafe.Pointer</code>记录了数组a的下标为0的地址。s1字段中<code>Data unsafe.Pointer</code>记录了数组a的下标为3的地址。</li>\n<li>切片的长度是<code>左闭右开</code>的，容量是从指向的起始位置开始算，例如s1指向是下标0，按照容量是数组剩余大小的话，cap = 8， 同理s2的cap = 5。</li>\n<li>s1 = append(s1,16)执行时，因为切片会操作原来的数组，所以这时候打印数组a时，数组a下标为6的值会变成16。</li>\n</ul>\n<p>上面我们说s1 = append(s1,16)时，s1会操作底层的数组。下面还有一种情况并不会修改到底层数组，我们具体来看个图。</p>\n<p><img src=\"/2021/05/18/go-study-01/2.png\" alt></p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">TestSlice</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">8</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">}</span>\n    s3 <span class=\"token operator\">:=</span> a<span class=\"token punctuation\">[</span><span class=\"token number\">6</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n    s3 <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>s3<span class=\"token punctuation\">,</span><span class=\"token number\">19</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">// 打印结果 ： [0 1 2 3 4 5 6 7]</span></code></pre>\n<p>上面执行s3 = append(s3,19)后，数组并没有我们想象中的发生改变，原因是此时s3的容量=长度，如果append增加元素时需要扩容，而扩容就会导致s3指向新的数组。</p>\n<h3 id=\"make和new的区别\"><a href=\"#make和new的区别\" class=\"headerlink\" title=\"make和new的区别\"></a>make和new的区别</h3><p>new 是 Golang 的内建函数，用于分配内存和初始化默认值。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span>Type<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span>Type</code></pre>\n<p>几个重要的点 : </p>\n<ul>\n<li>传入的是一个类型。</li>\n<li>返回的是一个指针类型。</li>\n<li>其值会被分配成初始值。</li>\n</ul>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">TestNew</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    a <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int64</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"指针变量a的类型: %T  指针变量a指向的值: %v 指针变量a的值: %v \\n\"</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>a<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 指针变量a的类型: *int64  指针变量a指向的值: 0 指针变量a的值: 0xc00000a300 </span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><img src=\"/2021/05/18/go-study-01/3.png\" alt></p>\n<p>如图所示，new出来的是一个指针类型，指向了初始化的值对应的物理地址。</p>\n<p>make是Golang的内建函数，<strong>只用于slice,map,channel</strong>的内存分配和初始化。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span>t Type<span class=\"token punctuation\">,</span> size <span class=\"token operator\">...</span>IntegerType<span class=\"token punctuation\">)</span> Type</code></pre>\n<p>可以看到，返回的是一个类型，而不是指针类型。</p>\n<h3 id=\"new和make初始化切片例子详解\"><a href=\"#new和make初始化切片例子详解\" class=\"headerlink\" title=\"new和make初始化切片例子详解\"></a>new和make初始化切片例子详解</h3><p>下面通过一个例子具体来看下make和new初始化切片的情况。</p>\n<p>假设有如下代码，此时我只是证明了一个int类型的切片，那么此时这个切片结构的data = nil , len = 0 , cap = 0.</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> ints <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span>        #声明一个切片类型</code></pre>\n<p>当我们使用make函数为其分配内存时</p>\n<pre class=\" language-go\"><code class=\"language-go\">ints <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">,</span> <span class=\"token number\">2</span> <span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\nints <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>ints<span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span></code></pre>\n<p>此时make会帮我们<strong>开辟这个切片的底层数组</strong>，且存储两个元素，如下图，绿色表示已经存储了两个元素。当继续执行append时，就会在第三个方格中继续存入。</p>\n<p><img src=\"/2021/05/18/go-study-01/4.png\" alt></p>\n<p>如果是使用new分配的话，我们再来看一下，还是上面的代码</p>\n<pre class=\" language-go\"><code class=\"language-go\">ints <span class=\"token operator\">:=</span> <span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>ints<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>        <span class=\"token comment\" spellcheck=\"true\">// 此时这一句会报错</span>\n<span class=\"token operator\">*</span>ints <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>ints <span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>ints<span class=\"token punctuation\">)</span></code></pre>\n<p>由于new只是分配内存和初始化0值，并不会像make那样为其分配内存。所以此时ints是一个指针类型，指向了切片这个结构，且这个切片的data = nil , len = 0 , cap = 0 。</p>\n<p><img src=\"/2021/05/18/go-study-01/5.png\" alt></p>\n<p>当用new初始化后执行<code>(*ints)[0] = 1</code>是会报错的，因为此时data还没有指向数组。如果要分配数组，我们可以用append方法，这个方法是可以帮我们自动创建底层数组的。所以执行<code>*ints = append(*ints , 1)</code>是可以行得通的。</p>\n<h3 id=\"slice切片的扩容\"><a href=\"#slice切片的扩容\" class=\"headerlink\" title=\"slice切片的扩容\"></a>slice切片的扩容</h3><p>append是如果容量不够，slice会自动扩容。扩容的原理其实是新建一个底层数组，先将之前数组的元素复制过来，再将新元素追加到后面，然后返回新的 slice，底层数组改变。</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">TestSlice</span><span class=\"token punctuation\">(</span>t <span class=\"token operator\">*</span>testing<span class=\"token punctuation\">.</span>T<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    ints <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"切片ints len = %d , cap = %d \\n\"</span> <span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>ints<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">,</span> <span class=\"token function\">cap</span><span class=\"token punctuation\">(</span>ints<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    ints <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>ints<span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"切片ints len = %d , cap = %d \\n\"</span> <span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>ints<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">,</span> <span class=\"token function\">cap</span><span class=\"token punctuation\">(</span>ints<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//切片ints len = 2 , cap = 2 </span>\n<span class=\"token comment\" spellcheck=\"true\">//切片ints len = 5 , cap = 6</span></code></pre>\n<p>slice的扩容预估规则是怎么样的呢，我们假设原来的容量为oldCap，最小容量为cap。例如上面的代码，刚开始oldCap=2，append()后要求最小容量是5，即cap = 5。</p>\n<ul>\n<li>如果 oldCap * 2 &lt; cap ，即假设我把原来的容量扩容2倍后小于所需最小容量，则将newCap = cap。</li>\n<li>否则在细分<ul>\n<li>oldLen &lt; 1024   则  newCap = cap</li>\n<li>oldLen &gt;= 1024 则 扩容1/4 ， 即 newCap = oldCap * 1.25</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么时候用指针？\"><a href=\"#什么时候用指针？\" class=\"headerlink\" title=\"什么时候用指针？\"></a>什么时候用指针？</h3><ul>\n<li>不要对 map、slice、channel 这类引用类型使用指针；</li>\n<li>如果需要修改方法接收者内部的数据或者状态时，需要使用指针；</li>\n<li>如果需要修改参数的值或者内部数据时，也需要使用指针类型的参数；</li>\n<li>如果是比较大的结构体，每次参数传递或者调用方法都要内存拷贝，内存占用多，这时候可以考虑使用指针；</li>\n<li>像 int、bool 这样的小数据类型没必要使用指针；</li>\n<li>如果需要并发安全，则尽可能地不要使用指针，使用指针一定要保证并发安全；</li>\n<li>指针最好不要嵌套，也就是不要使用一个指向指针的指针，虽然 Go 语言允许这么做，但是这会使你的代码变得异常复杂。</li>\n</ul>\n<h3 id=\"slice切片类型结构\"><a href=\"#slice切片类型结构\" class=\"headerlink\" title=\"slice切片类型结构\"></a>slice切片类型结构</h3><pre><code class=\"go\">type Slice struct {\n    Data unsafe.Pointer     // 指向底层数组的指针\n    Len  int             // 切片的已存储的长度\n    Cap  int             // 切片的容量\n}</code></pre>\n<p><img src=\"/2021/05/18/go-study-01/1.png\" alt></p>\n<pre><code class=\"go\">func TestSlice(t *testing.T) {\n    a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}\n    s1 := a[0:5]\n    fmt.Printf(&quot;切片的len = %d, cap = %d \\n&quot;, len(s1) , cap(s1))\n    s2 := a[3:5]\n    fmt.Printf(&quot;切片的len = %d, cap = %d \\n&quot;, len(s2) , cap(s2))\n    s1 = append(s1,16)\n    fmt.Println(a)\n}\n//打印结果\n//切片的len = 5, cap = 8 \n//切片的len = 2, cap = 5 \n//[0 1 2 3 4 16 6 7]</code></pre>\n<p>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。如图</p>\n<ul>\n<li>s1字段中<code>Data unsafe.Pointer</code>记录了数组a的下标为0的地址。s1字段中<code>Data unsafe.Pointer</code>记录了数组a的下标为3的地址。</li>\n<li>切片的长度是<code>左闭右开</code>的，容量是从指向的起始位置开始算，例如s1指向是下标0，按照容量是数组剩余大小的话，cap = 8， 同理s2的cap = 5。</li>\n<li>s1 = append(s1,16)执行时，因为切片会操作原来的数组，所以这时候打印数组a时，数组a下标为6的值会变成16。</li>\n</ul>\n<p>上面我们说s1 = append(s1,16)时，s1会操作底层的数组。下面还有一种情况并不会修改到底层数组，我们具体来看个图。</p>\n<p><img src=\"/2021/05/18/go-study-01/2.png\" alt></p>\n<pre><code class=\"go\">func TestSlice(t *testing.T) {\n    a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}\n    s3 := a[6:]\n    s3 = append(s3,19)\n    fmt.println(a)\n}\n// 打印结果 ： [0 1 2 3 4 5 6 7]</code></pre>\n<p>上面执行s3 = append(s3,19)后，数组并没有我们想象中的发生改变，原因是此时s3的容量=长度，如果append增加元素时需要扩容，而扩容就会导致s3指向新的数组。</p>\n<h3 id=\"make和new的区别\"><a href=\"#make和new的区别\" class=\"headerlink\" title=\"make和new的区别\"></a>make和new的区别</h3><p>new 是 Golang 的内建函数，用于分配内存和初始化默认值。</p>\n<pre><code class=\"go\">func new(Type) *Type</code></pre>\n<p>几个重要的点 : </p>\n<ul>\n<li>传入的是一个类型。</li>\n<li>返回的是一个指针类型。</li>\n<li>其值会被分配成初始值。</li>\n</ul>\n<pre><code class=\"go\">func TestNew(t *testing.T) {\n    a := new(int64)\n    fmt.Printf(&quot;指针变量a的类型: %T  指针变量a指向的值: %v 指针变量a的值: %v \\n&quot;, a, *a, a)\n    // 指针变量a的类型: *int64  指针变量a指向的值: 0 指针变量a的值: 0xc00000a300 \n}</code></pre>\n<p><img src=\"/2021/05/18/go-study-01/3.png\" alt></p>\n<p>如图所示，new出来的是一个指针类型，指向了初始化的值对应的物理地址。</p>\n<p>make是Golang的内建函数，<strong>只用于slice,map,channel</strong>的内存分配和初始化。</p>\n<pre><code class=\"go\">func make(t Type, size ...IntegerType) Type</code></pre>\n<p>可以看到，返回的是一个类型，而不是指针类型。</p>\n<h3 id=\"new和make初始化切片例子详解\"><a href=\"#new和make初始化切片例子详解\" class=\"headerlink\" title=\"new和make初始化切片例子详解\"></a>new和make初始化切片例子详解</h3><p>下面通过一个例子具体来看下make和new初始化切片的情况。</p>\n<p>假设有如下代码，此时我只是证明了一个int类型的切片，那么此时这个切片结构的data = nil , len = 0 , cap = 0.</p>\n<pre><code class=\"go\">var ints []int        #声明一个切片类型</code></pre>\n<p>当我们使用make函数为其分配内存时</p>\n<pre><code class=\"go\">ints := make([]int , 2 ,5)\nints = append(ints, 16)</code></pre>\n<p>此时make会帮我们<strong>开辟这个切片的底层数组</strong>，且存储两个元素，如下图，绿色表示已经存储了两个元素。当继续执行append时，就会在第三个方格中继续存入。</p>\n<p><img src=\"/2021/05/18/go-study-01/4.png\" alt></p>\n<p>如果是使用new分配的话，我们再来看一下，还是上面的代码</p>\n<pre><code class=\"go\">ints := new([]int)\n(*ints)[0] = 1        // 此时这一句会报错\n*ints = append(*ints , 1)\nfmt.Println(*ints)</code></pre>\n<p>由于new只是分配内存和初始化0值，并不会像make那样为其分配内存。所以此时ints是一个指针类型，指向了切片这个结构，且这个切片的data = nil , len = 0 , cap = 0 。</p>\n<p><img src=\"/2021/05/18/go-study-01/5.png\" alt></p>\n<p>当用new初始化后执行<code>(*ints)[0] = 1</code>是会报错的，因为此时data还没有指向数组。如果要分配数组，我们可以用append方法，这个方法是可以帮我们自动创建底层数组的。所以执行<code>*ints = append(*ints , 1)</code>是可以行得通的。</p>\n<h3 id=\"slice切片的扩容\"><a href=\"#slice切片的扩容\" class=\"headerlink\" title=\"slice切片的扩容\"></a>slice切片的扩容</h3><p>append是如果容量不够，slice会自动扩容。扩容的原理其实是新建一个底层数组，先将之前数组的元素复制过来，再将新元素追加到后面，然后返回新的 slice，底层数组改变。</p>\n<pre><code class=\"go\">func TestSlice(t *testing.T) {\n    ints := []int{1,2}\n    fmt.Printf(&quot;切片ints len = %d , cap = %d \\n&quot; , len(ints) , cap(ints))\n    ints = append(ints,3,4,5)\n    fmt.Printf(&quot;切片ints len = %d , cap = %d \\n&quot; , len(ints) , cap(ints))\n}\n//切片ints len = 2 , cap = 2 \n//切片ints len = 5 , cap = 6</code></pre>\n<p>slice的扩容预估规则是怎么样的呢，我们假设原来的容量为oldCap，最小容量为cap。例如上面的代码，刚开始oldCap=2，append()后要求最小容量是5，即cap = 5。</p>\n<ul>\n<li>如果 oldCap * 2 &lt; cap ，即假设我把原来的容量扩容2倍后小于所需最小容量，则将newCap = cap。</li>\n<li>否则在细分<ul>\n<li>oldLen &lt; 1024   则  newCap = cap</li>\n<li>oldLen &gt;= 1024 则 扩容1/4 ， 即 newCap = oldCap * 1.25</li>\n</ul>\n</li>\n</ul>\n"},{"title":"Solidity开发","description":"Solidity开发","date":"2021-05-30T05:53:30.000Z","_content":"\n### 常见知识点解释\n\n**Solidity中的`状态变量`与`局部变量`**\n\n`_age`和`_name`就属于状态变量。\n\n`age` `name` `name1`就属于局部变量。\n\n```java\npragma solidity >=0.4.22 <0.6.0;\ncontract Person {\n    int public _age;\n    string public _name;\n    function Person(int age,string name) {\n          _age = age;\n          _name = name;\n    }\n    function f(string name) {\n          var name1 = name;\n    }\n}\n```\n\n**Solidity中的引用类型`memory`与`storage`**\n\n`storage` : 是在合约部署创建时，根据你的合约中状态变量的声明，就固定下来了，并且不能在将来的合约方法调用中改变这个结构。\n\n`memory` : solidity应当在该函数运行时为变量创建一块空间，使其大小和结构满足函数运行的需要。\n\n注 : \n\n- 状态变量强制是storage类型\n- 任何函数参数当它的类型为引用类型时，这个函数参数都默认为memory类型。\n- memory类型的变量会临时拷贝一份值存储到内存中，当我们将这个参数值赋给一个新的变量，并尝试去修改这个新的变量的值时，最原始的变量的值并不会发生变化。\n- 当函数参数为`memory`类型时相当于**值传递**。\n- 当函数参数为`storage`类型时是**指针传递**。\n\n```java\npragma solidity >=0.4.22 <0.6.0;\ncontract Person {\n    string public  _name;\n    function Person() {\n        _name = \"liyuechun\";\n    }\n    function f() {\n        modifyName(_name);\n    }\n    function modifyName(string memory name)  {\n        var name1 = name;\n        bytes(name1)[0] = 'L';\n    }\n}\n```\n\n在本案例中，当创建合约时，`_name`的值为liyuechun，当我们调用f()函数时，f()函数中会将`_name`的值赋给临时的memory变量name，换句话说，因为name的类型为memory，所以name和`_name`会分别指向不同的对象，当我们尝试去修改name指针指向的值时，_name所指向的内容不会发生变化。\n\n\n\n```java\npragma solidity >=0.4.22 <0.6.0;\ncontract Person {\n    string public  _name;\n    function Person() {\n        _name = \"liyuechun\";\n    }\n    function f() {\n        modifyName(_name);\n    }\n    function modifyName(string storage name) internal {\n        var name1 = name;\n        bytes(name1)[0] = 'L';\n    }\n}\n```\n\n如果想要在modifyName函数中通过传递过来的指针修改`_name`的值，那么必须将函数参数的类型显示设置为storage类型，storage类型拷贝的不是值，而是`_name`指针，当调用modifyName(`_name`)函数时，相当于同时有`_name`，name,name1三个指针同时指向同一个对象，我们可以通过三个指针中的任何一个指针修改他们共同指向的内容的值。**函数默认是public类型的，当我们函数参数有storage类型时，必须加internal或者private修饰表示只能内部调用**。\n\n**Solidty中的`payable`,`view`,`pure`修饰**\n\n- `payable`方法是一种可以接收以太的特殊函数。如果一个函数需要进行货币操作，必须带上payable关键字这样才能正常接收`msg.value`。\n- `view`修饰的函数，是constant的别名，只能读取storage变量的值。\n- `pure`修饰的函数 ，不能对storage变量进行读写。\n\n**Solidity中internal、private、external、public区别**\n\n对于`public`和`private`，相信学过其他主流语言的人都能明白：\n\n- `public`修饰的变量和函数，任何用户或者合约都能调用和访问。\n- `private`修饰的变量和函数，只能在其所在的合约中调用和访问，即使是其子合约也没有权限访问。\n\n\n除 public 和 private 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：internal（内部） 和 external（外部）。\n\n- internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。\n- external 与public 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。\n\n`internal、private、external、public`这4种关键字都是可见性修饰符，**互不共存**。\n","source":"_posts/solidity.md","raw":"---\ntitle: Solidity开发\ntags:\n  - 区块链\ncategories:  区块链\ndescription : Solidity开发\ndate: 2021-05-30 13:53:30\n---\n\n### 常见知识点解释\n\n**Solidity中的`状态变量`与`局部变量`**\n\n`_age`和`_name`就属于状态变量。\n\n`age` `name` `name1`就属于局部变量。\n\n```java\npragma solidity >=0.4.22 <0.6.0;\ncontract Person {\n    int public _age;\n    string public _name;\n    function Person(int age,string name) {\n          _age = age;\n          _name = name;\n    }\n    function f(string name) {\n          var name1 = name;\n    }\n}\n```\n\n**Solidity中的引用类型`memory`与`storage`**\n\n`storage` : 是在合约部署创建时，根据你的合约中状态变量的声明，就固定下来了，并且不能在将来的合约方法调用中改变这个结构。\n\n`memory` : solidity应当在该函数运行时为变量创建一块空间，使其大小和结构满足函数运行的需要。\n\n注 : \n\n- 状态变量强制是storage类型\n- 任何函数参数当它的类型为引用类型时，这个函数参数都默认为memory类型。\n- memory类型的变量会临时拷贝一份值存储到内存中，当我们将这个参数值赋给一个新的变量，并尝试去修改这个新的变量的值时，最原始的变量的值并不会发生变化。\n- 当函数参数为`memory`类型时相当于**值传递**。\n- 当函数参数为`storage`类型时是**指针传递**。\n\n```java\npragma solidity >=0.4.22 <0.6.0;\ncontract Person {\n    string public  _name;\n    function Person() {\n        _name = \"liyuechun\";\n    }\n    function f() {\n        modifyName(_name);\n    }\n    function modifyName(string memory name)  {\n        var name1 = name;\n        bytes(name1)[0] = 'L';\n    }\n}\n```\n\n在本案例中，当创建合约时，`_name`的值为liyuechun，当我们调用f()函数时，f()函数中会将`_name`的值赋给临时的memory变量name，换句话说，因为name的类型为memory，所以name和`_name`会分别指向不同的对象，当我们尝试去修改name指针指向的值时，_name所指向的内容不会发生变化。\n\n\n\n```java\npragma solidity >=0.4.22 <0.6.0;\ncontract Person {\n    string public  _name;\n    function Person() {\n        _name = \"liyuechun\";\n    }\n    function f() {\n        modifyName(_name);\n    }\n    function modifyName(string storage name) internal {\n        var name1 = name;\n        bytes(name1)[0] = 'L';\n    }\n}\n```\n\n如果想要在modifyName函数中通过传递过来的指针修改`_name`的值，那么必须将函数参数的类型显示设置为storage类型，storage类型拷贝的不是值，而是`_name`指针，当调用modifyName(`_name`)函数时，相当于同时有`_name`，name,name1三个指针同时指向同一个对象，我们可以通过三个指针中的任何一个指针修改他们共同指向的内容的值。**函数默认是public类型的，当我们函数参数有storage类型时，必须加internal或者private修饰表示只能内部调用**。\n\n**Solidty中的`payable`,`view`,`pure`修饰**\n\n- `payable`方法是一种可以接收以太的特殊函数。如果一个函数需要进行货币操作，必须带上payable关键字这样才能正常接收`msg.value`。\n- `view`修饰的函数，是constant的别名，只能读取storage变量的值。\n- `pure`修饰的函数 ，不能对storage变量进行读写。\n\n**Solidity中internal、private、external、public区别**\n\n对于`public`和`private`，相信学过其他主流语言的人都能明白：\n\n- `public`修饰的变量和函数，任何用户或者合约都能调用和访问。\n- `private`修饰的变量和函数，只能在其所在的合约中调用和访问，即使是其子合约也没有权限访问。\n\n\n除 public 和 private 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：internal（内部） 和 external（外部）。\n\n- internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。\n- external 与public 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。\n\n`internal、private、external、public`这4种关键字都是可见性修饰符，**互不共存**。\n","slug":"solidity","published":1,"updated":"2021-09-19T13:14:47.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckwbpt4jg000nzsv29eapec7c","content":"<h3 id=\"常见知识点解释\"><a href=\"#常见知识点解释\" class=\"headerlink\" title=\"常见知识点解释\"></a>常见知识点解释</h3><p><strong>Solidity中的<code>状态变量</code>与<code>局部变量</code></strong></p>\n<p><code>_age</code>和<code>_name</code>就属于状态变量。</p>\n<p><code>age</code> <code>name</code> <code>name1</code>就属于局部变量。</p>\n<pre class=\" language-java\"><code class=\"language-java\">pragma solidity <span class=\"token operator\">>=</span><span class=\"token number\">0.4</span><span class=\"token punctuation\">.</span><span class=\"token number\">22</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">0.6</span><span class=\"token punctuation\">.</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\ncontract Person <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> <span class=\"token keyword\">public</span> _age<span class=\"token punctuation\">;</span>\n    string <span class=\"token keyword\">public</span> _name<span class=\"token punctuation\">;</span>\n    function <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">,</span>string name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          _age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n          _name <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    function <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>string name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          var name1 <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><strong>Solidity中的引用类型<code>memory</code>与<code>storage</code></strong></p>\n<p><code>storage</code> : 是在合约部署创建时，根据你的合约中状态变量的声明，就固定下来了，并且不能在将来的合约方法调用中改变这个结构。</p>\n<p><code>memory</code> : solidity应当在该函数运行时为变量创建一块空间，使其大小和结构满足函数运行的需要。</p>\n<p>注 : </p>\n<ul>\n<li>状态变量强制是storage类型</li>\n<li>任何函数参数当它的类型为引用类型时，这个函数参数都默认为memory类型。</li>\n<li>memory类型的变量会临时拷贝一份值存储到内存中，当我们将这个参数值赋给一个新的变量，并尝试去修改这个新的变量的值时，最原始的变量的值并不会发生变化。</li>\n<li>当函数参数为<code>memory</code>类型时相当于<strong>值传递</strong>。</li>\n<li>当函数参数为<code>storage</code>类型时是<strong>指针传递</strong>。</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\">pragma solidity <span class=\"token operator\">>=</span><span class=\"token number\">0.4</span><span class=\"token punctuation\">.</span><span class=\"token number\">22</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">0.6</span><span class=\"token punctuation\">.</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\ncontract Person <span class=\"token punctuation\">{</span>\n    string <span class=\"token keyword\">public</span>  _name<span class=\"token punctuation\">;</span>\n    function <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _name <span class=\"token operator\">=</span> <span class=\"token string\">\"liyuechun\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    function <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">modifyName</span><span class=\"token punctuation\">(</span>_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    function <span class=\"token function\">modifyName</span><span class=\"token punctuation\">(</span>string memory name<span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n        var name1 <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">bytes</span><span class=\"token punctuation\">(</span>name1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'L'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>在本案例中，当创建合约时，<code>_name</code>的值为liyuechun，当我们调用f()函数时，f()函数中会将<code>_name</code>的值赋给临时的memory变量name，换句话说，因为name的类型为memory，所以name和<code>_name</code>会分别指向不同的对象，当我们尝试去修改name指针指向的值时，_name所指向的内容不会发生变化。</p>\n<pre class=\" language-java\"><code class=\"language-java\">pragma solidity <span class=\"token operator\">>=</span><span class=\"token number\">0.4</span><span class=\"token punctuation\">.</span><span class=\"token number\">22</span> <span class=\"token operator\">&lt;</span><span class=\"token number\">0.6</span><span class=\"token punctuation\">.</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\ncontract Person <span class=\"token punctuation\">{</span>\n    string <span class=\"token keyword\">public</span>  _name<span class=\"token punctuation\">;</span>\n    function <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        _name <span class=\"token operator\">=</span> <span class=\"token string\">\"liyuechun\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    function <span class=\"token function\">f</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">modifyName</span><span class=\"token punctuation\">(</span>_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    function <span class=\"token function\">modifyName</span><span class=\"token punctuation\">(</span>string storage name<span class=\"token punctuation\">)</span> internal <span class=\"token punctuation\">{</span>\n        var name1 <span class=\"token operator\">=</span> name<span class=\"token punctuation\">;</span>\n        <span class=\"token function\">bytes</span><span class=\"token punctuation\">(</span>name1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">'L'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>如果想要在modifyName函数中通过传递过来的指针修改<code>_name</code>的值，那么必须将函数参数的类型显示设置为storage类型，storage类型拷贝的不是值，而是<code>_name</code>指针，当调用modifyName(<code>_name</code>)函数时，相当于同时有<code>_name</code>，name,name1三个指针同时指向同一个对象，我们可以通过三个指针中的任何一个指针修改他们共同指向的内容的值。<strong>函数默认是public类型的，当我们函数参数有storage类型时，必须加internal或者private修饰表示只能内部调用</strong>。</p>\n<p><strong>Solidty中的<code>payable</code>,<code>view</code>,<code>pure</code>修饰</strong></p>\n<ul>\n<li><code>payable</code>方法是一种可以接收以太的特殊函数。如果一个函数需要进行货币操作，必须带上payable关键字这样才能正常接收<code>msg.value</code>。</li>\n<li><code>view</code>修饰的函数，是constant的别名，只能读取storage变量的值。</li>\n<li><code>pure</code>修饰的函数 ，不能对storage变量进行读写。</li>\n</ul>\n<p><strong>Solidity中internal、private、external、public区别</strong></p>\n<p>对于<code>public</code>和<code>private</code>，相信学过其他主流语言的人都能明白：</p>\n<ul>\n<li><code>public</code>修饰的变量和函数，任何用户或者合约都能调用和访问。</li>\n<li><code>private</code>修饰的变量和函数，只能在其所在的合约中调用和访问，即使是其子合约也没有权限访问。</li>\n</ul>\n<p>除 public 和 private 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：internal（内部） 和 external（外部）。</p>\n<ul>\n<li>internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</li>\n<li>external 与public 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。</li>\n</ul>\n<p><code>internal、private、external、public</code>这4种关键字都是可见性修饰符，<strong>互不共存</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"常见知识点解释\"><a href=\"#常见知识点解释\" class=\"headerlink\" title=\"常见知识点解释\"></a>常见知识点解释</h3><p><strong>Solidity中的<code>状态变量</code>与<code>局部变量</code></strong></p>\n<p><code>_age</code>和<code>_name</code>就属于状态变量。</p>\n<p><code>age</code> <code>name</code> <code>name1</code>就属于局部变量。</p>\n<pre><code class=\"java\">pragma solidity &gt;=0.4.22 &lt;0.6.0;\ncontract Person {\n    int public _age;\n    string public _name;\n    function Person(int age,string name) {\n          _age = age;\n          _name = name;\n    }\n    function f(string name) {\n          var name1 = name;\n    }\n}</code></pre>\n<p><strong>Solidity中的引用类型<code>memory</code>与<code>storage</code></strong></p>\n<p><code>storage</code> : 是在合约部署创建时，根据你的合约中状态变量的声明，就固定下来了，并且不能在将来的合约方法调用中改变这个结构。</p>\n<p><code>memory</code> : solidity应当在该函数运行时为变量创建一块空间，使其大小和结构满足函数运行的需要。</p>\n<p>注 : </p>\n<ul>\n<li>状态变量强制是storage类型</li>\n<li>任何函数参数当它的类型为引用类型时，这个函数参数都默认为memory类型。</li>\n<li>memory类型的变量会临时拷贝一份值存储到内存中，当我们将这个参数值赋给一个新的变量，并尝试去修改这个新的变量的值时，最原始的变量的值并不会发生变化。</li>\n<li>当函数参数为<code>memory</code>类型时相当于<strong>值传递</strong>。</li>\n<li>当函数参数为<code>storage</code>类型时是<strong>指针传递</strong>。</li>\n</ul>\n<pre><code class=\"java\">pragma solidity &gt;=0.4.22 &lt;0.6.0;\ncontract Person {\n    string public  _name;\n    function Person() {\n        _name = &quot;liyuechun&quot;;\n    }\n    function f() {\n        modifyName(_name);\n    }\n    function modifyName(string memory name)  {\n        var name1 = name;\n        bytes(name1)[0] = &#39;L&#39;;\n    }\n}</code></pre>\n<p>在本案例中，当创建合约时，<code>_name</code>的值为liyuechun，当我们调用f()函数时，f()函数中会将<code>_name</code>的值赋给临时的memory变量name，换句话说，因为name的类型为memory，所以name和<code>_name</code>会分别指向不同的对象，当我们尝试去修改name指针指向的值时，_name所指向的内容不会发生变化。</p>\n<pre><code class=\"java\">pragma solidity &gt;=0.4.22 &lt;0.6.0;\ncontract Person {\n    string public  _name;\n    function Person() {\n        _name = &quot;liyuechun&quot;;\n    }\n    function f() {\n        modifyName(_name);\n    }\n    function modifyName(string storage name) internal {\n        var name1 = name;\n        bytes(name1)[0] = &#39;L&#39;;\n    }\n}</code></pre>\n<p>如果想要在modifyName函数中通过传递过来的指针修改<code>_name</code>的值，那么必须将函数参数的类型显示设置为storage类型，storage类型拷贝的不是值，而是<code>_name</code>指针，当调用modifyName(<code>_name</code>)函数时，相当于同时有<code>_name</code>，name,name1三个指针同时指向同一个对象，我们可以通过三个指针中的任何一个指针修改他们共同指向的内容的值。<strong>函数默认是public类型的，当我们函数参数有storage类型时，必须加internal或者private修饰表示只能内部调用</strong>。</p>\n<p><strong>Solidty中的<code>payable</code>,<code>view</code>,<code>pure</code>修饰</strong></p>\n<ul>\n<li><code>payable</code>方法是一种可以接收以太的特殊函数。如果一个函数需要进行货币操作，必须带上payable关键字这样才能正常接收<code>msg.value</code>。</li>\n<li><code>view</code>修饰的函数，是constant的别名，只能读取storage变量的值。</li>\n<li><code>pure</code>修饰的函数 ，不能对storage变量进行读写。</li>\n</ul>\n<p><strong>Solidity中internal、private、external、public区别</strong></p>\n<p>对于<code>public</code>和<code>private</code>，相信学过其他主流语言的人都能明白：</p>\n<ul>\n<li><code>public</code>修饰的变量和函数，任何用户或者合约都能调用和访问。</li>\n<li><code>private</code>修饰的变量和函数，只能在其所在的合约中调用和访问，即使是其子合约也没有权限访问。</li>\n</ul>\n<p>除 public 和 private 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：internal（内部） 和 external（外部）。</p>\n<ul>\n<li>internal 和 private 类似，不过， 如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</li>\n<li>external 与public 类似，只不过这些函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。</li>\n</ul>\n<p><code>internal、private、external、public</code>这4种关键字都是可见性修饰符，<strong>互不共存</strong>。</p>\n"}],"PostAsset":[{"_id":"source/_posts/db-w-r-dynamic/db1.png","slug":"db1.png","post":"ckcujgdbf0000e0xlg085gsal","modified":0,"renderable":0},{"_id":"source/_posts/db-w-r-dynamic/AbstractRoutingDataSource.png","slug":"AbstractRoutingDataSource.png","post":"ckcujgdbf0000e0xlg085gsal","modified":0,"renderable":0},{"_id":"source/_posts/io/3.png","slug":"3.png","post":"ckn9yvhuq000hqwv2d2ae5br4","modified":0,"renderable":0},{"_id":"source/_posts/jvm-optimization/2.png","slug":"2.png","post":"ckn9yvhuy000vqwv29m0m7m80","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index/8.png","slug":"8.png","post":"ckn9yvhvg0026qwv29cdy8q8h","modified":0,"renderable":0},{"_id":"source/_posts/redis-rdb-aop/2.png","slug":"2.png","post":"ckn9yvhvq0037qwv2e2q19khp","modified":0,"renderable":0},{"_id":"source/_posts/spring-forbean/2.png","slug":"2.png","post":"ckn9yvhvv003qqwv2c6353vtk","modified":0,"renderable":0},{"_id":"source/_posts/spring-forbean/4.png","slug":"4.png","post":"ckn9yvhvv003qqwv2c6353vtk","modified":0,"renderable":0},{"_id":"source/_posts/springboot-custom-start/3.png","slug":"3.png","post":"ckn9yvhvx003yqwv2626945nt","modified":0,"renderable":0},{"_id":"source/_posts/springboot-custom-start/7.png","slug":"7.png","post":"ckn9yvhvx003yqwv2626945nt","modified":0,"renderable":0},{"_id":"source/_posts/springmvc2/15.png","slug":"15.png","post":"ckn9yvhw00049qwv23866gmu1","modified":0,"renderable":0},{"_id":"source/_posts/springmvc2/16.png","slug":"16.png","post":"ckn9yvhw00049qwv23866gmu1","modified":0,"renderable":0},{"_id":"source/_posts/hashmap/3.png","slug":"3.png","post":"ckn9yvhur000kqwv2a85nbo4u","modified":0,"renderable":0},{"_id":"source/_posts/hashmap/1.png","slug":"1.png","post":"ckn9yvhur000kqwv2a85nbo4u","modified":0,"renderable":0},{"_id":"source/_posts/io/4.png","slug":"4.png","post":"ckn9yvhuq000hqwv2d2ae5br4","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/9.png","slug":"9.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/threadlocal/3.png","slug":"3.png","post":"ckn9yvhw3004kqwv2gassfatz","modified":0,"renderable":0},{"_id":"source/_posts/kafka-muticustomerthread/1.png","slug":"1.png","post":"ckn9yvhv70016qwv27dy1djjx","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-use/1.png","slug":"1.png","post":"ckn9yvhvb001oqwv22g36hv60","modified":0,"renderable":0},{"_id":"source/_posts/mysql-masterslave-solve/1.jpg","slug":"1.jpg","post":"ckn9yvhvh0029qwv21eef5q0l","modified":0,"renderable":0},{"_id":"source/_posts/springcloud-1/1.png","slug":"1.png","post":"ckn9yvhvx0041qwv28f7z74rb","modified":0,"renderable":0},{"_id":"source/_posts/futuretask/1.png","slug":"1.png","post":"ckn9yvhun000cqwv27tig1h1x","modified":0,"renderable":0},{"_id":"source/_posts/futuretask/2.png","slug":"2.png","post":"ckn9yvhun000cqwv27tig1h1x","modified":0,"renderable":0},{"_id":"source/_posts/limit-single/1.png","slug":"1.png","post":"ckn9yvhv9001eqwv28yb05t1b","modified":0,"renderable":0},{"_id":"source/_posts/limit-single/2.png","slug":"2.png","post":"ckn9yvhv9001eqwv28yb05t1b","modified":0,"renderable":0},{"_id":"source/_posts/mysql-log/1.png","slug":"1.png","post":"ckn9yvhvf0022qwv2gwed7t7d","modified":0,"renderable":0},{"_id":"source/_posts/mysql-log/2.png","slug":"2.png","post":"ckn9yvhvf0022qwv2gwed7t7d","modified":0,"renderable":0},{"_id":"source/_posts/mysql-mvcc/1.png","slug":"1.png","post":"ckn9yvhvi002dqwv2a6o1e3ab","modified":0,"renderable":0},{"_id":"source/_posts/mysql-mvcc/2.png","slug":"2.png","post":"ckn9yvhvi002dqwv2a6o1e3ab","modified":0,"renderable":0},{"_id":"source/_posts/redis-aop-limit-boot/1.png","slug":"1.png","post":"ckn9yvhvj002kqwv229tjfcf0","modified":0,"renderable":0},{"_id":"source/_posts/redis-aop-limit-boot/2.png","slug":"2.png","post":"ckn9yvhvj002kqwv229tjfcf0","modified":0,"renderable":0},{"_id":"source/_posts/redis-known/1.png","slug":"1.png","post":"ckn9yvhvp0033qwv2cm36d9tz","modified":0,"renderable":0},{"_id":"source/_posts/redis-known/2.png","slug":"2.png","post":"ckn9yvhvp0033qwv2cm36d9tz","modified":0,"renderable":0},{"_id":"source/_posts/redis-sentinel/1.png","slug":"1.png","post":"ckn9yvhvr003bqwv25nzk0l95","modified":0,"renderable":0},{"_id":"source/_posts/redis-sentinel/2.png","slug":"2.png","post":"ckn9yvhvr003bqwv25nzk0l95","modified":0,"renderable":0},{"_id":"source/_posts/shardingjdbc-reg/1.png","slug":"1.png","post":"ckn9yvhvs003eqwv2b9h426cc","modified":0,"renderable":0},{"_id":"source/_posts/shardingjdbc-reg/2.png","slug":"2.png","post":"ckn9yvhvs003eqwv2b9h426cc","modified":0,"renderable":0},{"_id":"source/_posts/shardingphere-problem/1.png","slug":"1.png","post":"ckn9yvhvw003tqwv2c41fb2zf","modified":0,"renderable":0},{"_id":"source/_posts/shardingphere-problem/2.png","slug":"2.png","post":"ckn9yvhvw003tqwv2c41fb2zf","modified":0,"renderable":0},{"_id":"source/_posts/springcloud-2/1.png","slug":"1.png","post":"ckn9yvhvz0046qwv22hrf25le","modified":0,"renderable":0},{"_id":"source/_posts/springcloud-2/Hystrix.png","slug":"Hystrix.png","post":"ckn9yvhvz0046qwv22hrf25le","modified":0,"renderable":0},{"_id":"source/_posts/volatile/1.png","slug":"1.png","post":"ckn9yvhw6004sqwv2c40o9wr5","modified":0,"renderable":0},{"_id":"source/_posts/volatile/2.png","slug":"2.png","post":"ckn9yvhw6004sqwv2c40o9wr5","modified":0,"renderable":0},{"_id":"source/_posts/kafka-messge-complete/1.png","slug":"1.png","post":"ckn9yvhv3000zqwv2940fawon","modified":0,"renderable":0},{"_id":"source/_posts/kafka-messge-complete/2.png","slug":"2.png","post":"ckn9yvhv3000zqwv2940fawon","modified":0,"renderable":0},{"_id":"source/_posts/kafka-messge-complete/3.png","slug":"3.png","post":"ckn9yvhv3000zqwv2940fawon","modified":0,"renderable":0},{"_id":"source/_posts/redis-master-slave/1.png","slug":"1.png","post":"ckn9yvhvn002zqwv28sr9g006","modified":0,"renderable":0},{"_id":"source/_posts/redis-master-slave/2.png","slug":"2.png","post":"ckn9yvhvn002zqwv28sr9g006","modified":0,"renderable":0},{"_id":"source/_posts/redis-master-slave/3.png","slug":"3.png","post":"ckn9yvhvn002zqwv28sr9g006","modified":0,"renderable":0},{"_id":"source/_posts/redis-rdb-aop/1.png","slug":"1.png","post":"ckn9yvhvq0037qwv2e2q19khp","modified":0,"renderable":0},{"_id":"source/_posts/redis-rdb-aop/3.png","slug":"3.png","post":"ckn9yvhvq0037qwv2e2q19khp","modified":0,"renderable":0},{"_id":"source/_posts/zookeeper-lock/1.png","slug":"1.png","post":"ckn9yvhw80050qwv22sdp6hlv","modified":0,"renderable":0},{"_id":"source/_posts/zookeeper-lock/2.png","slug":"2.png","post":"ckn9yvhw80050qwv22sdp6hlv","modified":0,"renderable":0},{"_id":"source/_posts/zookeeper-lock/3.png","slug":"3.png","post":"ckn9yvhw80050qwv22sdp6hlv","modified":0,"renderable":0},{"_id":"source/_posts/gc-log/1.jpg","slug":"1.jpg","post":"ckn9yvhug0007qwv26zbi3n30","modified":0,"renderable":0},{"_id":"source/_posts/gc-log/2.jpg","slug":"2.jpg","post":"ckn9yvhug0007qwv26zbi3n30","modified":0,"renderable":0},{"_id":"source/_posts/gc-log/3.png","slug":"3.png","post":"ckn9yvhug0007qwv26zbi3n30","modified":0,"renderable":0},{"_id":"source/_posts/gc-log/4.png","slug":"4.png","post":"ckn9yvhug0007qwv26zbi3n30","modified":0,"renderable":0},{"_id":"source/_posts/io/1.png","slug":"1.png","post":"ckn9yvhuq000hqwv2d2ae5br4","modified":0,"renderable":0},{"_id":"source/_posts/io/2.png","slug":"2.png","post":"ckn9yvhuq000hqwv2d2ae5br4","modified":0,"renderable":0},{"_id":"source/_posts/kafka-base/1.png","slug":"1.png","post":"ckn9yvhuv000rqwv23h4c5d88","modified":0,"renderable":0},{"_id":"source/_posts/kafka-base/2.png","slug":"2.png","post":"ckn9yvhuv000rqwv23h4c5d88","modified":0,"renderable":0},{"_id":"source/_posts/kafka-base/3.png","slug":"3.png","post":"ckn9yvhuv000rqwv23h4c5d88","modified":0,"renderable":0},{"_id":"source/_posts/kafka-base/4.png","slug":"4.png","post":"ckn9yvhuv000rqwv23h4c5d88","modified":0,"renderable":0},{"_id":"source/_posts/sharding-student/1.png","slug":"1.png","post":"ckn9yvhvt003iqwv21k7k2dns","modified":0,"renderable":0},{"_id":"source/_posts/sharding-student/2.png","slug":"2.png","post":"ckn9yvhvt003iqwv21k7k2dns","modified":0,"renderable":0},{"_id":"source/_posts/sharding-student/3.png","slug":"3.png","post":"ckn9yvhvt003iqwv21k7k2dns","modified":0,"renderable":0},{"_id":"source/_posts/sharding-student/4.png","slug":"4.png","post":"ckn9yvhvt003iqwv21k7k2dns","modified":0,"renderable":0},{"_id":"source/_posts/spring-extend/1.png","slug":"1.png","post":"ckn9yvhvu003mqwv26ydf4751","modified":0,"renderable":0},{"_id":"source/_posts/spring-extend/2.png","slug":"2.png","post":"ckn9yvhvu003mqwv26ydf4751","modified":0,"renderable":0},{"_id":"source/_posts/spring-extend/3.png","slug":"3.png","post":"ckn9yvhvu003mqwv26ydf4751","modified":0,"renderable":0},{"_id":"source/_posts/spring-extend/4.png","slug":"4.png","post":"ckn9yvhvu003mqwv26ydf4751","modified":0,"renderable":0},{"_id":"source/_posts/executorservice/1.jpg","slug":"1.jpg","post":"ckn9yvhu70002qwv28poxegic","modified":0,"renderable":0},{"_id":"source/_posts/executorservice/1.png","slug":"1.png","post":"ckn9yvhu70002qwv28poxegic","modified":0,"renderable":0},{"_id":"source/_posts/executorservice/2.png","slug":"2.png","post":"ckn9yvhu70002qwv28poxegic","modified":0,"renderable":0},{"_id":"source/_posts/executorservice/3.png","slug":"3.png","post":"ckn9yvhu70002qwv28poxegic","modified":0,"renderable":0},{"_id":"source/_posts/executorservice/4.png","slug":"4.png","post":"ckn9yvhu70002qwv28poxegic","modified":0,"renderable":0},{"_id":"source/_posts/hashmap/2.png","slug":"2.png","post":"ckn9yvhur000kqwv2a85nbo4u","modified":0,"renderable":0},{"_id":"source/_posts/hashmap/4.png","slug":"4.png","post":"ckn9yvhur000kqwv2a85nbo4u","modified":0,"renderable":0},{"_id":"source/_posts/hashmap/5.png","slug":"5.png","post":"ckn9yvhur000kqwv2a85nbo4u","modified":0,"renderable":0},{"_id":"source/_posts/java-aqs/1.jpg","slug":"1.jpg","post":"ckn9yvhut000pqwv2cy3f903v","modified":0,"renderable":0},{"_id":"source/_posts/java-aqs/1.png","slug":"1.png","post":"ckn9yvhut000pqwv2cy3f903v","modified":0,"renderable":0},{"_id":"source/_posts/java-aqs/2.jpg","slug":"2.jpg","post":"ckn9yvhut000pqwv2cy3f903v","modified":0,"renderable":0},{"_id":"source/_posts/java-aqs/2.png","slug":"2.png","post":"ckn9yvhut000pqwv2cy3f903v","modified":0,"renderable":0},{"_id":"source/_posts/java-aqs/3.jpg","slug":"3.jpg","post":"ckn9yvhut000pqwv2cy3f903v","modified":0,"renderable":0},{"_id":"source/_posts/redis-data-type/1.png","slug":"1.png","post":"ckn9yvhvl002vqwv232lkay5s","modified":0,"renderable":0},{"_id":"source/_posts/redis-data-type/2.png","slug":"2.png","post":"ckn9yvhvl002vqwv232lkay5s","modified":0,"renderable":0},{"_id":"source/_posts/redis-data-type/3.png","slug":"3.png","post":"ckn9yvhvl002vqwv232lkay5s","modified":0,"renderable":0},{"_id":"source/_posts/redis-data-type/4.png","slug":"4.png","post":"ckn9yvhvl002vqwv232lkay5s","modified":0,"renderable":0},{"_id":"source/_posts/redis-data-type/5.png","slug":"5.png","post":"ckn9yvhvl002vqwv232lkay5s","modified":0,"renderable":0},{"_id":"source/_posts/sring-class/1.jpg","slug":"1.jpg","post":"ckn9yvhw5004nqwv2d3r39hb6","modified":0,"renderable":0},{"_id":"source/_posts/sring-class/1.png","slug":"1.png","post":"ckn9yvhw5004nqwv2d3r39hb6","modified":0,"renderable":0},{"_id":"source/_posts/sring-class/2.jpg","slug":"2.jpg","post":"ckn9yvhw5004nqwv2d3r39hb6","modified":0,"renderable":0},{"_id":"source/_posts/sring-class/3.png","slug":"3.png","post":"ckn9yvhw5004nqwv2d3r39hb6","modified":0,"renderable":0},{"_id":"source/_posts/sring-class/4.png","slug":"4.png","post":"ckn9yvhw5004nqwv2d3r39hb6","modified":0,"renderable":0},{"_id":"source/_posts/jvm-optimization/1.png","slug":"1.png","post":"ckn9yvhuy000vqwv29m0m7m80","modified":0,"renderable":0},{"_id":"source/_posts/jvm-optimization/3.png","slug":"3.png","post":"ckn9yvhuy000vqwv29m0m7m80","modified":0,"renderable":0},{"_id":"source/_posts/jvm-optimization/4.png","slug":"4.png","post":"ckn9yvhuy000vqwv29m0m7m80","modified":0,"renderable":0},{"_id":"source/_posts/jvm-optimization/5.png","slug":"5.png","post":"ckn9yvhuy000vqwv29m0m7m80","modified":0,"renderable":0},{"_id":"source/_posts/jvm-optimization/6.png","slug":"6.png","post":"ckn9yvhuy000vqwv29m0m7m80","modified":0,"renderable":0},{"_id":"source/_posts/linux-netstat/1.png","slug":"1.png","post":"ckn9yvhv9001iqwv27jp34xc9","modified":0,"renderable":0},{"_id":"source/_posts/linux-netstat/2.png","slug":"2.png","post":"ckn9yvhv9001iqwv27jp34xc9","modified":0,"renderable":0},{"_id":"source/_posts/linux-netstat/3.png","slug":"3.png","post":"ckn9yvhv9001iqwv27jp34xc9","modified":0,"renderable":0},{"_id":"source/_posts/linux-netstat/4.png","slug":"4.png","post":"ckn9yvhv9001iqwv27jp34xc9","modified":0,"renderable":0},{"_id":"source/_posts/linux-netstat/5.png","slug":"5.png","post":"ckn9yvhv9001iqwv27jp34xc9","modified":0,"renderable":0},{"_id":"source/_posts/linux-netstat/6.png","slug":"6.png","post":"ckn9yvhv9001iqwv27jp34xc9","modified":0,"renderable":0},{"_id":"source/_posts/linux-top/1.png","slug":"1.png","post":"ckn9yvhva001mqwv2hanmfrzj","modified":0,"renderable":0},{"_id":"source/_posts/linux-top/2.png","slug":"2.png","post":"ckn9yvhva001mqwv2hanmfrzj","modified":0,"renderable":0},{"_id":"source/_posts/linux-top/3.png","slug":"3.png","post":"ckn9yvhva001mqwv2hanmfrzj","modified":0,"renderable":0},{"_id":"source/_posts/linux-top/4.png","slug":"4.png","post":"ckn9yvhva001mqwv2hanmfrzj","modified":0,"renderable":0},{"_id":"source/_posts/linux-top/5.png","slug":"5.png","post":"ckn9yvhva001mqwv2hanmfrzj","modified":0,"renderable":0},{"_id":"source/_posts/linux-top/6.png","slug":"6.png","post":"ckn9yvhva001mqwv2hanmfrzj","modified":0,"renderable":0},{"_id":"source/_posts/spring-forbean/1.jpg","slug":"1.jpg","post":"ckn9yvhvv003qqwv2c6353vtk","modified":0,"renderable":0},{"_id":"source/_posts/spring-forbean/1.png","slug":"1.png","post":"ckn9yvhvv003qqwv2c6353vtk","modified":0,"renderable":0},{"_id":"source/_posts/spring-forbean/3.png","slug":"3.png","post":"ckn9yvhvv003qqwv2c6353vtk","modified":0,"renderable":0},{"_id":"source/_posts/spring-forbean/5.png","slug":"5.png","post":"ckn9yvhvv003qqwv2c6353vtk","modified":0,"renderable":0},{"_id":"source/_posts/synchronized-up/1.jpg","slug":"1.jpg","post":"ckn9yvhw2004gqwv2f31ef3cp","modified":0,"renderable":0},{"_id":"source/_posts/synchronized-up/2.png","slug":"2.png","post":"ckn9yvhw2004gqwv2f31ef3cp","modified":0,"renderable":0},{"_id":"source/_posts/synchronized-up/3.png","slug":"3.png","post":"ckn9yvhw2004gqwv2f31ef3cp","modified":0,"renderable":0},{"_id":"source/_posts/synchronized-up/4.png","slug":"4.png","post":"ckn9yvhw2004gqwv2f31ef3cp","modified":0,"renderable":0},{"_id":"source/_posts/synchronized-up/5.png","slug":"5.png","post":"ckn9yvhw2004gqwv2f31ef3cp","modified":0,"renderable":0},{"_id":"source/_posts/synchronized-up/6.png","slug":"6.png","post":"ckn9yvhw2004gqwv2f31ef3cp","modified":0,"renderable":0},{"_id":"source/_posts/threadlocal/1.png","slug":"1.png","post":"ckn9yvhw3004kqwv2gassfatz","modified":0,"renderable":0},{"_id":"source/_posts/threadlocal/2.png","slug":"2.png","post":"ckn9yvhw3004kqwv2gassfatz","modified":0,"renderable":0},{"_id":"source/_posts/threadlocal/4.png","slug":"4.png","post":"ckn9yvhw3004kqwv2gassfatz","modified":0,"renderable":0},{"_id":"source/_posts/threadlocal/5.png","slug":"5.png","post":"ckn9yvhw3004kqwv2gassfatz","modified":0,"renderable":0},{"_id":"source/_posts/threadlocal/6.png","slug":"6.png","post":"ckn9yvhw3004kqwv2gassfatz","modified":0,"renderable":0},{"_id":"source/_posts/springboot-custom-start/1.png","slug":"1.png","post":"ckn9yvhvx003yqwv2626945nt","modified":0,"renderable":0},{"_id":"source/_posts/springboot-custom-start/2.png","slug":"2.png","post":"ckn9yvhvx003yqwv2626945nt","modified":0,"renderable":0},{"_id":"source/_posts/springboot-custom-start/4.png","slug":"4.png","post":"ckn9yvhvx003yqwv2626945nt","modified":0,"renderable":0},{"_id":"source/_posts/springboot-custom-start/5.png","slug":"5.png","post":"ckn9yvhvx003yqwv2626945nt","modified":0,"renderable":0},{"_id":"source/_posts/springboot-custom-start/6.png","slug":"6.png","post":"ckn9yvhvx003yqwv2626945nt","modified":0,"renderable":0},{"_id":"source/_posts/springmvc2/10.png","slug":"10.png","post":"ckn9yvhw00049qwv23866gmu1","modified":0,"renderable":0},{"_id":"source/_posts/springmvc2/11.png","slug":"11.png","post":"ckn9yvhw00049qwv23866gmu1","modified":0,"renderable":0},{"_id":"source/_posts/springmvc2/12.png","slug":"12.png","post":"ckn9yvhw00049qwv23866gmu1","modified":0,"renderable":0},{"_id":"source/_posts/springmvc2/13.png","slug":"13.png","post":"ckn9yvhw00049qwv23866gmu1","modified":0,"renderable":0},{"_id":"source/_posts/springmvc2/14.png","slug":"14.png","post":"ckn9yvhw00049qwv23866gmu1","modified":0,"renderable":0},{"_id":"source/_posts/blockingqueue/0.png","slug":"0.png","post":"ckn9yvhu00000qwv2glga3xcy","modified":0,"renderable":0},{"_id":"source/_posts/blockingqueue/1.png","slug":"1.png","post":"ckn9yvhu00000qwv2glga3xcy","modified":0,"renderable":0},{"_id":"source/_posts/blockingqueue/2.png","slug":"2.png","post":"ckn9yvhu00000qwv2glga3xcy","modified":0,"renderable":0},{"_id":"source/_posts/blockingqueue/3.png","slug":"3.png","post":"ckn9yvhu00000qwv2glga3xcy","modified":0,"renderable":0},{"_id":"source/_posts/blockingqueue/4.png","slug":"4.png","post":"ckn9yvhu00000qwv2glga3xcy","modified":0,"renderable":0},{"_id":"source/_posts/blockingqueue/5.png","slug":"5.png","post":"ckn9yvhu00000qwv2glga3xcy","modified":0,"renderable":0},{"_id":"source/_posts/blockingqueue/6.png","slug":"6.png","post":"ckn9yvhu00000qwv2glga3xcy","modified":0,"renderable":0},{"_id":"source/_posts/blockingqueue/7.png","slug":"7.png","post":"ckn9yvhu00000qwv2glga3xcy","modified":0,"renderable":0},{"_id":"source/_posts/mysql-lock/1.png","slug":"1.png","post":"ckn9yvhvc001vqwv2huefgvah","modified":0,"renderable":0},{"_id":"source/_posts/mysql-lock/2.png","slug":"2.png","post":"ckn9yvhvc001vqwv2huefgvah","modified":0,"renderable":0},{"_id":"source/_posts/mysql-lock/3.png","slug":"3.png","post":"ckn9yvhvc001vqwv2huefgvah","modified":0,"renderable":0},{"_id":"source/_posts/mysql-lock/4.png","slug":"4.png","post":"ckn9yvhvc001vqwv2huefgvah","modified":0,"renderable":0},{"_id":"source/_posts/mysql-lock/5.png","slug":"5.png","post":"ckn9yvhvc001vqwv2huefgvah","modified":0,"renderable":0},{"_id":"source/_posts/mysql-lock/6.png","slug":"6.png","post":"ckn9yvhvc001vqwv2huefgvah","modified":0,"renderable":0},{"_id":"source/_posts/mysql-lock/7.png","slug":"7.png","post":"ckn9yvhvc001vqwv2huefgvah","modified":0,"renderable":0},{"_id":"source/_posts/mysql-lock/8.png","slug":"8.png","post":"ckn9yvhvc001vqwv2huefgvah","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index/1.png","slug":"1.png","post":"ckn9yvhvg0026qwv29cdy8q8h","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index/2.png","slug":"2.png","post":"ckn9yvhvg0026qwv29cdy8q8h","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index/3.png","slug":"3.png","post":"ckn9yvhvg0026qwv29cdy8q8h","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index/4.png","slug":"4.png","post":"ckn9yvhvg0026qwv29cdy8q8h","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index/5.png","slug":"5.png","post":"ckn9yvhvg0026qwv29cdy8q8h","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index/6.png","slug":"6.png","post":"ckn9yvhvg0026qwv29cdy8q8h","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index/7.png","slug":"7.png","post":"ckn9yvhvg0026qwv29cdy8q8h","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build-2/1.png","slug":"1.png","post":"ckn9yvhvk002oqwv2f6a705s4","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build-2/2.png","slug":"2.png","post":"ckn9yvhvk002oqwv2f6a705s4","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build-2/3.png","slug":"3.png","post":"ckn9yvhvk002oqwv2f6a705s4","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build-2/4.png","slug":"4.png","post":"ckn9yvhvk002oqwv2f6a705s4","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build-2/5.png","slug":"5.png","post":"ckn9yvhvk002oqwv2f6a705s4","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build-2/6.png","slug":"6.png","post":"ckn9yvhvk002oqwv2f6a705s4","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build-2/7.png","slug":"7.png","post":"ckn9yvhvk002oqwv2f6a705s4","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build-2/8.png","slug":"8.png","post":"ckn9yvhvk002oqwv2f6a705s4","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build-2/9.png","slug":"9.png","post":"ckn9yvhvk002oqwv2f6a705s4","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/1.png","slug":"1.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/10.png","slug":"10.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/2.png","slug":"2.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/3.png","slug":"3.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/4.png","slug":"4.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/5.png","slug":"5.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/6.png","slug":"6.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/7.png","slug":"7.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/8.png","slug":"8.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/mysql-index-single/9.png","slug":"9.png","post":"ckn9yvhvd001zqwv29xvu66f7","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/1.png","slug":"1.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/10.png","slug":"10.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/2.png","slug":"2.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/3.png","slug":"3.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/4.png","slug":"4.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/5.png","slug":"5.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/6.png","slug":"6.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/7.png","slug":"7.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/8.png","slug":"8.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-build/9.png","slug":"9.png","post":"ckn9yvhvi002gqwv259jp3j0j","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/1.png","slug":"1.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/10.png","slug":"10.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/2.png","slug":"2.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/3.png","slug":"3.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/4.png","slug":"4.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/5.png","slug":"5.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/6.png","slug":"6.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/7.png","slug":"7.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/springmvc/8.png","slug":"8.png","post":"ckn9yvhw1004eqwv24fnn05x6","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/1.jpg","slug":"1.jpg","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/1.png","slug":"1.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/10.png","slug":"10.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/11.png","slug":"11.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/12.png","slug":"12.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/13.png","slug":"13.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/14.png","slug":"14.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/2.png","slug":"2.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/3.png","slug":"3.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/4.png","slug":"4.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/5.png","slug":"5.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/6.png","slug":"6.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/7.png","slug":"7.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/8.png","slug":"8.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/mysql-explain/9.png","slug":"9.png","post":"ckn9yvhvb001sqwv2fa488nq5","modified":0,"renderable":0},{"_id":"source/_posts/go-pointer/1.png","slug":"1.png","post":"ckwbpt4if0000zsv295atdo8q","modified":0,"renderable":0},{"_id":"source/_posts/go-pointer/2.png","slug":"2.png","post":"ckwbpt4if0000zsv295atdo8q","modified":0,"renderable":0},{"_id":"source/_posts/go-pointer/3.png","slug":"3.png","post":"ckwbpt4if0000zsv295atdo8q","modified":0,"renderable":0},{"_id":"source/_posts/go-study-01/1.png","slug":"1.png","post":"ckwbpt4ix0006zsv22qoidjh9","modified":0,"renderable":0},{"_id":"source/_posts/go-study-01/2.png","slug":"2.png","post":"ckwbpt4ix0006zsv22qoidjh9","modified":0,"renderable":0},{"_id":"source/_posts/go-study-01/3.png","slug":"3.png","post":"ckwbpt4ix0006zsv22qoidjh9","modified":0,"renderable":0},{"_id":"source/_posts/go-study-01/4.png","slug":"4.png","post":"ckwbpt4ix0006zsv22qoidjh9","modified":0,"renderable":0},{"_id":"source/_posts/go-study-01/5.png","slug":"5.png","post":"ckwbpt4ix0006zsv22qoidjh9","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckn9yvhue0006qwv2fdat28gv","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhuo000dqwv2d41o3gvz"},{"post_id":"ckn9yvhu00000qwv2glga3xcy","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhuq000iqwv25vxl6rua"},{"post_id":"ckn9yvhug0007qwv26zbi3n30","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhus000lqwv2852ec1gm"},{"post_id":"ckn9yvhul000bqwv28px8gnnq","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhuu000qqwv28lp35s0c"},{"post_id":"ckn9yvhu70002qwv28poxegic","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhuw000sqwv20r660dku"},{"post_id":"ckn9yvhun000cqwv27tig1h1x","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhv1000wqwv20r1vblv5"},{"post_id":"ckn9yvhuc0005qwv2cft38t6r","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhv30010qwv29khz93mj"},{"post_id":"ckn9yvhur000kqwv2a85nbo4u","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhv50014qwv2dlj5cfyw"},{"post_id":"ckn9yvhut000pqwv2cy3f903v","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhv70018qwv2b2vy22vy"},{"post_id":"ckn9yvhuq000hqwv2d2ae5br4","category_id":"ckn9yvhut000nqwv2491z2enk","_id":"ckn9yvhv8001cqwv29ydyfb4b"},{"post_id":"ckn9yvhuy000vqwv29m0m7m80","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhv9001fqwv27p8a2c2v"},{"post_id":"ckn9yvhv50013qwv20sa97ixg","category_id":"ckn9yvhv2000xqwv27se1ajnh","_id":"ckn9yvhva001jqwv27vjn8gnx"},{"post_id":"ckn9yvhuv000rqwv23h4c5d88","category_id":"ckn9yvhv2000xqwv27se1ajnh","_id":"ckn9yvhva001nqwv2567j1m0w"},{"post_id":"ckn9yvhv70016qwv27dy1djjx","category_id":"ckn9yvhv2000xqwv27se1ajnh","_id":"ckn9yvhvb001pqwv22oo19zbp"},{"post_id":"ckn9yvhv3000zqwv2940fawon","category_id":"ckn9yvhv2000xqwv27se1ajnh","_id":"ckn9yvhvc001tqwv22fu10cgf"},{"post_id":"ckn9yvhv9001eqwv28yb05t1b","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhvd001wqwv26t9lad7p"},{"post_id":"ckn9yvhv9001iqwv27jp34xc9","category_id":"ckn9yvhut000nqwv2491z2enk","_id":"ckn9yvhvf0020qwv2hotq89ve"},{"post_id":"ckn9yvhva001mqwv2hanmfrzj","category_id":"ckn9yvhut000nqwv2491z2enk","_id":"ckn9yvhvg0023qwv2bpmx5gef"},{"post_id":"ckn9yvhv8001bqwv2a2f8989q","category_id":"ckn9yvhv9001gqwv240uigsrm","_id":"ckn9yvhvh0027qwv21t0aetcp"},{"post_id":"ckn9yvhvb001oqwv22g36hv60","category_id":"ckn9yvhv9001gqwv240uigsrm","_id":"ckn9yvhvh002aqwv24phagziz"},{"post_id":"ckn9yvhvb001sqwv2fa488nq5","category_id":"ckn9yvhv9001gqwv240uigsrm","_id":"ckn9yvhvi002eqwv23k3i6zf1"},{"post_id":"ckn9yvhvc001vqwv2huefgvah","category_id":"ckn9yvhv9001gqwv240uigsrm","_id":"ckn9yvhvj002hqwv2b25nda1t"},{"post_id":"ckn9yvhvd001zqwv29xvu66f7","category_id":"ckn9yvhv9001gqwv240uigsrm","_id":"ckn9yvhvk002lqwv2hf5n1f9c"},{"post_id":"ckn9yvhvf0022qwv2gwed7t7d","category_id":"ckn9yvhv9001gqwv240uigsrm","_id":"ckn9yvhvl002pqwv267pge075"},{"post_id":"ckn9yvhvg0026qwv29cdy8q8h","category_id":"ckn9yvhv9001gqwv240uigsrm","_id":"ckn9yvhvl002tqwv22g8v2l0m"},{"post_id":"ckn9yvhvh0029qwv21eef5q0l","category_id":"ckn9yvhv9001gqwv240uigsrm","_id":"ckn9yvhvm002xqwv2ersq6yxp"},{"post_id":"ckn9yvhvi002dqwv2a6o1e3ab","category_id":"ckn9yvhv9001gqwv240uigsrm","_id":"ckn9yvhvo0030qwv2f1vr8dcd"},{"post_id":"ckn9yvhvl002sqwv2gc3fal4k","category_id":"ckn9yvhvk002mqwv253w783ef","_id":"ckn9yvhvp0035qwv2gw8r941d"},{"post_id":"ckn9yvhvi002gqwv259jp3j0j","category_id":"ckn9yvhvk002mqwv253w783ef","_id":"ckn9yvhvr0038qwv23p4hb4qg"},{"post_id":"ckn9yvhvl002vqwv232lkay5s","category_id":"ckn9yvhvk002mqwv253w783ef","_id":"ckn9yvhvs003cqwv296l1b201"},{"post_id":"ckn9yvhvn002zqwv28sr9g006","category_id":"ckn9yvhvk002mqwv253w783ef","_id":"ckn9yvhvs003fqwv284kr53hk"},{"post_id":"ckn9yvhvj002kqwv229tjfcf0","category_id":"ckn9yvhvk002mqwv253w783ef","_id":"ckn9yvhvu003jqwv26lbbgybv"},{"post_id":"ckn9yvhvp0033qwv2cm36d9tz","category_id":"ckn9yvhvk002mqwv253w783ef","_id":"ckn9yvhvu003nqwv2b2dx8u3d"},{"post_id":"ckn9yvhvq0037qwv2e2q19khp","category_id":"ckn9yvhvk002mqwv253w783ef","_id":"ckn9yvhvv003rqwv2eutv8xat"},{"post_id":"ckn9yvhvk002oqwv2f6a705s4","category_id":"ckn9yvhvk002mqwv253w783ef","_id":"ckn9yvhvw003vqwv23fzlbtns"},{"post_id":"ckn9yvhvr003bqwv25nzk0l95","category_id":"ckn9yvhvk002mqwv253w783ef","_id":"ckn9yvhvx003zqwv270zpdxwo"},{"post_id":"ckn9yvhvs003eqwv2b9h426cc","category_id":"ckn9yvhvu003kqwv274ho83o7","_id":"ckn9yvhvy0043qwv23t30guw6"},{"post_id":"ckn9yvhvw003tqwv2c41fb2zf","category_id":"ckn9yvhvu003kqwv274ho83o7","_id":"ckn9yvhvz0047qwv2egaa268q"},{"post_id":"ckn9yvhvt003iqwv21k7k2dns","category_id":"ckn9yvhvu003kqwv274ho83o7","_id":"ckn9yvhw0004aqwv2fcpv5p8e"},{"post_id":"ckn9yvhvu003mqwv26ydf4751","category_id":"ckn9yvhvy0042qwv2drgndm5p","_id":"ckn9yvhw3004iqwv251f8e8o5"},{"post_id":"ckn9yvhw00049qwv23866gmu1","category_id":"ckn9yvhvy0042qwv2drgndm5p","_id":"ckn9yvhw5004lqwv2g474g9dp"},{"post_id":"ckn9yvhw1004eqwv24fnn05x6","category_id":"ckn9yvhvy0042qwv2drgndm5p","_id":"ckn9yvhw6004pqwv2h38jcmaq"},{"post_id":"ckn9yvhvv003qqwv2c6353vtk","category_id":"ckn9yvhvy0042qwv2drgndm5p","_id":"ckn9yvhw7004tqwv22ewag22t"},{"post_id":"ckn9yvhw2004gqwv2f31ef3cp","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhw8004wqwv2h59v2zni"},{"post_id":"ckn9yvhw3004kqwv2gassfatz","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhw90051qwv2gshn2ewy"},{"post_id":"ckn9yvhvx003yqwv2626945nt","category_id":"ckn9yvhvy0042qwv2drgndm5p","_id":"ckn9yvhw90053qwv25lzh741d"},{"post_id":"ckn9yvhw5004nqwv2d3r39hb6","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhwa0057qwv2ggutfzfz"},{"post_id":"ckn9yvhw6004sqwv2c40o9wr5","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhwa0059qwv2fjikhfmi"},{"post_id":"ckn9yvhvx0041qwv28f7z74rb","category_id":"ckn9yvhw6004oqwv2bebqbtxq","_id":"ckn9yvhwa005cqwv23cjygea9"},{"post_id":"ckn9yvhw7004vqwv2doo29zz0","category_id":"ckn9yvhua0003qwv20e2fceb2","_id":"ckn9yvhwa005eqwv20ia6fjt9"},{"post_id":"ckn9yvhvz0046qwv22hrf25le","category_id":"ckn9yvhw6004oqwv2bebqbtxq","_id":"ckn9yvhwb005hqwv25a3q4s3e"},{"post_id":"ckn9yvhw80050qwv22sdp6hlv","category_id":"ckn9yvhw90055qwv2dcjqfso9","_id":"ckn9yvhwb005jqwv23r1r0a6q"},{"post_id":"ckcujgdbf0000e0xlg085gsal","category_id":"ckn9yvhwi005uqwv2eypzfb12","_id":"ckn9yvhx4005vqwv2ch9o9ai9"},{"post_id":"ckpxmxgrw0000h8v2egzj7693","category_id":"ckpxmxgsc0002h8v23tnn8wbb","_id":"ckpxmxgsj0008h8v2hs5414u5"},{"post_id":"ckpxmxgs00001h8v2bwk7a7ve","category_id":"ckpxmxgsi0005h8v2bbvg6twm","_id":"ckpxmxgsk000ch8v26d9k58b6"},{"post_id":"ckpxmxgsh0004h8v2a6axbhhq","category_id":"ckpxmxgsk0009h8v28hs7gosd","_id":"ckpxmxgsk000eh8v2g9szcnre"},{"post_id":"ckwbpt4if0000zsv295atdo8q","category_id":"ckwbpt4ir0002zsv2f53i8sju","_id":"ckwbpt4j0000bzsv2hk6kd5mk"},{"post_id":"ckwbpt4ix0006zsv22qoidjh9","category_id":"ckwbpt4ir0002zsv2f53i8sju","_id":"ckwbpt4j2000ezsv2hy5x5xcj"},{"post_id":"ckwbpt4ij0001zsv21ijs980z","category_id":"ckwbpt4iy0007zsv2cwyr7zd6","_id":"ckwbpt4j3000hzsv2g1md8s3s"},{"post_id":"ckwbpt4iw0004zsv28b8xhers","category_id":"ckwbpt4iy0007zsv2cwyr7zd6","_id":"ckwbpt4j3000kzsv2bsug1lle"},{"post_id":"ckwbpt4ix0005zsv2e2f62itu","category_id":"ckwbpt4j2000gzsv2ax606pdu","_id":"ckwbpt4j3000mzsv2crh347k8"},{"post_id":"ckwbpt4jg000nzsv29eapec7c","category_id":"ckpxmxgsc0002h8v23tnn8wbb","_id":"ckwbpt4jk000pzsv2dlp7f8vk"}],"PostTag":[{"post_id":"ckcujgdbf0000e0xlg085gsal","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckcujgdbr0006e0xle9gc6mot"},{"post_id":"ckcujgdbf0000e0xlg085gsal","tag_id":"ckcujgdbq0004e0xlacni3caf","_id":"ckcujgdbs0007e0xla7jiczah"},{"post_id":"ckn9yvhu00000qwv2glga3xcy","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhul000aqwv221j27jro"},{"post_id":"ckn9yvhul000bqwv28px8gnnq","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhuq000gqwv26q1ug9dy"},{"post_id":"ckn9yvhu70002qwv28poxegic","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhur000jqwv2cw1y8acv"},{"post_id":"ckn9yvhun000cqwv27tig1h1x","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhut000oqwv2ed2dhfev"},{"post_id":"ckn9yvhut000pqwv2cy3f903v","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhuy000uqwv25khpgogv"},{"post_id":"ckn9yvhuc0005qwv2cft38t6r","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhv2000yqwv2cl5re8f5"},{"post_id":"ckn9yvhuc0005qwv2cft38t6r","tag_id":"ckn9yvhus000mqwv2gilvakeq","_id":"ckn9yvhv50012qwv25zl00ww9"},{"post_id":"ckn9yvhuy000vqwv29m0m7m80","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhv70015qwv2e50lbnb9"},{"post_id":"ckn9yvhue0006qwv2fdat28gv","tag_id":"ckn9yvhuw000tqwv24apr9pmb","_id":"ckn9yvhv80019qwv2eg8yao0x"},{"post_id":"ckn9yvhug0007qwv26zbi3n30","tag_id":"ckn9yvhv40011qwv21uhu3tid","_id":"ckn9yvhv9001dqwv295ah1ys3"},{"post_id":"ckn9yvhv8001bqwv2a2f8989q","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckn9yvhv9001hqwv25uhyfhoj"},{"post_id":"ckn9yvhuq000hqwv2d2ae5br4","tag_id":"ckn9yvhv8001aqwv204102gyl","_id":"ckn9yvhva001lqwv2476j9rzr"},{"post_id":"ckn9yvhva001mqwv2hanmfrzj","tag_id":"ckn9yvhv8001aqwv204102gyl","_id":"ckn9yvhvb001rqwv251zh3wfk"},{"post_id":"ckn9yvhur000kqwv2a85nbo4u","tag_id":"ckn9yvhva001kqwv20b6a6xcz","_id":"ckn9yvhvc001uqwv26a1e58ua"},{"post_id":"ckn9yvhvb001oqwv22g36hv60","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckn9yvhvd001yqwv2h23j0bl0"},{"post_id":"ckn9yvhvb001sqwv2fa488nq5","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckn9yvhvf0021qwv25zw5hbqe"},{"post_id":"ckn9yvhuv000rqwv23h4c5d88","tag_id":"ckn9yvhvb001qqwv2cl3n1d7f","_id":"ckn9yvhvg0025qwv2csk38ba7"},{"post_id":"ckn9yvhvc001vqwv2huefgvah","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckn9yvhvh0028qwv2d5g28q5u"},{"post_id":"ckn9yvhvd001zqwv29xvu66f7","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckn9yvhvi002cqwv27rxmctaf"},{"post_id":"ckn9yvhv3000zqwv2940fawon","tag_id":"ckn9yvhvb001qqwv2cl3n1d7f","_id":"ckn9yvhvi002fqwv2e4nn4w94"},{"post_id":"ckn9yvhvf0022qwv2gwed7t7d","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckn9yvhvj002jqwv20me2hv0q"},{"post_id":"ckn9yvhvg0026qwv29cdy8q8h","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckn9yvhvk002nqwv258g6be1d"},{"post_id":"ckn9yvhv50013qwv20sa97ixg","tag_id":"ckn9yvhvb001qqwv2cl3n1d7f","_id":"ckn9yvhvl002qqwv23ene0w3l"},{"post_id":"ckn9yvhvh0029qwv21eef5q0l","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckn9yvhvl002uqwv2fp0e6esz"},{"post_id":"ckn9yvhvi002dqwv2a6o1e3ab","tag_id":"ckcujgdbn0002e0xlhojchej4","_id":"ckn9yvhvm002yqwv240hm1g1i"},{"post_id":"ckn9yvhv70016qwv27dy1djjx","tag_id":"ckn9yvhvb001qqwv2cl3n1d7f","_id":"ckn9yvhvp0032qwv27wrv63u5"},{"post_id":"ckn9yvhv9001eqwv28yb05t1b","tag_id":"ckn9yvhvj002iqwv28yks0ikq","_id":"ckn9yvhvq0036qwv2dstd11mi"},{"post_id":"ckn9yvhv9001iqwv27jp34xc9","tag_id":"ckn9yvhv8001aqwv204102gyl","_id":"ckn9yvhvr003aqwv2g3m65kev"},{"post_id":"ckn9yvhv9001iqwv27jp34xc9","tag_id":"ckn9yvhvl002rqwv2419y600x","_id":"ckn9yvhvs003dqwv29uhwcnqz"},{"post_id":"ckn9yvhvp0033qwv2cm36d9tz","tag_id":"ckn9yvhvo0031qwv2g28jadm3","_id":"ckn9yvhvt003hqwv23ekh07y6"},{"post_id":"ckn9yvhvi002gqwv259jp3j0j","tag_id":"ckn9yvhvo0031qwv2g28jadm3","_id":"ckn9yvhvu003lqwv2aqq6ecky"},{"post_id":"ckn9yvhvq0037qwv2e2q19khp","tag_id":"ckn9yvhvo0031qwv2g28jadm3","_id":"ckn9yvhvv003pqwv287x83r2c"},{"post_id":"ckn9yvhvr003bqwv25nzk0l95","tag_id":"ckn9yvhvo0031qwv2g28jadm3","_id":"ckn9yvhvv003sqwv20nyfg0rf"},{"post_id":"ckn9yvhvj002kqwv229tjfcf0","tag_id":"ckn9yvhvo0031qwv2g28jadm3","_id":"ckn9yvhvx003xqwv26hr391mz"},{"post_id":"ckn9yvhvj002kqwv229tjfcf0","tag_id":"ckn9yvhvj002iqwv28yks0ikq","_id":"ckn9yvhvx0040qwv2cjii38p1"},{"post_id":"ckn9yvhvk002oqwv2f6a705s4","tag_id":"ckn9yvhvo0031qwv2g28jadm3","_id":"ckn9yvhvz0045qwv2cgp5bgu6"},{"post_id":"ckn9yvhvl002sqwv2gc3fal4k","tag_id":"ckn9yvhvo0031qwv2g28jadm3","_id":"ckn9yvhw00048qwv2cs8cbuqe"},{"post_id":"ckn9yvhvl002vqwv232lkay5s","tag_id":"ckn9yvhvo0031qwv2g28jadm3","_id":"ckn9yvhw1004dqwv2c9bd1tex"},{"post_id":"ckn9yvhvn002zqwv28sr9g006","tag_id":"ckn9yvhvo0031qwv2g28jadm3","_id":"ckn9yvhw2004fqwv2czzqhubu"},{"post_id":"ckn9yvhvs003eqwv2b9h426cc","tag_id":"ckn9yvhw1004cqwv22ro212lh","_id":"ckn9yvhw5004mqwv2ffi748nv"},{"post_id":"ckn9yvhw2004gqwv2f31ef3cp","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhw6004qqwv2hka627zn"},{"post_id":"ckn9yvhw3004kqwv2gassfatz","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhw7004uqwv2am9m0hzk"},{"post_id":"ckn9yvhvt003iqwv21k7k2dns","tag_id":"ckn9yvhw1004cqwv22ro212lh","_id":"ckn9yvhw8004xqwv26zce39nn"},{"post_id":"ckn9yvhw5004nqwv2d3r39hb6","tag_id":"ckn9yvhv40011qwv21uhu3tid","_id":"ckn9yvhw90052qwv2bxm18r7h"},{"post_id":"ckn9yvhw6004sqwv2c40o9wr5","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhw90054qwv2d2zj2bdk"},{"post_id":"ckn9yvhvu003mqwv26ydf4751","tag_id":"ckn9yvhw6004rqwv2dnchg5ey","_id":"ckn9yvhwa0058qwv24al3e555"},{"post_id":"ckn9yvhw7004vqwv2doo29zz0","tag_id":"ckn9yvhuc0004qwv27rup1c75","_id":"ckn9yvhwa005aqwv25p7u6tax"},{"post_id":"ckn9yvhvv003qqwv2c6353vtk","tag_id":"ckn9yvhw6004rqwv2dnchg5ey","_id":"ckn9yvhwa005dqwv27rgvbh3t"},{"post_id":"ckn9yvhvw003tqwv2c41fb2zf","tag_id":"ckn9yvhw1004cqwv22ro212lh","_id":"ckn9yvhwb005fqwv2gf8kcmrv"},{"post_id":"ckn9yvhvx003yqwv2626945nt","tag_id":"ckn9yvhw6004rqwv2dnchg5ey","_id":"ckn9yvhwb005iqwv2blxofsur"},{"post_id":"ckn9yvhvx0041qwv28f7z74rb","tag_id":"ckn9yvhwb005gqwv285ev22dq","_id":"ckn9yvhwb005lqwv260k5cqkh"},{"post_id":"ckn9yvhvz0046qwv22hrf25le","tag_id":"ckn9yvhwb005gqwv285ev22dq","_id":"ckn9yvhwc005nqwv2ea8mfgjy"},{"post_id":"ckn9yvhw00049qwv23866gmu1","tag_id":"ckn9yvhw6004rqwv2dnchg5ey","_id":"ckn9yvhwc005pqwv24t4p5ukq"},{"post_id":"ckn9yvhw1004eqwv24fnn05x6","tag_id":"ckn9yvhw6004rqwv2dnchg5ey","_id":"ckn9yvhwc005rqwv22zbc969k"},{"post_id":"ckn9yvhw80050qwv22sdp6hlv","tag_id":"ckn9yvhwc005qqwv24izndj6p","_id":"ckn9yvhwc005sqwv24w6qeond"},{"post_id":"ckpxmxgrw0000h8v2egzj7693","tag_id":"ckpxmxgsg0003h8v26sqzfbp6","_id":"ckpxmxgsj0007h8v2g992dd22"},{"post_id":"ckpxmxgs00001h8v2bwk7a7ve","tag_id":"ckpxmxgsj0006h8v2d13d2a41","_id":"ckpxmxgsk000bh8v2f6sh2da5"},{"post_id":"ckpxmxgsh0004h8v2a6axbhhq","tag_id":"ckpxmxgsk000ah8v2b341e828","_id":"ckpxmxgsk000dh8v22radfr6l"},{"post_id":"ckwbpt4if0000zsv295atdo8q","tag_id":"ckwbpt4iv0003zsv23afj0l8n","_id":"ckwbpt4j00009zsv2d4i472df"},{"post_id":"ckwbpt4ix0006zsv22qoidjh9","tag_id":"ckwbpt4iv0003zsv23afj0l8n","_id":"ckwbpt4j0000azsv24gwmd6qp"},{"post_id":"ckwbpt4ij0001zsv21ijs980z","tag_id":"ckwbpt4iz0008zsv2bjyo1svj","_id":"ckwbpt4j2000fzsv26je4fexk"},{"post_id":"ckwbpt4iw0004zsv28b8xhers","tag_id":"ckwbpt4iz0008zsv2bjyo1svj","_id":"ckwbpt4j3000jzsv2akdshcxl"},{"post_id":"ckwbpt4ix0005zsv2e2f62itu","tag_id":"ckwbpt4j3000izsv2aowi0s7a","_id":"ckwbpt4j3000lzsv24lbf20qt"},{"post_id":"ckwbpt4jg000nzsv29eapec7c","tag_id":"ckpxmxgsg0003h8v26sqzfbp6","_id":"ckwbpt4ji000ozsv28qar23bv"}],"Tag":[{"name":"mysql","_id":"ckcujgdbn0002e0xlhojchej4"},{"name":"架构","_id":"ckcujgdbq0004e0xlacni3caf"},{"name":"hexo","_id":"ckcujgdbr0005e0xlhecqaty2"},{"name":"java并发","_id":"ckn9yvhuc0004qwv27rup1c75"},{"name":"java8","_id":"ckn9yvhus000mqwv2gilvakeq"},{"name":"设计模式","_id":"ckn9yvhuw000tqwv24apr9pmb"},{"name":"jvm","_id":"ckn9yvhv40011qwv21uhu3tid"},{"name":"linux","_id":"ckn9yvhv8001aqwv204102gyl"},{"name":"java集合","_id":"ckn9yvhva001kqwv20b6a6xcz"},{"name":"kafka","_id":"ckn9yvhvb001qqwv2cl3n1d7f"},{"name":"项目实践","_id":"ckn9yvhvj002iqwv28yks0ikq"},{"name":"网络","_id":"ckn9yvhvl002rqwv2419y600x"},{"name":"redis","_id":"ckn9yvhvo0031qwv2g28jadm3"},{"name":"shardingjdbc","_id":"ckn9yvhw1004cqwv22ro212lh"},{"name":"spring","_id":"ckn9yvhw6004rqwv2dnchg5ey"},{"name":"SpringCloud","_id":"ckn9yvhwb005gqwv285ev22dq"},{"name":"zookeeper","_id":"ckn9yvhwc005qqwv24izndj6p"},{"name":"区块链","_id":"ckpxmxgsg0003h8v26sqzfbp6"},{"name":"influxdb","_id":"ckpxmxgsj0006h8v2d13d2a41"},{"name":"ElasticSearch","_id":"ckpxmxgsk000ah8v2b341e828"},{"name":"GoLang","_id":"ckwbpt4iv0003zsv23afj0l8n"},{"name":"Docker","_id":"ckwbpt4iz0008zsv2bjyo1svj"},{"name":"rust","_id":"ckwbpt4j3000izsv2aowi0s7a"}]}}